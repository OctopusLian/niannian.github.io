<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>以写作调身心</title>
  
  <subtitle>熟能生巧，勤能补拙；念念不忘，必有回响。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://octopuslian.github.io/"/>
  <updated>2021-04-21T14:25:30.609Z</updated>
  <id>https://octopuslian.github.io/</id>
  
  <author>
    <name>Neo Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>四川省都江堰市青城后山一日游</title>
    <link href="https://octopuslian.github.io/2021/04/21/qing-cheng-hou-shan-one-day-trip/"/>
    <id>https://octopuslian.github.io/2021/04/21/qing-cheng-hou-shan-one-day-trip/</id>
    <published>2021-04-21T14:24:02.000Z</published>
    <updated>2021-04-21T14:25:30.609Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --><p>上周五去跟一位朋友约去爬山，地点选在都江堰市的青城山，本文将详细分享旅游攻略，以及旅行完的顿悟。</p><h2 id="出发前"><a href="#出发前" class="headerlink" title="出发前"></a>出发前</h2><p>出发之前，我和袁准备了一个背包，想着先爬到山上再去补给。</p><p>我和袁住在成都市，早上7点半约好见面，吃过早餐坐地铁到犀浦，然后转城际列车(10元/人)到青城山下车即可。建议如果去青城山最好直接上车前买直达，不然到车上补票还需要另外收费。</p><p>到了青城山车站出来，由于我们是要去的后山，自然景观丰富，空气清新，因此我们两人打了个车，一个人15（景区要16，还有等一会，小车直接走）。在此需要提醒：由于是上山的路且弯道众多，因此可能会晕车。</p><p>到了泰安古镇，也就是景区的入口处，我们吃了顿午饭（还是有些小贵），买了20元/人的门票，就开始爬山了。</p><h2 id="上山过程"><a href="#上山过程" class="headerlink" title="上山过程"></a>上山过程</h2><p>我们白天爬，感觉都还好，不是很热，沿途有各种卖饮料的，不过价格稍贵，水5元、饮料10元，棒棒糖3元一根。</p><p>爬到半山腰大概3个小时，然后有缆车可以往返，不过我们年轻小伙子想着多运动，于是就没有坐缆车（这是我最后悔的决定）。接着就开始体力不支，因为大多是上坡，很累，爬一会就得休息一下，不过还好在5点的时候（用了两个小时）爬到了白云寺，拜了拜佛，然后准备下山，这时候从卖饮料的大妈口中得知，5点半缆车停运！！！</p><h2 id="下山过程"><a href="#下山过程" class="headerlink" title="下山过程"></a>下山过程</h2><p>下山稍微轻松，但腿开始软了，感到走不动路，看着手机上还有几百米的距离到达缆车地点，我真想飞过去。结果我们5点20到那里后，人家告诉我缆车工作人员早就下班了，我不甘心，下去看了一眼，果然都停了，于是在想怎么办。有个姐姐告诉我下山大概一个小时可以坐船，坐上船后再走一个小时就下山了，我们一看时间，嗯，争取赶晚上8点下山，然后坐列车回成都。</p><p>结果坐船说过了运营时间，要涨价，5元/人（正常是2元/人）。行吧，就这样，结果坐完船就开始晕，恶心，头晕，心跳的贼快，于是朋友叫我先休息，最后休息到7点往下走，还是感到不舒服，没办法，直接叫救援。</p><h2 id="救援过程"><a href="#救援过程" class="headerlink" title="救援过程"></a>救援过程</h2><p>首先打完救援电话后，被告知救援费要1000元，我在犹豫间朋友已经替我答应了，挂了电话对我说，钱花了可以挣，但一定要保证你的安全。于是，我们在夜幕降临的过程中，用手机闪光灯照着周围环境，防止有蛇、虫子之类的靠近，同时我们也看到草丛里有一双泛着黄光的动物眼睛盯着我们。</p><p>等了大概一个小时，救援队上来，把我抬了下去，最后由120救护车把我送到医院做检查。</p><p>身体没有大碍，就心跳的太快了，于是开了一些降心率的药，叮嘱我回成都市了要好好检查。</p><p>就这样，在一天中结束了自己跌宕起伏的青城的后山爬山之旅。</p><h2 id="此次旅行感悟"><a href="#此次旅行感悟" class="headerlink" title="此次旅行感悟"></a>此次旅行感悟</h2><ul><li>有时候不能硬撑，实在走不动了，就用钱代替交通；</li><li>钱没了可以再挣，身体是最重要的；</li><li>出发前做好旅行规划很重要；</li><li>体检有不舒服的就赶紧去查，防止小病拖成大病；</li><li>不要把问题想的太严重，总会有解决之道。</li></ul><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;上周五去跟一位朋友约去爬山，地点选在都江堰市的青城山，本文将详细分享旅游攻略，以及旅行完的顿悟。&lt;/p&gt;&lt;h2 id=&quot;出发前&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="Travel-notes" scheme="https://octopuslian.github.io/categories/Travel-notes/"/>
    
    
      <category term="旅行" scheme="https://octopuslian.github.io/tags/%E6%97%85%E8%A1%8C/"/>
    
      <category term="青城山" scheme="https://octopuslian.github.io/tags/%E9%9D%92%E5%9F%8E%E5%B1%B1/"/>
    
      <category term="都江堰" scheme="https://octopuslian.github.io/tags/%E9%83%BD%E6%B1%9F%E5%A0%B0/"/>
    
  </entry>
  
  <entry>
    <title>玩转docker-核心知识概述</title>
    <link href="https://octopuslian.github.io/2021/04/08/fun-with-docker-1-core-knowledge/"/>
    <id>https://octopuslian.github.io/2021/04/08/fun-with-docker-1-core-knowledge/</id>
    <published>2021-04-08T02:14:24.000Z</published>
    <updated>2021-04-08T13:14:46.219Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 22:32:20 GMT+0800 (GMT+08:00) --><h2 id="What——什么是容器"><a href="#What——什么是容器" class="headerlink" title="What——什么是容器"></a>What——什么是容器</h2><p>容器由两部分组成：（1）应用程序本身；（2）依赖：比如应用程序需要的库或其他软件容器在Host操作系统的用户空间中运行，与操作系统的其他进程隔离。这一点显著区别于的虚拟机。</p><p>传统的虚拟化技术，比如VMWare、KVM、Xen，目标是创建完整的虚拟机。为了运行应用，除了部署应用本身及其依赖（通常几十MB），还得安装整个操作系统（几十GB）。</p><h2 id="Why——为什么需要容器"><a href="#Why——为什么需要容器" class="headerlink" title="Why——为什么需要容器"></a>Why——为什么需要容器</h2><p>容器使软件具备了超强的可移植能力。</p><p>Docker将集装箱思想运用到软件打包上，为代码提供了一个基于容器的标准化运输系统。Docker可以将任何应用及其依赖打包成一个轻量级、可移植、自包含的容器。容器可以运行在几乎所有的操作系统上</p><h3 id="容器的优势"><a href="#容器的优势" class="headerlink" title="容器的优势"></a>容器的优势</h3><p>对于开发人员：Build Once、Run Anywhere。</p><p>对于运维人员：Configure Once、Run Anything。</p><h2 id="How——容器是如何工作的"><a href="#How——容器是如何工作的" class="headerlink" title="How——容器是如何工作的"></a>How——容器是如何工作的</h2><h3 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h3><p>Docker的核心组件包括：</p><p>● Docker客户端：Client<br>● Docker服务器：Docker daemon<br>● Docker镜像：Image● Registry<br>● Docker容器：Container</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 22:32:20 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;What——什么是容器&quot;&gt;&lt;a href=&quot;#What——什么是容器&quot; class=&quot;headerlink&quot; title=&quot;What—
      
    
    </summary>
    
    
      <category term="Learn-Docker" scheme="https://octopuslian.github.io/categories/Learn-Docker/"/>
    
    
      <category term="docker" scheme="https://octopuslian.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>玩转Docker-鸟瞰容器生态系统</title>
    <link href="https://octopuslian.github.io/2021/04/08/fun-with-docker-0-container-ecosystem/"/>
    <id>https://octopuslian.github.io/2021/04/08/fun-with-docker-0-container-ecosystem/</id>
    <published>2021-04-08T02:13:26.000Z</published>
    <updated>2021-04-08T14:27:39.406Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 22:32:20 GMT+0800 (GMT+08:00) --><p>这篇文章有一张思维导图足以</p><p><img src="/2021/04/08/fun-with-docker-0-container-ecosystem/container.jpg" alt></p><p>意外发现一本国人写的《玩转Docker容器技术》，好好学习一下Docker系列，就从开头为<code>fun with...</code>开始。</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 22:32:20 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;这篇文章有一张思维导图足以&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/2021/04/08/fun-with-docker-0-container-ec
      
    
    </summary>
    
    
      <category term="Learn-Docker" scheme="https://octopuslian.github.io/categories/Learn-Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>今年终于要开始忙了</title>
    <link href="https://octopuslian.github.io/2021/04/07/first-entrepreneurship/"/>
    <id>https://octopuslian.github.io/2021/04/07/first-entrepreneurship/</id>
    <published>2021-04-07T02:08:18.000Z</published>
    <updated>2021-04-10T02:04:01.601Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 22:32:20 GMT+0800 (GMT+08:00) --><p>昨天收到两条消息，我的副业&amp;创业终于要开始了。</p><p>聊天1：</p><p><img src="/2021/04/07/first-entrepreneurship/weixin1.png" alt></p><p>和川大计算机硕士毕业的学长一起做一款程序，预计9月初上线。</p><p>这位学长我是意外在工作中认识的，后来他毕业后，我俩有次在望江楼公园闲聊，他说他第一眼看到我就觉得我是个非常<code>nice</code>的人。我笑了笑说，一般对我没有攻击的我我都会真诚以待，不造谣，隐私除外。</p><p>技术和市场都做完调研，但对我来说是一块全新的领域。</p><p>聊天2：</p><p><img src="/2021/04/07/first-entrepreneurship/weixin2.png" alt></p><p>和清华在读博士的创业。</p><p>2月底他找到我时，问我有没有兴趣做这个，他目前拿到第一笔融资，想等9月中旬项目第一版上线后再去谈下一笔融资。我不懂融资，但我信过他这个人，从本科时接触他写的<a href="http://www.demongan.com/" target="_blank" rel="noopener">恶魔的世界</a>，到硕士出了一本黑客书籍，并创办了<a href="https://www.write-bug.com/" target="_blank" rel="noopener">WRITR-BUG技术共享平台</a>，在他身上我看到了许多将不可能转换为可能的事情。</p><p>2017年夏天我和他在北邮相遇，非常帅气的小伙子，带我逛了北邮，同时在他面前班门弄斧了一下汇编，哈哈</p><p>2月底他打电话说如果我要做的话，就会给我发工资，我说你即使不给我发工资我也愿意做。我嘛，总觉得按部就班的会缺少一些什么，你给我的这次机会，我要好好把握，我觉得我的一生，总要去尝试一些没有做过的事情。</p><p>半年时间，半年后，我会来这里还愿。</p><p>GOOD LUCK~</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 22:32:20 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;昨天收到两条消息，我的副业&amp;amp;创业终于要开始了。&lt;/p&gt;&lt;p&gt;聊天1：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/2021/04/07/first
      
    
    </summary>
    
    
      <category term="Try-to-Challenges" scheme="https://octopuslian.github.io/categories/Try-to-Challenges/"/>
    
    
      <category term="项目" scheme="https://octopuslian.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="创业" scheme="https://octopuslian.github.io/tags/%E5%88%9B%E4%B8%9A/"/>
    
      <category term="融资" scheme="https://octopuslian.github.io/tags/%E8%9E%8D%E8%B5%84/"/>
    
      <category term="技术" scheme="https://octopuslian.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>十年之约</title>
    <link href="https://octopuslian.github.io/2021/03/31/happy-25-birthday-ten-years-promise/"/>
    <id>https://octopuslian.github.io/2021/03/31/happy-25-birthday-ten-years-promise/</id>
    <published>2021-03-31T12:33:56.000Z</published>
    <updated>2021-03-31T14:21:24.249Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --><p>种一棵树最好的时间是十年前，其次是现在。</p><h2 id="过去十年"><a href="#过去十年" class="headerlink" title="过去十年"></a>过去十年</h2><h3 id="心中的童话镇"><a href="#心中的童话镇" class="headerlink" title="心中的童话镇"></a>心中的童话镇</h3><p>心中至今还记得， 大三暑假那会，每天早晨去公园散步，然后吃一碗粥，再加几个馒头，过几天换成可口的豆腐脑，上午看会《新概念英语》，睡个午觉，下午在卧室看一会小说，打一小会游戏，然后抱着冰镇的西瓜边啃边看剧的欢乐时光，偶尔想起几个好友，约着去体育公园打球，亦或是去是自助餐和看电影。</p><p>也许这就是我心中理想的幸福生活。</p><p>只是，我知道，我终将是要离开父母，独自去生活。</p><h3 id="高中三年"><a href="#高中三年" class="headerlink" title="高中三年"></a>高中三年</h3><p>收获最多的就是结识了几位良师益友，他们给予过我鼓励，安慰和期望，让我坚定自己的目标，不断向前。</p><h3 id="大学四年"><a href="#大学四年" class="headerlink" title="大学四年"></a>大学四年</h3><p>感触最多的是从大学同班同学何和唐身上学到的，也是我毕业后一直保持联系的人。</p><p>大一时我曾对何不以为然，觉得他只是个会考试会背题的机器罢了。直到大四机缘巧合搬进了何的宿舍，跟他做了一学期舍友，才发现我错了。</p><p>曾经我通过打算法竞赛和写博客结识了很多北京上海的竞赛大佬，直到我将他们和何对比了一下，才发现都有共通点，这一点我在唐的身上也看到了。</p><p>所以，我在大三的时候，抛弃了所有所谓的荣誉、职务，专心做自己觉得有价值的事情，因为那样我觉得才是踏实的。</p><h3 id="工作接近三年"><a href="#工作接近三年" class="headerlink" title="工作接近三年"></a>工作接近三年</h3><p>上班三年，实现了自己小时候想当工程师的梦想，从游戏服务端开发工程师到图形图像算法工程师，再到<code>Golang</code>后端研发工程师以及兼职的音视频工程师，虽然<code>title</code>在变，但一直不变的就是加班以及研发在国内卑微的地位。嗯，这和我小时候的设想的貌似不太一样呢。</p><h2 id="一些顿悟"><a href="#一些顿悟" class="headerlink" title="一些顿悟"></a>一些顿悟</h2><h3 id="对996以及加班的感悟"><a href="#对996以及加班的感悟" class="headerlink" title="对996以及加班的感悟"></a>对996以及加班的感悟</h3><ul><li>命是自己的，即使加班出事故了，企业也买了保险，大不了用废了再换一个，但自己的生命只有一次，这是大前提；</li><li>结合三年加班的经验，以及吸收消化那些加班场景，无非就是项目上线出事故或者是老板想看你好不好使唤（阶级思想），这是国内私企大部分加班的根本原因；</li><li>活是做不完的，即使做完了，老板也不会感慨你效率多高，而会开心的说自己花一个人的价钱省了三个人的成本。</li></ul><p>因此，结合以上三点，在保持不会没有存款的大前提之下，我会尽量边提升自己的技术，边找一些管理规范且<code>nice</code>的企业，小企业就不去浪费时间和精力了。</p><h3 id="关于离职"><a href="#关于离职" class="headerlink" title="关于离职"></a>关于离职</h3><p>感到是一种解脱，是从封闭的办公室，嘈杂的喧闹声和咳嗽声后带来的一份宁静。</p><h3 id="关于本科学历"><a href="#关于本科学历" class="headerlink" title="关于本科学历"></a>关于本科学历</h3><p>这是个沉重的话题，因为它会跟到你老。面试的时候会决定你和名校毕业生的起点，关系到升职加薪等等等。可能我刚毕业会担心，但经过这三年的洗礼，以及和一位南天信息的技术专家的沟通，我验证并得出了结论：<strong>只要你一直更新自己的知识储备，就永远不会被这个社会淘汰。</strong></p><h3 id="关于离别"><a href="#关于离别" class="headerlink" title="关于离别"></a>关于离别</h3><p>小学毕业时，我哭了，想着毕业后大家一定要常聚；初中毕业时，我悄悄地哭，想着以后还在一座城市，可以常聚；高中毕业时，我忍住没哭，即使高考结束后我依旧会突然从8点多惊醒，想着快迟到了；大学毕业时，我没有哭，平静的收拾好自己的行李，拿好毕业证学位证，定好火车票，就此离去；工作了，偶尔在机场碰到我的高中同班同学，惊喜、意外接踵而至，但这些过后呢，依旧平静，然后错过。</p><p>曾经我比喻两个人的关系就像平行线，如果相交后，错过可能就再也见不到了，是这样的。</p><p>在乌鲁木齐时失去了一个从幼儿园玩到大学的好朋友，那时我会失眠，会迷茫，像是生命中突然缺少了什么东西似的。直到大学毕业前，父母问起我和他还有联系没，我心中都会隐隐作痛后摇摇头，但我又无能为力。直到毕业后，我突然顿悟，有时候也许就是两个人缘分尽了就平静的看待吧，想想快乐的事情——两个人从小学相互打闹；初中因为没有手机就互传书信，就差买只鸽子做飞鸽传书了；相互请教理综和数学题；周末约着一起去打球或者看电影；老师看到我俩还以为是亲兄弟…哈哈。</p><p>如果要离别，我会微笑，会真诚的对你说一声：<strong>谢谢你，曾出现在我的回忆里，感谢相遇，离别保重。</strong>。然后继续走好我自己的路。</p><h2 id="未来十年"><a href="#未来十年" class="headerlink" title="未来十年"></a>未来十年</h2><ul><li>用一年时间沉淀自己的基础，深入后端开发；</li><li>用两年时间搭建自己的副业体系的雏形并开始运作；</li><li>用三年时间提升一下自己的核心竞争力，并尝试横向拓宽自己的技术面；</li><li>用四年时间丰富自己工作履历和项目经验，争取达到专家级别；</li><li>拥有自己的一套房；</li><li>注：以上流程可以交替并发运作。</li></ul><h2 id="十年的约定"><a href="#十年的约定" class="headerlink" title="十年的约定"></a>十年的约定</h2><p>回想起，我在大三时在北邮遇见了<code>DemonGan</code>，他给自己在一定时间内定了个目标，然后好长时间没发朋友圈，突然在研三之际发布保博清华；我也在大二时受到一位北大毕业的天使投资人的影响，他说<strong>优秀的人相互都是吸引的</strong>，于是我明白了——需要先让自己变强，才有和大佬共同合作的资本，所以，做一个可以创造价值的人，是我未来十年的要实现的理想。</p><p>因此，我也在25岁生日来临之际，给自己定个目标————十年之约。十年后，我35岁，即使不做技术，我也希望我的副业可以支撑着我的日常开销，我想到那时，我才是真正实现了财务自由以及真正在做着有意义的事情。</p><p>GOOD LUCK:)</p><p><img src="/2021/03/31/happy-25-birthday-ten-years-promise/dream.jpg" alt></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;种一棵树最好的时间是十年前，其次是现在。&lt;/p&gt;&lt;h2 id=&quot;过去十年&quot;&gt;&lt;a href=&quot;#过去十年&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="Happy-Birthday" scheme="https://octopuslian.github.io/categories/Happy-Birthday/"/>
    
    
      <category term="成长" scheme="https://octopuslian.github.io/tags/%E6%88%90%E9%95%BF/"/>
    
      <category term="生日祝福" scheme="https://octopuslian.github.io/tags/%E7%94%9F%E6%97%A5%E7%A5%9D%E7%A6%8F/"/>
    
      <category term="随笔" scheme="https://octopuslian.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="顿悟" scheme="https://octopuslian.github.io/tags/%E9%A1%BF%E6%82%9F/"/>
    
      <category term="约定" scheme="https://octopuslian.github.io/tags/%E7%BA%A6%E5%AE%9A/"/>
    
      <category term="承诺" scheme="https://octopuslian.github.io/tags/%E6%89%BF%E8%AF%BA/"/>
    
  </entry>
  
  <entry>
    <title>汇总LeetCode实现数据结构和算法的题目</title>
    <link href="https://octopuslian.github.io/2021/03/05/leetcode-all-achieve-data-structure-and-algo-problems/"/>
    <id>https://octopuslian.github.io/2021/03/05/leetcode-all-achieve-data-structure-and-algo-problems/</id>
    <published>2021-03-05T15:23:24.000Z</published>
    <updated>2021-03-13T14:09:03.379Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --><p>汇总各种实现数据结构和算法的<code>LeetCode</code>题目，等刷完《剑指offer》后将重点关注的题目，通过边刷题边梳理数据结构算法的知识。</p><h2 id="链表-跳表"><a href="#链表-跳表" class="headerlink" title="链表-跳表"></a>链表-跳表</h2><p><a href="https://leetcode-cn.com/problems/design-linked-list/" target="_blank" rel="noopener">707. 设计链表</a></p><p><a href="https://leetcode-cn.com/problems/design-skiplist/" target="_blank" rel="noopener">1206. 设计跳表</a></p><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 09. 用两个栈实现队列</a></p><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232. 用栈实现队列</a></p><p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">225. 用队列实现栈</a></p><p><a href="https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/" target="_blank" rel="noopener">1381. 设计一个支持增量操作的栈</a></p><p><a href="https://leetcode-cn.com/problems/design-circular-queue/" target="_blank" rel="noopener">622. 设计循环队列</a></p><p><a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">641. 设计循环双端队列</a></p><p><a href="https://leetcode-cn.com/problems/design-front-middle-back-queue/" target="_blank" rel="noopener">1670. 设计前中后队列</a></p><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p><a href="https://leetcode-cn.com/problems/design-hashset/" target="_blank" rel="noopener">705. 设计哈希集合</a></p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 07. 重建二叉树</a></p><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">剑指 Offer 27. 二叉树的镜像</a></p><p><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 28. 对称的二叉树</a></p><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></p><p><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 37. 序列化二叉树</a></p><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. 平衡二叉树</a></p><p><a href="https://leetcode-cn.com/problems/minimum-height-trees/" target="_blank" rel="noopener">310. 最小高度树</a></p><p><a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">641. 设计循环双端队列</a></p><p><a href="https://leetcode-cn.com/problems/design-front-middle-back-queue/" target="_blank" rel="noopener">1670. 设计前中后队列</a></p><p><a href="https://leetcode-cn.com/problems/er-cha-shu-ren-wu-diao-du/" target="_blank" rel="noopener">LCP 10. 二叉树任务调度</a></p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU 缓存机制</a></p><h2 id="场景设计"><a href="#场景设计" class="headerlink" title="场景设计"></a>场景设计</h2><p><a href="https://leetcode-cn.com/problems/design-twitter/" target="_blank" rel="noopener">355. 设计推特</a></p><p><a href="https://leetcode-cn.com/problems/design-hashset/" target="_blank" rel="noopener">705. 设计哈希集合</a></p><p><a href="https://leetcode-cn.com/problems/design-hashmap/" target="_blank" rel="noopener">706. 设计哈希映射</a></p><p><a href="https://leetcode-cn.com/problems/design-underground-system/" target="_blank" rel="noopener">1396. 设计地铁系统</a></p><p><a href="https://leetcode-cn.com/problems/design-browser-history/" target="_blank" rel="noopener">1472. 设计浏览器历史记录</a></p><p><a href="https://leetcode-cn.com/problems/design-parking-system/" target="_blank" rel="noopener">1603. 设计停车系统</a></p><p><a href="https://leetcode-cn.com/problems/design-an-ordered-stream/" target="_blank" rel="noopener">1656. 设计有序流</a></p><p><a href="https://leetcode-cn.com/problems/goal-parser-interpretation/" target="_blank" rel="noopener">1678. 设计 Goal 解析器</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;汇总各种实现数据结构和算法的&lt;code&gt;LeetCode&lt;/code&gt;题目，等刷完《剑指offer》后将重点关注的题目，通过边刷题边梳理数据结构
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
      <category term="算法" scheme="https://octopuslian.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://octopuslian.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 07. 重建二叉树</title>
    <link href="https://octopuslian.github.io/2021/03/05/leetcode-lcof-07-zhong-jian-er-cha-shu/"/>
    <id>https://octopuslian.github.io/2021/03/05/leetcode-lcof-07-zhong-jian-er-cha-shu/</id>
    <published>2021-03-05T10:42:24.000Z</published>
    <updated>2021-03-05T10:57:22.032Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">力扣-剑指 Offer 07. 重建二叉树</a></p><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">例如，给出</span><br><span class="line"></span><br><span class="line">前序遍历 preorder = [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"></span><br><span class="line">0 &lt;= 节点个数 &lt;= 5000</span><br></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>二叉树的遍历顺序</li></ul><p>1，前序（Pre-order）：根-左-右<br>2，中序（In-order）：左-根-右<br>3，后序（Post-order）：左-右-根</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>难度为中等。</p><h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>按题目给的示例来划分：<br>前序遍历划分 [ 3 | 9 | 20 15 7 ]<br>中序遍历划分 [ 9 | 3 | 15 20 7 ]</p><p>根据以上性质，可得出以下推论：</p><ul><li>前序遍历的首元素 为 树的根节点 <code>node</code> 的值。</li><li>在中序遍历中搜索根节点 <code>node</code> 的索引 ，可将 中序遍历 划分为 [ 左子树 | 根节点 | 右子树 ] 。</li><li>根据中序遍历中的左 / 右子树的节点数量，可将 前序遍历 划分为 [ 根节点 | 左子树 | 右子树 ] 。</li></ul><p>考虑通过递归对所有子树进行划分：</p><ul><li><p>递推参数： 根节点在前序遍历的索引 root 、子树在中序遍历的左边界 left 、子树在中序遍历的右边界 right ；</p></li><li><p>终止条件： 当 left &gt; right ，代表已经越过叶节点，此时返回 null ；</p></li><li><p>递推工作：<br>建立根节点 node ： 节点值为 preorder[root] ；<br>划分左右子树： 查找根节点在中序遍历 inorder 中的索引 i ；</p></li></ul><p><img src="/2021/03/05/leetcode-lcof-07-zhong-jian-er-cha-shu/7-tijie.png" alt></p><p>网上摘的保姆式的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java借助Map版本 (Go的没写出来，等后面写出来了再更新)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//标记中序遍历</span></span><br><span class="line">    <span class="keyword">int</span>[] preorder;<span class="comment">//保留的先序遍历，方便递归时依据索引查看先序遍历的值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preorder = preorder;</span><br><span class="line">        <span class="comment">//将中序遍历的值及索引放在map中，方便递归时获取左子树与右子树的数量及其根的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//三个索引分别为</span></span><br><span class="line">        <span class="comment">//当前根的的索引</span></span><br><span class="line">        <span class="comment">//递归树的左边界，即数组左边界</span></span><br><span class="line">        <span class="comment">//递归树的右边界，即数组右边界</span></span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">recur</span><span class="params">(<span class="keyword">int</span> pre_root, <span class="keyword">int</span> in_left, <span class="keyword">int</span> in_right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(in_left &gt; in_right) <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">// 相等的话就是自己</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[pre_root]);<span class="comment">//获取root节点</span></span><br><span class="line">        <span class="keyword">int</span> idx = map.get(preorder[pre_root]);<span class="comment">//获取在中序遍历中根节点所在索引，以方便获取左子树的数量</span></span><br><span class="line">        <span class="comment">//左子树的根的索引为先序中的根节点+1 </span></span><br><span class="line">        <span class="comment">//递归左子树的左边界为原来的中序in_left</span></span><br><span class="line">        <span class="comment">//递归右子树的右边界为中序中的根节点索引-1</span></span><br><span class="line">        root.left = recur(pre_root+<span class="number">1</span>, in_left, idx-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//右子树的根的索引为先序中的 当前根位置 + 左子树的数量 + 1</span></span><br><span class="line">        <span class="comment">//递归右子树的左边界为中序中当前根节点+1</span></span><br><span class="line">        <span class="comment">//递归右子树的有边界为中序中原来右子树的边界</span></span><br><span class="line">        root.right = recur(pre_root + (idx - in_left) + <span class="number">1</span>, idx+<span class="number">1</span>, in_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode-cn执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">3 ms, 在所有 Java 提交中击败了55.11%的用户</span><br><span class="line">内存消耗：</span><br><span class="line">38.4 MB, 在所有 Java 提交中击败了80.00%的用户</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go，不借助Map版本</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="keyword">int</span>, inorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    root := <span class="built_in">new</span>(TreeNode)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    root_val := preorder[<span class="number">0</span>]</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> inorder[i] != root_val &#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    left_tree := buildTree(preorder[<span class="number">1</span>:i+<span class="number">1</span>],inorder[:i])</span><br><span class="line">    right_tree := buildTree(preorder[i+<span class="number">1</span>:],inorder[i+<span class="number">1</span>:])</span><br><span class="line">    root.Val = root_val</span><br><span class="line">    root.Left = left_tree</span><br><span class="line">    root.Right = right_tree</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode-cn执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">4 ms, 在所有 Go 提交中击败了95.75%的用户</span><br><span class="line">内存消耗：</span><br><span class="line">4.2 MB, 在所有 Go 提交中击败了25.36%的用户</span><br></pre></td></tr></table></figure><p>牛客网运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行时间：5ms</span><br><span class="line">超过39.31%用Go提交的代码</span><br><span class="line">占用内存：2344KB</span><br><span class="line">超过9.75%用Go提交的代码</span><br></pre></td></tr></table></figure><h2 id="思考：为什么二叉树的题目一般用递归来解？"><a href="#思考：为什么二叉树的题目一般用递归来解？" class="headerlink" title="思考：为什么二叉树的题目一般用递归来解？"></a>思考：为什么二叉树的题目一般用递归来解？</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/4chong-jie-fa-di-gui-zhan-dui-lie-by-sdwwld/" target="_blank" rel="noopener">4种解法（递归，栈，队列），最后一种击败了100%的用户</a><br><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/" target="_blank" rel="noopener">力扣官方题解</a><br><a href="https://blog.csdn.net/Mr_SCX/article/details/106690412" target="_blank" rel="noopener">【面试题】重建二叉树（解题思路分析+Java、Python实现+代码详细注释）</a><br><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-di-gui-fa-qin/" target="_blank" rel="noopener">面试题07. 重建二叉树（递归法，清晰图解）</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="LeetCode-lcof-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-lcof-Solutions/"/>
    
    
      <category term="二叉树" scheme="https://octopuslian.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://octopuslian.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>2021春招找工作计划</title>
    <link href="https://octopuslian.github.io/2021/03/04/2021-spring-find-job/"/>
    <id>https://octopuslian.github.io/2021/03/04/2021-spring-find-job/</id>
    <published>2021-03-04T13:53:47.000Z</published>
    <updated>2021-03-04T14:10:26.247Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 22:32:20 GMT+0800 (GMT+08:00) --><p>三月到来，各个企业又开始招人了，我也收到了几家企业的面试邀请。</p><p>找工作避免不了被问到“是否接受加班？”————当然是看情况了，我有事就拒绝加班，没事但是一天的工作没做完肯定是会自觉加班的，但我最讨厌最讨厌最讨厌那种磨洋工式的加班。</p><p>今天就收到了一位很有礼貌的猎头小哥问我“有家游戏公司995可以接受吗？” 我果断拒绝，因为说是995，有可能就临上线就变成996甚至997，人的欲望是无穷无尽的，所以如何摆脱困境，就是要找到从根源上就拒绝加班的企业。</p><p>犹记得我在第一家游戏公司的时候，美其名曰加班，实际上是因为一个人回去也没啥意思，就跟着同事一块在公司看书学习敲代码，顺便拿加班补贴和打车补助；第二家公司，刚开始基本7点就准时下班了，但后面逐渐开始那种毫无意义的加班，甚至根据加班来看工作态度、年终考核的时候，我放弃了，放弃了那可有可无的年终奖。</p><p>因此，我看透了国内这种加班的本质，要么高效完成工作，要么加班按照劳动法给加班费，否则一切强制无意义的加班就是压榨。</p><p>今天写下这篇文章，拒绝无意义的加班，不知道以后正在屠龙的少年是否会变成恶龙，以此当做一个记录吧。</p><p>新的一年，祝自己能顺利拿到满意的<code>offer</code>！</p><p><img src="/2021/03/04/2021-spring-find-job/reject-996.jpg" alt></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 22:32:20 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;三月到来，各个企业又开始招人了，我也收到了几家企业的面试邀请。&lt;/p&gt;&lt;p&gt;找工作避免不了被问到“是否接受加班？”————当然是看情况了，我有事
      
    
    </summary>
    
    
      <category term="Work-Career" scheme="https://octopuslian.github.io/categories/Work-Career/"/>
    
    
      <category term="找工作" scheme="https://octopuslian.github.io/tags/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="春招" scheme="https://octopuslian.github.io/tags/%E6%98%A5%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 06. 从尾到头打印链表</title>
    <link href="https://octopuslian.github.io/2021/03/04/leetcode-lcof-06-cong-wei-dao-tou-da-yin-lian-biao/"/>
    <id>https://octopuslian.github.io/2021/03/04/leetcode-lcof-06-cong-wei-dao-tou-da-yin-lian-biao/</id>
    <published>2021-03-04T05:44:25.000Z</published>
    <updated>2021-03-04T05:51:17.010Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">力扣-剑指 Offer 06. 从尾到头打印链表</a></p><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">0 &lt;= s 的长度 &lt;= 10000</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>该题难度为简单。</p><h3 id="解法一：两个for循环"><a href="#解法一：两个for循环" class="headerlink" title="解法一：两个for循环"></a>解法一：两个for循环</h3><ul><li>1，先声明两个整型数组；</li><li>2，第一个<code>for</code>循环从头到尾记录链表的每个节点的值；</li><li>3，第二个<code>for</code>循环逆序记录链表的每个节点的值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reversePrint</span><span class="params">(head *ListNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> re []<span class="keyword">int</span>  <span class="comment">//正序</span></span><br><span class="line">    <span class="keyword">var</span> er []<span class="keyword">int</span>  <span class="comment">//逆序</span></span><br><span class="line">    <span class="keyword">for</span> ;head != <span class="literal">nil</span>; &#123;</span><br><span class="line">        re = <span class="built_in">append</span>(re,head.Val)  <span class="comment">//从头到尾记录链表的每个节点的值</span></span><br><span class="line">        head = head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="built_in">len</span>(re)<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-- &#123;</span><br><span class="line">        er = <span class="built_in">append</span>(er,re[i])  <span class="comment">//逆序记录链表的每个节点的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> er  <span class="comment">//返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode-cn执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">0 ms, 在所有 Go 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：</span><br><span class="line">3.5 MB, 在所有 Go 提交中击败了46.84%的用户</span><br></pre></td></tr></table></figure><p>牛客网执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行时间：3ms</span><br><span class="line">超过2.29%用Go提交的代码</span><br><span class="line">占用内存：868KB</span><br><span class="line">超过39.69%用Go提交的代码</span><br></pre></td></tr></table></figure><h3 id="解法二：递归"><a href="#解法二：递归" class="headerlink" title="解法二：递归"></a>解法二：递归</h3><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/solution/liang-chong-jie-fa-zhan-yu-di-gui-by-jalan/" target="_blank" rel="noopener">两种解法：栈与递归</a></p><ul><li>递归函数作用：将链表节点值逆序存入结果集</li><li>结束条件：当节点为空时</li><li>递归调用条件：当下一个节点不为空时</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//Go</span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * type ListNode struct &#123;</span><br><span class="line"> *     Val int</span><br><span class="line"> *     Next *ListNode</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">func reversePrint(head *ListNode) []int &#123;</span><br><span class="line">    if head == nil &#123;</span><br><span class="line">        return []int&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res := reversePrint(head.Next)</span><br><span class="line">    return append(res, head.Val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode-cn执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">4 ms, 在所有 Go 提交中击败了63.34%的用户</span><br><span class="line">内存消耗：</span><br><span class="line">4.7 MB, 在所有 Go 提交中击败了28.61%的用户</span><br></pre></td></tr></table></figure><p>牛客网执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行时间：3ms</span><br><span class="line">超过2.29%用Go提交的代码</span><br><span class="line">占用内存：868KB</span><br><span class="line">超过39.69%用Go提交的代码</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="LeetCode-lcof-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-lcof-Solutions/"/>
    
    
      <category term="链表" scheme="https://octopuslian.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="栈" scheme="https://octopuslian.github.io/tags/%E6%A0%88/"/>
    
      <category term="遍历" scheme="https://octopuslian.github.io/tags/%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 05. 替换空格</title>
    <link href="https://octopuslian.github.io/2021/03/03/leetcode-lcof-05-ti-huan-kong-ge/"/>
    <id>https://octopuslian.github.io/2021/03/03/leetcode-lcof-05-ti-huan-kong-ge/</id>
    <published>2021-03-03T15:20:54.000Z</published>
    <updated>2021-03-04T04:32:19.567Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">力扣-剑指 Offer 05. 替换空格</a></p><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">0 &lt;= s 的长度 &lt;= 10000</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>该题难度为简单。</p><h3 id="解法一：使用strings-Replace"><a href="#解法一：使用strings-Replace" class="headerlink" title="解法一：使用strings.Replace"></a>解法一：使用strings.Replace</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">replaceSpace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> strings.Replace(s, <span class="string">" "</span>, <span class="string">"%20"</span>, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法二：遍历添加"><a href="#解法二：遍历添加" class="headerlink" title="解法二：遍历添加"></a>解法二：遍历添加</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">replaceSpace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    ans := <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> s&#123;</span><br><span class="line">        <span class="keyword">if</span> v == <span class="string">' '</span>&#123;</span><br><span class="line">            ans = ans + <span class="string">"%20"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = ans + <span class="keyword">string</span>(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode-执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">0 ms, 在所有 Go 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：</span><br><span class="line">3.4 MB, 在所有 Go 提交中击败了16.95%的用户</span><br></pre></td></tr></table></figure><p>牛客网执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行时间：2ms</span><br><span class="line">超过100.00%用Go提交的代码</span><br><span class="line">占用内存：956KB</span><br><span class="line">超过23.81%用Go提交的代码</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="LeetCode-lcof-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-lcof-Solutions/"/>
    
    
      <category term="字符串" scheme="https://octopuslian.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="lcof" scheme="https://octopuslian.github.io/tags/lcof/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-微服务概览与治理</title>
    <link href="https://octopuslian.github.io/2021/03/03/goatc-1-microservice-overview-and-governance/"/>
    <id>https://octopuslian.github.io/2021/03/03/goatc-1-microservice-overview-and-governance/</id>
    <published>2021-03-03T07:21:10.000Z</published>
    <updated>2021-03-04T12:32:59.076Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --><h2 id="微服务概览"><a href="#微服务概览" class="headerlink" title="微服务概览"></a>微服务概览</h2><h3 id="单体设计"><a href="#单体设计" class="headerlink" title="单体设计"></a>单体设计</h3><p>尽管也是模块化逻辑，但是最终它还是会打包并部署为单体式应用。其中最主要问题就是这个应用太复杂，以至于任何单个开发者都不可能搞懂它。应用无法扩展，可靠性很低，最终敏捷性和部署变的无法完成。</p><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/simple.png" alt></p><p>因此，我们应对的思路：<strong>化繁为简，分而治之</strong></p><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/web-inter.png" alt></p><h3 id="微服务起源"><a href="#微服务起源" class="headerlink" title="微服务起源"></a>微服务起源</h3><h4 id="Q：SOA-面向服务的架构模式-和微服务是什么关系？"><a href="#Q：SOA-面向服务的架构模式-和微服务是什么关系？" class="headerlink" title="Q：SOA(面向服务的架构模式)和微服务是什么关系？"></a>Q：SOA(面向服务的架构模式)和微服务是什么关系？</h4><p>A:可以把微服务想成是SOA的一种实践。</p><ul><li>小即是美：</li><li>单一职责：</li><li>尽可能早地创造原型：</li><li>可移植性比效率更重要：</li></ul><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/ms-ma-database.png" alt></p><h3 id="微服务定义"><a href="#微服务定义" class="headerlink" title="微服务定义"></a>微服务定义</h3><p>定义：围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术。微服务架构通过业务拆分实现服务组件化，通过组件组合快速开发系统，业务单一的服务组件又可以独立部署，使得整个系统变得清晰灵活。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>原子服务</li><li>独立进程</li><li>隔离部署</li><li>去中心化服务治理</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>基础设施的建设、复杂度高</li></ul><h3 id="微服务不足"><a href="#微服务不足" class="headerlink" title="微服务不足"></a>微服务不足</h3><ul><li>微服务应用是分布式系统，由此会带来固有的复杂性。开发者不得不使用<code>RPC</code>或者消息传递，来实现进程间通信；此外，必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题。</li><li>分区的数据库架构，同时更新多个业务主体的事务很普遍。这种事务对于单体式应用来说很容易，因为只有一个数据库。在微服务架构应用中，需要更新不同服务所使用的不同的数据库，从而对开发者提出了更高的要求和挑战。</li><li>测试一个基于微服务的应用也是很复杂的任务。</li><li>服务模块间的依赖，应用的升级有可能波及多个服务模块的修改。</li><li>对运维基础设施的挑战比较大。</li></ul><h3 id="组件服务化"><a href="#组件服务化" class="headerlink" title="组件服务化"></a>组件服务化</h3><p>传统实现组件的方式是通过库(library)，库是和应用一起运行在进程中，库的局部变化意味着整个应用的重新部署。通过微服务来实现组件，意味着将应用拆散为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需要新部署对应的服务进程。我们用<code>Go</code>实施一个微服务：</p><ul><li>kit：一个微服务的基础库(框架)。</li><li>service：业务代码 + kit依赖 + 第三方依赖组成的业务微服务</li><li>rpc + message queue：轻量级通讯</li></ul><p><strong>本质上等同于多个服务组合(compose)完成了一个完整的用户场景(usecase)。</strong></p><h3 id="重要-按业务组织服务"><a href="#重要-按业务组织服务" class="headerlink" title="(重要)按业务组织服务"></a>(重要)按业务组织服务</h3><p>按业务能力组织服务的意思是服务提供的能力和业务功能对应，比如：订单服务和数据访问服务，前者反应了真实的订单相关服务，后者是一种技术抽象服务不反应真实的业务。所以按照微服务架构理念来划分服务时，是不应该存在数据访问服务这样一个服务的。</p><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/law.png" alt></p><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/law2.png" alt></p><p>我们的模式：大前端(移动/Web) &gt; 网关接入 &gt; 业务服务 &gt; 平台服务 &gt; 基础设施(PaaS/Saas)<br><strong>开发团队对软件在生产环境的运行负全部责任。</strong></p><h3 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h3><ul><li>数据去中心化</li><li>治理去中心化</li><li>技术去中心化</li></ul><p><strong>每个服务独享自身的数据存储设施(缓存、数据库等)，不像传统应用共享一个缓存和数据库，这样有利于服务的独立性，这样有利于服务的独立性，隔离相关干扰。</strong></p><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/qu-zhong-xin.png" alt></p><h2 id="基础设施自动化"><a href="#基础设施自动化" class="headerlink" title="基础设施自动化"></a>基础设施自动化</h2><ul><li>CICD：Gitlab + Gitlab Hooks + k8s</li><li>Testing：测试环境、单元测试、API自动化测试</li><li>在线运行时：k8s，以及一系列Prometheus、ELK、Conrtol Panle</li></ul><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/ji-chu-she-shi-zi-dong-hua.png" alt></p><h3 id="可用性-amp-兼容性设计"><a href="#可用性-amp-兼容性设计" class="headerlink" title="可用性 &amp; 兼容性设计"></a>可用性 &amp; 兼容性设计</h3><p>著名的<code>Design For Failure</code>思想，微服务架构采用粗粒度的进程间通信，引入了额外的复杂性和需要处理的新问题，如网络延迟、消息格式、负载均衡和容错，忽略了其中任何一点都属于对“分布式计算的误解”。</p><ul><li>隔离</li><li>超时控制</li><li>负载保护</li><li>限流</li><li>降级</li><li>重试</li><li>负载均衡</li></ul><p>特别注意：<strong>服务提供者的变更可能引发服务消费者的兼容性破坏，时刻谨记保持服务契约(接口)的兼容性。</strong></p><p>Be conserative in what you send, be liberal in what you accept.</p><p>发送时要保守，接收时要开放。按照伯斯塔尔法则的思想来设计和实现服务时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。</p><h2 id="微服务设计"><a href="#微服务设计" class="headerlink" title="微服务设计"></a>微服务设计</h2><h3 id="API-Gateway"><a href="#API-Gateway" class="headerlink" title="API Gateway"></a>API Gateway</h3><p>按照垂直功能进行拆分，对外暴露了一批微服务，但是缺乏统一的出口面临了不少困难：</p><ul><li>客户端到微服务直接通信，强耦合；</li><li>需要多次请求，客户端聚合数据，工作量巨大，延迟高；</li><li>协议不利于统一，各个部门有差异，需要端来兼容；</li><li>面向“端”的<code>API</code>适配，耦合到了内部服务；</li><li>多终端兼容逻辑复杂，每个服务都需要处理；</li><li>统一逻辑无法收敛，比如安全认证、限流。</li></ul><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/web-server.png" alt></p><p><strong>要内聚模式配合。</strong></p><p>新增了一个<code>app-interface</code>用于统一的协议出口，在服务进行大量的<code>dataset join</code>，按照业务场景设计粗粒度的<code>API</code>，给后续服务的演进带来很多优势：</p><ul><li>轻量交互：协议精简、聚合。</li><li>差异服务：数据裁剪以及聚合、针对终端定制化<code>API</code>。</li><li>动态升级：原有系统兼容升级，更新服务而非协议。</li><li>沟通效率提升，协作模式演进为移动业务+网管小组。</li></ul><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/BFF.png" alt></p><p><code>BFF</code>可以认为是一种适配服务，将后端的微服务进行适配(主要包括聚合裁剪和格式适配等逻辑)，向无线端设备暴露友好和统一的<code>API</code>，方便无线设备接入访问后端服务。</p><h4 id="single-point-of-failure"><a href="#single-point-of-failure" class="headerlink" title="single point of failure"></a>single point of failure</h4><p>严重代码缺陷或者流量洪峰可能引发集群宕机。</p><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/aws2.png" alt><br><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/api2.png" alt></p><ul><li>单个模块也会导致后续业务集成复杂度高，根据康威法则，单块的无线<code>BFF</code>和多团队之间就出现不匹配的问题，团队之间沟通协调成本高，交付效率低下。</li><li>很多横跨切面逻辑，比如安全认证，日志监控，限流熔断等。随着时间的推移，代码变得越来越复杂，技术债越堆越多。</li></ul><h4 id="跨横切面（Cross-Cutting-Concerns）"><a href="#跨横切面（Cross-Cutting-Concerns）" class="headerlink" title="跨横切面（Cross-Cutting Concerns）"></a>跨横切面（Cross-Cutting Concerns）</h4><p>跨横切面(Cross-Cutting Concerns)的功能，需要协调更新框架升级发版(路由、认证、限流、安全)，因此全部上沉，引入了 API Gateway，把业务集成度高的 BFF 层和通用功能服务层 <code>APIGateway</code> 进行了分层处理</p><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/api-gateway.png" alt></p><p>在新的架构中，网关承担了重要的角色，它是解耦拆分和后续升级迁移的利器。在网关的配合下，单块 BFF实现了解耦拆分，各业务线团队可以独立开发和交付各自的微服务，研发效率大大提升。另外，把跨横切面逻辑从 BFF 剥离到网关上去以后，BFF 的开发人员可以更加专注业务逻辑交付，实现了架构上的关注分离(Separation of Concerns)。</p><p>我们业务流量实际为：移动端 -&gt; API Gateway -&gt; BFF -&gt; Mircoservice，在FE Web业务中，BFF 可以是 nodejs 来做服务端渲染(SSR，Server-Side Rendering)，注意这里忽略了上游的 CDN、4/7层负载均衡(ELB)。</p><p>注：4层负载均衡可能是——LVS/F5/NetScala，7层负载均衡——Nginx/ELB、SLB/API Gateway/BFS。</p><h3 id="Mircoservice-划分"><a href="#Mircoservice-划分" class="headerlink" title="Mircoservice 划分"></a>Mircoservice 划分</h3><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/bounded-context.png" alt></p><p>微服务架构时遇到的第一个问题就是如何划分服务的边界。在实际项目中通常会采用两种不同的方式划分服务边界，即通过业务职能(BusinessCapability)或是 DDD 的限界上下文(BoundedContext)。</p><ul><li><p>Business Capability<br>由公司内部不同部门提供的职能。例如客户服务部门提供客户服务的职能，财务部门提供财务相关的职能。</p></li><li><p>Bounded Context<br>限界上下文是DDD中用来划分不同业务边界的元素，这里业务边界的含义是“解决不同业务问题”的问题域和对应的解决方案域，为了解决某种类型的业务问题，贴近领域知识，也就是业务。这本质上也促进了组织结构的演进：Service perteam</p></li></ul><p>CQRS，将应用程序分为两部分：命令端和查询端。命令端处理程序创建，更新和删除请求，并在数据更改时发出事件。查询端通过针对一个或多个物化视图执行查询来处理查询，这些物化视图通过订阅数据更改时发出的事件流而保持最新。</p><p>在稿件服务演进过程中，我们发现围绕着创作稿件、审核稿件、最终发布稿件有大量的逻辑揉在一块，其中稿件本身的状态也有非常多种，但是最终前台用户只关注稿件能否查看，我们依赖稿件数据库 binlog 以及订阅binlog 的中间件canal，将我们的稿件结果发布到消息队列 kafka 中，最终消费数据独立组建一个稿件查阅结果数据库，并对外提供一个独立查询服务，来拆分复杂架构和业务。</p><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/CRQS.png" alt></p><p>我们架构也从 Polling publisher -&gt; Transaction logtailing 进行了演进(Pull vs Push)</p><h2 id="gRPC-amp-服务实现"><a href="#gRPC-amp-服务实现" class="headerlink" title="gRPC &amp; 服务实现"></a>gRPC &amp; 服务实现</h2><h2 id="多集群-amp-多租户"><a href="#多集群-amp-多租户" class="headerlink" title="多集群 &amp; 多租户"></a>多集群 &amp; 多租户</h2><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;微服务概览&quot;&gt;&lt;a href=&quot;#微服务概览&quot; class=&quot;headerlink&quot; title=&quot;微服务概览&quot;&gt;&lt;/a&gt;微服务概览&lt;
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="Golang" scheme="https://octopuslian.github.io/tags/Golang/"/>
    
      <category term="微服务" scheme="https://octopuslian.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="gRPC" scheme="https://octopuslian.github.io/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营总结和收获</title>
    <link href="https://octopuslian.github.io/2021/03/03/geekbang-gatc-gain/"/>
    <id>https://octopuslian.github.io/2021/03/03/geekbang-gatc-gain/</id>
    <published>2021-03-03T04:55:22.000Z</published>
    <updated>2021-03-03T03:28:41.223Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --><p>花了将近一个月终于刷完了<code>GATC</code>，让我系统学习了算法与数据结构的知识，尤其是后面接触的字典树、并查集、布隆过滤器、<code>AVL Tree</code>、<code>Red black Tree</code>这种高级数据结构，让我不得不感人类思想的伟大。</p><p>字符串算法和排序算法很重要，面试经常考，要及时掌握，同时不能放弃刷题，要时刻保持做题手感，同时要时刻借鉴别人优秀的解题思路。这样编程能力以及算法的基本功会慢慢得到提升。</p><p>加油！^_^</p><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h2><p><a href="https://octopuslian.github.io/categories/GATC/">GATC</a><br><a href="https://octopuslian.github.io/2020/11/29/geekbang-live-a-week-algo-training-camp-1-time-space-complex-analyze/">时间复杂度和空间复杂度分析</a><br><a href="https://octopuslian.github.io/2020/11/30/geekbang-live-a-week-algo-training-camp-2-array-linked-list-skip-list/">数组、链表、跳表</a><br><a href="https://octopuslian.github.io/2020/12/01/geekbang-live-a-week-algo-training-camp-3-tree-binary-tree-and-binary-search-tree/">树、二叉树、二叉搜索树</a><br><a href="https://octopuslian.github.io/2020/12/02/geekbang-live-a-week-algo-training-camp-4-recursive/">递归</a><br><a href="https://octopuslian.github.io/2020/12/03/geekbang-live-a-week-algo-training-camp-5-test/">算法体验营-结课考试题</a><br><a href="https://octopuslian.github.io/2021/01/22/geekbang-gatc-04-stack-and-queue/">栈和队列</a><br><a href="https://octopuslian.github.io/2021/01/22/geekbang-gatc-12-dynamic-programming/">动态规划</a><br><a href="https://octopuslian.github.io/2021/01/22/geekbang-gatc-13-dictionary-tree-and-union-loopup/">Trie树、并查集</a><br><a href="https://octopuslian.github.io/2021/01/22/geekbang-gatc-16-bit-operation/">位运算基础</a><br><a href="https://octopuslian.github.io/2021/01/22/geekbang-gatc-05-hashmap-and-set/">哈希表、映射、集合</a><br><a href="https://octopuslian.github.io/2021/01/23/geekbang-gatc-08-divide-conquer-and-backtracking/">分治、回溯</a><br><a href="https://octopuslian.github.io/2021/01/23/geekbang-gatc-09-dfs-and-bfs/">深度优先搜索、广度优先搜索</a><br><a href="https://octopuslian.github.io/2021/02/23/geekbang-gatc-10-greedy-algo/">贪心算法</a><br><a href="https://octopuslian.github.io/2021/02/23/geekbang-gatc-11-binary-search/">二分查找</a><br><a href="https://octopuslian.github.io/2021/02/24/geekbang-gatc-18-sort-algo/">初级排序和高级排序</a><br><a href="https://octopuslian.github.io/2021/02/24/geekbang-gatc-20-string-algo/">字符串基础知识、高级字符串算法、字符串匹配算法</a><br><a href="https://octopuslian.github.io/2021/03/01/geekbang-gatc-14-advanced-search/">高级搜索</a><br><a href="https://octopuslian.github.io/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/">AVL树和红黑树</a><br><a href="https://octopuslian.github.io/2021/03/02/geekbang-gatc-17-bloom-filter-and-lru-cache/">布隆过滤器、LRUCache</a><br><a href="https://octopuslian.github.io/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/">动态规划、状态转移方程</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;花了将近一个月终于刷完了&lt;code&gt;GATC&lt;/code&gt;，让我系统学习了算法与数据结构的知识，尤其是后面接触的字典树、并查集、布隆过滤器、&lt;c
      
    
    </summary>
    
    
      <category term="GATC" scheme="https://octopuslian.github.io/categories/GATC/"/>
    
    
      <category term="算法" scheme="https://octopuslian.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="收获" scheme="https://octopuslian.github.io/tags/%E6%94%B6%E8%8E%B7/"/>
    
      <category term="总结" scheme="https://octopuslian.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 04.二维数组中的查找</title>
    <link href="https://octopuslian.github.io/2021/03/02/leetcode-lcof-04-er-wei-shu-zu-zhong-de-cha-zhao/"/>
    <id>https://octopuslian.github.io/2021/03/02/leetcode-lcof-04-er-wei-shu-zu-zhong-de-cha-zhao/</id>
    <published>2021-03-02T15:24:40.000Z</published>
    <updated>2021-03-02T15:25:34.251Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/submissions/" target="_blank" rel="noopener">力扣-剑指 Offer 04. 二维数组中的查找</a></p><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">现有矩阵 matrix 如下：</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">给定 target = 5，返回 true。</span><br><span class="line">给定 target = 20，返回 false。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">0 &lt;= n &lt;= 1000</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>难度为中等。</p><h3 id="解法一：暴力法"><a href="#解法一：暴力法" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h3><p>先用一个循环，每次遍历出一个数组<code>nums</code>，然后用<a href="https://golang.org/pkg/sort/#SearchInts" target="_blank" rel="noopener">sort.SearchInts</a>查出<code>nums</code>数组中<code>target</code>的下标，接着做下判断即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findNumberIn2DArray</span><span class="params">(matrix [][]<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, nums := <span class="keyword">range</span> matrix &#123;</span><br><span class="line"><span class="comment">//遍历数组切片，查找数组中是否含有target值，如果查找不到，返回值是target应该插入数组的位置（会保持数组的递增顺序）</span></span><br><span class="line">i := sort.SearchInts(nums, target) <span class="comment">//查找nums数组中target的下标</span></span><br><span class="line"><span class="comment">//插入的位置小于数组长度 且 插入数组的位置上的值和目标值相等</span></span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="built_in">len</span>(nums) &amp;&amp; target == nums[i] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode-cn执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">28 ms, 在所有 Go 提交中击败了80.58%的用户</span><br><span class="line">内存消耗：6.6 MB, 在所有 Go 提交中击败了70.78%的用户</span><br></pre></td></tr></table></figure><p>牛客网运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行时间：7ms</span><br><span class="line">超过8.42%用Go提交的代码</span><br><span class="line">占用内存：3204KB</span><br><span class="line">超过44.21%用Go提交的代码</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="LeetCode-lcof-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-lcof-Solutions/"/>
    
    
      <category term="数组" scheme="https://octopuslian.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="暴力" scheme="https://octopuslian.github.io/tags/%E6%9A%B4%E5%8A%9B/"/>
    
      <category term="sort" scheme="https://octopuslian.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营-动态规划、状态转移方程串讲</title>
    <link href="https://octopuslian.github.io/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/"/>
    <id>https://octopuslian.github.io/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/</id>
    <published>2021-03-02T14:10:35.000Z</published>
    <updated>2021-03-02T14:14:39.233Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --><h2 id="常见的DP题目和状态转移方程"><a href="#常见的DP题目和状态转移方程" class="headerlink" title="常见的DP题目和状态转移方程"></a>常见的DP题目和状态转移方程</h2><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">爬楼梯</a></h3><p><img src="/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/pa-lou-ti.png" alt></p><h3 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">不同路径</a></h3><p><img src="/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/bu-tong-lu-jing.png" alt></p><h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">打家劫舍</a></h3><p><img src="/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/da-jia-jie-she.png" alt></p><h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">最小路径和</a></h3><p><img src="/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/zui-xiao.png" alt></p><h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">买卖股票的最佳时机</a></h3><p><img src="/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/gu-piao.png" alt></p><p><img src="/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/2-gu-piao.png" alt></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-w-5/" target="_blank" rel="noopener">一个通用方法团灭 6 道股票问题</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;常见的DP题目和状态转移方程&quot;&gt;&lt;a href=&quot;#常见的DP题目和状态转移方程&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="GATC" scheme="https://octopuslian.github.io/categories/GATC/"/>
    
    
      <category term="动态规划" scheme="https://octopuslian.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="DP" scheme="https://octopuslian.github.io/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营-布隆过滤器、LRUCache的实现和应用</title>
    <link href="https://octopuslian.github.io/2021/03/02/geekbang-gatc-17-bloom-filter-and-lru-cache/"/>
    <id>https://octopuslian.github.io/2021/03/02/geekbang-gatc-17-bloom-filter-and-lru-cache/</id>
    <published>2021-03-02T13:09:46.000Z</published>
    <updated>2021-03-02T13:46:47.333Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --><h2 id="布隆过滤器-Bloom-filter"><a href="#布隆过滤器-Bloom-filter" class="headerlink" title="布隆过滤器-Bloom filter"></a>布隆过滤器-Bloom filter</h2><p><img src="/2021/03/02/geekbang-gatc-17-bloom-filter-and-lru-cache/hashtable.png" alt></p><h3 id="Bloom-filter-vs-Hash-Table"><a href="#Bloom-filter-vs-Hash-Table" class="headerlink" title="Bloom filter vs Hash Table"></a>Bloom filter vs Hash Table</h3><p>一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。</p><p>优点：空间效率和查询时间都远远超过一般的算法。</p><p>缺点：有一定的误识别率和删除困难。</p><p><img src="/2021/03/02/geekbang-gatc-17-bloom-filter-and-lru-cache/buloom.png" alt></p><p><img src="/2021/03/02/geekbang-gatc-17-bloom-filter-and-lru-cache/bloom2.png" alt></p><p>结论：如果这个元素在布隆过滤器查不到，那肯定不存在；如果查得到，那可能存在。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>1，比特币网络<br>2，分布式系统（Map-Reduce）——Hadoop、Search Engine<br>3，Redis缓存<br>4，垃圾邮件、评论等的过滤</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="/2021/03/02/geekbang-gatc-17-bloom-filter-and-lru-cache/bpython.png" alt></p><h2 id="LRUCache"><a href="#LRUCache" class="headerlink" title="LRUCache"></a>LRUCache</h2><h3 id="Cache缓存"><a href="#Cache缓存" class="headerlink" title="Cache缓存"></a>Cache缓存</h3><p>1，记忆<br>2，钱包-储物柜<br>3，代码模块</p><ul><li>两个要素：大小、替换策略</li><li>Hash Table + Double LinkedList</li><li>O(1)查询，修改、更新</li></ul><p><img src="/2021/03/02/geekbang-gatc-17-bloom-filter-and-lru-cache/lru-cache-work.png" alt></p><p>代码示例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span><span class="params">(object)</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span> </span><br><span class="line">        self.dic = collections.OrderedDict() </span><br><span class="line">        self.remain = capacity<span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span> </span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.dic: </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span> </span><br><span class="line">            v = self.dic.pop(key) </span><br><span class="line">            self.dic[key] = v   <span class="comment"># key as the newest one </span></span><br><span class="line">            <span class="keyword">return</span> v </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key, value)</span>:</span> </span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> self.dic: </span><br><span class="line">                self.dic.pop(key) </span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">if</span> self.remain &gt; <span class="number">0</span>: </span><br><span class="line">                    self.remain -= <span class="number">1</span> </span><br><span class="line">                <span class="keyword">else</span>:   <span class="comment"># self.dic is full</span></span><br><span class="line">                    self.dic.popitem(last=<span class="literal">False</span>) </span><br><span class="line">            self.dic[key] = value</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 使用 哈希表 + 双端链表 实现 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedNode</span> </span>&#123;  constructor(key = <span class="number">0</span>, val = <span class="number">0</span>) &#123;    </span><br><span class="line">    <span class="keyword">this</span>.key = key    </span><br><span class="line">    <span class="keyword">this</span>.val = val    </span><br><span class="line">    <span class="keyword">this</span>.prev = <span class="keyword">null</span>    </span><br><span class="line">    <span class="keyword">this</span>.next = <span class="keyword">null</span>  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;  </span><br><span class="line">    constructor() &#123;    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode()    <span class="keyword">this</span>.tail = <span class="keyword">new</span> LinkedNode()    <span class="keyword">this</span>.head.next = <span class="keyword">this</span>.tail    <span class="keyword">this</span>.tail.prev = <span class="keyword">this</span>.head  &#125;  insertFirst(node) &#123;    node.next = <span class="keyword">this</span>.head.next    node.prev = <span class="keyword">this</span>.head    <span class="keyword">this</span>.head.next.prev = node    <span class="keyword">this</span>.head.next = node  &#125;  remove(node) &#123;    node.prev.next = node.next    node.next.prev = node.prev  &#125;  removeLast() &#123;    <span class="keyword">if</span> (<span class="keyword">this</span>.tail.prev === <span class="keyword">this</span>.head) <span class="keyword">return</span> <span class="keyword">null</span>    let last = <span class="keyword">this</span>.tail.prev    <span class="keyword">this</span>.remove(last)    <span class="keyword">return</span> last  &#125;&#125;<span class="comment">/** * <span class="doctag">@param</span> &#123;number&#125; capacity */</span><span class="keyword">var</span> LRUCache = function(capacity) &#123;  <span class="keyword">this</span>.capacity = capacity  <span class="keyword">this</span>.keyNodeMap = <span class="keyword">new</span> Map()  <span class="keyword">this</span>.cacheLink = <span class="keyword">new</span> LinkedList()&#125;;<span class="comment">/**  * <span class="doctag">@param</span> &#123;number&#125; key * <span class="doctag">@return</span> &#123;number&#125; */</span>LRUCache.prototype.get = function(key) &#123;  <span class="keyword">if</span> (!<span class="keyword">this</span>.keyNodeMap.has(key)) <span class="keyword">return</span> -<span class="number">1</span>  let val = <span class="keyword">this</span>.keyNodeMap.get(key).val  <span class="keyword">this</span>.put(key, val)  <span class="keyword">return</span> val&#125;;<span class="comment">/**  * <span class="doctag">@param</span> &#123;number&#125; key  * <span class="doctag">@param</span> &#123;number&#125; value * <span class="doctag">@return</span> &#123;void&#125; */</span>LRUCache.prototype.put = function(key, value) &#123;  let size = <span class="keyword">this</span>.keyNodeMap.<span class="function">size  <span class="title">if</span> <span class="params">(<span class="keyword">this</span>.keyNodeMap.has(key)</span>) </span>&#123;    <span class="keyword">this</span>.cacheLink.remove(<span class="keyword">this</span>.keyNodeMap.get(key));     --size   &#125;  <span class="keyword">if</span> (size &gt;= <span class="keyword">this</span>.capacity) &#123;    <span class="keyword">this</span>.keyNodeMap.delete(<span class="keyword">this</span>.cacheLink.removeLast().key)  &#125;  let node = <span class="keyword">new</span> LinkedNode(key, value)  <span class="keyword">this</span>.keyNodeMap.set(key, node)  <span class="keyword">this</span>.cacheLink.insertFirst(node)&#125;;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/cpselvis/p/6265825.html" target="_blank" rel="noopener">布隆过滤器(Bloom Filter)的原理和实现</a><br><a href="https://blog.csdn.net/tianyaleixiaowu/article/details/74721877" target="_blank" rel="noopener">使用BloomFilter布隆过滤器解决缓存击穿、垃圾邮件识别、集合判重</a><br><a href="https://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/" target="_blank" rel="noopener">Bloom Filters – Introduction and Implementation</a><br><a href="https://github.com/jhgg/pybloof" target="_blank" rel="noopener">Github-Pybloof</a><br><a href="https://github.com/lovasoa/bloomfilter/blob/master/src/main/java/BloomFilter.java" target="_blank" rel="noopener">布隆过滤器Java实现示例1</a><br><a href="https://github.com/Baqend/Orestes-Bloomfilter" target="_blank" rel="noopener">布隆过滤器Java实现示例2</a><br><a href="https://www.sqlpassion.at/archive/2018/01/06/understanding-the-meltdown-exploit-in-my-own-simple-words/" target="_blank" rel="noopener">Understanding the Meltdown exploit – in my own simple words</a><br><a href="https://en.wikipedia.org/wiki/Cache_replacement_policies" target="_blank" rel="noopener">Cache replacement policies</a><br><a href="https://shimo.im/docs/tTxRkGwJpXG6WkGY/read" target="_blank" rel="noopener">LRU Cache Python代码</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;布隆过滤器-Bloom-filter&quot;&gt;&lt;a href=&quot;#布隆过滤器-Bloom-filter&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="GATC" scheme="https://octopuslian.github.io/categories/GATC/"/>
    
    
      <category term="布隆过滤器" scheme="https://octopuslian.github.io/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
      <category term="LRUCache" scheme="https://octopuslian.github.io/tags/LRUCache/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 03. 数组中重复的数字</title>
    <link href="https://octopuslian.github.io/2021/03/01/leetcode-lcof-03-shu-zu-zhong-zhong-fu-de-shu-zi/"/>
    <id>https://octopuslian.github.io/2021/03/01/leetcode-lcof-03-shu-zu-zhong-zhong-fu-de-shu-zi/</id>
    <published>2021-03-01T14:35:30.000Z</published>
    <updated>2021-03-01T14:37:05.708Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --><p>今天开始争取每天更新至少一道<a href="https://leetcode-cn.com/problemset/lcof/" target="_blank" rel="noopener">《剑指offer》</a>的题解</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">力扣-剑指 Offer 03. 数组中重复的数字</a></p><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">2 &lt;= n &lt;= 100000</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>难度为简单。</p><h3 id="解法一：循环-Map"><a href="#解法一：循环-Map" class="headerlink" title="解法一：循环+Map"></a>解法一：循环+Map</h3><p>一次遍历，将扫描到数字做判断，如果可以在<code>map</code>中查到，就添加进去，否则返回这个数字，因为这个数字已经在<code>map</code>里存在了，属于重复数字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRepeatNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nummap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> _,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> !nummap[num] &#123;</span><br><span class="line">            nummap[num] = <span class="literal">true</span>  <span class="comment">//map中没有这个num</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> num  <span class="comment">//重复，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>leetcode-cn</code>执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">56 ms, 在所有 Go 提交中击败了8.84%的用户</span><br><span class="line">内存消耗：8.9 MB, 在所有 Go 提交中击败了39.48%的用户</span><br></pre></td></tr></table></figure><p>牛客网执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行时间：3ms</span><br><span class="line">超过100.00%用Go提交的代码</span><br><span class="line">占用内存：832KB</span><br><span class="line">超过100.00%用Go提交的代码</span><br></pre></td></tr></table></figure><h3 id="解法二：原地交换"><a href="#解法二：原地交换" class="headerlink" title="解法二：原地交换"></a>解法二：原地交换</h3><p>遍历数组并通过交换操作，使元素的 索引 与 值 一一对应（即 nums[i] = inums[i]=i ）。因而，就能通过索引映射对应的值，起到与字典等价的作用。可以看这个<a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-yua/" target="_blank" rel="noopener">题解</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRepeatNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] == i &#123;</span><br><span class="line">            i++</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[nums[i]] == nums[i] &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        tmp := nums[i]</span><br><span class="line">        nums[i] = nums[tmp]</span><br><span class="line">        nums[tmp] = tmp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode-cn执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">40 ms, 在所有 Go 提交中击败了86.59%的用户</span><br><span class="line">内存消耗：8.7 MB, 在所有 Go 提交中击败了89.50%的用户</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;今天开始争取每天更新至少一道&lt;a href=&quot;https://leetcode-cn.com/problemset/lcof/&quot; target=
      
    
    </summary>
    
    
      <category term="LeetCode-lcof-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-lcof-Solutions/"/>
    
    
      <category term="Map" scheme="https://octopuslian.github.io/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营-AVL树和红黑树的实现和特性</title>
    <link href="https://octopuslian.github.io/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/"/>
    <id>https://octopuslian.github.io/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/</id>
    <published>2021-03-01T05:08:36.000Z</published>
    <updated>2021-03-02T12:55:39.646Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><ul><li>发明者：Adelson-Velsky and Landis Tree</li><li>Blance Factor(平衡因子)：是它的左子树的高度减去它的右子树的高度（有时相反）。balance factor= {-1,0,1}</li><li>通过旋转操作来进行平衡（四种）</li><li><a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree" target="_blank" rel="noopener">Self-balancing binary search tree</a></li><li>不足：结点需要存储额外信息、且调整次数频繁</li></ul><h3 id="记录左右子树高度"><a href="#记录左右子树高度" class="headerlink" title="记录左右子树高度"></a>记录左右子树高度</h3><p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/hight.png" alt></p><p>例如F点，右子树高度1 - 左子树高度2 = -1</p><h3 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h3><p>1，左旋</p><p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/zuoxuan.png" alt></p><p>2，右旋</p><p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/youxuan.png" alt></p><p>3，左右旋</p><p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/zuoyouxuan2.png" alt></p><p>4，右左旋</p><p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/youzuoxuan.png" alt></p><h2 id="红黑树-Red-black-Tree"><a href="#红黑树-Red-black-Tree" class="headerlink" title="红黑树(Red-black Tree)"></a>红黑树(Red-black Tree)</h2><p>红黑树是一种近似平衡的二叉搜索树(Binary Search Tree)，它能够确保任何一个结点的左右子树的<strong>高度差小于两倍</strong>。具体来说，红黑树是满足如下条件的二叉搜索树：</p><ul><li>每个结点要么是红色，要么是黑色；</li><li>根结点是黑色；</li><li>每个叶结点(NIL结点、空结点)是黑色的；</li><li>不能有相邻的两个红色结点；</li><li>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。</li><li>关键性质：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。</li></ul><p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/rbtree.png" alt></p><p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/rbtree2.png" alt></p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/duibi-en.png" alt></p><p>翻译：</p><ul><li>AVL树提供了更快的查询，因为它是严格平衡的；</li><li>红黑树提供了更快的插入和删除的操作，因为AVL的旋转操作会更多而红黑树会更少一点；</li><li>AVL存在<code>factors</code>或<code>heights</code>更多一点，它需要更多的内存附加在每个结点里面来存这些了额外的信息，而红黑树要的信息非常少，它只要一个<code>bit</code>就是来存0和1表示黑或者是红；</li><li>红黑树是用在你们常常写的一些高级语言的库里面，比如C++中的<code>map、set</code>；如果用在数据库里面的话一般用<code>AVL</code></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91" target="_blank" rel="noopener">wiki-AVL树</a><br><a href="https://zhuanlan.zhihu.com/p/63272157" target="_blank" rel="noopener">leetcode刷题(十）：树（红黑树，B树）</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;AVL树&quot;&gt;&lt;a href=&quot;#AVL树&quot; class=&quot;headerlink&quot; title=&quot;AVL树&quot;&gt;&lt;/a&gt;AVL树&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="GATC" scheme="https://octopuslian.github.io/categories/GATC/"/>
    
    
      <category term="红黑树" scheme="https://octopuslian.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
      <category term="AVL树" scheme="https://octopuslian.github.io/tags/AVL%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营-高级搜索</title>
    <link href="https://octopuslian.github.io/2021/03/01/geekbang-gatc-14-advanced-search/"/>
    <id>https://octopuslian.github.io/2021/03/01/geekbang-gatc-14-advanced-search/</id>
    <published>2021-03-01T05:08:16.000Z</published>
    <updated>2021-03-02T12:55:33.101Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --><h2 id="剪枝的实现和特性"><a href="#剪枝的实现和特性" class="headerlink" title="剪枝的实现和特性"></a>剪枝的实现和特性</h2><h3 id="初级搜索"><a href="#初级搜索" class="headerlink" title="初级搜索"></a>初级搜索</h3><ul><li>1，朴素搜索：暴力搜索；</li><li>2，优化方式：不重复(fibonacci)、剪枝(生成括号问题)；</li><li>3，搜索方向：深度优先搜索、广度优先搜索、双向搜索、启发式搜索。</li></ul><h2 id="双向BFS的实现、特性"><a href="#双向BFS的实现、特性" class="headerlink" title="双向BFS的实现、特性"></a>双向BFS的实现、特性</h2><p>单向BFS</p><p><img src="/2021/03/01/geekbang-gatc-14-advanced-search/bfs.png" alt></p><p>变形：</p><p><img src="/2021/03/01/geekbang-gatc-14-advanced-search/bfs2.png" alt></p><p>双向BFS</p><p><img src="/2021/03/01/geekbang-gatc-14-advanced-search/Tbfs.png" alt></p><h2 id="启发式搜索的实现、特性-Heuristc-Search-A"><a href="#启发式搜索的实现、特性-Heuristc-Search-A" class="headerlink" title="启发式搜索的实现、特性 - Heuristc Search(A*)"></a>启发式搜索的实现、特性 - Heuristc Search(A*)</h2><p>代码模板</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AstarSearch</span><span class="params">(graph, start, end)</span>:</span></span><br><span class="line">    pq = collections.priority_queue() <span class="comment"># 优先级 —&gt; 估价函数</span></span><br><span class="line">    pq.append([start]) </span><br><span class="line">    visited.add(start)</span><br><span class="line">    <span class="keyword">while</span> pq: </span><br><span class="line">        node = pq.pop() <span class="comment"># can we add more intelligence here ?</span></span><br><span class="line">        visited.add(node)</span><br><span class="line">        process(node) </span><br><span class="line">        nodes = generate_related_nodes(node)    </span><br><span class="line">        unvisited = [node <span class="keyword">for</span> node <span class="keyword">in</span> nodes <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited]</span><br><span class="line">        pq.push(unvisited)</span><br></pre></td></tr></table></figure><h3 id="估价函数"><a href="#估价函数" class="headerlink" title="估价函数"></a>估价函数</h3><p>启发式搜索：h(n)，它用来评价哪些结点最有希望的是一个我们要找的结点，h(n)会返回一个非负实数，也可以认为是从结点<code>n</code>的目标结点路径的估计成本。<br>启发式搜索是一种告知搜索方向的方法。它提供了一种明智的方法来猜测哪个邻居结点会导向一个目标。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="双向BFS"><a href="#双向BFS" class="headerlink" title="双向BFS"></a>双向BFS</h3><ul><li><a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-ladder/</a></li><li><a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-genetic-mutation/</a></li></ul><h3 id="启发式搜索"><a href="#启发式搜索" class="headerlink" title="启发式搜索"></a>启发式搜索</h3><ul><li><a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/</a></li><li><a href="https://leetcode-cn.com/problems/sliding-puzzle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sliding-puzzle/</a></li><li><a href="https://leetcode-cn.com/problems/sudoku-solver/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sudoku-solver/</a></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://nikcheerla.github.io/deeplearningschool/2018/01/01/AlphaZero-Explained/" target="_blank" rel="noopener">AlphaZero Explained</a><br><a href="https://en.wikipedia.org/wiki/Game_complexity" target="_blank" rel="noopener">棋类复杂度</a><br><a href="https://shimo.im/docs/CXvjHyWhpQcxXjcw/read" target="_blank" rel="noopener">A*代码模板</a><br><a href="https://dataaspirant.com/2015/04/11/five-most-popular-similarity-measures-implementation-in-python/" target="_blank" rel="noopener">相似度测量方法</a><br><a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/discuss/313347/A*-search-in-Python" target="_blank" rel="noopener">二进制矩阵中的最短路径的 A* 解法</a><br><a href="https://zxi.mytechroad.com/blog/searching/8-puzzles-bidirectional-astar-vs-bidirectional-bfs/" target="_blank" rel="noopener">8 puzzles 解法比较</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;剪枝的实现和特性&quot;&gt;&lt;a href=&quot;#剪枝的实现和特性&quot; class=&quot;headerlink&quot; title=&quot;剪枝的实现和特性&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="GATC" scheme="https://octopuslian.github.io/categories/GATC/"/>
    
    
      <category term="剪枝" scheme="https://octopuslian.github.io/tags/%E5%89%AA%E6%9E%9D/"/>
    
      <category term="双向BFS" scheme="https://octopuslian.github.io/tags/%E5%8F%8C%E5%90%91BFS/"/>
    
      <category term="双向DFS" scheme="https://octopuslian.github.io/tags/%E5%8F%8C%E5%90%91DFS/"/>
    
      <category term="启发式搜索" scheme="https://octopuslian.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营-字符串基础知识、高级字符串算法、字符串匹配算法</title>
    <link href="https://octopuslian.github.io/2021/02/24/geekbang-gatc-20-string-algo/"/>
    <id>https://octopuslian.github.io/2021/02/24/geekbang-gatc-20-string-algo/</id>
    <published>2021-02-24T13:11:04.000Z</published>
    <updated>2021-03-02T12:56:00.366Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --><h2 id="字符串匹配算法"><a href="#字符串匹配算法" class="headerlink" title="字符串匹配算法"></a>字符串匹配算法</h2><h2 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h2><h3 id="字符串基础问题"><a href="#字符串基础问题" class="headerlink" title="字符串基础问题"></a>字符串基础问题</h3><ul><li><a href="https://leetcode-cn.com/problems/to-lower-case/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/to-lower-case/</a></li><li><a href="https://leetcode-cn.com/problems/length-of-last-word/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/length-of-last-word/</a></li><li><a href="https://leetcode-cn.com/problems/jewels-and-stones/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jewels-and-stones/</a></li><li><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/first-unique-character-in-a-string/</a></li><li><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></li></ul><h3 id="字符串操作问题"><a href="#字符串操作问题" class="headerlink" title="字符串操作问题"></a>字符串操作问题</h3><ul><li><a href="https://leetcode-cn.com/problems/longest-common-prefix/description/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-prefix/description/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-string</a></li><li><a href="https://leetcode-cn.com/problems/reverse-string-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-string-ii/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-words-in-a-string/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-only-letters/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-only-letters/</a></li></ul><h3 id="异位词问题"><a href="#异位词问题" class="headerlink" title="异位词问题"></a>异位词问题</h3><ul><li><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-anagram/</a></li><li><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/group-anagrams/</a></li><li><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/</a></li></ul><h3 id="回文串问题"><a href="#回文串问题" class="headerlink" title="回文串问题"></a>回文串问题</h3><ul><li><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-palindrome/</a></li><li><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-palindrome-ii/</a></li><li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></li></ul><h3 id="最长子串、子序列问题"><a href="#最长子串、子序列问题" class="headerlink" title="最长子串、子序列问题"></a>最长子串、子序列问题</h3><ul><li><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-subsequence/</a></li><li><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/edit-distance/</a></li><li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></li></ul><h3 id="字符串-DP-问题"><a href="#字符串-DP-问题" class="headerlink" title="字符串 +DP 问题"></a>字符串 +DP 问题</h3><ul><li><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regular-expression-matching/</a></li><li><a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/</a></li><li><a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/wildcard-matching/</a></li><li><a href="https://leetcode-cn.com/problems/distinct-subsequences/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/distinct-subsequences/</a></li></ul><h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><ul><li><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/first-unique-character-in-a-string/</a></li><li><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-string-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-string-ii/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-words-in-a-string/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-only-letters/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-only-letters/</a></li><li><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/</a></li><li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></li><li><a href="https://leetcode-cn.com/problems/isomorphic-strings/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/isomorphic-strings/</a></li><li><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-palindrome-ii/</a></li><li><a href="https://leetcode-cn.com/problems/wildcard-matching" target="_blank" rel="noopener">https://leetcode-cn.com/problems/wildcard-matching</a></li><li><a href="https://leetcode-cn.com/problems/longest-valid-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-valid-parentheses</a></li><li><a href="https://leetcode-cn.com/problems/distinct-subsequences/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/distinct-subsequences/</a></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://lemire.me/blog/2017/07/07/are-your-strings-immutable/" target="_blank" rel="noopener">不可变字符串</a><br><a href="https://shimo.im/docs/KkDKkpWxjjrJXdpY/read" target="_blank" rel="noopener">Atoi 代码示例</a><br><a href="http://xn--https-ni33a/www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html" target="_blank" rel="noopener">Boyer-Moore 算法</a><br><a href="https://blog.csdn.net/u012505432/article/details/52210975" target="_blank" rel="noopener">Sunday 算法</a><br><a href="https://shimo.im/docs/dQDxQW8yXPXxh3Hg/read" target="_blank" rel="noopener">字符串匹配暴力法代码示例</a><br><a href="https://shimo.im/docs/KXDdkT99TVtXvTXP/read" target="_blank" rel="noopener">Rabin-Karp 代码示例</a><br><a href="https://www.bilibili.com/video/av11866460?from=search&seid=17425875345653862171" target="_blank" rel="noopener">KMP 字符串匹配算法视频</a><br><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">字符串匹配的 KMP 算法</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;字符串匹配算法&quot;&gt;&lt;a href=&quot;#字符串匹配算法&quot; class=&quot;headerlink&quot; title=&quot;字符串匹配算法&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="GATC" scheme="https://octopuslian.github.io/categories/GATC/"/>
    
    
      <category term="字符串" scheme="https://octopuslian.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="高级字符串算法" scheme="https://octopuslian.github.io/tags/%E9%AB%98%E7%BA%A7%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串匹配算法" scheme="https://octopuslian.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营-初级排序和高级排序的实现和特性</title>
    <link href="https://octopuslian.github.io/2021/02/24/geekbang-gatc-18-sort-algo/"/>
    <id>https://octopuslian.github.io/2021/02/24/geekbang-gatc-18-sort-algo/</id>
    <published>2021-02-24T05:10:05.000Z</published>
    <updated>2021-03-02T12:55:54.333Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="1，比较类排序"><a href="#1，比较类排序" class="headerlink" title="1，比较类排序"></a>1，比较类排序</h3><p>通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</p><h3 id="2，非比较类排序"><a href="#2，非比较类排序" class="headerlink" title="2，非比较类排序"></a>2，非比较类排序</h3><p>不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</p><p><img src="/2021/02/24/geekbang-gatc-18-sort-algo/sort.png" alt></p><p><img src="/2021/02/24/geekbang-gatc-18-sort-algo/sort2.png" alt></p><p>(大厂一般回考时间复杂度为<code>nlogn</code>的排序算法——<strong>堆排序、快速排序、归并排序</strong>，比如快速排序和归并排序用到了分治思想)</p><h2 id="初级排序-O-n-2"><a href="#初级排序-O-n-2" class="headerlink" title="初级排序-O(n^2)"></a>初级排序-O(n^2)</h2><ul><li><p>1,选择排序<br>每次找最小值，然后放到待排序数组的起始位置。</p></li><li><p>2，插入排序<br>从前往后逐步构建有序序列；对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p></li><li><p>3，冒泡排序<br>嵌套循环，每次查看相邻的元素，如果逆序，则交换</p></li></ul><h2 id="高级排序-O-N-LogN"><a href="#高级排序-O-N-LogN" class="headerlink" title="高级排序-O(N*LogN)"></a>高级排序-O(N*LogN)</h2><ul><li>快速排序<br>数组取标杆<code>pivot</code>，将小元素放<code>pivot</code>左边，大元素放右侧，然后依次对右边和右边的子数组继续快排，以达到整个序列有序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go</span></span><br><span class="line"><span class="function">func <span class="title">quickSort</span><span class="params">(array []<span class="keyword">int</span>, begin, end <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> end &lt;= begin &#123;</span><br><span class="line">                 <span class="keyword">return</span>   </span><br><span class="line">                 &#125;   </span><br><span class="line">    pivot := partition(array, begin, end)   </span><br><span class="line">    quickSort(array, begin, pivot-<span class="number">1</span>)   </span><br><span class="line">    quickSort(array, pivot+<span class="number">1</span>, end)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">partition</span><span class="params">(array []<span class="keyword">int</span>, begin, end <span class="keyword">int</span>)</span> <span class="keyword">int</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pivot: 标杆位置，counter: 小于pivot的元素的个数   </span></span><br><span class="line">    pivot, counter := end, begin   </span><br><span class="line">    <span class="keyword">for</span> i := begin; i &lt; end; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> array[i] &lt; array[pivot] &#123;</span><br><span class="line">            array[i], array[counter] = array[counter], array[i]         </span><br><span class="line">            counter++      </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    array[pivot], array[counter] = array[counter], array[pivot]   </span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>归并排序——分治<br>1，把长度为<code>n</code>的输入序列分成两个长度为<code>n/2</code>的子序列；<br>2，把这两个子序列分别采用归并排序；<br>3，将两个排序好的子序列合并成一个最终的排序序列。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (right &lt;= left) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;  <span class="comment">//(left + right) / 2</span></span><br><span class="line"></span><br><span class="line">    mergeSort(array,left,mid);</span><br><span class="line">    mergeSort(array,mid + <span class="number">1</span>,right);</span><br><span class="line">    merge(array,left,mid,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>]; <span class="comment">//中间数组</span></span><br><span class="line">    <span class="comment">//...未完</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>归并和快排具有相似性，但步骤顺序相反</strong></p><p>归并：先排序左右子数组，然后合并两个有序子数组；<br>快排：先调配出左右子数组，然后对于左右子数组进行排序。</p><ul><li>堆排序——堆插入O(logN)，取最大/小值O(1)<br>1，数组元素依次建立小顶堆；<br>2，依次取堆顶元素，并删除。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Cpp</span></span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">十大经典排序算法（动图演示）</a><br><a href="https://shimo.im/docs/98KjvGwwGpTpYGKy/read" target="_blank" rel="noopener">快速排序算法示例</a><br><a href="https://shimo.im/docs/YqgG6vtdKwkXJkWx/" target="_blank" rel="noopener">归并排序算法示例</a><br><a href="https://shimo.im/docs/6kRVHRphpgjHgCtx/" target="_blank" rel="noopener">堆排序代码示例</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 21 2021 22:32:21 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="GATC" scheme="https://octopuslian.github.io/categories/GATC/"/>
    
    
      <category term="排序算法" scheme="https://octopuslian.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>以写作调身心</title>
  
  <subtitle>熟能生巧，勤能补拙；念念不忘，必有回响。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://octopuslian.github.io/"/>
  <updated>2021-03-05T15:47:27.386Z</updated>
  <id>https://octopuslian.github.io/</id>
  
  <author>
    <name>Neo Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>汇总LeetCode实现数据结构和算法的题目</title>
    <link href="https://octopuslian.github.io/2021/03/05/leetcode-all-achieve-data-structure-and-algo-problems/"/>
    <id>https://octopuslian.github.io/2021/03/05/leetcode-all-achieve-data-structure-and-algo-problems/</id>
    <published>2021-03-05T15:23:24.000Z</published>
    <updated>2021-03-05T15:47:27.386Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --><p>汇总各种实现数据结构和算法的<code>LeetCode</code>题目，等刷完《剑指offer》后将重点关注的题目，通过边刷题边梳理数据结构算法的知识。</p><h2 id="链表-跳表"><a href="#链表-跳表" class="headerlink" title="链表-跳表"></a>链表-跳表</h2><p><a href="https://leetcode-cn.com/problems/design-linked-list/" target="_blank" rel="noopener">707. 设计链表</a></p><p><a href="https://leetcode-cn.com/problems/design-skiplist/" target="_blank" rel="noopener">1206. 设计跳表</a></p><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 09. 用两个栈实现队列</a></p><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232. 用栈实现队列</a></p><p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">225. 用队列实现栈</a></p><p><a href="https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/" target="_blank" rel="noopener">1381. 设计一个支持增量操作的栈</a></p><p><a href="https://leetcode-cn.com/problems/design-circular-queue/" target="_blank" rel="noopener">622. 设计循环队列</a></p><p><a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">641. 设计循环双端队列</a></p><p><a href="https://leetcode-cn.com/problems/design-front-middle-back-queue/" target="_blank" rel="noopener">1670. 设计前中后队列</a></p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 07. 重建二叉树</a></p><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">剑指 Offer 27. 二叉树的镜像</a></p><p><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 28. 对称的二叉树</a></p><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></p><p><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 37. 序列化二叉树</a></p><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. 平衡二叉树</a></p><p><a href="https://leetcode-cn.com/problems/minimum-height-trees/" target="_blank" rel="noopener">310. 最小高度树</a></p><p><a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">641. 设计循环双端队列</a></p><p><a href="https://leetcode-cn.com/problems/design-front-middle-back-queue/" target="_blank" rel="noopener">1670. 设计前中后队列</a></p><p><a href="https://leetcode-cn.com/problems/er-cha-shu-ren-wu-diao-du/" target="_blank" rel="noopener">LCP 10. 二叉树任务调度</a></p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU 缓存机制</a></p><h2 id="场景设计"><a href="#场景设计" class="headerlink" title="场景设计"></a>场景设计</h2><p><a href="https://leetcode-cn.com/problems/design-twitter/" target="_blank" rel="noopener">355. 设计推特</a></p><p><a href="https://leetcode-cn.com/problems/design-hashset/" target="_blank" rel="noopener">705. 设计哈希集合</a></p><p><a href="https://leetcode-cn.com/problems/design-hashmap/" target="_blank" rel="noopener">706. 设计哈希映射</a></p><p><a href="https://leetcode-cn.com/problems/design-underground-system/" target="_blank" rel="noopener">1396. 设计地铁系统</a></p><p><a href="https://leetcode-cn.com/problems/design-browser-history/" target="_blank" rel="noopener">1472. 设计浏览器历史记录</a></p><p><a href="https://leetcode-cn.com/problems/design-parking-system/" target="_blank" rel="noopener">1603. 设计停车系统</a></p><p><a href="https://leetcode-cn.com/problems/design-an-ordered-stream/" target="_blank" rel="noopener">1656. 设计有序流</a></p><p><a href="https://leetcode-cn.com/problems/goal-parser-interpretation/" target="_blank" rel="noopener">1678. 设计 Goal 解析器</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;汇总各种实现数据结构和算法的&lt;code&gt;LeetCode&lt;/code&gt;题目，等刷完《剑指offer》后将重点关注的题目，通过边刷题边梳理数据结构
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
      <category term="算法" scheme="https://octopuslian.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://octopuslian.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 07. 重建二叉树</title>
    <link href="https://octopuslian.github.io/2021/03/05/leetcode-lcof-07-zhong-jian-er-cha-shu/"/>
    <id>https://octopuslian.github.io/2021/03/05/leetcode-lcof-07-zhong-jian-er-cha-shu/</id>
    <published>2021-03-05T10:42:24.000Z</published>
    <updated>2021-03-05T10:57:22.032Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">力扣-剑指 Offer 07. 重建二叉树</a></p><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">例如，给出</span><br><span class="line"></span><br><span class="line">前序遍历 preorder = [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"></span><br><span class="line">0 &lt;= 节点个数 &lt;= 5000</span><br></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>二叉树的遍历顺序</li></ul><p>1，前序（Pre-order）：根-左-右<br>2，中序（In-order）：左-根-右<br>3，后序（Post-order）：左-右-根</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>难度为中等。</p><h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>按题目给的示例来划分：<br>前序遍历划分 [ 3 | 9 | 20 15 7 ]<br>中序遍历划分 [ 9 | 3 | 15 20 7 ]</p><p>根据以上性质，可得出以下推论：</p><ul><li>前序遍历的首元素 为 树的根节点 <code>node</code> 的值。</li><li>在中序遍历中搜索根节点 <code>node</code> 的索引 ，可将 中序遍历 划分为 [ 左子树 | 根节点 | 右子树 ] 。</li><li>根据中序遍历中的左 / 右子树的节点数量，可将 前序遍历 划分为 [ 根节点 | 左子树 | 右子树 ] 。</li></ul><p>考虑通过递归对所有子树进行划分：</p><ul><li><p>递推参数： 根节点在前序遍历的索引 root 、子树在中序遍历的左边界 left 、子树在中序遍历的右边界 right ；</p></li><li><p>终止条件： 当 left &gt; right ，代表已经越过叶节点，此时返回 null ；</p></li><li><p>递推工作：<br>建立根节点 node ： 节点值为 preorder[root] ；<br>划分左右子树： 查找根节点在中序遍历 inorder 中的索引 i ；</p></li></ul><p><img src="/2021/03/05/leetcode-lcof-07-zhong-jian-er-cha-shu/7-tijie.png" alt></p><p>网上摘的保姆式的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java借助Map版本 (Go的没写出来，等后面写出来了再更新)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//标记中序遍历</span></span><br><span class="line">    <span class="keyword">int</span>[] preorder;<span class="comment">//保留的先序遍历，方便递归时依据索引查看先序遍历的值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preorder = preorder;</span><br><span class="line">        <span class="comment">//将中序遍历的值及索引放在map中，方便递归时获取左子树与右子树的数量及其根的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//三个索引分别为</span></span><br><span class="line">        <span class="comment">//当前根的的索引</span></span><br><span class="line">        <span class="comment">//递归树的左边界，即数组左边界</span></span><br><span class="line">        <span class="comment">//递归树的右边界，即数组右边界</span></span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">recur</span><span class="params">(<span class="keyword">int</span> pre_root, <span class="keyword">int</span> in_left, <span class="keyword">int</span> in_right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(in_left &gt; in_right) <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">// 相等的话就是自己</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[pre_root]);<span class="comment">//获取root节点</span></span><br><span class="line">        <span class="keyword">int</span> idx = map.get(preorder[pre_root]);<span class="comment">//获取在中序遍历中根节点所在索引，以方便获取左子树的数量</span></span><br><span class="line">        <span class="comment">//左子树的根的索引为先序中的根节点+1 </span></span><br><span class="line">        <span class="comment">//递归左子树的左边界为原来的中序in_left</span></span><br><span class="line">        <span class="comment">//递归右子树的右边界为中序中的根节点索引-1</span></span><br><span class="line">        root.left = recur(pre_root+<span class="number">1</span>, in_left, idx-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//右子树的根的索引为先序中的 当前根位置 + 左子树的数量 + 1</span></span><br><span class="line">        <span class="comment">//递归右子树的左边界为中序中当前根节点+1</span></span><br><span class="line">        <span class="comment">//递归右子树的有边界为中序中原来右子树的边界</span></span><br><span class="line">        root.right = recur(pre_root + (idx - in_left) + <span class="number">1</span>, idx+<span class="number">1</span>, in_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode-cn执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">3 ms, 在所有 Java 提交中击败了55.11%的用户</span><br><span class="line">内存消耗：</span><br><span class="line">38.4 MB, 在所有 Java 提交中击败了80.00%的用户</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go，不借助Map版本</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="keyword">int</span>, inorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    root := <span class="built_in">new</span>(TreeNode)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    root_val := preorder[<span class="number">0</span>]</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> inorder[i] != root_val &#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    left_tree := buildTree(preorder[<span class="number">1</span>:i+<span class="number">1</span>],inorder[:i])</span><br><span class="line">    right_tree := buildTree(preorder[i+<span class="number">1</span>:],inorder[i+<span class="number">1</span>:])</span><br><span class="line">    root.Val = root_val</span><br><span class="line">    root.Left = left_tree</span><br><span class="line">    root.Right = right_tree</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode-cn执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">4 ms, 在所有 Go 提交中击败了95.75%的用户</span><br><span class="line">内存消耗：</span><br><span class="line">4.2 MB, 在所有 Go 提交中击败了25.36%的用户</span><br></pre></td></tr></table></figure><p>牛客网运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行时间：5ms</span><br><span class="line">超过39.31%用Go提交的代码</span><br><span class="line">占用内存：2344KB</span><br><span class="line">超过9.75%用Go提交的代码</span><br></pre></td></tr></table></figure><h2 id="思考：为什么二叉树的题目一般用递归来解？"><a href="#思考：为什么二叉树的题目一般用递归来解？" class="headerlink" title="思考：为什么二叉树的题目一般用递归来解？"></a>思考：为什么二叉树的题目一般用递归来解？</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/4chong-jie-fa-di-gui-zhan-dui-lie-by-sdwwld/" target="_blank" rel="noopener">4种解法（递归，栈，队列），最后一种击败了100%的用户</a><br><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/" target="_blank" rel="noopener">力扣官方题解</a><br><a href="https://blog.csdn.net/Mr_SCX/article/details/106690412" target="_blank" rel="noopener">【面试题】重建二叉树（解题思路分析+Java、Python实现+代码详细注释）</a><br><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-di-gui-fa-qin/" target="_blank" rel="noopener">面试题07. 重建二叉树（递归法，清晰图解）</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="LeetCode-lcof-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-lcof-Solutions/"/>
    
    
      <category term="二叉树" scheme="https://octopuslian.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://octopuslian.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>2021春招找工作计划</title>
    <link href="https://octopuslian.github.io/2021/03/04/2021-spring-find-job/"/>
    <id>https://octopuslian.github.io/2021/03/04/2021-spring-find-job/</id>
    <published>2021-03-04T13:53:47.000Z</published>
    <updated>2021-03-04T14:10:26.247Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --><p>三月到来，各个企业又开始招人了，我也收到了几家企业的面试邀请。</p><p>找工作避免不了被问到“是否接受加班？”————当然是看情况了，我有事就拒绝加班，没事但是一天的工作没做完肯定是会自觉加班的，但我最讨厌最讨厌最讨厌那种磨洋工式的加班。</p><p>今天就收到了一位很有礼貌的猎头小哥问我“有家游戏公司995可以接受吗？” 我果断拒绝，因为说是995，有可能就临上线就变成996甚至997，人的欲望是无穷无尽的，所以如何摆脱困境，就是要找到从根源上就拒绝加班的企业。</p><p>犹记得我在第一家游戏公司的时候，美其名曰加班，实际上是因为一个人回去也没啥意思，就跟着同事一块在公司看书学习敲代码，顺便拿加班补贴和打车补助；第二家公司，刚开始基本7点就准时下班了，但后面逐渐开始那种毫无意义的加班，甚至根据加班来看工作态度、年终考核的时候，我放弃了，放弃了那可有可无的年终奖。</p><p>因此，我看透了国内这种加班的本质，要么高效完成工作，要么加班按照劳动法给加班费，否则一切强制无意义的加班就是压榨。</p><p>今天写下这篇文章，拒绝无意义的加班，不知道以后正在屠龙的少年是否会变成恶龙，以此当做一个记录吧。</p><p>新的一年，祝自己能顺利拿到满意的<code>offer</code>！</p><p><img src="/2021/03/04/2021-spring-find-job/reject-996.jpg" alt></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;三月到来，各个企业又开始招人了，我也收到了几家企业的面试邀请。&lt;/p&gt;&lt;p&gt;找工作避免不了被问到“是否接受加班？”————当然是看情况了，我有事
      
    
    </summary>
    
    
      <category term="Work-Career" scheme="https://octopuslian.github.io/categories/Work-Career/"/>
    
    
      <category term="找工作" scheme="https://octopuslian.github.io/tags/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="春招" scheme="https://octopuslian.github.io/tags/%E6%98%A5%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 06. 从尾到头打印链表</title>
    <link href="https://octopuslian.github.io/2021/03/04/leetcode-lcof-06-cong-wei-dao-tou-da-yin-lian-biao/"/>
    <id>https://octopuslian.github.io/2021/03/04/leetcode-lcof-06-cong-wei-dao-tou-da-yin-lian-biao/</id>
    <published>2021-03-04T05:44:25.000Z</published>
    <updated>2021-03-04T05:51:17.010Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">力扣-剑指 Offer 06. 从尾到头打印链表</a></p><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">0 &lt;= s 的长度 &lt;= 10000</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>该题难度为简单。</p><h3 id="解法一：两个for循环"><a href="#解法一：两个for循环" class="headerlink" title="解法一：两个for循环"></a>解法一：两个for循环</h3><ul><li>1，先声明两个整型数组；</li><li>2，第一个<code>for</code>循环从头到尾记录链表的每个节点的值；</li><li>3，第二个<code>for</code>循环逆序记录链表的每个节点的值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reversePrint</span><span class="params">(head *ListNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> re []<span class="keyword">int</span>  <span class="comment">//正序</span></span><br><span class="line">    <span class="keyword">var</span> er []<span class="keyword">int</span>  <span class="comment">//逆序</span></span><br><span class="line">    <span class="keyword">for</span> ;head != <span class="literal">nil</span>; &#123;</span><br><span class="line">        re = <span class="built_in">append</span>(re,head.Val)  <span class="comment">//从头到尾记录链表的每个节点的值</span></span><br><span class="line">        head = head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="built_in">len</span>(re)<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-- &#123;</span><br><span class="line">        er = <span class="built_in">append</span>(er,re[i])  <span class="comment">//逆序记录链表的每个节点的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> er  <span class="comment">//返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode-cn执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">0 ms, 在所有 Go 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：</span><br><span class="line">3.5 MB, 在所有 Go 提交中击败了46.84%的用户</span><br></pre></td></tr></table></figure><p>牛客网执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行时间：3ms</span><br><span class="line">超过2.29%用Go提交的代码</span><br><span class="line">占用内存：868KB</span><br><span class="line">超过39.69%用Go提交的代码</span><br></pre></td></tr></table></figure><h3 id="解法二：递归"><a href="#解法二：递归" class="headerlink" title="解法二：递归"></a>解法二：递归</h3><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/solution/liang-chong-jie-fa-zhan-yu-di-gui-by-jalan/" target="_blank" rel="noopener">两种解法：栈与递归</a></p><ul><li>递归函数作用：将链表节点值逆序存入结果集</li><li>结束条件：当节点为空时</li><li>递归调用条件：当下一个节点不为空时</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//Go</span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * type ListNode struct &#123;</span><br><span class="line"> *     Val int</span><br><span class="line"> *     Next *ListNode</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">func reversePrint(head *ListNode) []int &#123;</span><br><span class="line">    if head == nil &#123;</span><br><span class="line">        return []int&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res := reversePrint(head.Next)</span><br><span class="line">    return append(res, head.Val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode-cn执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">4 ms, 在所有 Go 提交中击败了63.34%的用户</span><br><span class="line">内存消耗：</span><br><span class="line">4.7 MB, 在所有 Go 提交中击败了28.61%的用户</span><br></pre></td></tr></table></figure><p>牛客网执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行时间：3ms</span><br><span class="line">超过2.29%用Go提交的代码</span><br><span class="line">占用内存：868KB</span><br><span class="line">超过39.69%用Go提交的代码</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="LeetCode-lcof-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-lcof-Solutions/"/>
    
    
      <category term="链表" scheme="https://octopuslian.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="栈" scheme="https://octopuslian.github.io/tags/%E6%A0%88/"/>
    
      <category term="遍历" scheme="https://octopuslian.github.io/tags/%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 05. 替换空格</title>
    <link href="https://octopuslian.github.io/2021/03/03/leetcode-lcof-05-ti-huan-kong-ge/"/>
    <id>https://octopuslian.github.io/2021/03/03/leetcode-lcof-05-ti-huan-kong-ge/</id>
    <published>2021-03-03T15:20:54.000Z</published>
    <updated>2021-03-04T04:32:19.567Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">力扣-剑指 Offer 05. 替换空格</a></p><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">0 &lt;= s 的长度 &lt;= 10000</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>该题难度为简单。</p><h3 id="解法一：使用strings-Replace"><a href="#解法一：使用strings-Replace" class="headerlink" title="解法一：使用strings.Replace"></a>解法一：使用strings.Replace</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">replaceSpace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> strings.Replace(s, <span class="string">" "</span>, <span class="string">"%20"</span>, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法二：遍历添加"><a href="#解法二：遍历添加" class="headerlink" title="解法二：遍历添加"></a>解法二：遍历添加</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">replaceSpace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    ans := <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> s&#123;</span><br><span class="line">        <span class="keyword">if</span> v == <span class="string">' '</span>&#123;</span><br><span class="line">            ans = ans + <span class="string">"%20"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = ans + <span class="keyword">string</span>(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode-执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">0 ms, 在所有 Go 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：</span><br><span class="line">3.4 MB, 在所有 Go 提交中击败了16.95%的用户</span><br></pre></td></tr></table></figure><p>牛客网执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行时间：2ms</span><br><span class="line">超过100.00%用Go提交的代码</span><br><span class="line">占用内存：956KB</span><br><span class="line">超过23.81%用Go提交的代码</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="LeetCode-lcof-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-lcof-Solutions/"/>
    
    
      <category term="字符串" scheme="https://octopuslian.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="lcof" scheme="https://octopuslian.github.io/tags/lcof/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-微服务概览与治理</title>
    <link href="https://octopuslian.github.io/2021/03/03/goatc-1-microservice-overview-and-governance/"/>
    <id>https://octopuslian.github.io/2021/03/03/goatc-1-microservice-overview-and-governance/</id>
    <published>2021-03-03T07:21:10.000Z</published>
    <updated>2021-03-04T12:32:59.076Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --><h2 id="微服务概览"><a href="#微服务概览" class="headerlink" title="微服务概览"></a>微服务概览</h2><h3 id="单体设计"><a href="#单体设计" class="headerlink" title="单体设计"></a>单体设计</h3><p>尽管也是模块化逻辑，但是最终它还是会打包并部署为单体式应用。其中最主要问题就是这个应用太复杂，以至于任何单个开发者都不可能搞懂它。应用无法扩展，可靠性很低，最终敏捷性和部署变的无法完成。</p><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/simple.png" alt></p><p>因此，我们应对的思路：<strong>化繁为简，分而治之</strong></p><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/web-inter.png" alt></p><h3 id="微服务起源"><a href="#微服务起源" class="headerlink" title="微服务起源"></a>微服务起源</h3><h4 id="Q：SOA-面向服务的架构模式-和微服务是什么关系？"><a href="#Q：SOA-面向服务的架构模式-和微服务是什么关系？" class="headerlink" title="Q：SOA(面向服务的架构模式)和微服务是什么关系？"></a>Q：SOA(面向服务的架构模式)和微服务是什么关系？</h4><p>A:可以把微服务想成是SOA的一种实践。</p><ul><li>小即是美：</li><li>单一职责：</li><li>尽可能早地创造原型：</li><li>可移植性比效率更重要：</li></ul><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/ms-ma-database.png" alt></p><h3 id="微服务定义"><a href="#微服务定义" class="headerlink" title="微服务定义"></a>微服务定义</h3><p>定义：围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术。微服务架构通过业务拆分实现服务组件化，通过组件组合快速开发系统，业务单一的服务组件又可以独立部署，使得整个系统变得清晰灵活。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>原子服务</li><li>独立进程</li><li>隔离部署</li><li>去中心化服务治理</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>基础设施的建设、复杂度高</li></ul><h3 id="微服务不足"><a href="#微服务不足" class="headerlink" title="微服务不足"></a>微服务不足</h3><ul><li>微服务应用是分布式系统，由此会带来固有的复杂性。开发者不得不使用<code>RPC</code>或者消息传递，来实现进程间通信；此外，必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题。</li><li>分区的数据库架构，同时更新多个业务主体的事务很普遍。这种事务对于单体式应用来说很容易，因为只有一个数据库。在微服务架构应用中，需要更新不同服务所使用的不同的数据库，从而对开发者提出了更高的要求和挑战。</li><li>测试一个基于微服务的应用也是很复杂的任务。</li><li>服务模块间的依赖，应用的升级有可能波及多个服务模块的修改。</li><li>对运维基础设施的挑战比较大。</li></ul><h3 id="组件服务化"><a href="#组件服务化" class="headerlink" title="组件服务化"></a>组件服务化</h3><p>传统实现组件的方式是通过库(library)，库是和应用一起运行在进程中，库的局部变化意味着整个应用的重新部署。通过微服务来实现组件，意味着将应用拆散为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需要新部署对应的服务进程。我们用<code>Go</code>实施一个微服务：</p><ul><li>kit：一个微服务的基础库(框架)。</li><li>service：业务代码 + kit依赖 + 第三方依赖组成的业务微服务</li><li>rpc + message queue：轻量级通讯</li></ul><p><strong>本质上等同于多个服务组合(compose)完成了一个完整的用户场景(usecase)。</strong></p><h3 id="重要-按业务组织服务"><a href="#重要-按业务组织服务" class="headerlink" title="(重要)按业务组织服务"></a>(重要)按业务组织服务</h3><p>按业务能力组织服务的意思是服务提供的能力和业务功能对应，比如：订单服务和数据访问服务，前者反应了真实的订单相关服务，后者是一种技术抽象服务不反应真实的业务。所以按照微服务架构理念来划分服务时，是不应该存在数据访问服务这样一个服务的。</p><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/law.png" alt></p><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/law2.png" alt></p><p>我们的模式：大前端(移动/Web) &gt; 网关接入 &gt; 业务服务 &gt; 平台服务 &gt; 基础设施(PaaS/Saas)<br><strong>开发团队对软件在生产环境的运行负全部责任。</strong></p><h3 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h3><ul><li>数据去中心化</li><li>治理去中心化</li><li>技术去中心化</li></ul><p><strong>每个服务独享自身的数据存储设施(缓存、数据库等)，不像传统应用共享一个缓存和数据库，这样有利于服务的独立性，这样有利于服务的独立性，隔离相关干扰。</strong></p><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/qu-zhong-xin.png" alt></p><h2 id="基础设施自动化"><a href="#基础设施自动化" class="headerlink" title="基础设施自动化"></a>基础设施自动化</h2><ul><li>CICD：Gitlab + Gitlab Hooks + k8s</li><li>Testing：测试环境、单元测试、API自动化测试</li><li>在线运行时：k8s，以及一系列Prometheus、ELK、Conrtol Panle</li></ul><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/ji-chu-she-shi-zi-dong-hua.png" alt></p><h3 id="可用性-amp-兼容性设计"><a href="#可用性-amp-兼容性设计" class="headerlink" title="可用性 &amp; 兼容性设计"></a>可用性 &amp; 兼容性设计</h3><p>著名的<code>Design For Failure</code>思想，微服务架构采用粗粒度的进程间通信，引入了额外的复杂性和需要处理的新问题，如网络延迟、消息格式、负载均衡和容错，忽略了其中任何一点都属于对“分布式计算的误解”。</p><ul><li>隔离</li><li>超时控制</li><li>负载保护</li><li>限流</li><li>降级</li><li>重试</li><li>负载均衡</li></ul><p>特别注意：<strong>服务提供者的变更可能引发服务消费者的兼容性破坏，时刻谨记保持服务契约(接口)的兼容性。</strong></p><p>Be conserative in what you send, be liberal in what you accept.</p><p>发送时要保守，接收时要开放。按照伯斯塔尔法则的思想来设计和实现服务时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。</p><h2 id="微服务设计"><a href="#微服务设计" class="headerlink" title="微服务设计"></a>微服务设计</h2><h3 id="API-Gateway"><a href="#API-Gateway" class="headerlink" title="API Gateway"></a>API Gateway</h3><p>按照垂直功能进行拆分，对外暴露了一批微服务，但是缺乏统一的出口面临了不少困难：</p><ul><li>客户端到微服务直接通信，强耦合；</li><li>需要多次请求，客户端聚合数据，工作量巨大，延迟高；</li><li>协议不利于统一，各个部门有差异，需要端来兼容；</li><li>面向“端”的<code>API</code>适配，耦合到了内部服务；</li><li>多终端兼容逻辑复杂，每个服务都需要处理；</li><li>统一逻辑无法收敛，比如安全认证、限流。</li></ul><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/web-server.png" alt></p><p><strong>要内聚模式配合。</strong></p><p>新增了一个<code>app-interface</code>用于统一的协议出口，在服务进行大量的<code>dataset join</code>，按照业务场景设计粗粒度的<code>API</code>，给后续服务的演进带来很多优势：</p><ul><li>轻量交互：协议精简、聚合。</li><li>差异服务：数据裁剪以及聚合、针对终端定制化<code>API</code>。</li><li>动态升级：原有系统兼容升级，更新服务而非协议。</li><li>沟通效率提升，协作模式演进为移动业务+网管小组。</li></ul><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/BFF.png" alt></p><p><code>BFF</code>可以认为是一种适配服务，将后端的微服务进行适配(主要包括聚合裁剪和格式适配等逻辑)，向无线端设备暴露友好和统一的<code>API</code>，方便无线设备接入访问后端服务。</p><h4 id="single-point-of-failure"><a href="#single-point-of-failure" class="headerlink" title="single point of failure"></a>single point of failure</h4><p>严重代码缺陷或者流量洪峰可能引发集群宕机。</p><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/aws2.png" alt><br><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/api2.png" alt></p><ul><li>单个模块也会导致后续业务集成复杂度高，根据康威法则，单块的无线<code>BFF</code>和多团队之间就出现不匹配的问题，团队之间沟通协调成本高，交付效率低下。</li><li>很多横跨切面逻辑，比如安全认证，日志监控，限流熔断等。随着时间的推移，代码变得越来越复杂，技术债越堆越多。</li></ul><h4 id="跨横切面（Cross-Cutting-Concerns）"><a href="#跨横切面（Cross-Cutting-Concerns）" class="headerlink" title="跨横切面（Cross-Cutting Concerns）"></a>跨横切面（Cross-Cutting Concerns）</h4><p>跨横切面(Cross-Cutting Concerns)的功能，需要协调更新框架升级发版(路由、认证、限流、安全)，因此全部上沉，引入了 API Gateway，把业务集成度高的 BFF 层和通用功能服务层 <code>APIGateway</code> 进行了分层处理</p><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/api-gateway.png" alt></p><p>在新的架构中，网关承担了重要的角色，它是解耦拆分和后续升级迁移的利器。在网关的配合下，单块 BFF实现了解耦拆分，各业务线团队可以独立开发和交付各自的微服务，研发效率大大提升。另外，把跨横切面逻辑从 BFF 剥离到网关上去以后，BFF 的开发人员可以更加专注业务逻辑交付，实现了架构上的关注分离(Separation of Concerns)。</p><p>我们业务流量实际为：移动端 -&gt; API Gateway -&gt; BFF -&gt; Mircoservice，在FE Web业务中，BFF 可以是 nodejs 来做服务端渲染(SSR，Server-Side Rendering)，注意这里忽略了上游的 CDN、4/7层负载均衡(ELB)。</p><p>注：4层负载均衡可能是——LVS/F5/NetScala，7层负载均衡——Nginx/ELB、SLB/API Gateway/BFS。</p><h3 id="Mircoservice-划分"><a href="#Mircoservice-划分" class="headerlink" title="Mircoservice 划分"></a>Mircoservice 划分</h3><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/bounded-context.png" alt></p><p>微服务架构时遇到的第一个问题就是如何划分服务的边界。在实际项目中通常会采用两种不同的方式划分服务边界，即通过业务职能(BusinessCapability)或是 DDD 的限界上下文(BoundedContext)。</p><ul><li><p>Business Capability<br>由公司内部不同部门提供的职能。例如客户服务部门提供客户服务的职能，财务部门提供财务相关的职能。</p></li><li><p>Bounded Context<br>限界上下文是DDD中用来划分不同业务边界的元素，这里业务边界的含义是“解决不同业务问题”的问题域和对应的解决方案域，为了解决某种类型的业务问题，贴近领域知识，也就是业务。这本质上也促进了组织结构的演进：Service perteam</p></li></ul><p>CQRS，将应用程序分为两部分：命令端和查询端。命令端处理程序创建，更新和删除请求，并在数据更改时发出事件。查询端通过针对一个或多个物化视图执行查询来处理查询，这些物化视图通过订阅数据更改时发出的事件流而保持最新。</p><p>在稿件服务演进过程中，我们发现围绕着创作稿件、审核稿件、最终发布稿件有大量的逻辑揉在一块，其中稿件本身的状态也有非常多种，但是最终前台用户只关注稿件能否查看，我们依赖稿件数据库 binlog 以及订阅binlog 的中间件canal，将我们的稿件结果发布到消息队列 kafka 中，最终消费数据独立组建一个稿件查阅结果数据库，并对外提供一个独立查询服务，来拆分复杂架构和业务。</p><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/CRQS.png" alt></p><p>我们架构也从 Polling publisher -&gt; Transaction logtailing 进行了演进(Pull vs Push)</p><h2 id="gRPC-amp-服务实现"><a href="#gRPC-amp-服务实现" class="headerlink" title="gRPC &amp; 服务实现"></a>gRPC &amp; 服务实现</h2><h2 id="多集群-amp-多租户"><a href="#多集群-amp-多租户" class="headerlink" title="多集群 &amp; 多租户"></a>多集群 &amp; 多租户</h2><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;微服务概览&quot;&gt;&lt;a href=&quot;#微服务概览&quot; class=&quot;headerlink&quot; title=&quot;微服务概览&quot;&gt;&lt;/a&gt;微服务概览&lt;
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="Golang" scheme="https://octopuslian.github.io/tags/Golang/"/>
    
      <category term="微服务" scheme="https://octopuslian.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="gRPC" scheme="https://octopuslian.github.io/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营总结和收获</title>
    <link href="https://octopuslian.github.io/2021/03/03/geekbang-gatc-gain/"/>
    <id>https://octopuslian.github.io/2021/03/03/geekbang-gatc-gain/</id>
    <published>2021-03-03T04:55:22.000Z</published>
    <updated>2021-03-03T03:28:41.223Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --><p>花了将近一个月终于刷完了<code>GATC</code>，让我系统学习了算法与数据结构的知识，尤其是后面接触的字典树、并查集、布隆过滤器、<code>AVL Tree</code>、<code>Red black Tree</code>这种高级数据结构，让我不得不感人类思想的伟大。</p><p>字符串算法和排序算法很重要，面试经常考，要及时掌握，同时不能放弃刷题，要时刻保持做题手感，同时要时刻借鉴别人优秀的解题思路。这样编程能力以及算法的基本功会慢慢得到提升。</p><p>加油！^_^</p><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h2><p><a href="https://octopuslian.github.io/categories/GATC/">GATC</a><br><a href="https://octopuslian.github.io/2020/11/29/geekbang-live-a-week-algo-training-camp-1-time-space-complex-analyze/">时间复杂度和空间复杂度分析</a><br><a href="https://octopuslian.github.io/2020/11/30/geekbang-live-a-week-algo-training-camp-2-array-linked-list-skip-list/">数组、链表、跳表</a><br><a href="https://octopuslian.github.io/2020/12/01/geekbang-live-a-week-algo-training-camp-3-tree-binary-tree-and-binary-search-tree/">树、二叉树、二叉搜索树</a><br><a href="https://octopuslian.github.io/2020/12/02/geekbang-live-a-week-algo-training-camp-4-recursive/">递归</a><br><a href="https://octopuslian.github.io/2020/12/03/geekbang-live-a-week-algo-training-camp-5-test/">算法体验营-结课考试题</a><br><a href="https://octopuslian.github.io/2021/01/22/geekbang-gatc-04-stack-and-queue/">栈和队列</a><br><a href="https://octopuslian.github.io/2021/01/22/geekbang-gatc-12-dynamic-programming/">动态规划</a><br><a href="https://octopuslian.github.io/2021/01/22/geekbang-gatc-13-dictionary-tree-and-union-loopup/">Trie树、并查集</a><br><a href="https://octopuslian.github.io/2021/01/22/geekbang-gatc-16-bit-operation/">位运算基础</a><br><a href="https://octopuslian.github.io/2021/01/22/geekbang-gatc-05-hashmap-and-set/">哈希表、映射、集合</a><br><a href="https://octopuslian.github.io/2021/01/23/geekbang-gatc-08-divide-conquer-and-backtracking/">分治、回溯</a><br><a href="https://octopuslian.github.io/2021/01/23/geekbang-gatc-09-dfs-and-bfs/">深度优先搜索、广度优先搜索</a><br><a href="https://octopuslian.github.io/2021/02/23/geekbang-gatc-10-greedy-algo/">贪心算法</a><br><a href="https://octopuslian.github.io/2021/02/23/geekbang-gatc-11-binary-search/">二分查找</a><br><a href="https://octopuslian.github.io/2021/02/24/geekbang-gatc-18-sort-algo/">初级排序和高级排序</a><br><a href="https://octopuslian.github.io/2021/02/24/geekbang-gatc-20-string-algo/">字符串基础知识、高级字符串算法、字符串匹配算法</a><br><a href="https://octopuslian.github.io/2021/03/01/geekbang-gatc-14-advanced-search/">高级搜索</a><br><a href="https://octopuslian.github.io/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/">AVL树和红黑树</a><br><a href="https://octopuslian.github.io/2021/03/02/geekbang-gatc-17-bloom-filter-and-lru-cache/">布隆过滤器、LRUCache</a><br><a href="https://octopuslian.github.io/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/">动态规划、状态转移方程</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;花了将近一个月终于刷完了&lt;code&gt;GATC&lt;/code&gt;，让我系统学习了算法与数据结构的知识，尤其是后面接触的字典树、并查集、布隆过滤器、&lt;c
      
    
    </summary>
    
    
      <category term="GATC" scheme="https://octopuslian.github.io/categories/GATC/"/>
    
    
      <category term="算法" scheme="https://octopuslian.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="收获" scheme="https://octopuslian.github.io/tags/%E6%94%B6%E8%8E%B7/"/>
    
      <category term="总结" scheme="https://octopuslian.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 04.二维数组中的查找</title>
    <link href="https://octopuslian.github.io/2021/03/02/leetcode-lcof-04-er-wei-shu-zu-zhong-de-cha-zhao/"/>
    <id>https://octopuslian.github.io/2021/03/02/leetcode-lcof-04-er-wei-shu-zu-zhong-de-cha-zhao/</id>
    <published>2021-03-02T15:24:40.000Z</published>
    <updated>2021-03-02T15:25:34.251Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/submissions/" target="_blank" rel="noopener">力扣-剑指 Offer 04. 二维数组中的查找</a></p><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">现有矩阵 matrix 如下：</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">给定 target = 5，返回 true。</span><br><span class="line">给定 target = 20，返回 false。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">0 &lt;= n &lt;= 1000</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>难度为中等。</p><h3 id="解法一：暴力法"><a href="#解法一：暴力法" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h3><p>先用一个循环，每次遍历出一个数组<code>nums</code>，然后用<a href="https://golang.org/pkg/sort/#SearchInts" target="_blank" rel="noopener">sort.SearchInts</a>查出<code>nums</code>数组中<code>target</code>的下标，接着做下判断即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findNumberIn2DArray</span><span class="params">(matrix [][]<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, nums := <span class="keyword">range</span> matrix &#123;</span><br><span class="line"><span class="comment">//遍历数组切片，查找数组中是否含有target值，如果查找不到，返回值是target应该插入数组的位置（会保持数组的递增顺序）</span></span><br><span class="line">i := sort.SearchInts(nums, target) <span class="comment">//查找nums数组中target的下标</span></span><br><span class="line"><span class="comment">//插入的位置小于数组长度 且 插入数组的位置上的值和目标值相等</span></span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="built_in">len</span>(nums) &amp;&amp; target == nums[i] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode-cn执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">28 ms, 在所有 Go 提交中击败了80.58%的用户</span><br><span class="line">内存消耗：6.6 MB, 在所有 Go 提交中击败了70.78%的用户</span><br></pre></td></tr></table></figure><p>牛客网运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行时间：7ms</span><br><span class="line">超过8.42%用Go提交的代码</span><br><span class="line">占用内存：3204KB</span><br><span class="line">超过44.21%用Go提交的代码</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="LeetCode-lcof-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-lcof-Solutions/"/>
    
    
      <category term="数组" scheme="https://octopuslian.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="暴力" scheme="https://octopuslian.github.io/tags/%E6%9A%B4%E5%8A%9B/"/>
    
      <category term="sort" scheme="https://octopuslian.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营-动态规划、状态转移方程串讲</title>
    <link href="https://octopuslian.github.io/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/"/>
    <id>https://octopuslian.github.io/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/</id>
    <published>2021-03-02T14:10:35.000Z</published>
    <updated>2021-03-02T14:14:39.233Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --><h2 id="常见的DP题目和状态转移方程"><a href="#常见的DP题目和状态转移方程" class="headerlink" title="常见的DP题目和状态转移方程"></a>常见的DP题目和状态转移方程</h2><h3 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">爬楼梯</a></h3><p><img src="/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/pa-lou-ti.png" alt></p><h3 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">不同路径</a></h3><p><img src="/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/bu-tong-lu-jing.png" alt></p><h3 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">打家劫舍</a></h3><p><img src="/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/da-jia-jie-she.png" alt></p><h3 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a><a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">最小路径和</a></h3><p><img src="/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/zui-xiao.png" alt></p><h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">买卖股票的最佳时机</a></h3><p><img src="/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/gu-piao.png" alt></p><p><img src="/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/2-gu-piao.png" alt></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/solution/yi-ge-tong-yong-fang-fa-tuan-mie-6-dao-gu-piao-w-5/" target="_blank" rel="noopener">一个通用方法团灭 6 道股票问题</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;常见的DP题目和状态转移方程&quot;&gt;&lt;a href=&quot;#常见的DP题目和状态转移方程&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="GATC" scheme="https://octopuslian.github.io/categories/GATC/"/>
    
    
      <category term="动态规划" scheme="https://octopuslian.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="DP" scheme="https://octopuslian.github.io/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营-布隆过滤器、LRUCache的实现和应用</title>
    <link href="https://octopuslian.github.io/2021/03/02/geekbang-gatc-17-bloom-filter-and-lru-cache/"/>
    <id>https://octopuslian.github.io/2021/03/02/geekbang-gatc-17-bloom-filter-and-lru-cache/</id>
    <published>2021-03-02T13:09:46.000Z</published>
    <updated>2021-03-02T13:46:47.333Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --><h2 id="布隆过滤器-Bloom-filter"><a href="#布隆过滤器-Bloom-filter" class="headerlink" title="布隆过滤器-Bloom filter"></a>布隆过滤器-Bloom filter</h2><p><img src="/2021/03/02/geekbang-gatc-17-bloom-filter-and-lru-cache/hashtable.png" alt></p><h3 id="Bloom-filter-vs-Hash-Table"><a href="#Bloom-filter-vs-Hash-Table" class="headerlink" title="Bloom filter vs Hash Table"></a>Bloom filter vs Hash Table</h3><p>一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。</p><p>优点：空间效率和查询时间都远远超过一般的算法。</p><p>缺点：有一定的误识别率和删除困难。</p><p><img src="/2021/03/02/geekbang-gatc-17-bloom-filter-and-lru-cache/buloom.png" alt></p><p><img src="/2021/03/02/geekbang-gatc-17-bloom-filter-and-lru-cache/bloom2.png" alt></p><p>结论：如果这个元素在布隆过滤器查不到，那肯定不存在；如果查得到，那可能存在。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>1，比特币网络<br>2，分布式系统（Map-Reduce）——Hadoop、Search Engine<br>3，Redis缓存<br>4，垃圾邮件、评论等的过滤</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><img src="/2021/03/02/geekbang-gatc-17-bloom-filter-and-lru-cache/bpython.png" alt></p><h2 id="LRUCache"><a href="#LRUCache" class="headerlink" title="LRUCache"></a>LRUCache</h2><h3 id="Cache缓存"><a href="#Cache缓存" class="headerlink" title="Cache缓存"></a>Cache缓存</h3><p>1，记忆<br>2，钱包-储物柜<br>3，代码模块</p><ul><li>两个要素：大小、替换策略</li><li>Hash Table + Double LinkedList</li><li>O(1)查询，修改、更新</li></ul><p><img src="/2021/03/02/geekbang-gatc-17-bloom-filter-and-lru-cache/lru-cache-work.png" alt></p><p>代码示例：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span><span class="params">(object)</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity)</span>:</span> </span><br><span class="line">        self.dic = collections.OrderedDict() </span><br><span class="line">        self.remain = capacity<span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key)</span>:</span> </span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.dic: </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span> </span><br><span class="line">            v = self.dic.pop(key) </span><br><span class="line">            self.dic[key] = v   <span class="comment"># key as the newest one </span></span><br><span class="line">            <span class="keyword">return</span> v </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key, value)</span>:</span> </span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> self.dic: </span><br><span class="line">                self.dic.pop(key) </span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">if</span> self.remain &gt; <span class="number">0</span>: </span><br><span class="line">                    self.remain -= <span class="number">1</span> </span><br><span class="line">                <span class="keyword">else</span>:   <span class="comment"># self.dic is full</span></span><br><span class="line">                    self.dic.popitem(last=<span class="literal">False</span>) </span><br><span class="line">            self.dic[key] = value</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * 使用 哈希表 + 双端链表 实现 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedNode</span> </span>&#123;  constructor(key = <span class="number">0</span>, val = <span class="number">0</span>) &#123;    </span><br><span class="line">    <span class="keyword">this</span>.key = key    </span><br><span class="line">    <span class="keyword">this</span>.val = val    </span><br><span class="line">    <span class="keyword">this</span>.prev = <span class="keyword">null</span>    </span><br><span class="line">    <span class="keyword">this</span>.next = <span class="keyword">null</span>  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> </span>&#123;  </span><br><span class="line">    constructor() &#123;    <span class="keyword">this</span>.head = <span class="keyword">new</span> LinkedNode()    <span class="keyword">this</span>.tail = <span class="keyword">new</span> LinkedNode()    <span class="keyword">this</span>.head.next = <span class="keyword">this</span>.tail    <span class="keyword">this</span>.tail.prev = <span class="keyword">this</span>.head  &#125;  insertFirst(node) &#123;    node.next = <span class="keyword">this</span>.head.next    node.prev = <span class="keyword">this</span>.head    <span class="keyword">this</span>.head.next.prev = node    <span class="keyword">this</span>.head.next = node  &#125;  remove(node) &#123;    node.prev.next = node.next    node.next.prev = node.prev  &#125;  removeLast() &#123;    <span class="keyword">if</span> (<span class="keyword">this</span>.tail.prev === <span class="keyword">this</span>.head) <span class="keyword">return</span> <span class="keyword">null</span>    let last = <span class="keyword">this</span>.tail.prev    <span class="keyword">this</span>.remove(last)    <span class="keyword">return</span> last  &#125;&#125;<span class="comment">/** * <span class="doctag">@param</span> &#123;number&#125; capacity */</span><span class="keyword">var</span> LRUCache = function(capacity) &#123;  <span class="keyword">this</span>.capacity = capacity  <span class="keyword">this</span>.keyNodeMap = <span class="keyword">new</span> Map()  <span class="keyword">this</span>.cacheLink = <span class="keyword">new</span> LinkedList()&#125;;<span class="comment">/**  * <span class="doctag">@param</span> &#123;number&#125; key * <span class="doctag">@return</span> &#123;number&#125; */</span>LRUCache.prototype.get = function(key) &#123;  <span class="keyword">if</span> (!<span class="keyword">this</span>.keyNodeMap.has(key)) <span class="keyword">return</span> -<span class="number">1</span>  let val = <span class="keyword">this</span>.keyNodeMap.get(key).val  <span class="keyword">this</span>.put(key, val)  <span class="keyword">return</span> val&#125;;<span class="comment">/**  * <span class="doctag">@param</span> &#123;number&#125; key  * <span class="doctag">@param</span> &#123;number&#125; value * <span class="doctag">@return</span> &#123;void&#125; */</span>LRUCache.prototype.put = function(key, value) &#123;  let size = <span class="keyword">this</span>.keyNodeMap.<span class="function">size  <span class="title">if</span> <span class="params">(<span class="keyword">this</span>.keyNodeMap.has(key)</span>) </span>&#123;    <span class="keyword">this</span>.cacheLink.remove(<span class="keyword">this</span>.keyNodeMap.get(key));     --size   &#125;  <span class="keyword">if</span> (size &gt;= <span class="keyword">this</span>.capacity) &#123;    <span class="keyword">this</span>.keyNodeMap.delete(<span class="keyword">this</span>.cacheLink.removeLast().key)  &#125;  let node = <span class="keyword">new</span> LinkedNode(key, value)  <span class="keyword">this</span>.keyNodeMap.set(key, node)  <span class="keyword">this</span>.cacheLink.insertFirst(node)&#125;;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/cpselvis/p/6265825.html" target="_blank" rel="noopener">布隆过滤器(Bloom Filter)的原理和实现</a><br><a href="https://blog.csdn.net/tianyaleixiaowu/article/details/74721877" target="_blank" rel="noopener">使用BloomFilter布隆过滤器解决缓存击穿、垃圾邮件识别、集合判重</a><br><a href="https://www.geeksforgeeks.org/bloom-filters-introduction-and-python-implementation/" target="_blank" rel="noopener">Bloom Filters – Introduction and Implementation</a><br><a href="https://github.com/jhgg/pybloof" target="_blank" rel="noopener">Github-Pybloof</a><br><a href="https://github.com/lovasoa/bloomfilter/blob/master/src/main/java/BloomFilter.java" target="_blank" rel="noopener">布隆过滤器Java实现示例1</a><br><a href="https://github.com/Baqend/Orestes-Bloomfilter" target="_blank" rel="noopener">布隆过滤器Java实现示例2</a><br><a href="https://www.sqlpassion.at/archive/2018/01/06/understanding-the-meltdown-exploit-in-my-own-simple-words/" target="_blank" rel="noopener">Understanding the Meltdown exploit – in my own simple words</a><br><a href="https://en.wikipedia.org/wiki/Cache_replacement_policies" target="_blank" rel="noopener">Cache replacement policies</a><br><a href="https://shimo.im/docs/tTxRkGwJpXG6WkGY/read" target="_blank" rel="noopener">LRU Cache Python代码</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;布隆过滤器-Bloom-filter&quot;&gt;&lt;a href=&quot;#布隆过滤器-Bloom-filter&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="GATC" scheme="https://octopuslian.github.io/categories/GATC/"/>
    
    
      <category term="布隆过滤器" scheme="https://octopuslian.github.io/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
      <category term="LRUCache" scheme="https://octopuslian.github.io/tags/LRUCache/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 03. 数组中重复的数字</title>
    <link href="https://octopuslian.github.io/2021/03/01/leetcode-lcof-03-shu-zu-zhong-zhong-fu-de-shu-zi/"/>
    <id>https://octopuslian.github.io/2021/03/01/leetcode-lcof-03-shu-zu-zhong-zhong-fu-de-shu-zi/</id>
    <published>2021-03-01T14:35:30.000Z</published>
    <updated>2021-03-01T14:37:05.708Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --><p>今天开始争取每天更新至少一道<a href="https://leetcode-cn.com/problemset/lcof/" target="_blank" rel="noopener">《剑指offer》</a>的题解</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">力扣-剑指 Offer 03. 数组中重复的数字</a></p><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">2 &lt;= n &lt;= 100000</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>难度为简单。</p><h3 id="解法一：循环-Map"><a href="#解法一：循环-Map" class="headerlink" title="解法一：循环+Map"></a>解法一：循环+Map</h3><p>一次遍历，将扫描到数字做判断，如果可以在<code>map</code>中查到，就添加进去，否则返回这个数字，因为这个数字已经在<code>map</code>里存在了，属于重复数字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRepeatNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nummap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> _,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> !nummap[num] &#123;</span><br><span class="line">            nummap[num] = <span class="literal">true</span>  <span class="comment">//map中没有这个num</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> num  <span class="comment">//重复，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>leetcode-cn</code>执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">56 ms, 在所有 Go 提交中击败了8.84%的用户</span><br><span class="line">内存消耗：8.9 MB, 在所有 Go 提交中击败了39.48%的用户</span><br></pre></td></tr></table></figure><p>牛客网执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行时间：3ms</span><br><span class="line">超过100.00%用Go提交的代码</span><br><span class="line">占用内存：832KB</span><br><span class="line">超过100.00%用Go提交的代码</span><br></pre></td></tr></table></figure><h3 id="解法二：原地交换"><a href="#解法二：原地交换" class="headerlink" title="解法二：原地交换"></a>解法二：原地交换</h3><p>遍历数组并通过交换操作，使元素的 索引 与 值 一一对应（即 nums[i] = inums[i]=i ）。因而，就能通过索引映射对应的值，起到与字典等价的作用。可以看这个<a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-yua/" target="_blank" rel="noopener">题解</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRepeatNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] == i &#123;</span><br><span class="line">            i++</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[nums[i]] == nums[i] &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        tmp := nums[i]</span><br><span class="line">        nums[i] = nums[tmp]</span><br><span class="line">        nums[tmp] = tmp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode-cn执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">40 ms, 在所有 Go 提交中击败了86.59%的用户</span><br><span class="line">内存消耗：8.7 MB, 在所有 Go 提交中击败了89.50%的用户</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;今天开始争取每天更新至少一道&lt;a href=&quot;https://leetcode-cn.com/problemset/lcof/&quot; target=
      
    
    </summary>
    
    
      <category term="LeetCode-lcof-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-lcof-Solutions/"/>
    
    
      <category term="Map" scheme="https://octopuslian.github.io/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营-AVL树和红黑树的实现和特性</title>
    <link href="https://octopuslian.github.io/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/"/>
    <id>https://octopuslian.github.io/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/</id>
    <published>2021-03-01T05:08:36.000Z</published>
    <updated>2021-03-02T12:55:39.646Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><ul><li>发明者：Adelson-Velsky and Landis Tree</li><li>Blance Factor(平衡因子)：是它的左子树的高度减去它的右子树的高度（有时相反）。balance factor= {-1,0,1}</li><li>通过旋转操作来进行平衡（四种）</li><li><a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree" target="_blank" rel="noopener">Self-balancing binary search tree</a></li><li>不足：结点需要存储额外信息、且调整次数频繁</li></ul><h3 id="记录左右子树高度"><a href="#记录左右子树高度" class="headerlink" title="记录左右子树高度"></a>记录左右子树高度</h3><p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/hight.png" alt></p><p>例如F点，右子树高度1 - 左子树高度2 = -1</p><h3 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h3><p>1，左旋</p><p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/zuoxuan.png" alt></p><p>2，右旋</p><p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/youxuan.png" alt></p><p>3，左右旋</p><p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/zuoyouxuan2.png" alt></p><p>4，右左旋</p><p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/youzuoxuan.png" alt></p><h2 id="红黑树-Red-black-Tree"><a href="#红黑树-Red-black-Tree" class="headerlink" title="红黑树(Red-black Tree)"></a>红黑树(Red-black Tree)</h2><p>红黑树是一种近似平衡的二叉搜索树(Binary Search Tree)，它能够确保任何一个结点的左右子树的<strong>高度差小于两倍</strong>。具体来说，红黑树是满足如下条件的二叉搜索树：</p><ul><li>每个结点要么是红色，要么是黑色；</li><li>根结点是黑色；</li><li>每个叶结点(NIL结点、空结点)是黑色的；</li><li>不能有相邻的两个红色结点；</li><li>从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。</li><li>关键性质：从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。</li></ul><p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/rbtree.png" alt></p><p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/rbtree2.png" alt></p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/duibi-en.png" alt></p><p>翻译：</p><ul><li>AVL树提供了更快的查询，因为它是严格平衡的；</li><li>红黑树提供了更快的插入和删除的操作，因为AVL的旋转操作会更多而红黑树会更少一点；</li><li>AVL存在<code>factors</code>或<code>heights</code>更多一点，它需要更多的内存附加在每个结点里面来存这些了额外的信息，而红黑树要的信息非常少，它只要一个<code>bit</code>就是来存0和1表示黑或者是红；</li><li>红黑树是用在你们常常写的一些高级语言的库里面，比如C++中的<code>map、set</code>；如果用在数据库里面的话一般用<code>AVL</code></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91" target="_blank" rel="noopener">wiki-AVL树</a><br><a href="https://zhuanlan.zhihu.com/p/63272157" target="_blank" rel="noopener">leetcode刷题(十）：树（红黑树，B树）</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;AVL树&quot;&gt;&lt;a href=&quot;#AVL树&quot; class=&quot;headerlink&quot; title=&quot;AVL树&quot;&gt;&lt;/a&gt;AVL树&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="GATC" scheme="https://octopuslian.github.io/categories/GATC/"/>
    
    
      <category term="红黑树" scheme="https://octopuslian.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
      <category term="AVL树" scheme="https://octopuslian.github.io/tags/AVL%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营-高级搜索</title>
    <link href="https://octopuslian.github.io/2021/03/01/geekbang-gatc-14-advanced-search/"/>
    <id>https://octopuslian.github.io/2021/03/01/geekbang-gatc-14-advanced-search/</id>
    <published>2021-03-01T05:08:16.000Z</published>
    <updated>2021-03-02T12:55:33.101Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --><h2 id="剪枝的实现和特性"><a href="#剪枝的实现和特性" class="headerlink" title="剪枝的实现和特性"></a>剪枝的实现和特性</h2><h3 id="初级搜索"><a href="#初级搜索" class="headerlink" title="初级搜索"></a>初级搜索</h3><ul><li>1，朴素搜索：暴力搜索；</li><li>2，优化方式：不重复(fibonacci)、剪枝(生成括号问题)；</li><li>3，搜索方向：深度优先搜索、广度优先搜索、双向搜索、启发式搜索。</li></ul><h2 id="双向BFS的实现、特性"><a href="#双向BFS的实现、特性" class="headerlink" title="双向BFS的实现、特性"></a>双向BFS的实现、特性</h2><p>单向BFS</p><p><img src="/2021/03/01/geekbang-gatc-14-advanced-search/bfs.png" alt></p><p>变形：</p><p><img src="/2021/03/01/geekbang-gatc-14-advanced-search/bfs2.png" alt></p><p>双向BFS</p><p><img src="/2021/03/01/geekbang-gatc-14-advanced-search/Tbfs.png" alt></p><h2 id="启发式搜索的实现、特性-Heuristc-Search-A"><a href="#启发式搜索的实现、特性-Heuristc-Search-A" class="headerlink" title="启发式搜索的实现、特性 - Heuristc Search(A*)"></a>启发式搜索的实现、特性 - Heuristc Search(A*)</h2><p>代码模板</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AstarSearch</span><span class="params">(graph, start, end)</span>:</span></span><br><span class="line">    pq = collections.priority_queue() <span class="comment"># 优先级 —&gt; 估价函数</span></span><br><span class="line">    pq.append([start]) </span><br><span class="line">    visited.add(start)</span><br><span class="line">    <span class="keyword">while</span> pq: </span><br><span class="line">        node = pq.pop() <span class="comment"># can we add more intelligence here ?</span></span><br><span class="line">        visited.add(node)</span><br><span class="line">        process(node) </span><br><span class="line">        nodes = generate_related_nodes(node)    </span><br><span class="line">        unvisited = [node <span class="keyword">for</span> node <span class="keyword">in</span> nodes <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited]</span><br><span class="line">        pq.push(unvisited)</span><br></pre></td></tr></table></figure><h3 id="估价函数"><a href="#估价函数" class="headerlink" title="估价函数"></a>估价函数</h3><p>启发式搜索：h(n)，它用来评价哪些结点最有希望的是一个我们要找的结点，h(n)会返回一个非负实数，也可以认为是从结点<code>n</code>的目标结点路径的估计成本。<br>启发式搜索是一种告知搜索方向的方法。它提供了一种明智的方法来猜测哪个邻居结点会导向一个目标。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="双向BFS"><a href="#双向BFS" class="headerlink" title="双向BFS"></a>双向BFS</h3><ul><li><a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-ladder/</a></li><li><a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-genetic-mutation/</a></li></ul><h3 id="启发式搜索"><a href="#启发式搜索" class="headerlink" title="启发式搜索"></a>启发式搜索</h3><ul><li><a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/</a></li><li><a href="https://leetcode-cn.com/problems/sliding-puzzle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sliding-puzzle/</a></li><li><a href="https://leetcode-cn.com/problems/sudoku-solver/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sudoku-solver/</a></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://nikcheerla.github.io/deeplearningschool/2018/01/01/AlphaZero-Explained/" target="_blank" rel="noopener">AlphaZero Explained</a><br><a href="https://en.wikipedia.org/wiki/Game_complexity" target="_blank" rel="noopener">棋类复杂度</a><br><a href="https://shimo.im/docs/CXvjHyWhpQcxXjcw/read" target="_blank" rel="noopener">A*代码模板</a><br><a href="https://dataaspirant.com/2015/04/11/five-most-popular-similarity-measures-implementation-in-python/" target="_blank" rel="noopener">相似度测量方法</a><br><a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/discuss/313347/A*-search-in-Python" target="_blank" rel="noopener">二进制矩阵中的最短路径的 A* 解法</a><br><a href="https://zxi.mytechroad.com/blog/searching/8-puzzles-bidirectional-astar-vs-bidirectional-bfs/" target="_blank" rel="noopener">8 puzzles 解法比较</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;剪枝的实现和特性&quot;&gt;&lt;a href=&quot;#剪枝的实现和特性&quot; class=&quot;headerlink&quot; title=&quot;剪枝的实现和特性&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="GATC" scheme="https://octopuslian.github.io/categories/GATC/"/>
    
    
      <category term="剪枝" scheme="https://octopuslian.github.io/tags/%E5%89%AA%E6%9E%9D/"/>
    
      <category term="双向BFS" scheme="https://octopuslian.github.io/tags/%E5%8F%8C%E5%90%91BFS/"/>
    
      <category term="双向DFS" scheme="https://octopuslian.github.io/tags/%E5%8F%8C%E5%90%91DFS/"/>
    
      <category term="启发式搜索" scheme="https://octopuslian.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营-字符串基础知识、高级字符串算法、字符串匹配算法</title>
    <link href="https://octopuslian.github.io/2021/02/24/geekbang-gatc-20-string-algo/"/>
    <id>https://octopuslian.github.io/2021/02/24/geekbang-gatc-20-string-algo/</id>
    <published>2021-02-24T13:11:04.000Z</published>
    <updated>2021-03-02T12:56:00.366Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --><h2 id="字符串匹配算法"><a href="#字符串匹配算法" class="headerlink" title="字符串匹配算法"></a>字符串匹配算法</h2><h2 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h2><h3 id="字符串基础问题"><a href="#字符串基础问题" class="headerlink" title="字符串基础问题"></a>字符串基础问题</h3><ul><li><a href="https://leetcode-cn.com/problems/to-lower-case/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/to-lower-case/</a></li><li><a href="https://leetcode-cn.com/problems/length-of-last-word/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/length-of-last-word/</a></li><li><a href="https://leetcode-cn.com/problems/jewels-and-stones/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jewels-and-stones/</a></li><li><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/first-unique-character-in-a-string/</a></li><li><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></li></ul><h3 id="字符串操作问题"><a href="#字符串操作问题" class="headerlink" title="字符串操作问题"></a>字符串操作问题</h3><ul><li><a href="https://leetcode-cn.com/problems/longest-common-prefix/description/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-prefix/description/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-string</a></li><li><a href="https://leetcode-cn.com/problems/reverse-string-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-string-ii/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-words-in-a-string/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-only-letters/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-only-letters/</a></li></ul><h3 id="异位词问题"><a href="#异位词问题" class="headerlink" title="异位词问题"></a>异位词问题</h3><ul><li><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-anagram/</a></li><li><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/group-anagrams/</a></li><li><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/</a></li></ul><h3 id="回文串问题"><a href="#回文串问题" class="headerlink" title="回文串问题"></a>回文串问题</h3><ul><li><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-palindrome/</a></li><li><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-palindrome-ii/</a></li><li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></li></ul><h3 id="最长子串、子序列问题"><a href="#最长子串、子序列问题" class="headerlink" title="最长子串、子序列问题"></a>最长子串、子序列问题</h3><ul><li><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-subsequence/</a></li><li><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/edit-distance/</a></li><li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></li></ul><h3 id="字符串-DP-问题"><a href="#字符串-DP-问题" class="headerlink" title="字符串 +DP 问题"></a>字符串 +DP 问题</h3><ul><li><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regular-expression-matching/</a></li><li><a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/</a></li><li><a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/wildcard-matching/</a></li><li><a href="https://leetcode-cn.com/problems/distinct-subsequences/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/distinct-subsequences/</a></li></ul><h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><ul><li><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/first-unique-character-in-a-string/</a></li><li><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-string-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-string-ii/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-words-in-a-string/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-only-letters/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-only-letters/</a></li><li><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/</a></li><li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></li><li><a href="https://leetcode-cn.com/problems/isomorphic-strings/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/isomorphic-strings/</a></li><li><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-palindrome-ii/</a></li><li><a href="https://leetcode-cn.com/problems/wildcard-matching" target="_blank" rel="noopener">https://leetcode-cn.com/problems/wildcard-matching</a></li><li><a href="https://leetcode-cn.com/problems/longest-valid-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-valid-parentheses</a></li><li><a href="https://leetcode-cn.com/problems/distinct-subsequences/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/distinct-subsequences/</a></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://lemire.me/blog/2017/07/07/are-your-strings-immutable/" target="_blank" rel="noopener">不可变字符串</a><br><a href="https://shimo.im/docs/KkDKkpWxjjrJXdpY/read" target="_blank" rel="noopener">Atoi 代码示例</a><br><a href="http://xn--https-ni33a/www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html" target="_blank" rel="noopener">Boyer-Moore 算法</a><br><a href="https://blog.csdn.net/u012505432/article/details/52210975" target="_blank" rel="noopener">Sunday 算法</a><br><a href="https://shimo.im/docs/dQDxQW8yXPXxh3Hg/read" target="_blank" rel="noopener">字符串匹配暴力法代码示例</a><br><a href="https://shimo.im/docs/KXDdkT99TVtXvTXP/read" target="_blank" rel="noopener">Rabin-Karp 代码示例</a><br><a href="https://www.bilibili.com/video/av11866460?from=search&seid=17425875345653862171" target="_blank" rel="noopener">KMP 字符串匹配算法视频</a><br><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">字符串匹配的 KMP 算法</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;字符串匹配算法&quot;&gt;&lt;a href=&quot;#字符串匹配算法&quot; class=&quot;headerlink&quot; title=&quot;字符串匹配算法&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="GATC" scheme="https://octopuslian.github.io/categories/GATC/"/>
    
    
      <category term="字符串" scheme="https://octopuslian.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="高级字符串算法" scheme="https://octopuslian.github.io/tags/%E9%AB%98%E7%BA%A7%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串匹配算法" scheme="https://octopuslian.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营-初级排序和高级排序的实现和特性</title>
    <link href="https://octopuslian.github.io/2021/02/24/geekbang-gatc-18-sort-algo/"/>
    <id>https://octopuslian.github.io/2021/02/24/geekbang-gatc-18-sort-algo/</id>
    <published>2021-02-24T05:10:05.000Z</published>
    <updated>2021-03-02T12:55:54.333Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="1，比较类排序"><a href="#1，比较类排序" class="headerlink" title="1，比较类排序"></a>1，比较类排序</h3><p>通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</p><h3 id="2，非比较类排序"><a href="#2，非比较类排序" class="headerlink" title="2，非比较类排序"></a>2，非比较类排序</h3><p>不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</p><p><img src="/2021/02/24/geekbang-gatc-18-sort-algo/sort.png" alt></p><p><img src="/2021/02/24/geekbang-gatc-18-sort-algo/sort2.png" alt></p><p>(大厂一般回考时间复杂度为<code>nlogn</code>的排序算法——<strong>堆排序、快速排序、归并排序</strong>，比如快速排序和归并排序用到了分治思想)</p><h2 id="初级排序-O-n-2"><a href="#初级排序-O-n-2" class="headerlink" title="初级排序-O(n^2)"></a>初级排序-O(n^2)</h2><ul><li><p>1,选择排序<br>每次找最小值，然后放到待排序数组的起始位置。</p></li><li><p>2，插入排序<br>从前往后逐步构建有序序列；对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p></li><li><p>3，冒泡排序<br>嵌套循环，每次查看相邻的元素，如果逆序，则交换</p></li></ul><h2 id="高级排序-O-N-LogN"><a href="#高级排序-O-N-LogN" class="headerlink" title="高级排序-O(N*LogN)"></a>高级排序-O(N*LogN)</h2><ul><li>快速排序<br>数组取标杆<code>pivot</code>，将小元素放<code>pivot</code>左边，大元素放右侧，然后依次对右边和右边的子数组继续快排，以达到整个序列有序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go</span></span><br><span class="line"><span class="function">func <span class="title">quickSort</span><span class="params">(array []<span class="keyword">int</span>, begin, end <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> end &lt;= begin &#123;</span><br><span class="line">                 <span class="keyword">return</span>   </span><br><span class="line">                 &#125;   </span><br><span class="line">    pivot := partition(array, begin, end)   </span><br><span class="line">    quickSort(array, begin, pivot-<span class="number">1</span>)   </span><br><span class="line">    quickSort(array, pivot+<span class="number">1</span>, end)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">partition</span><span class="params">(array []<span class="keyword">int</span>, begin, end <span class="keyword">int</span>)</span> <span class="keyword">int</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pivot: 标杆位置，counter: 小于pivot的元素的个数   </span></span><br><span class="line">    pivot, counter := end, begin   </span><br><span class="line">    <span class="keyword">for</span> i := begin; i &lt; end; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> array[i] &lt; array[pivot] &#123;</span><br><span class="line">            array[i], array[counter] = array[counter], array[i]         </span><br><span class="line">            counter++      </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    array[pivot], array[counter] = array[counter], array[pivot]   </span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>归并排序——分治<br>1，把长度为<code>n</code>的输入序列分成两个长度为<code>n/2</code>的子序列；<br>2，把这两个子序列分别采用归并排序；<br>3，将两个排序好的子序列合并成一个最终的排序序列。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (right &lt;= left) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;  <span class="comment">//(left + right) / 2</span></span><br><span class="line"></span><br><span class="line">    mergeSort(array,left,mid);</span><br><span class="line">    mergeSort(array,mid + <span class="number">1</span>,right);</span><br><span class="line">    merge(array,left,mid,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>]; <span class="comment">//中间数组</span></span><br><span class="line">    <span class="comment">//...未完</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>归并和快排具有相似性，但步骤顺序相反</strong></p><p>归并：先排序左右子数组，然后合并两个有序子数组；<br>快排：先调配出左右子数组，然后对于左右子数组进行排序。</p><ul><li>堆排序——堆插入O(logN)，取最大/小值O(1)<br>1，数组元素依次建立小顶堆；<br>2，依次取堆顶元素，并删除。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Cpp</span></span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">十大经典排序算法（动图演示）</a><br><a href="https://shimo.im/docs/98KjvGwwGpTpYGKy/read" target="_blank" rel="noopener">快速排序算法示例</a><br><a href="https://shimo.im/docs/YqgG6vtdKwkXJkWx/" target="_blank" rel="noopener">归并排序算法示例</a><br><a href="https://shimo.im/docs/6kRVHRphpgjHgCtx/" target="_blank" rel="noopener">堆排序代码示例</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="GATC" scheme="https://octopuslian.github.io/categories/GATC/"/>
    
    
      <category term="排序算法" scheme="https://octopuslian.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营-二分查找的实现、特性及实战题目解析</title>
    <link href="https://octopuslian.github.io/2021/02/23/geekbang-gatc-11-binary-search/"/>
    <id>https://octopuslian.github.io/2021/02/23/geekbang-gatc-11-binary-search/</id>
    <published>2021-02-23T10:06:14.000Z</published>
    <updated>2021-03-02T12:55:18.373Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --><h2 id="二分查找的前提"><a href="#二分查找的前提" class="headerlink" title="二分查找的前提"></a>二分查找的前提</h2><p>1，目标函数单调性（单调递增或者递减）——在有序的里面查找<br>2，存在上下界（bounded）<br>3，能够通过索引访问（index accessible）</p><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><p>(一定要写的非常熟练)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">left,right := <span class="number">0</span>,len(array) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt;= right:</span><br><span class="line">    mid := (left + right) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> array[mid] == target:</span><br><span class="line">        <span class="comment"># find the target</span></span><br><span class="line">        <span class="keyword">break</span> <span class="keyword">or</span> <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">elif</span> array[mid] &lt; target:</span><br><span class="line">        left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right = mid - <span class="number">1</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;二分查找的前提&quot;&gt;&lt;a href=&quot;#二分查找的前提&quot; class=&quot;headerlink&quot; title=&quot;二分查找的前提&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="GATC" scheme="https://octopuslian.github.io/categories/GATC/"/>
    
    
      <category term="二分查找" scheme="https://octopuslian.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营-贪心的实现、特性及实战题目解析</title>
    <link href="https://octopuslian.github.io/2021/02/23/geekbang-gatc-10-greedy-algo/"/>
    <id>https://octopuslian.github.io/2021/02/23/geekbang-gatc-10-greedy-algo/</id>
    <published>2021-02-23T09:40:38.000Z</published>
    <updated>2021-03-02T12:55:14.422Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --><h2 id="贪心算法-Greedy"><a href="#贪心算法-Greedy" class="headerlink" title="贪心算法-Greedy"></a>贪心算法-Greedy</h2><p>贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是全局最好或最优的算法。</p><p>贪心算法与动态规划的不同在于<strong>它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</strong></p><ul><li>贪心：当下做局部最优判断</li><li>回溯：能够回退</li><li>动态规划：最优判断 + 回溯</li></ul><h3 id="可以解决的最优化问题"><a href="#可以解决的最优化问题" class="headerlink" title="可以解决的最优化问题"></a>可以解决的最优化问题</h3><ul><li>求图中的最小生成树</li><li>求哈夫曼编码等</li></ul><p><strong>由于贪心法的高效性以及所求得的答案比较接近最优结果，贪心算法可以用作辅助算法或直接解决一些要求结果不特别精确的问题。</strong></p><h2 id="适用贪心算法的场景"><a href="#适用贪心算法的场景" class="headerlink" title="适用贪心算法的场景"></a>适用贪心算法的场景</h2><p>简单来说：问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。这种子问题最优解称为最优子结构。</p><h2 id="实战题目"><a href="#实战题目" class="headerlink" title="实战题目"></a>实战题目</h2><p><a href>leetcode-322.Coin Change</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;贪心算法-Greedy&quot;&gt;&lt;a href=&quot;#贪心算法-Greedy&quot; class=&quot;headerlink&quot; title=&quot;贪心算法-
      
    
    </summary>
    
    
      <category term="GATC" scheme="https://octopuslian.github.io/categories/GATC/"/>
    
    
      <category term="贪心算法" scheme="https://octopuslian.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-38. Count and Say | 外观数列</title>
    <link href="https://octopuslian.github.io/2021/02/14/leetcode-38-count-and-say/"/>
    <id>https://octopuslian.github.io/2021/02/14/leetcode-38-count-and-say/</id>
    <published>2021-02-14T01:19:04.000Z</published>
    <updated>2021-02-26T02:51:21.799Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/count-and-say/" target="_blank" rel="noopener">LeetCode</a><br><a href="https://leetcode-cn.com/problems/count-and-say/" target="_blank" rel="noopener">LeetCode-cn</a></p><p>The count-and-say sequence is a sequence of digit strings defined by the recursive formula:</p><ul><li>countAndSay(1) = “1”</li><li>countAndSay(n) is the way you would “say” the digit string from countAndSay(n-1), which is then converted into a different digit string.</li></ul><p>To determine how you “say” a digit string, split it into the minimal number of groups so that each group is a contiguous section all of the same character. Then for each group, say the number of characters, then say the character. To convert the saying into a digit string, replace the counts with a number and concatenate every saying.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: n = 1</span><br><span class="line">Output: &quot;1&quot;</span><br><span class="line">Explanation: This is the base case.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: n = 4</span><br><span class="line">Output: &quot;1211&quot;</span><br><span class="line">Explanation:</span><br><span class="line">countAndSay(1) = &quot;1&quot;</span><br><span class="line">countAndSay(2) = say &quot;1&quot; = one 1 = &quot;11&quot;</span><br><span class="line">countAndSay(3) = say &quot;11&quot; = two 1&apos;s = &quot;21&quot;</span><br><span class="line">countAndSay(4) = say &quot;21&quot; = one 2 + one 1 = &quot;12&quot; + &quot;11&quot; = &quot;1211&quot;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line">1 &lt;= n &lt;= 30</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目为简单难度。<br>典型的递归题目。</p><h3 id="解法一：笨办法-打表"><a href="#解法一：笨办法-打表" class="headerlink" title="解法一：笨办法-打表"></a>解法一：笨办法-打表</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countAndSay</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> arr = []<span class="keyword">string</span>&#123;<span class="string">""</span>,<span class="string">"1"</span>,</span><br><span class="line"><span class="string">"11"</span>,</span><br><span class="line"><span class="string">"21"</span>,</span><br><span class="line"><span class="string">"1211"</span>,</span><br><span class="line"><span class="string">"111221"</span>,</span><br><span class="line"><span class="string">"312211"</span>,</span><br><span class="line"><span class="string">"13112221"</span>,</span><br><span class="line"><span class="string">"1113213211"</span>,</span><br><span class="line"><span class="string">"31131211131221"</span>,</span><br><span class="line"><span class="string">"13211311123113112211"</span>,</span><br><span class="line"><span class="string">"11131221133112132113212221"</span>,</span><br><span class="line"><span class="string">"3113112221232112111312211312113211"</span>,</span><br><span class="line"><span class="string">"1321132132111213122112311311222113111221131221"</span>,</span><br><span class="line"><span class="string">"11131221131211131231121113112221121321132132211331222113112211"</span>,</span><br><span class="line"><span class="string">"311311222113111231131112132112311321322112111312211312111322212311322113212221"</span>,</span><br><span class="line"><span class="string">"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211"</span>,</span><br><span class="line"><span class="string">"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221"</span>,</span><br><span class="line"><span class="string">"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211"</span>,</span><br><span class="line"><span class="string">"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221"</span>,</span><br><span class="line"><span class="string">"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211"</span>,</span><br><span class="line"><span class="string">"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221"</span>,</span><br><span class="line"><span class="string">"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211"</span>,</span><br><span class="line"><span class="string">"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221"</span>,</span><br><span class="line"><span class="string">"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211"</span>,</span><br><span class="line"><span class="string">"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221"</span>,</span><br><span class="line"><span class="string">"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211"</span>,</span><br><span class="line"><span class="string">"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221"</span>,</span><br><span class="line"><span class="string">"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211"</span>,</span><br><span class="line"><span class="string">"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221"</span>,</span><br><span class="line"><span class="string">"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211"</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> arr[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码时间复杂度为<code>O(1)</code></p><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leetcode-cn：</span><br><span class="line">执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：2.1 MB, 在所有 Go 提交中击败了99.11%的用户</span><br><span class="line"></span><br><span class="line">leetcode：</span><br><span class="line">Runtime: 0 ms, faster than 100.00% of Go online submissions for Count and Say.</span><br><span class="line">Memory Usage: 2.1 MB, less than 100.00% of Go online submissions for Count and Say.</span><br></pre></td></tr></table></figure><h3 id="解法二：递归"><a href="#解法二：递归" class="headerlink" title="解法二：递归"></a>解法二：递归</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strconv"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countAndSay</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digui(<span class="string">"1"</span>,n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">digui</span><span class="params">(prestr <span class="keyword">string</span>,n <span class="keyword">int</span>)</span><span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> prestr</span><br><span class="line">    &#125;</span><br><span class="line">    temp:=<span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="built_in">len</span>(prestr);i&gt;<span class="number">0</span>;&#123;</span><br><span class="line">        j:=i</span><br><span class="line">        <span class="keyword">for</span> ;j&gt;<span class="number">0</span>&amp;&amp;prestr[j<span class="number">-1</span>:j] == prestr[i<span class="number">-1</span>:i];j--&#123;&#125;</span><br><span class="line">        temp=strconv.Itoa(i-j)+prestr[i<span class="number">-1</span>:i]+temp</span><br><span class="line">        i = i-(i-j)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digui(temp,n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leetcode-cn：</span><br><span class="line">执行用时：12 ms, 在所有 Go 提交中击败了28.30%的用户</span><br><span class="line">内存消耗：7.3 MB, 在所有 Go 提交中击败了25.81%的用户</span><br><span class="line"></span><br><span class="line">leetcode：</span><br><span class="line">Runtime: 8 ms, faster than 46.85% of Go online submissions for Count and Say.</span><br><span class="line">Memory Usage: 6.6 MB, less than 32.43% of Go online submissions for Count and Say.</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="数组" scheme="https://octopuslian.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="递" scheme="https://octopuslian.github.io/tags/%E9%80%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-35. Search Insert Position | 搜索插入位置</title>
    <link href="https://octopuslian.github.io/2021/02/13/leetcode-35-search-insert-position/"/>
    <id>https://octopuslian.github.io/2021/02/13/leetcode-35-search-insert-position/</id>
    <published>2021-02-13T13:36:51.000Z</published>
    <updated>2021-02-13T13:37:33.910Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/search-insert-position/" target="_blank" rel="noopener">LeetCode</a><br><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">LeetCode-cn</a></p><p>Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: nums = [1,3,5,6], target = 5</span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: nums = [1,3,5,6], target = 2</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: nums = [1,3,5,6], target = 7</span><br><span class="line">Output: 4</span><br><span class="line"></span><br><span class="line">Example 4:</span><br><span class="line">Input: nums = [1,3,5,6], target = 0</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Example 5:</span><br><span class="line">Input: nums = [1], target = 0</span><br><span class="line">Output: 0</span><br><span class="line"> </span><br><span class="line">Constraints:</span><br><span class="line">1 &lt;= nums.length &lt;= 104</span><br><span class="line">-104 &lt;= nums[i] &lt;= 104</span><br><span class="line">nums contains distinct values sorted in ascending order.</span><br><span class="line">-104 &lt;= target &lt;= 104</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目为简单难度。</p><h3 id="解法一：暴力求解法"><a href="#解法一：暴力求解法" class="headerlink" title="解法一：暴力求解法"></a>解法一：暴力求解法</h3><p>使用<code>for</code>循环遍历<code>nums</code>数组，从下标<code>0</code>开始按个与目标值<code>target</code>进行对比，如果<code>nums[i]&gt;=target</code>，说明目标值在数组所有元素之前，直接返回<code>i</code>即可；另一种情况就是目标值在数组所有元素之后，这时返回<code>nums</code>数组长度<code>len(nums)</code>即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt;= target &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leetcode：</span><br><span class="line">Runtime: 4 ms, faster than 88.29% of Go online submissions for Search Insert Position.</span><br><span class="line">Memory Usage: 3.1 MB, less than 100.00% of Go online submissions for Search Insert Position.</span><br><span class="line"></span><br><span class="line">leetcode-cn：</span><br><span class="line">执行用时：4 ms, 在所有 Go 提交中击败了90.15%的用户</span><br><span class="line">内存消耗：2.9 MB, 在所有 Go 提交中击败了100.00%的用户</span><br></pre></td></tr></table></figure><h3 id="解法二：二分查找法"><a href="#解法二：二分查找法" class="headerlink" title="解法二：二分查找法"></a>解法二：二分查找法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    low := <span class="number">0</span></span><br><span class="line">    high := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> low &lt;= high &#123;</span><br><span class="line">        <span class="comment">// 下方写法为了防止数据溢出，如果先加在除以2 加完的值可能会大于INT_MAX，造成溢出 </span></span><br><span class="line">        mid := low + (high - low) / <span class="number">2</span></span><br><span class="line">        guess := nums[mid]</span><br><span class="line">        <span class="keyword">if</span> guess == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid <span class="comment">//找到了，返回下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> guess &gt; target &#123;</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid +<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> low <span class="comment">//没找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leetcode-cn：</span><br><span class="line">执行用时：4 ms, 在所有 Go 提交中击败了90.15%的用户</span><br><span class="line">内存消耗：3 MB, 在所有 Go 提交中击败了56.60%的用户</span><br><span class="line"></span><br><span class="line">leetcode：</span><br><span class="line">Runtime: 8 ms, faster than 8.78% of Go online submissions for Search Insert Position.</span><br><span class="line">Memory Usage: 3.3 MB, less than 6.08% of Go online submissions for Search Insert Position.</span><br></pre></td></tr></table></figure><h3 id="解法三：golang-sort-SearchInts包"><a href="#解法三：golang-sort-SearchInts包" class="headerlink" title="解法三：golang-sort.SearchInts包"></a>解法三：<a href="https://golang.org/pkg/sort/#SearchInts" target="_blank" rel="noopener">golang-sort.SearchInts</a>包</h3><p>解题时不推荐。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sort.SearchInts(nums, target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leetcode：</span><br><span class="line">Runtime: 4 ms, faster than 88.29% of Go online submissions for Search Insert Position.</span><br><span class="line">Memory Usage: 3.1 MB, less than 100.00% of Go online submissions for Search Insert Position.</span><br><span class="line"></span><br><span class="line">leetcode-cn：</span><br><span class="line">执行用时：4 ms, 在所有 Go 提交中击败了90.15%的用户</span><br><span class="line">内存消耗：3 MB, 在所有 Go 提交中击败了56.60%的用户</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="数组" scheme="https://octopuslian.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="暴力法" scheme="https://octopuslian.github.io/tags/%E6%9A%B4%E5%8A%9B%E6%B3%95/"/>
    
      <category term="排序" scheme="https://octopuslian.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="二分法" scheme="https://octopuslian.github.io/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-28-implement-strstr | 实现 strStr()</title>
    <link href="https://octopuslian.github.io/2021/02/12/leetcode-28-implement-strstr/"/>
    <id>https://octopuslian.github.io/2021/02/12/leetcode-28-implement-strstr/</id>
    <published>2021-02-12T13:53:52.000Z</published>
    <updated>2021-02-12T14:38:26.671Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="noopener">LeetCode</a><br><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">LeetCode-cn</a></p><p>Implement strStr().</p><p>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p><p>Clarification:</p><p>What should we return when needle is an empty string? This is a great question to ask during an interview.</p><p>For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf().</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class="line">Output: -1</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: haystack = &quot;&quot;, needle = &quot;&quot;</span><br><span class="line">Output: 0</span><br><span class="line"> </span><br><span class="line">Constraints:</span><br><span class="line">0 &lt;= haystack.length, needle.length &lt;= 5 * 104</span><br><span class="line">haystack and needle consist of only lower-case English characters.</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>难度简单。<br>这道题就是说要找到<code>needle</code>在<code>haystack</code>第一个出现的位置，如果没有出现就返回<code>-1</code>。</p><h3 id="解法一：暴力法"><a href="#解法一：暴力法" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack <span class="keyword">string</span>, needle <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">//考虑特殊情况</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(haystack) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(needle) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(haystack) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(needle) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(haystack) &lt; <span class="built_in">len</span>(needle) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    len_h := <span class="built_in">len</span>(haystack)  <span class="comment">//获取haystack字符串的长度</span></span><br><span class="line">    len_n := <span class="built_in">len</span>(needle)  <span class="comment">//获取needle字符串的长度</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;len_h-len_n+<span class="number">1</span>;i++ &#123;</span><br><span class="line">        j := <span class="number">0</span>;  <span class="comment">//子串每次都要重头开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> ;j&lt;len_n;j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i+j] != needle[j]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == len_n) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leetcode-cn：</span><br><span class="line">执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：2.2 MB, 在所有 Go 提交中击败了64.54%的用户</span><br><span class="line"></span><br><span class="line">leetcode：</span><br><span class="line">Runtime: 0 ms, faster than 100.00% of Go online submissions for Implement strStr().</span><br><span class="line">Memory Usage: 2.3 MB, less than 100.00% of Go online submissions for Implement strStr().</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><code>Golang</code>中的内置函数<a href="https://golang.org/pkg/strings/#Index" target="_blank" rel="noopener">strings.Index</a>也可以实现，可以参考它的源码实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack <span class="keyword">string</span>, needle <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> strings.Index(haystack,needle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 05 2021 23:47:44 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
      <category term="字符串" scheme="https://octopuslian.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="KMP" scheme="https://octopuslian.github.io/tags/KMP/"/>
    
      <category term="暴力法" scheme="https://octopuslian.github.io/tags/%E6%9A%B4%E5%8A%9B%E6%B3%95/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>以写作调身心</title>
  
  <subtitle>熟能生巧，勤能补拙；念念不忘，必有回响。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://octopuslian.github.io/"/>
  <updated>2021-05-04T08:18:32.895Z</updated>
  <id>https://octopuslian.github.io/</id>
  
  <author>
    <name>Neo Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go进阶-并行编程</title>
    <link href="https://octopuslian.github.io/2021/05/02/goatc-3-concurrency/"/>
    <id>https://octopuslian.github.io/2021/05/02/goatc-3-concurrency/</id>
    <published>2021-05-02T13:32:19.000Z</published>
    <updated>2021-05-04T08:18:32.895Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --><h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><h3 id="Processes-and-Threads"><a href="#Processes-and-Threads" class="headerlink" title="Processes and Threads"></a>Processes and Threads</h3><p>操作系统会为该应用程序创建一个进程。作为一个应用程序，它像一个为所有资源而运行的容器。这些资源包括内存地址空间、文件句柄、设备和线程。<br>线程是操作系统调度的一种执行路径，用于在处理器执行我们在函数中编写的代码。一个进程从一个线程开始，即主线程，当该线程终止时，进程终止。这是因为主线程是应用程序的原点。然后，主线程可以依次启动更多的线程，而这些线程可以启动更多的线程。</p><p>无论线程属于哪个进程，操作系统都会安排线程在可用处理器上运行。每个操作系统都有自己的算法来做出这些决定。</p><h2 id="Goroutines-and-Parallelism"><a href="#Goroutines-and-Parallelism" class="headerlink" title="Goroutines and Parallelism"></a>Goroutines and Parallelism</h2><p>Go 语言层面支持的 go 关键字，可以快速的让一个函数创建为 goroutine，我们可以认为 main 函数就是作为 goroutine 执行的。操作系统调度线程在可用处理器上运行，Go运行时调度 goroutines 在绑定到单个操作系统线程的逻辑处理器中运行(P)。即使使用这个单一的逻辑处理器和操作系统线程，也可以调度数十万 goroutine 以惊人的效率和性能并发运行。</p><p><strong>Concurrency is not Parallelism.（并行不意味着并发）</strong></p><p>并发(可以同时做)不是并行(不同的执行单元)。</p><p>并行是指两个或多个线程同时在不同的处理器执行代码。如果将运行时配置为使用多个逻辑处理器，则调度程序将在这些逻辑处理器之间分配 goroutine，这将导致 goroutine 在不同的操作系统线程上运行。但是，要获得真正的并行性，您需要在具有多个物理处理器的计算机上运行程序。否则，goroutines 将针对单个物理处理器并发运行，即使 Go 运行时使用多个逻辑处理器。</p><h3 id="Keep-your-busy-or-do-the-work-yourself"><a href="#Keep-your-busy-or-do-the-work-yourself" class="headerlink" title="Keep your busy or do the work yourself"></a>Keep your busy or do the work yourself</h3><p>空的select语句将永远堵塞：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Sprintln(w, <span class="string">"Hello，GopherCon SG"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":8000"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Incomplete-Work"><a href="#Incomplete-Work" class="headerlink" title="Incomplete Work"></a>Incomplete Work</h3><h2 id="Memory-model"><a href="#Memory-model" class="headerlink" title="Memory model"></a>Memory model</h2><p><a href="https://golang.org/ref/mem" target="_blank" rel="noopener">https://golang.org/ref/mem</a></p><p>如何保证在一个 goroutine 中看到在另一个 goroutine 修改的变量的值，如果程序中修改数据时有其他 goroutine 同时读取，那么必须将读取串行化。为了串行化访问，请使用 channel 或其他同步原语，例如 sync 和 sync/atomic 来保护数据。</p><h3 id="Happen-Before"><a href="#Happen-Before" class="headerlink" title="Happen-Before"></a>Happen-Before</h3><p>在一个 goroutine 中，读和写一定是按照程序中的顺序执行的。即编译器和处理器只有在不会改变这个 goroutine 的行为时才可能修改读和写的执行顺序。由于重排，不同的goroutine 可能会看到不同的执行顺序。例如，一个goroutine 执行 a = 1;b = 2;，另一个 goroutine 可能看到 b 在 a 之前更新。</p><h3 id="Memory-Reordering"><a href="#Memory-Reordering" class="headerlink" title="Memory Reordering"></a>Memory Reordering</h3><p>用户写下的代码，先要编译成汇编代码，也就是各种指令，包括读写内存的指令。CPU 的设计者们，为了榨干 CPU 的性能，无所不用其极，各种手段都用上了，你可能听过不少，像流水线、分支预测等等。其中，为了提高读写内存的效率，会对读写指令进行重新排列，这就是所谓的 内存重排，英文为 MemoryReordering。</p><h2 id="Package-sync"><a href="#Package-sync" class="headerlink" title="Package sync"></a>Package sync</h2><p>传统的线程模型(通常在编写 Java、C++ 和Python 程序时使用)程序员在线程之间通信需要使用共享内存。通常，共享数据结构由锁保护，线程将争用这些锁来访问数据。在某些情况下，通过使用线程安全的数据结构(如Python的Queue)，这会变得更容易。</p><p>Go 的并发原语 goroutines 和 channels 为构造并发软件提供了一种优雅而独特的方法。Go 没有显式地使用锁来协调对共享数据的访问，而是鼓励使用 chan 在 goroutine 之间传递对数据的引用。这种方法确保在给定的时间只有一个goroutine 可以访问数据。</p><p>Do not communicate by sharing memory; instead, share memory by communicating.</p><h3 id="Detecting-Race-Conditions-With-Go"><a href="#Detecting-Race-Conditions-With-Go" class="headerlink" title="Detecting Race Conditions With Go"></a>Detecting Race Conditions With Go</h3><p>data race 是两个或多个 goroutine 访问同一个资源(如变量或数据结构)，并尝试对该资源进行读写而不考虑其他 goroutine。这种类型的代码可以创建您见过的最疯狂和最随机的 bug。通常需要大量的日志记录和运气才能找到这些类型的bug。</p><p>早在6月份的Go 1.1中，Go 工具引入了一个 race detector。竞争检测器是在构建过程中内置到程序中的代码。然后，一旦你的程序运行，它就能够检测并报告它发现的任何竞争条件。它非常酷，并且在识别罪魁祸首的代码方面做了令人难以置信的工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3/8.go</span><br><span class="line">go build -race</span><br><span class="line">go test -race</span><br></pre></td></tr></table></figure><h3 id="sync-atomic"><a href="#sync-atomic" class="headerlink" title="sync.atomic"></a>sync.atomic</h3><h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><h3 id="errgroup"><a href="#errgroup" class="headerlink" title="errgroup"></a>errgroup</h3><h3 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a>sync.Pool</h3><h2 id="chan"><a href="#chan" class="headerlink" title="chan"></a>chan</h2><h3 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h3><p>channels 是一种类型安全的消息队列，充当两个 goroutine 之间的管道，将通过它同步的进行任意资源的交换。chan 控制 goroutines 交互的能力从而创建了 Go 同步机制。当创建的 chan 没有容量时，称为无缓冲通道。反过来，使用容量创建的 chan 称为缓冲通道。</p><h3 id="Unbuffered-Channels"><a href="#Unbuffered-Channels" class="headerlink" title="Unbuffered Channels"></a>Unbuffered Channels</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>无缓冲 chan 没有容量，因此进行任何交换前需要两个 goroutine 同时准备好。当 goroutine 试图将一个资源发送到一个无缓冲的通道并且没有goroutine 等待接收该资源时，该通道将锁住发送 goroutine 并使其等待。当 goroutine 尝试从无缓冲通道接收，并且没有 goroutine 等待发送资源时，该通道将锁住接收 goroutine 并使其等待。</p><p>无缓冲信道的本质是保证同步。</p><h3 id="Buffered-Channels"><a href="#Buffered-Channels" class="headerlink" title="Buffered Channels"></a>Buffered Channels</h3><p>buffered channel 具有容量，因此其行为可能有点不同。当 goroutine 试图将资源发送到缓冲通道，而该通道已满时，该通道将锁住 goroutine并使其等待缓冲区可用。如果通道中有空间，发送可以立即进行，goroutine 可以继续。当goroutine 试图从缓冲通道接收数据，而缓冲通道为空时，该通道将锁住 goroutine 并使其等待资源被发送。</p><h3 id="Latencies-due-to-under-sized-buffer"><a href="#Latencies-due-to-under-sized-buffer" class="headerlink" title="Latencies due to under-sized buffer"></a>Latencies due to under-sized buffer</h3><p>我们在 chan 创建过程中定义的缓冲区大小可能会极大地影响性能。我将使用密集使用 chan 的扇出模式来查看不同缓冲区大小的影响。在我们的基准测试中，一个 producer 将在通道中注入百万个整数元素，而5个 worker 将读取并将它们追加到一个名为 total 的结果变量中。</p><h3 id="Go-Concurrency-Patterns"><a href="#Go-Concurrency-Patterns" class="headerlink" title="Go Concurrency Patterns"></a>Go Concurrency Patterns</h3><ul><li><p>Timing out</p></li><li><p>Moving on</p></li><li><p>Pipeline</p></li><li><p>Fan-out, Fan-in</p></li><li><p>Cancellation<br>Close 先于 Receive 发生(类似 Buffered)。<br>不需要传递数据，或者传递 nil。<br>非常适合去掉和超时控制。</p></li><li><p>Contex<br><a href="https://blog.golang.org/concurrency-timeouts" target="_blank" rel="noopener">https://blog.golang.org/concurrency-timeouts</a><br><a href="https://blog.golang.org/pipelines" target="_blank" rel="noopener">https://blog.golang.org/pipelines</a><br><a href="https://talks.golang.org/2013/advconc.slide#1" target="_blank" rel="noopener">https://talks.golang.org/2013/advconc.slide#1</a><br><a href="https://github.com/go-kratos/kratos/tree/master/pkg/sync" target="_blank" rel="noopener">https://github.com/go-kratos/kratos/tree/master/pkg/sync</a></p></li></ul><h2 id="Package-context"><a href="#Package-context" class="headerlink" title="Package context"></a>Package context</h2><h3 id="Request-scoped-context"><a href="#Request-scoped-context" class="headerlink" title="Request-scoped context"></a>Request-scoped context</h3><p>在 Go 服务中，每个传入的请求都在其自己的goroutine 中处理。请求处理程序通常启动额外的 goroutine 来访问其他后端，如数据库和 RPC服务。处理请求的 goroutine 通常需要访问特定于请求(request-specific context)的值，例如最终用户的身份、授权令牌和请求的截止日期(deadline)。当一个请求被取消或超时时，处理该请求的所有 goroutine 都应该快速退出(fail fast)，这样系统就可以回收它们正在使用的任何资源。</p><p>Go 1.7 引入一个 context 包，它使得跨 API 边界的请求范围元数据、取消信号和截止日期很容易传递给处理请求所涉及的所有 goroutine(显示传递)。</p><h3 id="Do-not-store-Contexts-inside-a-struct-type"><a href="#Do-not-store-Contexts-inside-a-struct-type" class="headerlink" title="Do not store Contexts inside a struct type"></a>Do not store Contexts inside a struct type</h3><h3 id="context-WithValue"><a href="#context-WithValue" class="headerlink" title="context.WithValue"></a>context.WithValue</h3><h3 id="Debugging-or-tracing-data-is-safe-to-pass-in-a-Context"><a href="#Debugging-or-tracing-data-is-safe-to-pass-in-a-Context" class="headerlink" title="Debugging or tracing data is safe to pass in a Context"></a>Debugging or tracing data is safe to pass in a Context</h3><h3 id="When-a-Context-is-canceled-all-Contexts-derived-from-it-are-also-canceled"><a href="#When-a-Context-is-canceled-all-Contexts-derived-from-it-are-also-canceled" class="headerlink" title="When a Context is canceled, all Contexts derived from it are also canceled"></a>When a Context is canceled, all Contexts derived from it are also canceled</h3><h3 id="All-blocking-long-operations-should-be-cancelable"><a href="#All-blocking-long-operations-should-be-cancelable" class="headerlink" title="All blocking/long operations should be cancelable"></a>All blocking/long operations should be cancelable</h3><h2 id="Final-Notes"><a href="#Final-Notes" class="headerlink" title="Final Notes"></a>Final Notes</h2><ul><li>Incoming requests to a server should create a Context.</li><li>Outgoing calls to servers should accept a Context.</li><li>Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it.</li><li>The chain of function calls between them must propagate the Context.</li><li>Replace a Context using WithCancel, WithDeadline, WithTimeout, or WithValue.</li><li>When a Context is canceled, all Contexts derived from it are also canceled.</li><li>The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines.</li><li>Do not pass a nil Context, even if a function permits it. Pass a TODO context if you are unsure about which Context to use.</li><li>Use context values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html</a><br><a href="https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html</a><br><a href="https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html</a><br><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_concurrency" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html#_concurrency</a><br><a href="https://golang.org/ref/mem" target="_blank" rel="noopener">https://golang.org/ref/mem</a><br><a href="https://blog.csdn.net/caoshangpa/article/details/78853919" target="_blank" rel="noopener">https://blog.csdn.net/caoshangpa/article/details/78853919</a><br><a href="https://blog.csdn.net/qcrao/article/details/92759907" target="_blank" rel="noopener">https://blog.csdn.net/qcrao/article/details/92759907</a><br><a href="https://cch123.github.io/ooo/" target="_blank" rel="noopener">https://cch123.github.io/ooo/</a><br><a href="https://blog.golang.org/codelab-share" target="_blank" rel="noopener">https://blog.golang.org/codelab-share</a><br><a href="https://dave.cheney.net/2018/01/06/" target="_blank" rel="noopener">https://dave.cheney.net/2018/01/06/</a></p><p><code>if-aligned-memory-writes-are-atomic-why-do-we-need-the-sync-atomic-package</code></p><p><a href="http://blog.golang.org/race-detector" target="_blank" rel="noopener">http://blog.golang.org/race-detector</a><br><a href="https://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races" target="_blank" rel="noopener">https://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races</a><br><a href="https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html</a><br><a href="https://medium.com/a-journey-with-go/" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/</a></p><p><code>go-how-to-reduce-lock-contention-with-the-atomic-package-ba3b2664b549</code></p><p><a href="https://medium.com/a-journey-with-go/go-discovery-of-the-trace-package-e5a821743c3c" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-discovery-of-the-trace-package-e5a821743c3c</a><br><a href="https://medium.com/a-journey-with-go/go-mutex-and-starvation-3f4f4e75ad50" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-mutex-and-starvation-3f4f4e75ad50</a><br><a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html</a><br><a href="https://medium.com/a-journey-with-go/go-buffered-and-unbuffered-channels-29a107c00268" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-buffered-and-unbuffered-channels-29a107c00268</a><br><a href="https://medium.com/a-journey-with-go/go-ordering-in-select-statements-fd0ff80fd8d6" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-ordering-in-select-statements-fd0ff80fd8d6</a><br><a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html</a><br><a href="https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html</a><br><a href="https://www.ardanlabs.com/blog/2013/10/my-channel-select-bug.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2013/10/my-channel-select-bug.html</a><br><a href="https://blog.golang.org/io2013-talk-concurrency" target="_blank" rel="noopener">https://blog.golang.org/io2013-talk-concurrency</a><br><a href="https://blog.golang.org/waza-talk" target="_blank" rel="noopener">https://blog.golang.org/waza-talk</a><br><a href="https://blog.golang.org/io2012-videos" target="_blank" rel="noopener">https://blog.golang.org/io2012-videos</a><br><a href="https://blog.golang.org/concurrency-timeouts" target="_blank" rel="noopener">https://blog.golang.org/concurrency-timeouts</a><br><a href="https://blog.golang.org/pipelines" target="_blank" rel="noopener">https://blog.golang.org/pipelines</a><br><a href="https://www.ardanlabs.com/blog/2014/02/running-queries-concurrently-against.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/02/running-queries-concurrently-against.html</a><br><a href="https://blogtitle.github.io/go-advanced-concurrency-patterns-part-3-channels/" target="_blank" rel="noopener">https://blogtitle.github.io/go-advanced-concurrency-patterns-part-3-channels/</a><br><a href="https://www.ardanlabs.com/blog/2013/05/thread-pooling-in-go-programming.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2013/05/thread-pooling-in-go-programming.html</a><br><a href="https://www.ardanlabs.com/blog/2013/09/pool-go-routines-to-process-task.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2013/09/pool-go-routines-to-process-task.html</a><br><a href="https://blogtitle.github.io/categories/concurrency/" target="_blank" rel="noopener">https://blogtitle.github.io/categories/concurrency/</a><br><a href="https://medium.com/@cep21/how-to-correctly-use-context-context-in-go-1-7-8f2c0fafdf39" target="_blank" rel="noopener">https://medium.com/@cep21/how-to-correctly-use-context-context-in-go-1-7-8f2c0fafdf39</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Goroutine&quot;&gt;&lt;a href=&quot;#Goroutine&quot; class=&quot;headerlink&quot; title=&quot;Goroutine
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="Golang" scheme="https://octopuslian.github.io/tags/Golang/"/>
    
      <category term="并行" scheme="https://octopuslian.github.io/tags/%E5%B9%B6%E8%A1%8C/"/>
    
      <category term="并发" scheme="https://octopuslian.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="goroutine" scheme="https://octopuslian.github.io/tags/goroutine/"/>
    
      <category term="channel" scheme="https://octopuslian.github.io/tags/channel/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-异常处理</title>
    <link href="https://octopuslian.github.io/2021/05/02/goatc-2-error/"/>
    <id>https://octopuslian.github.io/2021/05/02/goatc-2-error/</id>
    <published>2021-05-02T13:12:25.000Z</published>
    <updated>2021-05-02T14:47:44.274Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --><h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>Golang的<code>error</code>就是普通的一个接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span>&#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Error-vs-Exception"><a href="#Error-vs-Exception" class="headerlink" title="Error vs Exception"></a>Error vs Exception</h2><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>单返回值，一般通过传递指针作为入参，返回值为 int 表示成功还是失败。</p><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><p>引入了 exception，但是无法知道被调用方会抛出什么异常。</p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>引入了 checked exception，方法的所有者必须申明，调用者必须处理。在启动时抛出大量的异常是司空见惯的事情，并在它们的调用堆栈中尽职地记录下来。Java 异常不再是异常，而是变得司空见惯了。它们从良性到灾难性都有使用，异常的严重性由函数的调用者来区分。</p><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p>Go 的处理异常逻辑是不引入 exception，支持多参数返回，所以你很容易的在函数签名中带上实现了 error interface 的对象，交由调用者来判定。</p><p>如果一个函数返回了 value, error，你不能对这个 value 做任何假设，必须先判定 error。唯一可以忽略 error 的是，如果你连 value 也不关心。</p><p>Go 中有 panic 的机制，如果你认为和其他语言的 exception 一样，那你就错了。当我们抛出异常的时候，相当于你把 exception 扔给了调用者来处理。</p><p>比如，你在 C++ 中，把 string 转为 int，如果转换失败，会抛出异常。或者在 java 中转换 string 为 date 失败时，会抛出异常。</p><p>Go panic 意味着 fatal error(就是挂了)。不能假设调用者来解决 panic，意味着代码不能继续运行。<br>使用多个返回值和一个简单的约定，Go 解决了让程序员知道什么时候出了问题，并为真正的异常情况保留了 panic。</p><p>对于真正意外的情况，那些表示不可恢复的程序错误，例如索引越界、不可恢复的环境问题、栈溢出，我们才使用 panic。对于其他的错误情况，我们应该是期望使用 error 来进行判定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">you only need to check the error value if you care about the result.  -- Dave  </span><br><span class="line">This blog post from Microsoft’s engineering blog in 2005 still holds true today, namely:  </span><br><span class="line">My point isn’t that exceptions are bad. My point is that exceptions are too hard and I’m not smart enough to handle them.</span><br></pre></td></tr></table></figure><ul><li>简单。</li><li>考虑失败，而不是成功(Plan for failure, not success)。</li><li>没有隐藏的控制流。</li><li>完全交给你来控制 error。</li><li>Error are values。</li></ul><h2 id="Error-Type"><a href="#Error-Type" class="headerlink" title="Error Type"></a>Error Type</h2><h3 id="Sentinel-Error"><a href="#Sentinel-Error" class="headerlink" title="Sentinel Error"></a>Sentinel Error</h3><p>预定义的特定错误，我们叫为 sentinel error，这个名字来源于计算机编程中使用一个特定值来表示不可能进行进一步处理的做法。所以对于 Go，我们使用特定的值来表示错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err == ErrSomething &#123; … &#125;</span><br></pre></td></tr></table></figure><p>类似的 io.EOF，更底层的 syscall.ENOENT。</p><p>使用 sentinel 值是最不灵活的错误处理策略，因为调用方必须使用 == 将结果与预先声明的值进行比较。当您想要提供更多的上下文时，这就出现了一个问题，因为返回一个不同的错误将破坏相等性检查。</p><p>甚至是一些有意义的 fmt.Errorf 携带一些上下文，也会破坏调用者的 == ，调用者将被迫查看 error.Error() 方法的输出，以查看它是否与特定的字符串匹配。</p><ul><li><p>不依赖检查 error.Error 的输出。<br>不应该依赖检测 error.Error 的输出，Error 方法存在于 error 接口主要用于方便程序员使用，但不是程序(编写测试可能会依赖这个返回)。这个输出的字符串用于记录日志、输出到 stdout 等。</p></li><li><p>Sentinel errors 成为你 API 公共部分<br>如果您的公共函数或方法返回一个特定值的错误，那么该值必须是公共的，当然要有文档记录，这会增加 API 的表面积。<br>如果 API 定义了一个返回特定错误的 interface，则该接口的所有实现都将被限制为仅返回该错误，即使它们可以提供更具描述性的错误。<br>比如 io.Reader。像 io.Copy 这类函数需要 reader 的实现者比如返回 io.EOF 来告诉调用者没有更多数据了，但这又不是错误。</p></li><li><p>Sentinel errors 在两个包之间创建了依赖<br>sentinel errors 最糟糕的问题是它们在两个包之间创建了源代码依赖关系。例如，检查错误是否等于 io.EOF，您的代码必须导入 io 包。这个特定的例子听起来并不那么糟糕，因为它非常常见，但是想象一下，当项目中的许多包导出错误值时，存在耦合，项目中的其他包必须导入这些错误值才能检查特定的错误条件(in the form of an import loop)。</p></li><li><p>结论: 尽可能避免 sentinel errors<br>我的建议是避免在编写的代码中使用 sentinel errors。在标准库中有一些使用它们的情况，但这不是一个您应该模仿的模式。</p></li></ul><p><strong>Error type 是实现了 error 接口的自定义类型。</strong></p><h3 id="Opaque-errors"><a href="#Opaque-errors" class="headerlink" title="Opaque errors"></a>Opaque errors</h3><p>在我看来，这是最灵活的错误处理策略，因为它要求代码和调用者之间的耦合最少。<br>我将这种风格称为不透明错误处理，因为虽然您知道发生了错误，但您没有能力看到错误的内部。作为调用者，关于操作的结果，您所知道的就是它起作用了，或者没有起作用(成功还是失败)。<br>这就是不透明错误处理的全部功能–只需返回错误而不假设其内容。</p><ul><li>Assert errors for behaviour, not type<br>在少数情况下，这种二分错误处理方法是不够的。例如，与进程外的世界进行交互(如网络活动)，需要调用方调查错误的性质，以确定重试该操作是否合理。在这种情况下，我们可以断言错误实现了特定的行为，而不是断言错误是特定的类型或值。</li></ul><h2 id="Handling-Error"><a href="#Handling-Error" class="headerlink" title="Handling Error"></a>Handling Error</h2><h3 id="Indented-flow-is-for-errors"><a href="#Indented-flow-is-for-errors" class="headerlink" title="Indented flow is for errors"></a>Indented flow is for errors</h3><p>无错误的正常流程代码，将成为一条直线，而不是缩进的代码。</p><h3 id="Eliminate-error-handling-by-eliminating-errors"><a href="#Eliminate-error-handling-by-eliminating-errors" class="headerlink" title="Eliminate error handling by eliminating errors"></a>Eliminate error handling by eliminating errors</h3><p>(后面再细说)</p><h3 id="Wrap-erros"><a href="#Wrap-erros" class="headerlink" title="Wrap erros"></a>Wrap erros</h3><p>在程序的顶部，程序的主体将把错误打印到屏幕或日志文件中，打印出来的只是：没有这样的文件或目录。</p><p>没有生成错误的 file:line 信息。没有导致错误的调用堆栈的堆栈跟踪。这段代码的作者将被迫进行长时间的代码分割，以发现是哪个代码路径触发了文件未找到错误。</p><p>这种模式与 sentinel errors 或 type assertions 的使用不兼容，因为将错误值转换为字符串，将其与另一个字符串合并，然后将其转换回 fmt.Errorf 破坏了原始错误，导致等值判定失败。</p><p>Go 中的错误处理契约规定，在出现错误的情况下，不能对其他返回值的内容做出任何假设。由于 JSON 序列化失败，buf 的内容是未知的，可能它不包含任何内容，但更糟糕的是，它可能包含一个半写的 JSON 片段。</p><p>由于程序员在检查并记录错误后忘记 return，损坏的缓冲区将被传递给 WriteAll，这可能会成功，因此配置文件将被错误地写入。但是，该函数返回的结果是正确的。</p><p>日志记录与错误无关且对调试没有帮助的信息应被视为噪音，应予以质疑。记录的原因是因为某些东西失败了，而日志包含了答案。</p><ul><li>错误要被日志记录。</li><li>应用程序处理错误，保证100%完整性。</li><li>之后不再报告当前错误。</li></ul><h2 id="Go-1-13-errors"><a href="#Go-1-13-errors" class="headerlink" title="Go 1.13 errors"></a>Go 1.13 errors</h2><p>最简单的错误检查：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">//something went wrong</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><p>我们在数据库操作的时候，比如 dao 层中当遇到一个 sql.ErrNoRows 的时候，是否应该 Wrap 这个 error，抛给上层。为什么，应该怎么做请写出代码？</p><h2 id="Go-2-Error-Inspection"><a href="#Go-2-Error-Inspection" class="headerlink" title="Go 2 Error Inspection"></a>Go 2 Error Inspection</h2><p><a href="https://go.googlesource.com/proposal/+/master/design/29934-error-values.md" target="_blank" rel="noopener">https://go.googlesource.com/proposal/+/master/design/29934-error-values.md</a></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://dave.cheney.net/2012/01/18/why-go-gets-exceptions-right" target="_blank" rel="noopener">https://dave.cheney.net/2012/01/18/why-go-gets-exceptions-right</a><br><a href="https://dave.cheney.net/2015/01/26/errors-and-exceptions-redux" target="_blank" rel="noopener">https://dave.cheney.net/2015/01/26/errors-and-exceptions-redux</a><br><a href="https://dave.cheney.net/2014/11/04/error-handling-vs-exceptions-redux" target="_blank" rel="noopener">https://dave.cheney.net/2014/11/04/error-handling-vs-exceptions-redux</a><br><a href="https://rauljordan.com/2020/07/06/why-go-error-handling-is-awesome.html" target="_blank" rel="noopener">https://rauljordan.com/2020/07/06/why-go-error-handling-is-awesome.html</a><br><a href="https://morsmachine.dk/error-handling" target="_blank" rel="noopener">https://morsmachine.dk/error-handling</a><br><a href="https://blog.golang.org/error-handling-and-go" target="_blank" rel="noopener">https://blog.golang.org/error-handling-and-go</a><br><a href="https://www.ardanlabs.com/blog/2014/10/error-handling-in-go-part-i.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/10/error-handling-in-go-part-i.html</a><br><a href="https://www.ardanlabs.com/blog/2014/11/error-handling-in-go-part-ii.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/11/error-handling-in-go-part-ii.html</a><br><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully</a><br><a href="https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html" target="_blank" rel="noopener">https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html</a><br><a href="https://blog.golang.org/errors-are-values" target="_blank" rel="noopener">https://blog.golang.org/errors-are-values</a><br><a href="https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package" target="_blank" rel="noopener">https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package</a><br><a href="https://www.ardanlabs.com/blog/2017/05/design-philosophy-on-logging.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2017/05/design-philosophy-on-logging.html</a><br><a href="https://crawshaw.io/blog/xerrors" target="_blank" rel="noopener">https://crawshaw.io/blog/xerrors</a><br><a href="https://blog.golang.org/go1.13-errors" target="_blank" rel="noopener">https://blog.golang.org/go1.13-errors</a><br><a href="https://medium.com/gett-engineering/error-handling-in-go-53b8a7112d04" target="_blank" rel="noopener">https://medium.com/gett-engineering/error-handling-in-go-53b8a7112d04</a><br><a href="https://medium.com/gett-engineering/error-handling-in-go-1-13-5ee6d1e0a55c" target="_blank" rel="noopener">https://medium.com/gett-engineering/error-handling-in-go-1-13-5ee6d1e0a55c</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Error&quot;&gt;&lt;a href=&quot;#Error&quot; class=&quot;headerlink&quot; title=&quot;Error&quot;&gt;&lt;/a&gt;Error&lt;
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="Golang" scheme="https://octopuslian.github.io/tags/Golang/"/>
    
      <category term="error" scheme="https://octopuslian.github.io/tags/error/"/>
    
      <category term="异常" scheme="https://octopuslian.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 42.trapping-rain-water | 接雨水</title>
    <link href="https://octopuslian.github.io/2021/04/25/leetcode-42-trapping-rain-water/"/>
    <id>https://octopuslian.github.io/2021/04/25/leetcode-42-trapping-rain-water/</id>
    <published>2021-04-25T05:57:53.000Z</published>
    <updated>2021-04-25T05:59:55.292Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left, right, leftMax, rightMax, res <span class="keyword">int</span></span><br><span class="line">right = <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line"><span class="keyword">if</span> height[left] &lt; height[right] &#123;</span><br><span class="line"><span class="keyword">if</span> height[left] &gt;= leftMax &#123;</span><br><span class="line"><span class="comment">//设置左边最高柱子</span></span><br><span class="line">leftMax = height[left]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//右边必定有柱子挡水，所以，遇到所有值小于等于leftMax的，全部加入水池</span></span><br><span class="line">res += leftMax - height[left]</span><br><span class="line">&#125;</span><br><span class="line">left++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> height[right] &gt; rightMax &#123; </span><br><span class="line"><span class="comment">//设置右边最高柱子</span></span><br><span class="line">rightMax = height[right] </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//左边必定有柱子挡水，所以，遇到所有值小于等于rightMax的，全部加入水池</span></span><br><span class="line">res += rightMax - height[right] </span><br><span class="line">&#125;</span><br><span class="line">right--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 12. 矩阵中的路径</title>
    <link href="https://octopuslian.github.io/2021/04/25/leetcode-lcof-12-ju-zhen-zhong-de-lu-jing/"/>
    <id>https://octopuslian.github.io/2021/04/25/leetcode-lcof-12-ju-zhen-zhong-de-lu-jing/</id>
    <published>2021-04-25T05:52:34.000Z</published>
    <updated>2021-04-27T09:50:44.097Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>题目同<a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">leetcode 70.word-search</a></p><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><h3 id="DFS解法"><a href="#DFS解法" class="headerlink" title="DFS解法"></a>DFS解法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exist</span><span class="params">(board [][]<span class="keyword">byte</span>, word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> row := <span class="number">0</span>; row &lt; <span class="built_in">len</span>(board); row ++&#123;</span><br><span class="line">        <span class="keyword">for</span> col := <span class="number">0</span>;col &lt; <span class="built_in">len</span>(board[row]); col ++&#123;</span><br><span class="line">            <span class="keyword">if</span> dfs(board, word, row, col, <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(board [][]<span class="keyword">byte</span>, word <span class="keyword">string</span>, i, j, idx <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">//越界或者字符不相等</span></span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span> || i &gt;= <span class="built_in">len</span>(board) || </span><br><span class="line">    j &lt; <span class="number">0</span> || j &gt;= <span class="built_in">len</span>(board[<span class="number">0</span>]) || </span><br><span class="line">    board[i][j] != word[idx] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> idx == <span class="built_in">len</span>(word) - <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标记已被访问</span></span><br><span class="line">    tmpCh := board[i][j]</span><br><span class="line">    board[i][j] = <span class="string">'/'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//上下左右检查一下</span></span><br><span class="line">    check := (dfs(board, word, i+<span class="number">1</span>, j, idx+<span class="number">1</span>) || dfs(board, word, i<span class="number">-1</span>, j, idx + <span class="number">1</span>) || </span><br><span class="line">    dfs(board, word, i, j+<span class="number">1</span>, idx+<span class="number">1</span>) || dfs(board, word, i, j<span class="number">-1</span>, idx+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复</span></span><br><span class="line">    board[i][j] = tmpCh</span><br><span class="line">    <span class="keyword">return</span> check</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="LeetCode-lcof-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-lcof-Solutions/"/>
    
    
      <category term="BFS" scheme="https://octopuslian.github.io/tags/BFS/"/>
    
      <category term="矩阵路径" scheme="https://octopuslian.github.io/tags/%E7%9F%A9%E9%98%B5%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 329.longest-increasing-path-in-a-matrix | 矩阵中的最长递增路径</title>
    <link href="https://octopuslian.github.io/2021/04/25/leetcode-329-longest-increasing-path-in-a-matrix/"/>
    <id>https://octopuslian.github.io/2021/04/25/leetcode-329-longest-increasing-path-in-a-matrix/</id>
    <published>2021-04-25T05:02:21.000Z</published>
    <updated>2021-04-27T09:54:34.238Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。</p><p><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">329. 矩阵中的最长递增路径</a></p><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rangeSumBST</span><span class="params">(root *TreeNode, low <span class="keyword">int</span>, high <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &gt; high &#123;</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(root.Left, low, high)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &lt; low &#123;</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(root.Right, low, high)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root.Val + rangeSumBST(root.Left, low, high) + rangeSumBST(root.Right, low, high)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="宽度优先搜索（待完善）"><a href="#宽度优先搜索（待完善）" class="headerlink" title="宽度优先搜索（待完善）"></a>宽度优先搜索（待完善）</h3><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="BFS" scheme="https://octopuslian.github.io/tags/BFS/"/>
    
      <category term="DFS" scheme="https://octopuslian.github.io/tags/DFS/"/>
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 179.largest-number | 最大数</title>
    <link href="https://octopuslian.github.io/2021/04/25/leetcode-179-largest-number/"/>
    <id>https://octopuslian.github.io/2021/04/25/leetcode-179-largest-number/</id>
    <published>2021-04-25T04:50:11.000Z</published>
    <updated>2021-04-26T07:00:34.645Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p><p>注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [10,2]</span><br><span class="line">输出：&quot;210&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [3,30,34,5,9]</span><br><span class="line">输出：&quot;9534330&quot;</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [1]</span><br><span class="line">输出：&quot;1&quot;</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：nums = [10]</span><br><span class="line">输出：&quot;10&quot;</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">1 &lt;= nums.length &lt;= 100</span><br><span class="line">0 &lt;= nums[i] &lt;= 109</span><br></pre></td></tr></table></figure><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 10- II. 青蛙跳台阶问题</title>
    <link href="https://octopuslian.github.io/2021/04/25/leetcode-lcof-10-ii-qing-wa-tiao-tai-jie-wen-ti/"/>
    <id>https://octopuslian.github.io/2021/04/25/leetcode-lcof-10-ii-qing-wa-tiao-tai-jie-wen-ti/</id>
    <published>2021-04-25T04:44:37.000Z</published>
    <updated>2021-04-25T04:49:34.550Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;= n &lt;= 100</span><br></pre></td></tr></table></figure><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><h3 id="循环求余法"><a href="#循环求余法" class="headerlink" title="循环求余法"></a>循环求余法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numWays</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    a := <span class="number">1</span></span><br><span class="line">    b := <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; n;i++ &#123;</span><br><span class="line">        sum = (a + b) % <span class="number">1000000007</span></span><br><span class="line">        a = b</span><br><span class="line">        b = sum</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="LeetCode-lcof-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-lcof-Solutions/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
      <category term="青蛙跳台阶" scheme="https://octopuslian.github.io/tags/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>九章算法基础-宽度优先搜索</title>
    <link href="https://octopuslian.github.io/2021/04/23/jiu-zhang-algo-elementary-bfs/"/>
    <id>https://octopuslian.github.io/2021/04/23/jiu-zhang-algo-elementary-bfs/</id>
    <published>2021-04-23T13:37:06.000Z</published>
    <updated>2021-04-26T07:00:34.643Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><h3 id="二叉树上的宽搜"><a href="#二叉树上的宽搜" class="headerlink" title="二叉树上的宽搜"></a>二叉树上的宽搜</h3><h3 id="图上的宽搜"><a href="#图上的宽搜" class="headerlink" title="图上的宽搜"></a>图上的宽搜</h3><p>拓扑排序</p><h3 id="棋盘上的宽搜"><a href="#棋盘上的宽搜" class="headerlink" title="棋盘上的宽搜"></a>棋盘上的宽搜</h3><h2 id="什么时候应该使用BFS"><a href="#什么时候应该使用BFS" class="headerlink" title="什么时候应该使用BFS"></a>什么时候应该使用BFS</h2><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><ul><li>层级遍历</li><li>由点及面</li><li>拓扑排序</li></ul><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><ul><li>仅限简单图求最短路径</li><li>图中每条边长度是1，没有方向</li></ul><h3 id="题目是最短路径，除了BFS还有什么算法"><a href="#题目是最短路径，除了BFS还有什么算法" class="headerlink" title="题目是最短路径，除了BFS还有什么算法"></a>题目是最短路径，除了BFS还有什么算法</h3><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;大纲&quot;&gt;&lt;a href=&quot;#大纲&quot; class=&quot;headerlink&quot; title=&quot;大纲&quot;&gt;&lt;/a&gt;大纲&lt;/h2&gt;&lt;h3 id=&quot;
      
    
    </summary>
    
    
      <category term="JZCourse" scheme="https://octopuslian.github.io/categories/JZCourse/"/>
    
    
      <category term="宽度优先搜索" scheme="https://octopuslian.github.io/tags/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="九章" scheme="https://octopuslian.github.io/tags/%E4%B9%9D%E7%AB%A0/"/>
    
      <category term="算法基础" scheme="https://octopuslian.github.io/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>四川省都江堰市青城后山一日游</title>
    <link href="https://octopuslian.github.io/2021/04/21/qing-cheng-hou-shan-one-day-trip/"/>
    <id>https://octopuslian.github.io/2021/04/21/qing-cheng-hou-shan-one-day-trip/</id>
    <published>2021-04-21T14:24:02.000Z</published>
    <updated>2021-04-21T14:25:30.609Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --><p>上周五去跟一位朋友约去爬山，地点选在都江堰市的青城山，本文将详细分享旅游攻略，以及旅行完的顿悟。</p><h2 id="出发前"><a href="#出发前" class="headerlink" title="出发前"></a>出发前</h2><p>出发之前，我和袁准备了一个背包，想着先爬到山上再去补给。</p><p>我和袁住在成都市，早上7点半约好见面，吃过早餐坐地铁到犀浦，然后转城际列车(10元/人)到青城山下车即可。建议如果去青城山最好直接上车前买直达，不然到车上补票还需要另外收费。</p><p>到了青城山车站出来，由于我们是要去的后山，自然景观丰富，空气清新，因此我们两人打了个车，一个人15（景区要16，还有等一会，小车直接走）。在此需要提醒：由于是上山的路且弯道众多，因此可能会晕车。</p><p>到了泰安古镇，也就是景区的入口处，我们吃了顿午饭（还是有些小贵），买了20元/人的门票，就开始爬山了。</p><h2 id="上山过程"><a href="#上山过程" class="headerlink" title="上山过程"></a>上山过程</h2><p>我们白天爬，感觉都还好，不是很热，沿途有各种卖饮料的，不过价格稍贵，水5元、饮料10元，棒棒糖3元一根。</p><p>爬到半山腰大概3个小时，然后有缆车可以往返，不过我们年轻小伙子想着多运动，于是就没有坐缆车（这是我最后悔的决定）。接着就开始体力不支，因为大多是上坡，很累，爬一会就得休息一下，不过还好在5点的时候（用了两个小时）爬到了白云寺，拜了拜佛，然后准备下山，这时候从卖饮料的大妈口中得知，5点半缆车停运！！！</p><h2 id="下山过程"><a href="#下山过程" class="headerlink" title="下山过程"></a>下山过程</h2><p>下山稍微轻松，但腿开始软了，感到走不动路，看着手机上还有几百米的距离到达缆车地点，我真想飞过去。结果我们5点20到那里后，人家告诉我缆车工作人员早就下班了，我不甘心，下去看了一眼，果然都停了，于是在想怎么办。有个姐姐告诉我下山大概一个小时可以坐船，坐上船后再走一个小时就下山了，我们一看时间，嗯，争取赶晚上8点下山，然后坐列车回成都。</p><p>结果坐船说过了运营时间，要涨价，5元/人（正常是2元/人）。行吧，就这样，结果坐完船就开始晕，恶心，头晕，心跳的贼快，于是朋友叫我先休息，最后休息到7点往下走，还是感到不舒服，没办法，直接叫救援。</p><h2 id="救援过程"><a href="#救援过程" class="headerlink" title="救援过程"></a>救援过程</h2><p>首先打完救援电话后，被告知救援费要1000元，我在犹豫间朋友已经替我答应了，挂了电话对我说，钱花了可以挣，但一定要保证你的安全。于是，我们在夜幕降临的过程中，用手机闪光灯照着周围环境，防止有蛇、虫子之类的靠近，同时我们也看到草丛里有一双泛着黄光的动物眼睛盯着我们。</p><p>等了大概一个小时，救援队上来，把我抬了下去，最后由120救护车把我送到医院做检查。</p><p>身体没有大碍，就心跳的太快了，于是开了一些降心率的药，叮嘱我回成都市了要好好检查。</p><p>就这样，在一天中结束了自己跌宕起伏的青城的后山爬山之旅。</p><h2 id="此次旅行感悟"><a href="#此次旅行感悟" class="headerlink" title="此次旅行感悟"></a>此次旅行感悟</h2><ul><li>有时候不能硬撑，实在走不动了，就用钱代替交通；</li><li>钱没了可以再挣，身体是最重要的；</li><li>出发前做好旅行规划很重要；</li><li>体检有不舒服的就赶紧去查，防止小病拖成大病；</li><li>不要把问题想的太严重，总会有解决之道。</li></ul><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;上周五去跟一位朋友约去爬山，地点选在都江堰市的青城山，本文将详细分享旅游攻略，以及旅行完的顿悟。&lt;/p&gt;&lt;h2 id=&quot;出发前&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="Travel-notes" scheme="https://octopuslian.github.io/categories/Travel-notes/"/>
    
    
      <category term="旅行" scheme="https://octopuslian.github.io/tags/%E6%97%85%E8%A1%8C/"/>
    
      <category term="青城山" scheme="https://octopuslian.github.io/tags/%E9%9D%92%E5%9F%8E%E5%B1%B1/"/>
    
      <category term="都江堰" scheme="https://octopuslian.github.io/tags/%E9%83%BD%E6%B1%9F%E5%A0%B0/"/>
    
  </entry>
  
  <entry>
    <title>玩转docker-核心知识概述</title>
    <link href="https://octopuslian.github.io/2021/04/08/fun-with-docker-1-core-knowledge/"/>
    <id>https://octopuslian.github.io/2021/04/08/fun-with-docker-1-core-knowledge/</id>
    <published>2021-04-08T02:14:24.000Z</published>
    <updated>2021-04-26T07:00:34.645Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 04 2021 16:19:28 GMT+0800 (GMT+08:00) --><h2 id="What——什么是容器"><a href="#What——什么是容器" class="headerlink" title="What——什么是容器"></a>What——什么是容器</h2><p>容器由两部分组成：（1）应用程序本身；（2）依赖：比如应用程序需要的库或其他软件容器在Host操作系统的用户空间中运行，与操作系统的其他进程隔离。这一点显著区别于的虚拟机。</p><p>传统的虚拟化技术，比如VMWare、KVM、Xen，目标是创建完整的虚拟机。为了运行应用，除了部署应用本身及其依赖（通常几十MB），还得安装整个操作系统（几十GB）。</p><h2 id="Why——为什么需要容器"><a href="#Why——为什么需要容器" class="headerlink" title="Why——为什么需要容器"></a>Why——为什么需要容器</h2><p>容器使软件具备了超强的可移植能力。</p><p>Docker将集装箱思想运用到软件打包上，为代码提供了一个基于容器的标准化运输系统。Docker可以将任何应用及其依赖打包成一个轻量级、可移植、自包含的容器。容器可以运行在几乎所有的操作系统上</p><h3 id="容器的优势"><a href="#容器的优势" class="headerlink" title="容器的优势"></a>容器的优势</h3><p>对于开发人员：Build Once、Run Anywhere。</p><p>对于运维人员：Configure Once、Run Anything。</p><h2 id="How——容器是如何工作的"><a href="#How——容器是如何工作的" class="headerlink" title="How——容器是如何工作的"></a>How——容器是如何工作的</h2><h3 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h3><p>Docker的核心组件包括：<br>● Docker客户端：Client<br>● Docker服务器：Docker daemon<br>● Docker镜像：Image● Registry<br>● Docker容器：Container</p><h3 id="Docker客户端"><a href="#Docker客户端" class="headerlink" title="Docker客户端"></a>Docker客户端</h3><p>最常用的Docker客户端是docker命令。通过docker我们可以方便地在Host上构建和运行容器。</p><h3 id="Docker服务器"><a href="#Docker服务器" class="headerlink" title="Docker服务器"></a>Docker服务器</h3><p>Docker daemon是服务器组件，以Linux后台服务的方式运行</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 04 2021 16:19:28 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;What——什么是容器&quot;&gt;&lt;a href=&quot;#What——什么是容器&quot; class=&quot;headerlink&quot; title=&quot;What—
      
    
    </summary>
    
    
      <category term="Learn-Docker" scheme="https://octopuslian.github.io/categories/Learn-Docker/"/>
    
    
      <category term="docker" scheme="https://octopuslian.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>玩转Docker-鸟瞰容器生态系统</title>
    <link href="https://octopuslian.github.io/2021/04/08/fun-with-docker-0-container-ecosystem/"/>
    <id>https://octopuslian.github.io/2021/04/08/fun-with-docker-0-container-ecosystem/</id>
    <published>2021-04-08T02:13:26.000Z</published>
    <updated>2021-04-08T14:27:39.406Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 04 2021 16:19:28 GMT+0800 (GMT+08:00) --><p>这篇文章有一张思维导图足以</p><p><img src="/2021/04/08/fun-with-docker-0-container-ecosystem/container.jpg" alt></p><p>意外发现一本国人写的《玩转Docker容器技术》，好好学习一下Docker系列，就从开头为<code>fun with...</code>开始。</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 04 2021 16:19:28 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;这篇文章有一张思维导图足以&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/2021/04/08/fun-with-docker-0-container-ec
      
    
    </summary>
    
    
      <category term="Learn-Docker" scheme="https://octopuslian.github.io/categories/Learn-Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>今年终于要开始忙了</title>
    <link href="https://octopuslian.github.io/2021/04/07/first-entrepreneurship/"/>
    <id>https://octopuslian.github.io/2021/04/07/first-entrepreneurship/</id>
    <published>2021-04-07T02:08:18.000Z</published>
    <updated>2021-04-10T02:04:01.601Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 04 2021 16:19:28 GMT+0800 (GMT+08:00) --><p>昨天收到两条消息，我的副业&amp;创业终于要开始了。</p><p>聊天1：</p><p><img src="/2021/04/07/first-entrepreneurship/weixin1.png" alt></p><p>和川大计算机硕士毕业的学长一起做一款程序，预计9月初上线。</p><p>这位学长我是意外在工作中认识的，后来他毕业后，我俩有次在望江楼公园闲聊，他说他第一眼看到我就觉得我是个非常<code>nice</code>的人。我笑了笑说，一般对我没有攻击的我我都会真诚以待，不造谣，隐私除外。</p><p>技术和市场都做完调研，但对我来说是一块全新的领域。</p><p>聊天2：</p><p><img src="/2021/04/07/first-entrepreneurship/weixin2.png" alt></p><p>和清华在读博士的创业。</p><p>2月底他找到我时，问我有没有兴趣做这个，他目前拿到第一笔融资，想等9月中旬项目第一版上线后再去谈下一笔融资。我不懂融资，但我信过他这个人，从本科时接触他写的<a href="http://www.demongan.com/" target="_blank" rel="noopener">恶魔的世界</a>，到硕士出了一本黑客书籍，并创办了<a href="https://www.write-bug.com/" target="_blank" rel="noopener">WRITR-BUG技术共享平台</a>，在他身上我看到了许多将不可能转换为可能的事情。</p><p>2017年夏天我和他在北邮相遇，非常帅气的小伙子，带我逛了北邮，同时在他面前班门弄斧了一下汇编，哈哈</p><p>2月底他打电话说如果我要做的话，就会给我发工资，我说你即使不给我发工资我也愿意做。我嘛，总觉得按部就班的会缺少一些什么，你给我的这次机会，我要好好把握，我觉得我的一生，总要去尝试一些没有做过的事情。</p><p>半年时间，半年后，我会来这里还愿。</p><p>GOOD LUCK~</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 04 2021 16:19:28 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;昨天收到两条消息，我的副业&amp;amp;创业终于要开始了。&lt;/p&gt;&lt;p&gt;聊天1：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/2021/04/07/first
      
    
    </summary>
    
    
      <category term="Try-to-Challenges" scheme="https://octopuslian.github.io/categories/Try-to-Challenges/"/>
    
    
      <category term="项目" scheme="https://octopuslian.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="创业" scheme="https://octopuslian.github.io/tags/%E5%88%9B%E4%B8%9A/"/>
    
      <category term="融资" scheme="https://octopuslian.github.io/tags/%E8%9E%8D%E8%B5%84/"/>
    
      <category term="技术" scheme="https://octopuslian.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>十年之约</title>
    <link href="https://octopuslian.github.io/2021/03/31/happy-25-birthday-ten-years-promise/"/>
    <id>https://octopuslian.github.io/2021/03/31/happy-25-birthday-ten-years-promise/</id>
    <published>2021-03-31T12:33:56.000Z</published>
    <updated>2021-03-31T14:21:24.249Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --><p>种一棵树最好的时间是十年前，其次是现在。</p><h2 id="过去十年"><a href="#过去十年" class="headerlink" title="过去十年"></a>过去十年</h2><h3 id="心中的童话镇"><a href="#心中的童话镇" class="headerlink" title="心中的童话镇"></a>心中的童话镇</h3><p>心中至今还记得， 大三暑假那会，每天早晨去公园散步，然后吃一碗粥，再加几个馒头，过几天换成可口的豆腐脑，上午看会《新概念英语》，睡个午觉，下午在卧室看一会小说，打一小会游戏，然后抱着冰镇的西瓜边啃边看剧的欢乐时光，偶尔想起几个好友，约着去体育公园打球，亦或是去是自助餐和看电影。</p><p>也许这就是我心中理想的幸福生活。</p><p>只是，我知道，我终将是要离开父母，独自去生活。</p><h3 id="高中三年"><a href="#高中三年" class="headerlink" title="高中三年"></a>高中三年</h3><p>收获最多的就是结识了几位良师益友，他们给予过我鼓励，安慰和期望，让我坚定自己的目标，不断向前。</p><h3 id="大学四年"><a href="#大学四年" class="headerlink" title="大学四年"></a>大学四年</h3><p>感触最多的是从大学同班同学何和唐身上学到的，也是我毕业后一直保持联系的人。</p><p>大一时我曾对何不以为然，觉得他只是个会考试会背题的机器罢了。直到大四机缘巧合搬进了何的宿舍，跟他做了一学期舍友，才发现我错了。</p><p>曾经我通过打算法竞赛和写博客结识了很多北京上海的竞赛大佬，直到我将他们和何对比了一下，才发现都有共通点，这一点我在唐的身上也看到了。</p><p>所以，我在大三的时候，抛弃了所有所谓的荣誉、职务，专心做自己觉得有价值的事情，因为那样我觉得才是踏实的。</p><h3 id="工作接近三年"><a href="#工作接近三年" class="headerlink" title="工作接近三年"></a>工作接近三年</h3><p>上班三年，实现了自己小时候想当工程师的梦想，从游戏服务端开发工程师到图形图像算法工程师，再到<code>Golang</code>后端研发工程师以及兼职的音视频工程师，虽然<code>title</code>在变，但一直不变的就是加班以及研发在国内卑微的地位。嗯，这和我小时候的设想的貌似不太一样呢。</p><h2 id="一些顿悟"><a href="#一些顿悟" class="headerlink" title="一些顿悟"></a>一些顿悟</h2><h3 id="对996以及加班的感悟"><a href="#对996以及加班的感悟" class="headerlink" title="对996以及加班的感悟"></a>对996以及加班的感悟</h3><ul><li>命是自己的，即使加班出事故了，企业也买了保险，大不了用废了再换一个，但自己的生命只有一次，这是大前提；</li><li>结合三年加班的经验，以及吸收消化那些加班场景，无非就是项目上线出事故或者是老板想看你好不好使唤（阶级思想），这是国内私企大部分加班的根本原因；</li><li>活是做不完的，即使做完了，老板也不会感慨你效率多高，而会开心的说自己花一个人的价钱省了三个人的成本。</li></ul><p>因此，结合以上三点，在保持不会没有存款的大前提之下，我会尽量边提升自己的技术，边找一些管理规范且<code>nice</code>的企业，小企业就不去浪费时间和精力了。</p><h3 id="关于离职"><a href="#关于离职" class="headerlink" title="关于离职"></a>关于离职</h3><p>感到是一种解脱，是从封闭的办公室，嘈杂的喧闹声和咳嗽声后带来的一份宁静。</p><h3 id="关于本科学历"><a href="#关于本科学历" class="headerlink" title="关于本科学历"></a>关于本科学历</h3><p>这是个沉重的话题，因为它会跟到你老。面试的时候会决定你和名校毕业生的起点，关系到升职加薪等等等。可能我刚毕业会担心，但经过这三年的洗礼，以及和一位南天信息的技术专家的沟通，我验证并得出了结论：<strong>只要你一直更新自己的知识储备，就永远不会被这个社会淘汰。</strong></p><h3 id="关于离别"><a href="#关于离别" class="headerlink" title="关于离别"></a>关于离别</h3><p>小学毕业时，我哭了，想着毕业后大家一定要常聚；初中毕业时，我悄悄地哭，想着以后还在一座城市，可以常聚；高中毕业时，我忍住没哭，即使高考结束后我依旧会突然从8点多惊醒，想着快迟到了；大学毕业时，我没有哭，平静的收拾好自己的行李，拿好毕业证学位证，定好火车票，就此离去；工作了，偶尔在机场碰到我的高中同班同学，惊喜、意外接踵而至，但这些过后呢，依旧平静，然后错过。</p><p>曾经我比喻两个人的关系就像平行线，如果相交后，错过可能就再也见不到了，是这样的。</p><p>在乌鲁木齐时失去了一个从幼儿园玩到大学的好朋友，那时我会失眠，会迷茫，像是生命中突然缺少了什么东西似的。直到大学毕业前，父母问起我和他还有联系没，我心中都会隐隐作痛后摇摇头，但我又无能为力。直到毕业后，我突然顿悟，有时候也许就是两个人缘分尽了就平静的看待吧，想想快乐的事情——两个人从小学相互打闹；初中因为没有手机就互传书信，就差买只鸽子做飞鸽传书了；相互请教理综和数学题；周末约着一起去打球或者看电影；老师看到我俩还以为是亲兄弟…哈哈。</p><p>如果要离别，我会微笑，会真诚的对你说一声：<strong>谢谢你，曾出现在我的回忆里，感谢相遇，离别保重。</strong>。然后继续走好我自己的路。</p><h2 id="未来十年"><a href="#未来十年" class="headerlink" title="未来十年"></a>未来十年</h2><ul><li>用一年时间沉淀自己的基础，深入后端开发；</li><li>用两年时间搭建自己的副业体系的雏形并开始运作；</li><li>用三年时间提升一下自己的核心竞争力，并尝试横向拓宽自己的技术面；</li><li>用四年时间丰富自己工作履历和项目经验，争取达到专家级别；</li><li>拥有自己的一套房；</li><li>注：以上流程可以交替并发运作。</li></ul><h2 id="十年的约定"><a href="#十年的约定" class="headerlink" title="十年的约定"></a>十年的约定</h2><p>回想起，我在大三时在北邮遇见了<code>DemonGan</code>，他给自己在一定时间内定了个目标，然后好长时间没发朋友圈，突然在研三之际发布保博清华；我也在大二时受到一位北大毕业的天使投资人的影响，他说<strong>优秀的人相互都是吸引的</strong>，于是我明白了——需要先让自己变强，才有和大佬共同合作的资本，所以，做一个可以创造价值的人，是我未来十年的要实现的理想。</p><p>因此，我也在25岁生日来临之际，给自己定个目标————十年之约。十年后，我35岁，即使不做技术，我也希望我的副业可以支撑着我的日常开销，我想到那时，我才是真正实现了财务自由以及真正在做着有意义的事情。</p><p>GOOD LUCK:)</p><p><img src="/2021/03/31/happy-25-birthday-ten-years-promise/dream.jpg" alt></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;种一棵树最好的时间是十年前，其次是现在。&lt;/p&gt;&lt;h2 id=&quot;过去十年&quot;&gt;&lt;a href=&quot;#过去十年&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="Happy-Birthday" scheme="https://octopuslian.github.io/categories/Happy-Birthday/"/>
    
    
      <category term="成长" scheme="https://octopuslian.github.io/tags/%E6%88%90%E9%95%BF/"/>
    
      <category term="生日祝福" scheme="https://octopuslian.github.io/tags/%E7%94%9F%E6%97%A5%E7%A5%9D%E7%A6%8F/"/>
    
      <category term="随笔" scheme="https://octopuslian.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="顿悟" scheme="https://octopuslian.github.io/tags/%E9%A1%BF%E6%82%9F/"/>
    
      <category term="约定" scheme="https://octopuslian.github.io/tags/%E7%BA%A6%E5%AE%9A/"/>
    
      <category term="承诺" scheme="https://octopuslian.github.io/tags/%E6%89%BF%E8%AF%BA/"/>
    
  </entry>
  
  <entry>
    <title>汇总LeetCode实现数据结构和算法的题目</title>
    <link href="https://octopuslian.github.io/2021/03/05/leetcode-all-achieve-data-structure-and-algo-problems/"/>
    <id>https://octopuslian.github.io/2021/03/05/leetcode-all-achieve-data-structure-and-algo-problems/</id>
    <published>2021-03-05T15:23:24.000Z</published>
    <updated>2021-03-13T14:09:03.379Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --><p>汇总各种实现数据结构和算法的<code>LeetCode</code>题目，等刷完《剑指offer》后将重点关注的题目，通过边刷题边梳理数据结构算法的知识。</p><h2 id="链表-跳表"><a href="#链表-跳表" class="headerlink" title="链表-跳表"></a>链表-跳表</h2><p><a href="https://leetcode-cn.com/problems/design-linked-list/" target="_blank" rel="noopener">707. 设计链表</a></p><p><a href="https://leetcode-cn.com/problems/design-skiplist/" target="_blank" rel="noopener">1206. 设计跳表</a></p><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 09. 用两个栈实现队列</a></p><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232. 用栈实现队列</a></p><p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">225. 用队列实现栈</a></p><p><a href="https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/" target="_blank" rel="noopener">1381. 设计一个支持增量操作的栈</a></p><p><a href="https://leetcode-cn.com/problems/design-circular-queue/" target="_blank" rel="noopener">622. 设计循环队列</a></p><p><a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">641. 设计循环双端队列</a></p><p><a href="https://leetcode-cn.com/problems/design-front-middle-back-queue/" target="_blank" rel="noopener">1670. 设计前中后队列</a></p><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p><a href="https://leetcode-cn.com/problems/design-hashset/" target="_blank" rel="noopener">705. 设计哈希集合</a></p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 07. 重建二叉树</a></p><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">剑指 Offer 27. 二叉树的镜像</a></p><p><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 28. 对称的二叉树</a></p><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></p><p><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 37. 序列化二叉树</a></p><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. 平衡二叉树</a></p><p><a href="https://leetcode-cn.com/problems/minimum-height-trees/" target="_blank" rel="noopener">310. 最小高度树</a></p><p><a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">641. 设计循环双端队列</a></p><p><a href="https://leetcode-cn.com/problems/design-front-middle-back-queue/" target="_blank" rel="noopener">1670. 设计前中后队列</a></p><p><a href="https://leetcode-cn.com/problems/er-cha-shu-ren-wu-diao-du/" target="_blank" rel="noopener">LCP 10. 二叉树任务调度</a></p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU 缓存机制</a></p><h2 id="场景设计"><a href="#场景设计" class="headerlink" title="场景设计"></a>场景设计</h2><p><a href="https://leetcode-cn.com/problems/design-twitter/" target="_blank" rel="noopener">355. 设计推特</a></p><p><a href="https://leetcode-cn.com/problems/design-hashset/" target="_blank" rel="noopener">705. 设计哈希集合</a></p><p><a href="https://leetcode-cn.com/problems/design-hashmap/" target="_blank" rel="noopener">706. 设计哈希映射</a></p><p><a href="https://leetcode-cn.com/problems/design-underground-system/" target="_blank" rel="noopener">1396. 设计地铁系统</a></p><p><a href="https://leetcode-cn.com/problems/design-browser-history/" target="_blank" rel="noopener">1472. 设计浏览器历史记录</a></p><p><a href="https://leetcode-cn.com/problems/design-parking-system/" target="_blank" rel="noopener">1603. 设计停车系统</a></p><p><a href="https://leetcode-cn.com/problems/design-an-ordered-stream/" target="_blank" rel="noopener">1656. 设计有序流</a></p><p><a href="https://leetcode-cn.com/problems/goal-parser-interpretation/" target="_blank" rel="noopener">1678. 设计 Goal 解析器</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;汇总各种实现数据结构和算法的&lt;code&gt;LeetCode&lt;/code&gt;题目，等刷完《剑指offer》后将重点关注的题目，通过边刷题边梳理数据结构
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="算法" scheme="https://octopuslian.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://octopuslian.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 07. 重建二叉树</title>
    <link href="https://octopuslian.github.io/2021/03/05/leetcode-lcof-07-zhong-jian-er-cha-shu/"/>
    <id>https://octopuslian.github.io/2021/03/05/leetcode-lcof-07-zhong-jian-er-cha-shu/</id>
    <published>2021-03-05T10:42:24.000Z</published>
    <updated>2021-03-05T10:57:22.032Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">力扣-剑指 Offer 07. 重建二叉树</a></p><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">例如，给出</span><br><span class="line"></span><br><span class="line">前序遍历 preorder = [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"></span><br><span class="line">0 &lt;= 节点个数 &lt;= 5000</span><br></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>二叉树的遍历顺序</li></ul><p>1，前序（Pre-order）：根-左-右<br>2，中序（In-order）：左-根-右<br>3，后序（Post-order）：左-右-根</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>难度为中等。</p><h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>按题目给的示例来划分：<br>前序遍历划分 [ 3 | 9 | 20 15 7 ]<br>中序遍历划分 [ 9 | 3 | 15 20 7 ]</p><p>根据以上性质，可得出以下推论：</p><ul><li>前序遍历的首元素 为 树的根节点 <code>node</code> 的值。</li><li>在中序遍历中搜索根节点 <code>node</code> 的索引 ，可将 中序遍历 划分为 [ 左子树 | 根节点 | 右子树 ] 。</li><li>根据中序遍历中的左 / 右子树的节点数量，可将 前序遍历 划分为 [ 根节点 | 左子树 | 右子树 ] 。</li></ul><p>考虑通过递归对所有子树进行划分：</p><ul><li><p>递推参数： 根节点在前序遍历的索引 root 、子树在中序遍历的左边界 left 、子树在中序遍历的右边界 right ；</p></li><li><p>终止条件： 当 left &gt; right ，代表已经越过叶节点，此时返回 null ；</p></li><li><p>递推工作：<br>建立根节点 node ： 节点值为 preorder[root] ；<br>划分左右子树： 查找根节点在中序遍历 inorder 中的索引 i ；</p></li></ul><p><img src="/2021/03/05/leetcode-lcof-07-zhong-jian-er-cha-shu/7-tijie.png" alt></p><p>网上摘的保姆式的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java借助Map版本 (Go的没写出来，等后面写出来了再更新)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//标记中序遍历</span></span><br><span class="line">    <span class="keyword">int</span>[] preorder;<span class="comment">//保留的先序遍历，方便递归时依据索引查看先序遍历的值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preorder = preorder;</span><br><span class="line">        <span class="comment">//将中序遍历的值及索引放在map中，方便递归时获取左子树与右子树的数量及其根的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//三个索引分别为</span></span><br><span class="line">        <span class="comment">//当前根的的索引</span></span><br><span class="line">        <span class="comment">//递归树的左边界，即数组左边界</span></span><br><span class="line">        <span class="comment">//递归树的右边界，即数组右边界</span></span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">recur</span><span class="params">(<span class="keyword">int</span> pre_root, <span class="keyword">int</span> in_left, <span class="keyword">int</span> in_right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(in_left &gt; in_right) <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">// 相等的话就是自己</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[pre_root]);<span class="comment">//获取root节点</span></span><br><span class="line">        <span class="keyword">int</span> idx = map.get(preorder[pre_root]);<span class="comment">//获取在中序遍历中根节点所在索引，以方便获取左子树的数量</span></span><br><span class="line">        <span class="comment">//左子树的根的索引为先序中的根节点+1 </span></span><br><span class="line">        <span class="comment">//递归左子树的左边界为原来的中序in_left</span></span><br><span class="line">        <span class="comment">//递归右子树的右边界为中序中的根节点索引-1</span></span><br><span class="line">        root.left = recur(pre_root+<span class="number">1</span>, in_left, idx-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//右子树的根的索引为先序中的 当前根位置 + 左子树的数量 + 1</span></span><br><span class="line">        <span class="comment">//递归右子树的左边界为中序中当前根节点+1</span></span><br><span class="line">        <span class="comment">//递归右子树的有边界为中序中原来右子树的边界</span></span><br><span class="line">        root.right = recur(pre_root + (idx - in_left) + <span class="number">1</span>, idx+<span class="number">1</span>, in_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode-cn执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">3 ms, 在所有 Java 提交中击败了55.11%的用户</span><br><span class="line">内存消耗：</span><br><span class="line">38.4 MB, 在所有 Java 提交中击败了80.00%的用户</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go，不借助Map版本</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="keyword">int</span>, inorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    root := <span class="built_in">new</span>(TreeNode)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    root_val := preorder[<span class="number">0</span>]</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> inorder[i] != root_val &#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    left_tree := buildTree(preorder[<span class="number">1</span>:i+<span class="number">1</span>],inorder[:i])</span><br><span class="line">    right_tree := buildTree(preorder[i+<span class="number">1</span>:],inorder[i+<span class="number">1</span>:])</span><br><span class="line">    root.Val = root_val</span><br><span class="line">    root.Left = left_tree</span><br><span class="line">    root.Right = right_tree</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode-cn执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">4 ms, 在所有 Go 提交中击败了95.75%的用户</span><br><span class="line">内存消耗：</span><br><span class="line">4.2 MB, 在所有 Go 提交中击败了25.36%的用户</span><br></pre></td></tr></table></figure><p>牛客网运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行时间：5ms</span><br><span class="line">超过39.31%用Go提交的代码</span><br><span class="line">占用内存：2344KB</span><br><span class="line">超过9.75%用Go提交的代码</span><br></pre></td></tr></table></figure><h2 id="思考：为什么二叉树的题目一般用递归来解？"><a href="#思考：为什么二叉树的题目一般用递归来解？" class="headerlink" title="思考：为什么二叉树的题目一般用递归来解？"></a>思考：为什么二叉树的题目一般用递归来解？</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/4chong-jie-fa-di-gui-zhan-dui-lie-by-sdwwld/" target="_blank" rel="noopener">4种解法（递归，栈，队列），最后一种击败了100%的用户</a><br><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/" target="_blank" rel="noopener">力扣官方题解</a><br><a href="https://blog.csdn.net/Mr_SCX/article/details/106690412" target="_blank" rel="noopener">【面试题】重建二叉树（解题思路分析+Java、Python实现+代码详细注释）</a><br><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-di-gui-fa-qin/" target="_blank" rel="noopener">面试题07. 重建二叉树（递归法，清晰图解）</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="LeetCode-lcof-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-lcof-Solutions/"/>
    
    
      <category term="二叉树" scheme="https://octopuslian.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://octopuslian.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>2021春招找工作计划</title>
    <link href="https://octopuslian.github.io/2021/03/04/2021-spring-find-job/"/>
    <id>https://octopuslian.github.io/2021/03/04/2021-spring-find-job/</id>
    <published>2021-03-04T13:53:47.000Z</published>
    <updated>2021-03-04T14:10:26.247Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 04 2021 16:19:28 GMT+0800 (GMT+08:00) --><p>三月到来，各个企业又开始招人了，我也收到了几家企业的面试邀请。</p><p>找工作避免不了被问到“是否接受加班？”————当然是看情况了，我有事就拒绝加班，没事但是一天的工作没做完肯定是会自觉加班的，但我最讨厌最讨厌最讨厌那种磨洋工式的加班。</p><p>今天就收到了一位很有礼貌的猎头小哥问我“有家游戏公司995可以接受吗？” 我果断拒绝，因为说是995，有可能就临上线就变成996甚至997，人的欲望是无穷无尽的，所以如何摆脱困境，就是要找到从根源上就拒绝加班的企业。</p><p>犹记得我在第一家游戏公司的时候，美其名曰加班，实际上是因为一个人回去也没啥意思，就跟着同事一块在公司看书学习敲代码，顺便拿加班补贴和打车补助；第二家公司，刚开始基本7点就准时下班了，但后面逐渐开始那种毫无意义的加班，甚至根据加班来看工作态度、年终考核的时候，我放弃了，放弃了那可有可无的年终奖。</p><p>因此，我看透了国内这种加班的本质，要么高效完成工作，要么加班按照劳动法给加班费，否则一切强制无意义的加班就是压榨。</p><p>今天写下这篇文章，拒绝无意义的加班，不知道以后正在屠龙的少年是否会变成恶龙，以此当做一个记录吧。</p><p>新的一年，祝自己能顺利拿到满意的<code>offer</code>！</p><p><img src="/2021/03/04/2021-spring-find-job/reject-996.jpg" alt></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 04 2021 16:19:28 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;三月到来，各个企业又开始招人了，我也收到了几家企业的面试邀请。&lt;/p&gt;&lt;p&gt;找工作避免不了被问到“是否接受加班？”————当然是看情况了，我有事
      
    
    </summary>
    
    
      <category term="Work-Career" scheme="https://octopuslian.github.io/categories/Work-Career/"/>
    
    
      <category term="找工作" scheme="https://octopuslian.github.io/tags/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="春招" scheme="https://octopuslian.github.io/tags/%E6%98%A5%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 06. 从尾到头打印链表</title>
    <link href="https://octopuslian.github.io/2021/03/04/leetcode-lcof-06-cong-wei-dao-tou-da-yin-lian-biao/"/>
    <id>https://octopuslian.github.io/2021/03/04/leetcode-lcof-06-cong-wei-dao-tou-da-yin-lian-biao/</id>
    <published>2021-03-04T05:44:25.000Z</published>
    <updated>2021-03-04T05:51:17.010Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/" target="_blank" rel="noopener">力扣-剑指 Offer 06. 从尾到头打印链表</a></p><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">0 &lt;= s 的长度 &lt;= 10000</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>该题难度为简单。</p><h3 id="解法一：两个for循环"><a href="#解法一：两个for循环" class="headerlink" title="解法一：两个for循环"></a>解法一：两个for循环</h3><ul><li>1，先声明两个整型数组；</li><li>2，第一个<code>for</code>循环从头到尾记录链表的每个节点的值；</li><li>3，第二个<code>for</code>循环逆序记录链表的每个节点的值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reversePrint</span><span class="params">(head *ListNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> re []<span class="keyword">int</span>  <span class="comment">//正序</span></span><br><span class="line">    <span class="keyword">var</span> er []<span class="keyword">int</span>  <span class="comment">//逆序</span></span><br><span class="line">    <span class="keyword">for</span> ;head != <span class="literal">nil</span>; &#123;</span><br><span class="line">        re = <span class="built_in">append</span>(re,head.Val)  <span class="comment">//从头到尾记录链表的每个节点的值</span></span><br><span class="line">        head = head.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="built_in">len</span>(re)<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-- &#123;</span><br><span class="line">        er = <span class="built_in">append</span>(er,re[i])  <span class="comment">//逆序记录链表的每个节点的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> er  <span class="comment">//返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode-cn执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">0 ms, 在所有 Go 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：</span><br><span class="line">3.5 MB, 在所有 Go 提交中击败了46.84%的用户</span><br></pre></td></tr></table></figure><p>牛客网执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行时间：3ms</span><br><span class="line">超过2.29%用Go提交的代码</span><br><span class="line">占用内存：868KB</span><br><span class="line">超过39.69%用Go提交的代码</span><br></pre></td></tr></table></figure><h3 id="解法二：递归"><a href="#解法二：递归" class="headerlink" title="解法二：递归"></a>解法二：递归</h3><p><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/solution/liang-chong-jie-fa-zhan-yu-di-gui-by-jalan/" target="_blank" rel="noopener">两种解法：栈与递归</a></p><ul><li>递归函数作用：将链表节点值逆序存入结果集</li><li>结束条件：当节点为空时</li><li>递归调用条件：当下一个节点不为空时</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//Go</span><br><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * type ListNode struct &#123;</span><br><span class="line"> *     Val int</span><br><span class="line"> *     Next *ListNode</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">func reversePrint(head *ListNode) []int &#123;</span><br><span class="line">    if head == nil &#123;</span><br><span class="line">        return []int&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res := reversePrint(head.Next)</span><br><span class="line">    return append(res, head.Val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode-cn执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">4 ms, 在所有 Go 提交中击败了63.34%的用户</span><br><span class="line">内存消耗：</span><br><span class="line">4.7 MB, 在所有 Go 提交中击败了28.61%的用户</span><br></pre></td></tr></table></figure><p>牛客网执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行时间：3ms</span><br><span class="line">超过2.29%用Go提交的代码</span><br><span class="line">占用内存：868KB</span><br><span class="line">超过39.69%用Go提交的代码</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="LeetCode-lcof-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-lcof-Solutions/"/>
    
    
      <category term="链表" scheme="https://octopuslian.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="栈" scheme="https://octopuslian.github.io/tags/%E6%A0%88/"/>
    
      <category term="遍历" scheme="https://octopuslian.github.io/tags/%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 05. 替换空格</title>
    <link href="https://octopuslian.github.io/2021/03/03/leetcode-lcof-05-ti-huan-kong-ge/"/>
    <id>https://octopuslian.github.io/2021/03/03/leetcode-lcof-05-ti-huan-kong-ge/</id>
    <published>2021-03-03T15:20:54.000Z</published>
    <updated>2021-03-04T04:32:19.567Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">力扣-剑指 Offer 05. 替换空格</a></p><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br><span class="line"> </span><br><span class="line">限制：</span><br><span class="line">0 &lt;= s 的长度 &lt;= 10000</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>该题难度为简单。</p><h3 id="解法一：使用strings-Replace"><a href="#解法一：使用strings-Replace" class="headerlink" title="解法一：使用strings.Replace"></a>解法一：使用strings.Replace</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">replaceSpace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> strings.Replace(s, <span class="string">" "</span>, <span class="string">"%20"</span>, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法二：遍历添加"><a href="#解法二：遍历添加" class="headerlink" title="解法二：遍历添加"></a>解法二：遍历添加</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">replaceSpace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    ans := <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> s&#123;</span><br><span class="line">        <span class="keyword">if</span> v == <span class="string">' '</span>&#123;</span><br><span class="line">            ans = ans + <span class="string">"%20"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = ans + <span class="keyword">string</span>(v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode-执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">0 ms, 在所有 Go 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：</span><br><span class="line">3.4 MB, 在所有 Go 提交中击败了16.95%的用户</span><br></pre></td></tr></table></figure><p>牛客网执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行时间：2ms</span><br><span class="line">超过100.00%用Go提交的代码</span><br><span class="line">占用内存：956KB</span><br><span class="line">超过23.81%用Go提交的代码</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="LeetCode-lcof-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-lcof-Solutions/"/>
    
    
      <category term="字符串" scheme="https://octopuslian.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="lcof" scheme="https://octopuslian.github.io/tags/lcof/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-微服务概览与治理</title>
    <link href="https://octopuslian.github.io/2021/03/03/goatc-1-microservice-overview-and-governance/"/>
    <id>https://octopuslian.github.io/2021/03/03/goatc-1-microservice-overview-and-governance/</id>
    <published>2021-03-03T07:21:10.000Z</published>
    <updated>2021-03-04T12:32:59.076Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --><h2 id="微服务概览"><a href="#微服务概览" class="headerlink" title="微服务概览"></a>微服务概览</h2><h3 id="单体设计"><a href="#单体设计" class="headerlink" title="单体设计"></a>单体设计</h3><p>尽管也是模块化逻辑，但是最终它还是会打包并部署为单体式应用。其中最主要问题就是这个应用太复杂，以至于任何单个开发者都不可能搞懂它。应用无法扩展，可靠性很低，最终敏捷性和部署变的无法完成。</p><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/simple.png" alt></p><p>因此，我们应对的思路：<strong>化繁为简，分而治之</strong></p><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/web-inter.png" alt></p><h3 id="微服务起源"><a href="#微服务起源" class="headerlink" title="微服务起源"></a>微服务起源</h3><h4 id="Q：SOA-面向服务的架构模式-和微服务是什么关系？"><a href="#Q：SOA-面向服务的架构模式-和微服务是什么关系？" class="headerlink" title="Q：SOA(面向服务的架构模式)和微服务是什么关系？"></a>Q：SOA(面向服务的架构模式)和微服务是什么关系？</h4><p>A:可以把微服务想成是SOA的一种实践。</p><ul><li>小即是美：</li><li>单一职责：</li><li>尽可能早地创造原型：</li><li>可移植性比效率更重要：</li></ul><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/ms-ma-database.png" alt></p><h3 id="微服务定义"><a href="#微服务定义" class="headerlink" title="微服务定义"></a>微服务定义</h3><p>定义：围绕业务功能构建的，服务关注单一业务，服务间采用轻量级的通信机制，可以全自动独立部署，可以使用不同的编程语言和数据存储技术。微服务架构通过业务拆分实现服务组件化，通过组件组合快速开发系统，业务单一的服务组件又可以独立部署，使得整个系统变得清晰灵活。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>原子服务</li><li>独立进程</li><li>隔离部署</li><li>去中心化服务治理</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>基础设施的建设、复杂度高</li></ul><h3 id="微服务不足"><a href="#微服务不足" class="headerlink" title="微服务不足"></a>微服务不足</h3><ul><li>微服务应用是分布式系统，由此会带来固有的复杂性。开发者不得不使用<code>RPC</code>或者消息传递，来实现进程间通信；此外，必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题。</li><li>分区的数据库架构，同时更新多个业务主体的事务很普遍。这种事务对于单体式应用来说很容易，因为只有一个数据库。在微服务架构应用中，需要更新不同服务所使用的不同的数据库，从而对开发者提出了更高的要求和挑战。</li><li>测试一个基于微服务的应用也是很复杂的任务。</li><li>服务模块间的依赖，应用的升级有可能波及多个服务模块的修改。</li><li>对运维基础设施的挑战比较大。</li></ul><h3 id="组件服务化"><a href="#组件服务化" class="headerlink" title="组件服务化"></a>组件服务化</h3><p>传统实现组件的方式是通过库(library)，库是和应用一起运行在进程中，库的局部变化意味着整个应用的重新部署。通过微服务来实现组件，意味着将应用拆散为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需要新部署对应的服务进程。我们用<code>Go</code>实施一个微服务：</p><ul><li>kit：一个微服务的基础库(框架)。</li><li>service：业务代码 + kit依赖 + 第三方依赖组成的业务微服务</li><li>rpc + message queue：轻量级通讯</li></ul><p><strong>本质上等同于多个服务组合(compose)完成了一个完整的用户场景(usecase)。</strong></p><h3 id="重要-按业务组织服务"><a href="#重要-按业务组织服务" class="headerlink" title="(重要)按业务组织服务"></a>(重要)按业务组织服务</h3><p>按业务能力组织服务的意思是服务提供的能力和业务功能对应，比如：订单服务和数据访问服务，前者反应了真实的订单相关服务，后者是一种技术抽象服务不反应真实的业务。所以按照微服务架构理念来划分服务时，是不应该存在数据访问服务这样一个服务的。</p><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/law.png" alt></p><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/law2.png" alt></p><p>我们的模式：大前端(移动/Web) &gt; 网关接入 &gt; 业务服务 &gt; 平台服务 &gt; 基础设施(PaaS/Saas)<br><strong>开发团队对软件在生产环境的运行负全部责任。</strong></p><h3 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h3><ul><li>数据去中心化</li><li>治理去中心化</li><li>技术去中心化</li></ul><p><strong>每个服务独享自身的数据存储设施(缓存、数据库等)，不像传统应用共享一个缓存和数据库，这样有利于服务的独立性，这样有利于服务的独立性，隔离相关干扰。</strong></p><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/qu-zhong-xin.png" alt></p><h2 id="基础设施自动化"><a href="#基础设施自动化" class="headerlink" title="基础设施自动化"></a>基础设施自动化</h2><ul><li>CICD：Gitlab + Gitlab Hooks + k8s</li><li>Testing：测试环境、单元测试、API自动化测试</li><li>在线运行时：k8s，以及一系列Prometheus、ELK、Conrtol Panle</li></ul><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/ji-chu-she-shi-zi-dong-hua.png" alt></p><h3 id="可用性-amp-兼容性设计"><a href="#可用性-amp-兼容性设计" class="headerlink" title="可用性 &amp; 兼容性设计"></a>可用性 &amp; 兼容性设计</h3><p>著名的<code>Design For Failure</code>思想，微服务架构采用粗粒度的进程间通信，引入了额外的复杂性和需要处理的新问题，如网络延迟、消息格式、负载均衡和容错，忽略了其中任何一点都属于对“分布式计算的误解”。</p><ul><li>隔离</li><li>超时控制</li><li>负载保护</li><li>限流</li><li>降级</li><li>重试</li><li>负载均衡</li></ul><p>特别注意：<strong>服务提供者的变更可能引发服务消费者的兼容性破坏，时刻谨记保持服务契约(接口)的兼容性。</strong></p><p>Be conserative in what you send, be liberal in what you accept.</p><p>发送时要保守，接收时要开放。按照伯斯塔尔法则的思想来设计和实现服务时，发送的数据要更保守，意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。</p><h2 id="微服务设计"><a href="#微服务设计" class="headerlink" title="微服务设计"></a>微服务设计</h2><h3 id="API-Gateway"><a href="#API-Gateway" class="headerlink" title="API Gateway"></a>API Gateway</h3><p>按照垂直功能进行拆分，对外暴露了一批微服务，但是缺乏统一的出口面临了不少困难：</p><ul><li>客户端到微服务直接通信，强耦合；</li><li>需要多次请求，客户端聚合数据，工作量巨大，延迟高；</li><li>协议不利于统一，各个部门有差异，需要端来兼容；</li><li>面向“端”的<code>API</code>适配，耦合到了内部服务；</li><li>多终端兼容逻辑复杂，每个服务都需要处理；</li><li>统一逻辑无法收敛，比如安全认证、限流。</li></ul><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/web-server.png" alt></p><p><strong>要内聚模式配合。</strong></p><p>新增了一个<code>app-interface</code>用于统一的协议出口，在服务进行大量的<code>dataset join</code>，按照业务场景设计粗粒度的<code>API</code>，给后续服务的演进带来很多优势：</p><ul><li>轻量交互：协议精简、聚合。</li><li>差异服务：数据裁剪以及聚合、针对终端定制化<code>API</code>。</li><li>动态升级：原有系统兼容升级，更新服务而非协议。</li><li>沟通效率提升，协作模式演进为移动业务+网管小组。</li></ul><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/BFF.png" alt></p><p><code>BFF</code>可以认为是一种适配服务，将后端的微服务进行适配(主要包括聚合裁剪和格式适配等逻辑)，向无线端设备暴露友好和统一的<code>API</code>，方便无线设备接入访问后端服务。</p><h4 id="single-point-of-failure"><a href="#single-point-of-failure" class="headerlink" title="single point of failure"></a>single point of failure</h4><p>严重代码缺陷或者流量洪峰可能引发集群宕机。</p><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/aws2.png" alt><br><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/api2.png" alt></p><ul><li>单个模块也会导致后续业务集成复杂度高，根据康威法则，单块的无线<code>BFF</code>和多团队之间就出现不匹配的问题，团队之间沟通协调成本高，交付效率低下。</li><li>很多横跨切面逻辑，比如安全认证，日志监控，限流熔断等。随着时间的推移，代码变得越来越复杂，技术债越堆越多。</li></ul><h4 id="跨横切面（Cross-Cutting-Concerns）"><a href="#跨横切面（Cross-Cutting-Concerns）" class="headerlink" title="跨横切面（Cross-Cutting Concerns）"></a>跨横切面（Cross-Cutting Concerns）</h4><p>跨横切面(Cross-Cutting Concerns)的功能，需要协调更新框架升级发版(路由、认证、限流、安全)，因此全部上沉，引入了 API Gateway，把业务集成度高的 BFF 层和通用功能服务层 <code>APIGateway</code> 进行了分层处理</p><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/api-gateway.png" alt></p><p>在新的架构中，网关承担了重要的角色，它是解耦拆分和后续升级迁移的利器。在网关的配合下，单块 BFF实现了解耦拆分，各业务线团队可以独立开发和交付各自的微服务，研发效率大大提升。另外，把跨横切面逻辑从 BFF 剥离到网关上去以后，BFF 的开发人员可以更加专注业务逻辑交付，实现了架构上的关注分离(Separation of Concerns)。</p><p>我们业务流量实际为：移动端 -&gt; API Gateway -&gt; BFF -&gt; Mircoservice，在FE Web业务中，BFF 可以是 nodejs 来做服务端渲染(SSR，Server-Side Rendering)，注意这里忽略了上游的 CDN、4/7层负载均衡(ELB)。</p><p>注：4层负载均衡可能是——LVS/F5/NetScala，7层负载均衡——Nginx/ELB、SLB/API Gateway/BFS。</p><h3 id="Mircoservice-划分"><a href="#Mircoservice-划分" class="headerlink" title="Mircoservice 划分"></a>Mircoservice 划分</h3><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/bounded-context.png" alt></p><p>微服务架构时遇到的第一个问题就是如何划分服务的边界。在实际项目中通常会采用两种不同的方式划分服务边界，即通过业务职能(BusinessCapability)或是 DDD 的限界上下文(BoundedContext)。</p><ul><li><p>Business Capability<br>由公司内部不同部门提供的职能。例如客户服务部门提供客户服务的职能，财务部门提供财务相关的职能。</p></li><li><p>Bounded Context<br>限界上下文是DDD中用来划分不同业务边界的元素，这里业务边界的含义是“解决不同业务问题”的问题域和对应的解决方案域，为了解决某种类型的业务问题，贴近领域知识，也就是业务。这本质上也促进了组织结构的演进：Service perteam</p></li></ul><p>CQRS，将应用程序分为两部分：命令端和查询端。命令端处理程序创建，更新和删除请求，并在数据更改时发出事件。查询端通过针对一个或多个物化视图执行查询来处理查询，这些物化视图通过订阅数据更改时发出的事件流而保持最新。</p><p>在稿件服务演进过程中，我们发现围绕着创作稿件、审核稿件、最终发布稿件有大量的逻辑揉在一块，其中稿件本身的状态也有非常多种，但是最终前台用户只关注稿件能否查看，我们依赖稿件数据库 binlog 以及订阅binlog 的中间件canal，将我们的稿件结果发布到消息队列 kafka 中，最终消费数据独立组建一个稿件查阅结果数据库，并对外提供一个独立查询服务，来拆分复杂架构和业务。</p><p><img src="/2021/03/03/goatc-1-microservice-overview-and-governance/CRQS.png" alt></p><p>我们架构也从 Polling publisher -&gt; Transaction logtailing 进行了演进(Pull vs Push)</p><h2 id="gRPC-amp-服务实现"><a href="#gRPC-amp-服务实现" class="headerlink" title="gRPC &amp; 服务实现"></a>gRPC &amp; 服务实现</h2><h2 id="多集群-amp-多租户"><a href="#多集群-amp-多租户" class="headerlink" title="多集群 &amp; 多租户"></a>多集群 &amp; 多租户</h2><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;微服务概览&quot;&gt;&lt;a href=&quot;#微服务概览&quot; class=&quot;headerlink&quot; title=&quot;微服务概览&quot;&gt;&lt;/a&gt;微服务概览&lt;
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="微服务" scheme="https://octopuslian.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Golang" scheme="https://octopuslian.github.io/tags/Golang/"/>
    
      <category term="gRPC" scheme="https://octopuslian.github.io/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营总结和收获</title>
    <link href="https://octopuslian.github.io/2021/03/03/geekbang-gatc-gain/"/>
    <id>https://octopuslian.github.io/2021/03/03/geekbang-gatc-gain/</id>
    <published>2021-03-03T04:55:22.000Z</published>
    <updated>2021-03-03T03:28:41.223Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --><p>花了将近一个月终于刷完了<code>GATC</code>，让我系统学习了算法与数据结构的知识，尤其是后面接触的字典树、并查集、布隆过滤器、<code>AVL Tree</code>、<code>Red black Tree</code>这种高级数据结构，让我不得不感人类思想的伟大。</p><p>字符串算法和排序算法很重要，面试经常考，要及时掌握，同时不能放弃刷题，要时刻保持做题手感，同时要时刻借鉴别人优秀的解题思路。这样编程能力以及算法的基本功会慢慢得到提升。</p><p>加油！^_^</p><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h2><p><a href="https://octopuslian.github.io/categories/GATC/">GATC</a><br><a href="https://octopuslian.github.io/2020/11/29/geekbang-live-a-week-algo-training-camp-1-time-space-complex-analyze/">时间复杂度和空间复杂度分析</a><br><a href="https://octopuslian.github.io/2020/11/30/geekbang-live-a-week-algo-training-camp-2-array-linked-list-skip-list/">数组、链表、跳表</a><br><a href="https://octopuslian.github.io/2020/12/01/geekbang-live-a-week-algo-training-camp-3-tree-binary-tree-and-binary-search-tree/">树、二叉树、二叉搜索树</a><br><a href="https://octopuslian.github.io/2020/12/02/geekbang-live-a-week-algo-training-camp-4-recursive/">递归</a><br><a href="https://octopuslian.github.io/2020/12/03/geekbang-live-a-week-algo-training-camp-5-test/">算法体验营-结课考试题</a><br><a href="https://octopuslian.github.io/2021/01/22/geekbang-gatc-04-stack-and-queue/">栈和队列</a><br><a href="https://octopuslian.github.io/2021/01/22/geekbang-gatc-12-dynamic-programming/">动态规划</a><br><a href="https://octopuslian.github.io/2021/01/22/geekbang-gatc-13-dictionary-tree-and-union-loopup/">Trie树、并查集</a><br><a href="https://octopuslian.github.io/2021/01/22/geekbang-gatc-16-bit-operation/">位运算基础</a><br><a href="https://octopuslian.github.io/2021/01/22/geekbang-gatc-05-hashmap-and-set/">哈希表、映射、集合</a><br><a href="https://octopuslian.github.io/2021/01/23/geekbang-gatc-08-divide-conquer-and-backtracking/">分治、回溯</a><br><a href="https://octopuslian.github.io/2021/01/23/geekbang-gatc-09-dfs-and-bfs/">深度优先搜索、广度优先搜索</a><br><a href="https://octopuslian.github.io/2021/02/23/geekbang-gatc-10-greedy-algo/">贪心算法</a><br><a href="https://octopuslian.github.io/2021/02/23/geekbang-gatc-11-binary-search/">二分查找</a><br><a href="https://octopuslian.github.io/2021/02/24/geekbang-gatc-18-sort-algo/">初级排序和高级排序</a><br><a href="https://octopuslian.github.io/2021/02/24/geekbang-gatc-20-string-algo/">字符串基础知识、高级字符串算法、字符串匹配算法</a><br><a href="https://octopuslian.github.io/2021/03/01/geekbang-gatc-14-advanced-search/">高级搜索</a><br><a href="https://octopuslian.github.io/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/">AVL树和红黑树</a><br><a href="https://octopuslian.github.io/2021/03/02/geekbang-gatc-17-bloom-filter-and-lru-cache/">布隆过滤器、LRUCache</a><br><a href="https://octopuslian.github.io/2021/03/02/geekbang-gatc-19-advanced-dynamic-programming/">动态规划、状态转移方程</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue May 04 2021 16:19:29 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;花了将近一个月终于刷完了&lt;code&gt;GATC&lt;/code&gt;，让我系统学习了算法与数据结构的知识，尤其是后面接触的字典树、并查集、布隆过滤器、&lt;c
      
    
    </summary>
    
    
      <category term="GATC" scheme="https://octopuslian.github.io/categories/GATC/"/>
    
    
      <category term="收获" scheme="https://octopuslian.github.io/tags/%E6%94%B6%E8%8E%B7/"/>
    
      <category term="算法" scheme="https://octopuslian.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="总结" scheme="https://octopuslian.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>

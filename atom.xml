<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>以写作调身心</title>
  
  <subtitle>熟能生巧，勤能补拙；念念不忘，必有回响。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://octopuslian.github.io/"/>
  <updated>2020-07-31T00:48:02.716Z</updated>
  <id>https://octopuslian.github.io/</id>
  
  <author>
    <name>Neo Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode-392-is-subsequence | 判断子序列</title>
    <link href="https://octopuslian.github.io/2020/07/31/Leetcode-392-is-subsequence/"/>
    <id>https://octopuslian.github.io/2020/07/31/Leetcode-392-is-subsequence/</id>
    <published>2020-07-31T00:42:20.000Z</published>
    <updated>2020-07-31T00:48:02.716Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 08:48:16 GMT+0800 (CST) --><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://leetcode-cn.com/problems/is-subsequence/" target="_blank" rel="noopener">leetcode中国</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>Golang</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubsequence</span><span class="params">(s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    n, m := <span class="built_in">len</span>(s), <span class="built_in">len</span>(t)  </span><br><span class="line">    i, j := <span class="number">0</span>, <span class="number">0</span> <span class="comment">//初始化两个指针i,j分别指向s和t初始化的位置</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; n &amp;&amp; j &lt; m &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == t[j] &#123;</span><br><span class="line">            i++  <span class="comment">//匹配成功，则i,j同时右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        j++  <span class="comment">//匹配失败，则j右移，i不变</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i == n  <span class="comment">//最终如果i移动到s的末尾，就说明s是t的子序列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 08:48:16 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;链接&quot;&gt;&lt;a href=&quot;#链接&quot; class=&quot;headerlink&quot; title=&quot;链接&quot;&gt;&lt;/a&gt;链接&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;ht
      
    
    </summary>
    
    
      <category term="LeetCode题解" scheme="https://octopuslian.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数组" scheme="https://octopuslian.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>妹妹的中考</title>
    <link href="https://octopuslian.github.io/2020/07/30/sister-zhong-kao/"/>
    <id>https://octopuslian.github.io/2020/07/30/sister-zhong-kao/</id>
    <published>2020-07-30T00:21:23.000Z</published>
    <updated>2020-07-30T00:51:48.639Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 08:48:17 GMT+0800 (CST) --><p>这两周一直在忙妹妹的中考，这个月底总算尘埃落定。</p><p>由于今年疫情原因，取消中考体育，所以总分只有750分，妹妹说她考了670分，全市排名1700左右，我觉得可以冲下排名第二、三，保底是排名第四和第五的学校。</p><p>然而最终录取分数线出来后，排名第三的乌鲁木齐市八一中学分数线比妹妹的成绩高了5分，最终被排名第四的乌鲁木齐市八中录取了。</p><p>父母觉得有些遗憾，但只能接受，好在乌鲁木齐市八中也离家比较近，耗时近两周的中考录取终于结束了。</p><p>然而，我突然回想起我的中考，跌跌撞撞中被乌鲁木齐市高级中学实验班录取，巨大的校园和先进的设备吸引了我，还有各种兴趣小组可以参加，邻居们之前还对我家不屑一顾，突然听说我考到了乌鲁木齐市高级中学的时候，羡慕、嫉妒纷至沓来。从那时起我突然明白，原来好学校有时候就像一种荣誉的象征，不光是给自己争气，也是给父母脸上增光。</p><p>时隔多年，我依然庆幸，在高中里遇到的良师益友，影响了我的高考乃至大学生涯。</p><p>中考差5分也算是一次警醒，希望妹妹可以在乌鲁木齐市八中里茁壮成长，期待三年后的高考，也能取得一个满意的结果。</p><p><img src="/2020/07/30/sister-zhong-kao/light.jpg" alt></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 08:48:17 GMT+0800 (CST) --&gt;&lt;p&gt;这两周一直在忙妹妹的中考，这个月底总算尘埃落定。&lt;/p&gt;&lt;p&gt;由于今年疫情原因，取消中考体育，所以总分只有750分，妹妹说她考了670分，全市排名1700左
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://octopuslian.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="中考" scheme="https://octopuslian.github.io/tags/%E4%B8%AD%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>以五十步笑百步，则何如？</title>
    <link href="https://octopuslian.github.io/2020/07/26/how-wu-shi-bu-xiao-bai-bu/"/>
    <id>https://octopuslian.github.io/2020/07/26/how-wu-shi-bu-xiao-bai-bu/</id>
    <published>2020-07-26T02:24:30.000Z</published>
    <updated>2020-07-30T00:48:45.983Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 08:48:17 GMT+0800 (CST) --><p><strong>以五十步笑百步，则何如？</strong>——出自《孟子•梁惠王上》：孟子对曰：“王好战，请以战喻。填然鼓之。兵刃既接，弃甲曳兵而走。或百步而后止，或五十步而后止。以五十步笑百步，则何如？”曰：“不可。直不百步耳，是亦走也。”</p><p>为什么我会突然想起这段对话呢，源于前几个月发生的一起事情。</p><p>我记得当时在吃午饭，同事A突然觉得找不到什么新鲜话题了，对同事B说，坐你之前座位的同事C，写代码真是烂的一批，写的程序经常出错叫别人来解决，有一次出现的问题是他传输一个数据给另一个服务，结果还没传输到就没了，一直找不到原因，结果同事A看了同事C的代码后，说你还没将数据传到另一端的时候自己主动释放掉了。听完同事B哈哈大笑，笑的没玩没了，吃完饭的时候在电梯里又再笑个不停。我在想至于吗？大家都是搬砖的，无非就是你搬砖快一些，人家搬砖慢一些，没必要一直嘲笑吧？！</p><p>结果过了一段时间，同事A和同事B在业务上有合作，然而同事A那边测试总是出问题，找同事B来讨论原因，结果同事A大怒，说你自己写的东西不测试一下的吗？我用的是你封装好的接口，我这边要测试的话也不清楚你写的程序到底有没有出问题，结果你都不测试以下就提交上去了啊。然后同事B默不作声。</p><p>我突然觉得有些可笑，果然大家都习惯于发现别人身上的缺点，从来不会先在自己身上找缺点。</p><p>我又想起我刚毕业入职写程序的时候，因为逻辑不通，总是去请教一个工作比我多3-5年经验的同事，每次我都是去虚心请教，结果就是被他说一顿，然后再给旁边的同事分享这“快乐的片段”，我每次看到他得意的表情，都会怒火中烧，却仍然要保持表情上的平静。也许，这就是职场给我上的一课————<strong>控制情绪，面不改色，然后在深夜里不动声色的提升自己，静待转机出现</strong>。</p><p>以五十步笑百步，在我看来五十步和百步的性质是一样的，只是时间上的长短罢了。</p><p><img src="/2020/07/26/how-wu-shi-bu-xiao-bai-bu/ren.jpg" alt></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 08:48:17 GMT+0800 (CST) --&gt;&lt;p&gt;&lt;strong&gt;以五十步笑百步，则何如？&lt;/strong&gt;——出自《孟子•梁惠王上》：孟子对曰：“王好战，请以战喻。填然鼓之。兵刃既接，弃甲曳兵而走。或百步
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://octopuslian.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="嘲笑" scheme="https://octopuslian.github.io/tags/%E5%98%B2%E7%AC%91/"/>
    
      <category term="同事" scheme="https://octopuslian.github.io/tags/%E5%90%8C%E4%BA%8B/"/>
    
      <category term="职场" scheme="https://octopuslian.github.io/tags/%E8%81%8C%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Cooking_新疆大盘鸡</title>
    <link href="https://octopuslian.github.io/2020/07/19/cooking-xin-jiang-da-pan-ji/"/>
    <id>https://octopuslian.github.io/2020/07/19/cooking-xin-jiang-da-pan-ji/</id>
    <published>2020-07-19T11:42:23.000Z</published>
    <updated>2020-07-19T14:47:51.859Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 08:48:16 GMT+0800 (CST) --><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>一个土豆</li><li>一个红椒</li><li>半只鸡</li><li>4个蒜</li><li>盐、鸡精、冰糖、胡椒粉、八角</li></ul><p><img src="/2020/07/19/cooking-xin-jiang-da-pan-ji/1.jpg" alt></p><h2 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h2><ul><li>热油放冰糖<br>上色</li></ul><p><img src="/2020/07/19/cooking-xin-jiang-da-pan-ji/2.jpg" alt></p><ul><li>油烧焦红色时倒入鸡肉翻炒</li></ul><p><img src="/2020/07/19/cooking-xin-jiang-da-pan-ji/3.jpg" alt></p><ul><li><p>翻炒直到鸡肉有颜色（3-5分钟）</p></li><li><p>倒入蒜，料酒，酱油，味极鲜翻炒片刻后加八角</p></li><li><p>加热水，盖上锅煮20分钟<br>途中加点盐，花椒粉</p></li></ul><p><img src="/2020/07/19/cooking-xin-jiang-da-pan-ji/4.jpg" alt></p><ul><li>加入土豆块，青椒，红椒，洋葱片烧10分钟左右</li></ul><p><img src="/2020/07/19/cooking-xin-jiang-da-pan-ji/5.jpg" alt></p><ul><li>加入鸡精翻炒一下，出锅</li></ul><p><img src="/2020/07/19/cooking-xin-jiang-da-pan-ji/6.jpg" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>只要勤加练习，也能做出家乡的美味，感谢女友在旁的指导，哈哈哈。</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 08:48:16 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;一个土豆&lt;/
      
    
    </summary>
    
    
      <category term="厨艺学习" scheme="https://octopuslian.github.io/categories/%E5%8E%A8%E8%89%BA%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="厨艺" scheme="https://octopuslian.github.io/tags/%E5%8E%A8%E8%89%BA/"/>
    
      <category term="大盘鸡" scheme="https://octopuslian.github.io/tags/%E5%A4%A7%E7%9B%98%E9%B8%A1/"/>
    
      <category term="新疆" scheme="https://octopuslian.github.io/tags/%E6%96%B0%E7%96%86/"/>
    
  </entry>
  
  <entry>
    <title>今天我换了一个新头像</title>
    <link href="https://octopuslian.github.io/2020/07/13/today-i-changed-a-new-avatar/"/>
    <id>https://octopuslian.github.io/2020/07/13/today-i-changed-a-new-avatar/</id>
    <published>2020-07-13T15:15:31.000Z</published>
    <updated>2020-07-13T15:23:57.718Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 08:48:17 GMT+0800 (CST) --><p>今天我换了一个新头像，是妹妹亲自用数位板画的，看着蛮可爱的，最下面附带一行小字——“勇敢的去面对把！Neo Zhang”。</p><p>我想这个头像未来会陪伴我几年，甚至十几年，希望未来有一天这个头像可以当做一个计算机大佬象征性的标志（在此先立一个长远的Flag）。</p><p><img src="/2020/07/13/today-i-changed-a-new-avatar/neozhang.png" alt></p><p>另外今天收到了煎鱼哥和徐大两位写的书，总共有5个<code>Go</code>语言相关的项目，还有一章关于<code>Go</code>工具的讲解，我已经迫不及待想要翻阅了。</p><p><img src="/2020/07/13/today-i-changed-a-new-avatar/go-book.jpeg" alt></p><p><img src="/2020/07/13/today-i-changed-a-new-avatar/go-book2.jpeg" alt></p><p>2020下半年，加油！</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 08:48:17 GMT+0800 (CST) --&gt;&lt;p&gt;今天我换了一个新头像，是妹妹亲自用数位板画的，看着蛮可爱的，最下面附带一行小字——“勇敢的去面对把！Neo Zhang”。&lt;/p&gt;&lt;p&gt;我想这个头像未来会陪
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://octopuslian.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="头像" scheme="https://octopuslian.github.io/tags/%E5%A4%B4%E5%83%8F/"/>
    
      <category term="换新" scheme="https://octopuslian.github.io/tags/%E6%8D%A2%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>极客时间直播_乔新亮_为什么毕业5年后，同学间的差距越来越大</title>
    <link href="https://octopuslian.github.io/2020/07/07/geekbang-live-why-5-years-after-graduation-the-gap-between-classmates-is-growing/"/>
    <id>https://octopuslian.github.io/2020/07/07/geekbang-live-why-5-years-after-graduation-the-gap-between-classmates-is-growing/</id>
    <published>2020-07-07T12:20:09.000Z</published>
    <updated>2020-07-07T14:03:25.425Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 08:48:17 GMT+0800 (CST) --><h2 id="直播介绍"><a href="#直播介绍" class="headerlink" title="直播介绍"></a>直播介绍</h2><p>直播嘉宾：乔新亮，彩食鲜CTO</p><h3 id="你将获得"><a href="#你将获得" class="headerlink" title="你将获得"></a>你将获得</h3><ul><li>去做事，提高能力，钱自然会来</li><li>努力是为了提高下限，选择是为了提高上限</li><li>往上去想，往下去做</li><li>领导，只要你敢让我做，我就敢上。</li></ul><h2 id="选择和努力"><a href="#选择和努力" class="headerlink" title="选择和努力"></a>选择和努力</h2><ul><li>逆水行舟，不进则退。5年一道坎，不断提高自己的下限和上限。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如30岁当个技术总监，不算老，但30岁还是普通程序员，就很老</span><br><span class="line"></span><br><span class="line">比如40岁当个CTO，不算老，但50岁才是CTO就很老</span><br><span class="line"></span><br><span class="line">五年一道坎，跨不过去就会倒退</span><br></pre></td></tr></table></figure><ul><li><p>居安思危，不要当鸵鸟，问题不会因为你把头埋进沙子就不存在了。</p></li><li><p>连接是人类最大的价值，努力让自己成为一个有价值的点，选择进入更高等级的网络，技术的迭代+学习=跨越网络阶层最高效的方法</p></li><li><p>刚毕业的时候不要在意钱，要在意做事的机会</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果你知道你：10年后，睡前收入，1年等于毕业时10年，17年后，税前收入，1年等于毕业时200年</span><br><span class="line">你会怎么决定？</span><br></pre></td></tr></table></figure><ul><li>站在未来看现在，站在全局看自己</li></ul><h2 id="能力"><a href="#能力" class="headerlink" title="能力"></a>能力</h2><ul><li><p>能力提升很重要，技不压身，一直可以跟随你的是能力</p></li><li><p>T型人才：一竖，专业深度；一横，架构广度</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">专业上，敢于挑战任何人</span><br></pre></td></tr></table></figure><ul><li><p>10年的工作经验 VS 一年的工作经验用了10年</p></li><li><p>深度洞察，看清事物本质</p></li><li><p>逻辑推理，一切都有因果</p></li></ul><h2 id="做事"><a href="#做事" class="headerlink" title="做事"></a>做事</h2><ul><li><p>敢于决策，敢于承担</p></li><li><p>猛将必发于卒伍，为什么我说人活着就要不停的做事</p></li><li><p>只要你敢让我上，我就敢上</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">做砸了，至少还有公司，我还锻炼了能力</span><br><span class="line">做好了，那恭喜</span><br></pre></td></tr></table></figure><ul><li><p>锻炼的机会稍纵即逝，相信领导的眼光</p></li><li><p>往上去想，看清全局；往下去做，脚踏实地</p></li><li><p>契约精神</p></li><li><p>认知到位+彪悍执行=成功交付</p></li><li><p>有问题吗？第一反应——搞定它</p></li><li><p>事情做砸了怎么办？做砸了呗，拼尽权利，轻松心态</p></li><li><p>接受自己一切的不完美，相信自己会成长，丑小鸭不停在进步</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">人最怕否定自己</span><br></pre></td></tr></table></figure><ul><li><p>成长性思维：客观的肯定过去的成就；客观的认识过去存在的问题；接受自己的一切不完美；相信自己会成长。</p></li><li><p>持续学习，学以致用，终身成长</p></li></ul><h2 id="金钱观"><a href="#金钱观" class="headerlink" title="金钱观"></a>金钱观</h2><ul><li><p>为什么每个人都要有财务思维</p></li><li><p>不要为了钱工作，为了能力工作，能力会吸引钱来</p></li><li><p>努力挣钱的目的恰恰不是为了钱，是为了让自己不受钱的困扰，让自己有选择的权力，更是一种经历</p></li><li><p>提升能力可以鱼和熊掌剪得，成就感 VS 金钱</p></li><li><p>提升能力是在赚未来的钱，薪资是赚的当下的钱</p></li><li><p>不要总要立刻看到回报，一切的努力都不会白费，都会有回报</p></li><li><p>方向大致对了，剩下的交给时间，做时间的朋友</p></li><li><p>卓越，top(*10) Talent(一横一竖)</p></li><li><p>把自己当成一个公司经营，明确公司的方向、目标、年度目标、季度目标比月度目标，周度目标重要，价值投资、趋势投资、投机投资</p></li></ul><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><ul><li><p>一个人的时间非常少</p></li><li><p>少看朋友圈，多读书</p></li><li><p>每时每刻，专注那一刹那</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">专注谈方案，读一小时书，陪小孩玩，吃午饭，和别人聊天</span><br></pre></td></tr></table></figure><h2 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h2><ul><li><p>乐趣，专注与平静，心在身上，活在当下</p></li><li><p>享受专注的乐趣，想想自己喜欢的运动，比如打羽毛球，工作中，专注做一件事</p></li><li><p>多巴胺——经历新鲜、刺激或具有挑战性的事情；内啡肽有低变高——成就感、运动、深呼吸；血清素——健康饮食和锻炼</p></li><li><p>人啊，一定要活的真实一点，别装</p></li><li><p>热爱生活</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>成功者的叙事风格，会将一切都归纳于自己的先知先觉；</p></li><li><p>成长性思维；</p></li><li><p>站在未来看现在，站在全局看自己；</p></li><li><p>做T字型人才；</p></li><li><p>努力和选择是一个事情的两个方面（人生状态），都很重要；</p></li><li><p>专注，心在身上，感受自己心灵的平静，感受自己做事的乐趣。</p></li></ul><h2 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h2><ul><li><p>如何跳出舒适区？<br>结论：如果舒适了，就要考虑跳出来。</p></li><li><p>怎么找到领域导师，让自己更有深度？<br>沟通，观察。</p></li></ul><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 08:48:17 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;直播介绍&quot;&gt;&lt;a href=&quot;#直播介绍&quot; class=&quot;headerlink&quot; title=&quot;直播介绍&quot;&gt;&lt;/a&gt;直播介绍&lt;/h2&gt;&lt;p&gt;直播嘉
      
    
    </summary>
    
    
      <category term="直播分享" scheme="https://octopuslian.github.io/categories/%E7%9B%B4%E6%92%AD%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="成长" scheme="https://octopuslian.github.io/tags/%E6%88%90%E9%95%BF/"/>
    
      <category term="毕业" scheme="https://octopuslian.github.io/tags/%E6%AF%95%E4%B8%9A/"/>
    
      <category term="极客邦" scheme="https://octopuslian.github.io/tags/%E6%9E%81%E5%AE%A2%E9%82%A6/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode_1480_running-sum-of-1d-array | 一维数组的动态和</title>
    <link href="https://octopuslian.github.io/2020/07/03/Leetcode-1480-running-sum-of-1d-array/"/>
    <id>https://octopuslian.github.io/2020/07/03/Leetcode-1480-running-sum-of-1d-array/</id>
    <published>2020-07-03T15:25:40.000Z</published>
    <updated>2020-07-03T15:33:06.997Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 08:48:16 GMT+0800 (CST) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><a href="https://leetcode-cn.com/problems/running-sum-of-1d-array/" target="_blank" rel="noopener">leetcode中国</a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>设置中间变量，循环一次，记录一次元素和，遍历完后返回结果。</p><ul><li>Golang</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runningSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">//中间变量，一边循环，一边保存元素和</span></span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">        <span class="comment">//将索引小于等于i的全部元素相加，赋值索引为i的元素</span></span><br><span class="line">        sum += nums[i]</span><br><span class="line">        nums[i] = sum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 08:48:16 GMT+0800 (CST) --&gt;&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="LeetCode题解" scheme="https://octopuslian.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="Leetcode" scheme="https://octopuslian.github.io/tags/Leetcode/"/>
    
      <category term="数组" scheme="https://octopuslian.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="暴力" scheme="https://octopuslian.github.io/tags/%E6%9A%B4%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>第一次皮肤护理体验记录</title>
    <link href="https://octopuslian.github.io/2020/06/27/skin79-ba-wang-can-first-skin-care-notes/"/>
    <id>https://octopuslian.github.io/2020/06/27/skin79-ba-wang-can-first-skin-care-notes/</id>
    <published>2020-06-27T07:06:54.000Z</published>
    <updated>2020-06-27T07:36:32.349Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 08:48:17 GMT+0800 (CST) --><p>上周六用霸王餐去体验了一次皮肤护理，现将学习到的知识记录下来。</p><h2 id="皮肤检测"><a href="#皮肤检测" class="headerlink" title="皮肤检测"></a>皮肤检测</h2><p>首先，因为是第一次做护理，需要对皮肤做一次检测。</p><p>店长会拿一个仪器，类似放大镜，但又可以检测到皮肤下面的情况，于是在检测了一定时间后，得到如下结论：</p><ul><li>皮肤年龄，正常；</li><li>皮肤黑头，在T字区比较多；</li><li>皮肤干燥程度，脸颊两侧较严重；</li><li>皮肤红血丝，脸面有些多。</li></ul><p>之后给出方案，建议7-10天做一次皮肤清理，大概要做8次；皮肤修复大概做4-5次。</p><p>平时少吃辣，别熬夜，最晚11点就需要入睡，护肤品尽量选择氨基酸的，面膜选择医用蒸馏水面膜。</p><p>最后店长还说，你这情况不算严重，至少你每天早晚都用洗面奶水乳霜，保护的还不错。</p><p>接着便体验皮肤清理了。</p><h2 id="皮肤清理"><a href="#皮肤清理" class="headerlink" title="皮肤清理"></a>皮肤清理</h2><p>躺在一张床上，先用卸妆水摸遍全脸，然后用一种可以喷出热气的机器将脸上的毛孔打开，</p><p>接着用小气泡（感觉是利用大气压强原理，在皮肤和玻璃罩内构建一个压强，然后将皮肤里面的脏东西洗出来，再用蒸馏水清理掉，继续吸）清理一遍脸，</p><p>接着用铲鼻机（超声波震动原理，我是感觉不到震动的，然后将黑头震出来，再用铲鼻机头铲掉）清除黑头，这个过程有些长，</p><p>接着就是补水阶段，需要敷面膜，然后有姐姐帮你涂精华液，</p><p>然后就是用一种类似喷头的机器收缩毛孔，</p><p>接着敷医用蒸馏水面膜，还有泥浆软膜。</p><p>流程结束。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>做完之后感觉脸清爽许多，不过姐姐建议我晚上还得用补水面膜敷一下，不然脸太干会起皮（不过我还好，就敷了一次）。</p><p>这次体验让我学到了一些护肤上的知识（其实女朋友也在给我讲），还有见识了各种仪器的操作和作用，顺便用我仅存的高中物理化学和生物知识去理解他们的原理，还是很开心的。</p><p>最后办了一张价格还挺实惠的皮肤护理修复体验卡，估计可以用上半年，到时再多学习学习，积累护肤经验。</p><p><img src="/2020/06/27/skin79-ba-wang-can-first-skin-care-notes/hufu.jpg" alt></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 08:48:17 GMT+0800 (CST) --&gt;&lt;p&gt;上周六用霸王餐去体验了一次皮肤护理，现将学习到的知识记录下来。&lt;/p&gt;&lt;h2 id=&quot;皮肤检测&quot;&gt;&lt;a href=&quot;#皮肤检测&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="skin-care" scheme="https://octopuslian.github.io/categories/skin-care/"/>
    
    
      <category term="皮肤" scheme="https://octopuslian.github.io/tags/%E7%9A%AE%E8%82%A4/"/>
    
      <category term="护理" scheme="https://octopuslian.github.io/tags/%E6%8A%A4%E7%90%86/"/>
    
      <category term="skin79" scheme="https://octopuslian.github.io/tags/skin79/"/>
    
      <category term="黑头" scheme="https://octopuslian.github.io/tags/%E9%BB%91%E5%A4%B4/"/>
    
      <category term="清理" scheme="https://octopuslian.github.io/tags/%E6%B8%85%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>一位朋友面试字节跳动游戏开发岗经验</title>
    <link href="https://octopuslian.github.io/2020/06/26/a-friend-interview-bytedance-game-develop-experience/"/>
    <id>https://octopuslian.github.io/2020/06/26/a-friend-interview-bytedance-game-develop-experience/</id>
    <published>2020-06-26T10:57:45.000Z</published>
    <updated>2020-06-27T07:02:57.730Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 08:48:16 GMT+0800 (CST) --><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一位好友在西安某211读研究生，主攻图形学方向，下面是他面试字节跳动游戏开发岗的流程。</p><h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>注：此处略去有关项目经验的问题。</p><ul><li><p>C#接口、抽象类的区别</p></li><li><p>学习Unity的途径和方式</p></li><li><p>面向对象中class和struct的区别</p></li><li><p>C#的垃圾回收机制</p></li><li><p>引用类型、值类型和内存分配</p></li><li><p>堆和栈的区别</p></li><li><p>C++多态、虚表</p></li><li><p>list和vector的区别</p></li><li><p>为什么数组插入数据效率慢，而链表插入数据效率快</p></li><li><p>使用链表插入数据的过程</p></li><li><p>检查一个链表是否形成环路的方法</p></li><li><p>C++：Map和<code>Hash Map</code>的区别_对应_数据结构：红黑树和<code>Hash Map</code>的区别</p></li><li><p>哈希表的原理</p></li><li><p>模板测试和深度测试</p></li><li><p>场景题：在游戏中，怎么判断一次AOE攻击有没有命中这些单位</p></li><li><p>什么叫世界坐标转为局部坐标</p></li><li><p>进程和线程的区别</p></li></ul><p>答疑：</p><ul><li><p>怎么系统学习渲染？<br><code>OpenGL</code>是一个很好的切入点，然后看一下<a href="https://book.douban.com/subject/30296179/" target="_blank" rel="noopener">《Real-Time Rendering, Fourth Edition》</a></p></li><li><p>贵公司的游戏部门2018年新成立，请问做游戏的类型有哪些？<br>北京、杭州、广州、上海都有研发中心，有轻度、中毒、重度游戏，合作发布会多一些。</p></li><li><p>游戏引擎开发的学习路线<br>语言层面：引擎源码需要熟悉，还有C++；其次是渲染，就是读一下<a href="https://book.douban.com/subject/30296179/" target="_blank" rel="noopener">《Real-Time Rendering, Fourth Edition》</a></p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>大概40分钟的面试，问了<code>C#</code>和<code>C++</code>基础+数据结构+网络，然后是图形学方面的问题。总的来说我个人觉得这位面试官非常和蔼，即使他不知道为什么链表插入效率快，但会通过让他思考链表的插入方式对比数组的插入方式，从而得出链表插入快的结论（虽然到最后这层窗户纸还是没有捅破）。接着便问了很多语言特性和项目上的问题，答疑阶段也给了一些书籍和技术指点，总之给我带来的启发就是：</p><ul><li><p>如果要走游戏引擎开发，<code>C++</code>必不可少；</p></li><li><p>最好做一些和图形学相关的项目；</p></li><li><p>平时刷题时，首先保证要提交通过，其次需要考虑优化。例如插入数据时先考虑数组，其次链表，二叉树，这样也可以帮助自己理清各个数据结构的优缺点；</p></li><li><p>一面主要还是以理论为主，但不可放松对编码能力的训练；</p></li><li><p>最好准备两套回答问题的模板，一套用于回答自己擅长的问题，另一道用于回答自己不擅长的问题。</p></li></ul><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 08:48:16 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;一位好友在西安某211
      
    
    </summary>
    
    
      <category term="面试经验" scheme="https://octopuslian.github.io/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="字节跳动" scheme="https://octopuslian.github.io/tags/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8/"/>
    
      <category term="校招" scheme="https://octopuslian.github.io/tags/%E6%A0%A1%E6%8B%9B/"/>
    
      <category term="游戏开发" scheme="https://octopuslian.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>第一款 iPad 和 Apple Pencil</title>
    <link href="https://octopuslian.github.io/2020/06/22/first-ipad-and-apple-pencil/"/>
    <id>https://octopuslian.github.io/2020/06/22/first-ipad-and-apple-pencil/</id>
    <published>2020-06-22T13:44:34.000Z</published>
    <updated>2020-06-22T14:18:25.207Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 08:48:16 GMT+0800 (CST) --><p>今天利用好友推荐的官网教育优惠，终于下单了<code>Apple Pencil 一代</code>！</p><p><img src="/2020/06/22/first-ipad-and-apple-pencil/pencil-edu.png" alt></p><p>虽然比我预想的还要贵一些（因为之前3月底的时候答应一学妹，ipad2018 128g + pencil 2600元搞定），但因为疫情原因，学校迟迟不开学，正好6月1号京东苹果官方旗舰店秒杀<code>ipad2019 128g</code>，于是下单了，无奈<code>pencil</code>一直到618都没有降价（天猫苏宁旗舰店必须要凑单满1000减100即可，买一些没用的，总共要八百多，放弃）。</p><p>朋友说，虽然贵一些，但因为是官网，比较省心，今天终于体会到了。</p><p>希望这两位可以作为我强有力的生产力工具，加油！</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 08:48:16 GMT+0800 (CST) --&gt;&lt;p&gt;今天利用好友推荐的官网教育优惠，终于下单了&lt;code&gt;Apple Pencil 一代&lt;/code&gt;！&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/2020/06/22
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://octopuslian.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="ipad" scheme="https://octopuslian.github.io/tags/ipad/"/>
    
      <category term="pencil" scheme="https://octopuslian.github.io/tags/pencil/"/>
    
      <category term="生产力" scheme="https://octopuslian.github.io/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>2020年夏季面试总结</title>
    <link href="https://octopuslian.github.io/2020/06/18/2020-summer-interview-summary/"/>
    <id>https://octopuslian.github.io/2020/06/18/2020-summer-interview-summary/</id>
    <published>2020-06-18T14:04:39.000Z</published>
    <updated>2020-06-27T06:34:49.020Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 08:48:16 GMT+0800 (CST) --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>工作两年，想看看自己水平怎样，于是在刷了一定题量的<code>LeetCode</code>后，尝试去面试了一些成都的大中型公司，现将面试经验整理如下。</p><h2 id="收获最大的面试"><a href="#收获最大的面试" class="headerlink" title="收获最大的面试"></a>收获最大的面试</h2><h3 id="4月-成都腾讯-微信读书-后台开发"><a href="#4月-成都腾讯-微信读书-后台开发" class="headerlink" title="4月_成都腾讯_微信读书_后台开发"></a>4月_成都腾讯_微信读书_后台开发</h3><p>问了一些<code>Golang</code>基础和<code>MySQL</code>的基础知识，回答的还不错，最后卡在了一道业务场景题和网络经典面试题上，这次面试主要让我明白<strong>大厂面试一定要考虑到业务量巨大和优雅处理异步请求的情况，同时面试前最好做些练习，不然太紧张也不好。</strong></p><h3 id="4月-100课堂-后端开发"><a href="#4月-100课堂-后端开发" class="headerlink" title="4月_100课堂_后端开发"></a>4月_100课堂_后端开发</h3><p>一面技术面，聊了大概一个多小时，让我也算回顾了一些<code>Golang</code>的核心基础，另外考了一道如何实现内置<code>len</code>函数的题，主要看我有没有考虑代码优化。</p><h3 id="5月-平安城科-供应链事业部-Java高级开发"><a href="#5月-平安城科-供应链事业部-Java高级开发" class="headerlink" title="5月_平安城科_供应链事业部_Java高级开发"></a>5月_平安城科_供应链事业部_Java高级开发</h3><p>一上来就问了<code>MySQL</code>的核心原理，把我给整蒙了。后来和面试官闲聊才晓得，他们对原理的要求非常细且深，因为知道原理后就可以知道如何去优化，提升程序的执行效率，期间还给我举了用<code>MySQl</code>的数据算笛卡尔积再做优化的例子，虽然面试凉了，但让我更加懂得学习原理的意义之所在。</p><h3 id="5月-安麦云科技-音频算法"><a href="#5月-安麦云科技-音频算法" class="headerlink" title="5月_安麦云科技_音频算法"></a>5月_安麦云科技_音频算法</h3><p>面试官是一位博士后，闲聊之余才知道这岗位又要懂一些音视频，又要懂一些AI算法，然而我都是只知道皮毛。最后建议我发挥科班的优势，主攻大数据和人工智能领域，<code>Golang</code>的话就是高并发场景，因为音视频领域有一些我目前无法短时间内补上的短板。</p><h2 id="一般般的面试"><a href="#一般般的面试" class="headerlink" title="一般般的面试"></a>一般般的面试</h2><h3 id="4月-星网智慧-媒体开发工程师-星网锐捷-音视频软件工程师"><a href="#4月-星网智慧-媒体开发工程师-星网锐捷-音视频软件工程师" class="headerlink" title="4月_星网智慧_媒体开发工程师+星网锐捷_音视频软件工程师"></a>4月_星网智慧_媒体开发工程师+星网锐捷_音视频软件工程师</h3><p>都是和视音频相关的岗位，开发语言<code>C/C++</code>，问了一些数据结构、网络七层模型、<code>Apache</code>、<code>docker</code>与虚拟机、进程和线程方面的知识。</p><h3 id="5月-育碧软件-Graphics-Programmer"><a href="#5月-育碧软件-Graphics-Programmer" class="headerlink" title="5月_育碧软件_Graphics-Programmer"></a>5月_育碧软件_Graphics-Programmer</h3><p>一家做游戏的外企，无奈我图形学的项目经验不超过一年，<code>C++</code>也懂得不多，不过最后还是建议我可以利用业余时间做一些和游戏、图形学方面的<code>demo</code>，到时再去面试的话通过的几率会大一些。另外英语最好熟练听说读写基本技能。</p><h3 id="5月-北京尘锋信息技术-golang研发工程师"><a href="#5月-北京尘锋信息技术-golang研发工程师" class="headerlink" title="5月_北京尘锋信息技术_golang研发工程师"></a>5月_北京尘锋信息技术_golang研发工程师</h3><p>很平常的一家公司，主要做<code>CRM</code>。面试官人挺好，问了我一些<code>Golang</code>基础，还有业务场景举例分析，还跟我闲聊了一下程序员这个行业，最后估计是因为嫌我到岗时间比较晚，所以放弃。</p><h3 id="邮政易通公司外包-C语言开发工程师"><a href="#邮政易通公司外包-C语言开发工程师" class="headerlink" title="邮政易通公司外包_C语言开发工程师"></a>邮政易通公司外包_C语言开发工程师</h3><p>电话面试大概半个多小时，聊了C语言和数据库的基础，最后问了我能否接受外包，嗯…肯定不能接受。</p><h3 id="内推-阿里巴巴-OPPO-字节跳动-ThoughtWorks-研发"><a href="#内推-阿里巴巴-OPPO-字节跳动-ThoughtWorks-研发" class="headerlink" title="内推_阿里巴巴/OPPO/字节跳动/ThoughtWorks/_研发"></a>内推_阿里巴巴/OPPO/字节跳动/ThoughtWorks/_研发</h3><p>在此非常感谢给我内推机会的大佬们，虽然官方给出的答案是社招至少三年以上，但是我觉得提前一年先试试水也挺好的。</p><h2 id="吐槽及避坑"><a href="#吐槽及避坑" class="headerlink" title="吐槽及避坑"></a>吐槽及避坑</h2><p>面试的公司多了，难免会遇到一些不爽的企业，在此仅仅通过个人目前的阅历和经验，给出我自己认为正确的判断，仅供参考。</p><h3 id="5月-100课堂HR和管理"><a href="#5月-100课堂HR和管理" class="headerlink" title="5月_100课堂HR和管理"></a>5月_100课堂HR和管理</h3><p>强烈吐槽这样的<code>HR</code>，面试完了也不说话，吱一声能把你咋样？<br>我下班了跑过去面试了两轮，技术面也过了，最后通过内部关系，负责人很可笑的给出了一个“哦，我把这个人的面试给忘了，我目前想招个Golang高级点的”。<br>呵呵，你要招高级的岗位，那你职位描述上为什么写着经验1-3年或经验不限？不想招人就请直说，别浪费彼此的时间！！！</p><h3 id="5月-中天智慧-Golang开发工程师"><a href="#5月-中天智慧-Golang开发工程师" class="headerlink" title="5月_中天智慧_Golang开发工程师"></a>5月_中天智慧_Golang开发工程师</h3><p>面试就考了五道<code>Golang</code>填空题，也许是我习惯用编辑器的缘故，还有一些偏门语法我没有用过，导致结果不是很理想，然后面试官和HR就开始pua我：“你目前能力还不是很强，招进来风险有些大，不过我们还是愿意给你这个入职的机会，请你尽快入职哦，因为我们还有一个离职且条件比你好的备胎，你要是不愿意入职我就找他聊了，所以请尽快给我答复！”（注：薪资是平薪过去）。<br>我有些恼火，但还是有礼貌的说了句：“我放弃入职，请把机会给那位离职的老哥吧。”<br>过了半小时左右，<code>HR</code>慌了，问我是因为入职时间是不是太紧了延后一些你看怎么样，工资是不是低了，给你涨1000怎么样。<br>果然，<code>HR</code>的话不可信，果断拒绝。</p><p><img src="/2020/06/18/2020-summer-interview-summary/hrpua.jpg" alt></p><p>招人就坦诚一些，别想那么多花花肠子，我是程序员，但不是只沉迷与代码，你这样（指<code>HR</code>）只会让我感到恶心。</p><h3 id="6月-四川隧唐科技-Golang服务器开发"><a href="#6月-四川隧唐科技-Golang服务器开发" class="headerlink" title="6月_四川隧唐科技_Golang服务器开发"></a>6月_四川隧唐科技_Golang服务器开发</h3><p>这是我面试到现在唯一一家明确表明是<strong>不缴纳公积金</strong>的企业。</p><p>笔试+三轮面试表现良好，问及期望薪资时我给了一个范围，最后也不出所料的被录用，但是谈到薪资的时候让我大失所望，果然像这种连五险一金基本福利都不健全的小公司，不能抱有太大希望。</p><p>另外我也利用搜索引擎查到了这家公司曾有拖欠员工工资的不良记录，所以果断拒绝。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>当被面试官或<code>HR</code>贬低或旁击侧敲的说你技术很差，但我们愿意给你机会时，首先需要对自己有个清醒的认识，其次认定这家公司的这个岗位是不是自己真的想去的；</p></li><li><p>给某某银行做业务的xx科技公司，基本都是外包或驻厂开发，慎重选择；</p></li><li><p>面试前最好先问清对方能给的期望薪资大概是多少，这样也确认自己是否值得为此跑一趟；</p></li><li><p>面试时不要慌，坦然面对，当问及盲区的时候，可以让面试官给一些提示，实在不会就跳过；</p></li><li><p>五险一金是下限，连这个都不满足的企业，建议慎重选择。</p></li><li><p>刷题还是很有用的，这是面试的下限，项目和潜力是你的上限，欢迎大家一起来贡献<code>LeetCode</code>题目解法-<a href="https://github.com/OctopusLian/leetcode-solutions" target="_blank" rel="noopener">地址</a></p></li><li><p>谈薪资要有底气，就跟做买卖，可以谈价格的，不要觉得<code>HR</code>给多少就是板上钉钉的事。</p></li></ul><p>如果觉得我写得不错或有用，欢迎转发，让更多的人避坑。</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 08:48:16 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;工作两年，想看看自己水
      
    
    </summary>
    
    
      <category term="面试经验" scheme="https://octopuslian.github.io/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="面试" scheme="https://octopuslian.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="经验" scheme="https://octopuslian.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
      <category term="夏季" scheme="https://octopuslian.github.io/tags/%E5%A4%8F%E5%AD%A3/"/>
    
  </entry>
  
  <entry>
    <title>程序员如何阅读英语资料</title>
    <link href="https://octopuslian.github.io/2020/06/17/how-programmers-read-english-materials/"/>
    <id>https://octopuslian.github.io/2020/06/17/how-programmers-read-english-materials/</id>
    <published>2020-06-17T13:38:26.000Z</published>
    <updated>2020-06-17T14:07:18.001Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 08:48:17 GMT+0800 (CST) --><h2 id="Rule-of-Five"><a href="#Rule-of-Five" class="headerlink" title="Rule of Five"></a>Rule of Five</h2><p><strong>“三天打渔两天晒网”是学英语的大忌。Consistency 是最重要的。</strong></p><p><img src="/2020/06/17/how-programmers-read-english-materials/rule-of-five.jpg" alt></p><p>每天你哪怕只认识一个单词，连着 365 天，你也可以有很大的成就，对吧？你每天哪怕只看两段文章，你一定要看；每天哪怕只听 5 分钟，你一定要听。这个才是练一项技能最重要的。一定要持久，而不是心血来潮去强调它的强度，要细水长流，水滴石穿。</p><p>今天我突然发现自己太忙了，没有办法看 5 页，我只能看两段，可以的，没问题，这个不算违反规则。没有时间的话，你做少一点，都没有关系。这是一个基本的方法，这也是学习唯一的方法。</p><h2 id="关于词汇"><a href="#关于词汇" class="headerlink" title="关于词汇"></a>关于词汇</h2><p><img src="/2020/06/17/how-programmers-read-english-materials/cihui.jpg" alt></p><p><strong>学词汇，不要背字典，我再跟你们强调，千万不要背字典。</strong></p><p><strong>首先，要找一本自己比较习惯使用的一个字典。</strong>我比较推荐用朗文词典。因为朗文词典上面有标准的真人朗读的音标和例句，还会告诉你美英怎么读音，英音怎么读。另外，它的解释也比较简单，用低级的词来解释高级的词。有的词典会用比较高级的词来解释一些低级的词，越查越糊涂。</p><p><strong>我让大家不要背单词，另一个原因是，词组其实更重要，</strong>特别是动词。动词有千变万化的词组，它后面可能跟 20 个不同的介词，这样的话就出来 20 个不同的意思，还有一些搭配。</p><p>在英语里，1 万个单词里有 2000 个单词是真正核心单词，你要把它学透。</p><p>所有那些你看了好像能想起来，但平时不跟你说话的叫被动词汇。天天跟你说话、经常跟你联系的叫主动词汇，那是真正的好朋友。那么主动词汇怎么学呢？</p><ul><li><p>第一，要知道它怎么读。</p></li><li><p>第二，要读它的例句。除此之外，这些词你要自己学会造句。你可以在例句基础之上你来做一个 preference。你可以去改写一下例句，把它变成自己的话。造句之后还没有完，你还要有意识地去主动运用你今天学的词汇，比如说你要给自己创造一个条件，比如今天给别人要写个 Email，或者在论坛上面要发个 issue 等等。刻意地去用一下词汇，然后多用几次之后，这个就变成你的主动词汇了。</p></li><li><p>定制一本自己的词汇手册。</p></li><li><p>或者用卡片，把卡片分成三大堆。第一堆是你已经背熟的，你真正的好朋友。第二堆是你刚刚认识的还不太熟的。第三堆是你今天记下来的完全不熟的。慢慢地把第三堆变成第二堆、第 1 堆。当然，第一堆也要经常拿出来复习一下。长久不联系，这个人也就生疏了，对吧？跟交朋友一样的道理，质量永远比数量要来得重要。这些核心词汇，你一定要把它吃透，这些才是你最后才能够用得出来的词。</p></li></ul><h2 id="关于语法"><a href="#关于语法" class="headerlink" title="关于语法"></a>关于语法</h2><p><img src="/2020/06/17/how-programmers-read-english-materials/yufa.jpg" alt></p><p><strong>看语法书、刷语法题，不是掌握语法的最好的途径。大量的阅读才是掌握语法的最好的方法。</strong></p><p>语法就是我们认识一座新城市的地图。</p><p>看地图也是有技巧的，切记不要夸大地图的作用。</p><p>语法永远是为内容服务，你不是为了学语法而学语法。</p><h2 id="关于阅读"><a href="#关于阅读" class="headerlink" title="关于阅读"></a>关于阅读</h2><p><img src="/2020/06/17/how-programmers-read-english-materials/yuedu.jpg" alt></p><p><strong>你要养成一个习惯。每天坚持多读一点，多少没关系，设定一个小一点的目标。另外，读的时候，要把所有的干扰全部都关掉，不要一心多用。</strong></p><p>读的话一定要读自己感兴趣的内容，不要硬逼自己去读不感兴趣的内容。</p><p>难易度一定要适中，不要去读自己完全看不懂的东西。</p><p><strong>阅读，读的永远是它的思想。读完一篇文章，你知道他讲了什么，它的中心思想是什么，而不是读某一个单词或者读某一个句子。</strong></p><h2 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h2><h3 id="有必要背诵新概念吗？"><a href="#有必要背诵新概念吗？" class="headerlink" title="有必要背诵新概念吗？"></a>有必要背诵新概念吗？</h3><p>如果你觉得不是那么难的话，我建议你还是要背下来。不要把背诵英文的这个目的太局限化。我们不是为了背而背，而是为了模仿语音语调。你可以找到原版的英国人的录音，去模仿他的语音语调。然后，你自己找一支录音笔，把自己背诵的内容录下来自己听。听完了之后，你再去对照原来新概念的录音，比较一下，看看差别在哪里。</p><p>练语音语调没有第二种方法，只能是模仿。新概念是一个比较好的模仿材料。它的难度相对来说比较适中，是从容易到难循序渐进的。如果你模仿得非常像，从第 1 册开始，一般背到第 3 册，你的语音语调基本上就没有什么太大的问题了。</p><h3 id="怎样才能读懂长难句？"><a href="#怎样才能读懂长难句？" class="headerlink" title="怎样才能读懂长难句？"></a>怎样才能读懂长难句？</h3><p>首先，你要了解英文句式的特点。中文的句子像一列火车，它就是一个车厢接一个车厢，一句话你可以用逗号一直点下去。但是英文它是一棵树，你永远可以找出它的主干，然后你可以找出它的树枝，找到树枝上面的花或者果实。你可以剥洋葱一样把它剥开，之后你大概就知道它是什么意思了，然后你在脑子里面再给它组织在一起就可以了。</p><p>再长的长句、难句，多么变态的句子，我们都可以找到主干。英语的长句怎么读？先从找主干开始。</p><h3 id="看美剧有帮助吗？"><a href="#看美剧有帮助吗？" class="headerlink" title="看美剧有帮助吗？"></a>看美剧有帮助吗？</h3><p>看美剧当然是有帮助的，而且毫无疑问会有很大的益处。</p><p>世界上所有的语言，我们可以粗粗地把它分成两类。一类我们叫 formal English，正式的英语，比如你做演讲的时候或者公司领导做报告的时候，那个时候都是讲很正式的英语。我们平时在课堂当中学的也都是这些 formal English。这些句子非常工整，主谓宾能够非常清楚地找出来的，用的词也都非常正式。</p><p>而我们美剧中大部分都是生活领域的，我们有时候叫 casual English，有时候也叫 kitchen English。不是说它 informal，只是它是比较日常的用语。你看美剧里面，人家插科打诨或者讲一个 joke，你听不懂，因为这个是日常生活的用语，往往是我们学英语的短板，是课堂当中没学过的。</p><h3 id="翻译文章是不是提高阅读能力比较自然的方法？"><a href="#翻译文章是不是提高阅读能力比较自然的方法？" class="headerlink" title="翻译文章是不是提高阅读能力比较自然的方法？"></a>翻译文章是不是提高阅读能力比较自然的方法？</h3><p>不是。除非你的工作跟翻译有关系，你需要把那篇文章翻成中文，或者把中文翻成英文，你有工作上面的需要，否则的话，没事不要去练翻译，浪费时间。阅读就是阅读，不要在阅读的过程当中，把每一篇文章都想着把它给它翻成中文，没有必要。你要 think in English，你要用英文学英文。阅读，你把它理解了就好了。</p><p>但是反过来，当你要把中文翻成英文的时候，这个时候考查的其实并不是你的翻译，考查的是你的英文写作能力。大家老觉得，是我翻译技巧不好，或者是我翻译上面是不是什么东西没学？不是的。</p><p>比如说，一篇 Email，你脑子里面想好中文了，你要把它用英文表达出来，你觉得有困难。你想用英文把一件事情讲清楚，但是你讲不清楚，或者你原本可以用 5 个字讲清楚，绕来绕去，现在你要用 50 个字才能讲清楚。这个不是你翻译技巧有问题，而是你英文不够好。所以，在整个学习的过程当中，只要打英语听说读写的基础就可以了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><p>刻意的练习其实是一个 active training，是一个需要你主动投入一些精力，非常专注的、抱着一些特定的目的去寻求一些教练的反馈，然后通过不断接收反馈找到自己练习过程当中的问题，再进行下一轮有意识的练习的过程。</p></li><li><p>练习，我们一直在强调，要重持久，而不是重你的练习强度。</p></li></ul><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 08:48:17 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;Rule-of-Five&quot;&gt;&lt;a href=&quot;#Rule-of-Five&quot; class=&quot;headerlink&quot; title=&quot;Rule of F
      
    
    </summary>
    
    
      <category term="English-Study" scheme="https://octopuslian.github.io/categories/English-Study/"/>
    
    
      <category term="英语阅读" scheme="https://octopuslian.github.io/tags/%E8%8B%B1%E8%AF%AD%E9%98%85%E8%AF%BB/"/>
    
      <category term="程序员" scheme="https://octopuslian.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
  </entry>
  
  <entry>
    <title>每周一起背10句</title>
    <link href="https://octopuslian.github.io/2020/06/17/geekbang-column-hlwrdyysjk-memorize-10-sentences-a-week/"/>
    <id>https://octopuslian.github.io/2020/06/17/geekbang-column-hlwrdyysjk-memorize-10-sentences-a-week/</id>
    <published>2020-06-17T13:23:28.000Z</published>
    <updated>2020-06-17T13:52:16.976Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 08:48:16 GMT+0800 (CST) --><h2 id="week-01"><a href="#week-01" class="headerlink" title="week 01"></a>week 01</h2><p>例句 1：The United States is a sports-minded country, with millions of fans who follow football, baseball, basketball and hockey, among other sports.<br>翻译：美国是一个体育意识很强的国家，有数以百万计的球迷关注足球、棒球、篮球和曲棍球等体育运动。</p><p>例句 2：The difference between proactive people and reactive people is that proactive people take initiative, and they come up with ideas to get things done despite the conditions they are in. Reactive people, on the other hand, usually are the ones to react to a situation rather than take initiative to create a situation.<br>翻译：积极主动的人和消极被动的人之间的区别在于，积极主动的人会采取主动，无论他们所处的环境如何，都会想出办法来完成任务；而消极被动型的人通常只会对形势做出被动的反应，而不会主动采取行动去创造形势。</p><p>例句 3：Don’t jump to conclusions! Perhaps it was his daughter he was dancing with.<br>翻译：别匆忙下结论，和他跳舞的没准是他女儿呢。</p><p>例句 4：The workers approached the manager with a request for shorter working hours.<br>翻译：工人们找经理要求减少工作时间。</p><p>例句 5：His sober approach to the crisis averted a catastrophe.<br>翻译：他对危机的冷静处理避免了一场大灾难。</p><p>例句 6：They take the time to understand how the business works, how the product fits in, and what its goals are.<br>翻译：他们会花时间去了解企业是如何商业运作的，产品又是如何配合商业运作，以及最终要达到什么样的商业目标。</p><p>例句 7：You need to work hard—opportunities don’t just come out of thin air.<br>翻译：你得努力啦，机会不会凭空产生（天上不会掉馅饼）。</p><p>例句 8：He is empathetic with the jobless youth, as he was also struggling for a job in his early years.<br>翻译：他对失业的年轻人感同身受，因为他自己早年也为找工作挣扎过。</p><p>例句 9：Social media technologies have given companies access to an unprecedented flood of new analytics, metrics and user data.<br>翻译：有了社交网络之后，企业获取了空前大量的新分析方法、度量指标和用户数据。</p><p>例句 10：Steve Jobs was a gifted communicator, and he used this skill to capture the attention of millions.<br>翻译：乔布斯是一个有天赋的沟通者，他用这种技巧吸引了数百万人的注意力。</p><h2 id="week-02"><a href="#week-02" class="headerlink" title="week 02"></a>week 02</h2><p>例句 1：Apple will unveil a 10-inch touchscreen tablet device in January, and ship the product in March.<br>翻译：苹果将于一月份推出 10 英寸触屏平板电脑，并于三月份发货。</p><p>例句 2：We define an iteration as a phase or a milestone.<br>翻译：我们将一次迭代定义为一个阶段或一个里程碑。</p><p>例句 3：Her husband was unsympathetic and she felt she had no one to turn to.<br>翻译：她的丈夫不懂得体恤人，她觉得无人可以依靠。</p><p>例句 4：Steve Jobs was a gifted communicator, and he used this skill to capture the attention of millions.<br>翻译：乔布斯是一个有天赋的沟通者，他用这种技巧吸引了数百万人的注意力。</p><p>例句 5：Life is full of trade-offs. You cannot have your cake and eat it too.<br>翻译：生活充满了取舍。鱼和熊掌不可兼得。</p><p>例句 6：Point Break was a breakout film for Kathryn Bigelow in 1991.<br>翻译：凯瑟琳·毕格罗于 1991 年拍摄了《惊爆点》，该片突破了她之前的风格。</p><p>例句 7：I have little knowledge of computer and business, can I still learn Navisio？<br>翻译：我对计算机和商业知之甚少，我还能学习 Navision 系统吗？</p><p>例句 8：I was juggling books, shopping bags and the baby.<br>翻译：我手里又是书，又是购物袋，还抱着孩子，跟演杂技一样。</p><p>例句 9：I’ve always felt that tragedy and comedy are two sides of the same coin. Love and hate are the opposite sides of the same coin.<br>祸福相依、爱恨交织。/ 塞翁失马焉知非福。</p><p>例句 10：My computer keeps going funny.<br>翻译：我的计算机老出故障。</p><h2 id="week-03"><a href="#week-03" class="headerlink" title="week 03"></a>week 03</h2><p>例句 1：You are strongly encouraged to save your document frequently, back-up regularly, and print your work-in-progress periodically.<br>翻译：强烈建议你们经常保存和备份，并且定期把写作过程中的文稿打印出来。</p><p>例句 2：What Jock had done was beyond my comprehension.<br>翻译：我无法理解乔克的所作所为。</p><p>例句 3：Major breakthroughs have been made in the reform of China’s ownership structure.<br>翻译：中国所有制结构改革也取得了重大突破。</p><p>例句 4：They bring suggestions and tradeoffs to the table, some of which are included in the revised spec.<br>翻译：他们会提供建议和取舍方案，其中某些建议会反映在修订后的产品设计规范中。</p><p>例句 5：After each project, their product understanding deepens, and they start to develop better and better product instincts.<br>翻译：每完成一个项目，他们对产品的理解就会加深，他们开始培养起越来越好的产品直觉。</p><p>例句 6：Children do not know by instinct the difference between right and wrong.<br>翻译：儿童并非生来就会分辨是非。</p><p>例句 7：Tell us what you bring to the table, not just what you want.<br>翻译：告诉我们你能给公司带来什么，而不仅仅是你想要什么。</p><p>例句 8：I’ve delivered the cash as you instructed. Now you must live up to your end of the bargain!<br>翻译：我已经按照你说的把钱送来了。现在该你履行承诺了！</p><p>例句 9：I don’t see the relevance of your question.<br>翻译：我不懂你提的这个问题有什么意义。（口气非常强烈甚至不礼貌）</p><p>例句 10：All happy families resemble one another, each unhappy family is unhappy in its own way.<br>翻译：幸福的家庭都是相似的，不幸的家庭各有各的不幸。</p><h2 id="week-04"><a href="#week-04" class="headerlink" title="week 04"></a>week 04</h2><p>例句 1：Although I don’t like him, I agree he is a good manager.<br>翻译：虽然我不喜欢他，但我承认他是一个出色的经理人。</p><p>例句 2：I’m sorry, I think sleep deprivation contributed to my outburst just then.<br>翻译：抱歉，睡眠不足让我刚才情绪失控了。</p><p>例句 3：The second benefit is teams’ ability to safely experiment and fail fast.<br>翻译：第二个好处是团队能够安全地进行实验并获得“快速失败”的能力。</p><p>例句 4：I empowered my agent to close the deal.<br>翻译：我授权我的经纪人完成这笔交易。</p><p>例句 5：The third benefit open source offers is a better way of building software.<br>翻译：开源的第三个好处是提高软件开发质量。</p><p>例句 6：Well, my mom is really sick, which means that we might have exposed the kids to the flu virus when we had her watch them last week.<br>翻译：嗯，我妈妈病得很重，这意味着上周我们让她看孩子的时候，可能已经让他们接触了流感病毒。</p><p>例句 7：As an immediate result, their teams doubled the amount of code that was developed and shared, which directly reduced the amount and cost of redundant code.<br>翻译：立竿见影的结果是团队将开发和共享的代码量增加了一倍，直接减少了冗余代码的数量和成本。</p><p>例句 8：According to Aitken, the quality of the code increased dramatically because it was exposed to everyone inside the organization.<br>翻译：按照埃特金的说法，由于代码对组织内每一个人开放，代码的质量得以大幅提升。</p><p>例句 9：This led to software developers taking more care in the software they were writing.<br>翻译：这也使得软件开发人员在编写软件时更加用心。</p><p>例句 10：Open source is evolving at a rapid pace, and developers learn new open source technologies every few years.<br>翻译：开源软件发展迅猛，开发人员每隔几年就要学习新的开源技术。</p><h2 id="week-05"><a href="#week-05" class="headerlink" title="week 05"></a>week 05</h2><h3 id="第一段"><a href="#第一段" class="headerlink" title="第一段"></a>第一段</h3><p>For both employees and employers, remote work requires intentional design and implementation to be effective. People find remote work challenging because the established mindset says that being in an office is how work gets done. Remote workers also need to prioritize their mental health, by taking breaks, getting exercise, and having a social life. Despite the challenges, when remote work is done well, the advantages to employees and employer are sufficient to make it worthwhile.<br>无论对于雇员还是雇主，要想使远程工作有效，需要双方有心地设计和实施。人们感觉远程工作很有挑战性，是因为固有的思维模式都认为，去办公室上班才是完成工作的方式。远程工作者还需要通过休息、锻炼和社会生活，来优先保障他们的心理健康。尽管存在挑战，但只要安排得当，远程工作给雇员和雇主带来的好处都足以使其值得一试。</p><h3 id="第二段"><a href="#第二段" class="headerlink" title="第二段"></a>第二段</h3><p>The first starting point for remote employees is to have clear separation between home and work. This can be done through physical separation, by having a dedicated home office, or even working at a shared-work facility, such as Regus or WeWork. It is also helpful to have a transition point, something to replace a commute, that delineates the shift from being at home to being at work. Some people have found taking their dog for a walk, or simply going out the front door and coming in the back door of their house is enough to make the mental shift and start focusing on work.<br>员工在家远程工作，首先要把家和工作分开。要实现这一点，可以通过物理隔断，在家专设办公区或者干脆去共享工作空间（例如雷格斯或者 WeWork 等共创空间）。有时也可以人为设定一个取代通勤的转换点，作为从在家状态到工作状态的切换标志。有人发现，带狗出去散步，或者只是从前门出后门回，就足以使他们在心理上实现这种切换，并开始专注工作。</p><h3 id="第三段"><a href="#第三段" class="headerlink" title="第三段"></a>第三段</h3><p>Successful remote work is not just up to the employees. Companies and managers must make extra effort to exhibit transparency and establish trust, because you don’t have benefits of casual conversation and body language like you would working in the same location. Psychological safety is needed for remote working, and this means managers must be prepared to be vulnerable. Once a manager shows they are comfortable sharing something difficult, then employees will be more comfortable reciprocating. Humble said, “You have to fundamentally trust people because you can’t see what they do. They have to tell you.”<br>远程工作的成功不仅仅取决于员工。公司和管理者们必须做出额外的努力来展示透明度和建立信任，因为不在同一屋檐下共事，就无法享受轻松面谈和肢体语言的便利。远程工作需要心理安全感，这意味着经理们必须做好准备展现自己的脆弱一面。如果管理者乐于分享自己的难处，那么员工也就会乐于敞开心扉。亨堡说：“你必须完全信任他人，因为你看不到他们在做什么，必须由他们告诉你才行。”</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 08:48:16 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;week-01&quot;&gt;&lt;a href=&quot;#week-01&quot; class=&quot;headerlink&quot; title=&quot;week 01&quot;&gt;&lt;/a&gt;week 0
      
    
    </summary>
    
    
      <category term="English-Study" scheme="https://octopuslian.github.io/categories/English-Study/"/>
    
    
      <category term="英语" scheme="https://octopuslian.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
      <category term="背诵" scheme="https://octopuslian.github.io/tags/%E8%83%8C%E8%AF%B5/"/>
    
  </entry>
  
  <entry>
    <title>一篇文章了解基本的Java语法</title>
    <link href="https://octopuslian.github.io/2020/06/16/geekbang-column-sjmszm-learn-all-the-java-syntax-used-in-the-column/"/>
    <id>https://octopuslian.github.io/2020/06/16/geekbang-column-sjmszm-learn-all-the-java-syntax-used-in-the-column/</id>
    <published>2020-06-16T13:22:01.000Z</published>
    <updated>2020-07-02T16:00:54.317Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 08:48:17 GMT+0800 (CST) --><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>在 Java 中，所有的代码都必须写在类里面，所以，我们定义一个 HelloWorld 类。main() 函数是程序执行的入口。main() 函数中调用了 Java 开发包 JDK 提供的打印函数 System.out.println() 来打印 hello world 字符串。除此之外，Java 中有两种代码注释方式，第一种是“// 注释…”双斜杠，表示后面的字符串都是注释，第二种是“/* 注释…*/”，表示中间的内容都是注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*hello world程序*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>); <span class="comment">//打印Hello World</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ul><li><p>整型类型：byte（字节）、short（短整型）、int（整型）、long（长整型）</p></li><li><p>浮点类型：float（单精度浮点）、double（双精度浮点）</p></li><li><p>字符型：char</p></li><li><p>布尔型：boolean</p></li></ul><p>定义一个基本类型变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>除此之外，为了方便我们使用，Java 还提供了一些封装这些基本数据类型的类，这些类实现了一些常用的功能函数，可以直接拿来使用。常用的有下面几个类：</p><ul><li><p>Integer：对应封装了基本类型 int；</p></li><li><p>Long：对应封装了基本类型 long；</p></li><li><p>Float：对应封装了基本类型 float；</p></li><li><p>Double：对应封装了基本类型 double；</p></li><li><p>Boolean：对应封装了基本类型 boolean；</p></li><li><p>String：对应封装了字符串类型 char[]。</p></li></ul><p>定义一个 Integer 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer oa = <span class="keyword">new</span> Integer(<span class="number">6</span>);</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>Java 中，我们使用[]来定义一个数组，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">//定义了一个长度是10的int类型数组</span></span><br></pre></td></tr></table></figure><p>在 Java 中，我们通过如下方式访问数组中的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">1</span>] = <span class="number">3</span>; <span class="comment">//将下标是1的数组元素赋值为3</span></span><br><span class="line">System.out.println(a[<span class="number">2</span>]); <span class="comment">//打印下标是2的数组元素值</span></span><br></pre></td></tr></table></figure><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><ul><li>if-else 语句，代码示例如下所示：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用法一</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">//执行代码块</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//执行代码块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法二</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">//执行代码块</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">//执行代码块</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//执行代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>switch-case 语句，代码示例如下所示：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">switch</span> (a) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="comment">//执行代码块</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="comment">//执行代码块</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">//默认执行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>for、while 循环，代码示例如下所示：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">  <span class="comment">// 循环执行10次此代码块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="comment">// 循环执行10次此代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>continue、break、return，代码示例如下所示：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>; <span class="comment">//跳过本次循环，不会打印出4这个值</span></span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">//提前终止循环，只会打印0、1、2、3</span></span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">//结束一个函数，从此处返回</span></span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类、对象"><a href="#类、对象" class="headerlink" title="类、对象"></a>类、对象</h2><p>Java 语言使用关键词 class 来定义一个类，类中包含成员变量（也叫作属性）和方法（也叫作函数），其中有一种特殊的函数叫作构造函数，其命名比较固定，跟类名相同。除此之外，Java 语言通过 new 关键词来创建一个类的对象，并且可以通过构造函数，初始化一些成员变量的值。代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123; <span class="comment">// 定义了一个Dog类</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age; <span class="comment">// 属性或者成员变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(<span class="keyword">int</span> age, <span class="keyword">int</span> weight)</span> </span>&#123; <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="comment">// 函数或者方法</span></span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeigt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> weight;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog dog1 = <span class="keyword">new</span> Dog(<span class="number">2</span>, <span class="number">10</span>);<span class="comment">//通过new关键词创建了一个Dog对象dog1</span></span><br><span class="line"><span class="keyword">int</span> age = dog1.getAge();<span class="comment">//调用dog1的getAge()方法</span></span><br><span class="line">dog1.run();<span class="comment">//调用dog1的run()方法</span></span><br></pre></td></tr></table></figure><h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><p>在前面的代码示例中，我们多次用到 private、public，它们跟 protected 一起，构成了 Java 语言的三个权限修饰符。权限修饰符可以修饰函数、成员变量。</p><ul><li>private 修饰的函数或者成员变量，只能在类内部使用。</li><li>protected 修饰的函数或者成员变量，可以在类及其子类内使用。</li><li>public 修饰的函数或者成员变量，可以被任意访问。</li></ul><p>对于权限修饰符的理解，我们可以参看下面的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;<span class="comment">// public修饰类</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age; <span class="comment">// private修饰属性，只能在类内部使用</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(<span class="keyword">int</span> age, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="comment">//public修饰的方法，任意代码都是可以调用</span></span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>Java 语言使用 extends 关键字来实现继承。被继承的类叫作父类，继承类叫作子类。子类继承父类的所有非 private 属性和方法。具体的代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123; <span class="comment">// 父类</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> weight;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(<span class="keyword">int</span> age, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="comment">// 函数或者方法</span></span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeigt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> weight;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; <span class="comment">// 子类</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(<span class="keyword">int</span> age, <span class="keyword">int</span> weight)</span> </span>&#123; <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">super</span>(age, weight); <span class="comment">//调用父类的构造函数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wangwang</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; <span class="comment">//子类</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">(<span class="keyword">int</span> age, <span class="keyword">int</span> weight)</span> </span>&#123; <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">super</span>(age, weight); <span class="comment">//调用父类的构造函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">miaomiao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用举例</span></span><br><span class="line">Dog dog = <span class="keyword">new</span> Dog(<span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line">dog.run();</span><br><span class="line">dog.wangwang();</span><br><span class="line">Cat cat = <span class="keyword">new</span> Cat(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">cat.run();</span><br><span class="line">cat.miaomiao();</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Java 语言通过 interface 关键字来定义接口。接口中只能声明方法，不能包含实现，也不能定义属性。类通过 implements 关键字来实现接口中定义的方法。在专栏的第 8 讲中，我们会详细讲解接口，所以，这里我只简单介绍一下语法。具体的代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> age; <span class="comment">// 属性或者成员变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(<span class="keyword">int</span> age, <span class="keyword">int</span> weight)</span> </span>&#123; <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="comment">// 函数或者方法</span></span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeigt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> weight;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">//实现接口中定义的run()方法</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>Java 提供了一些现成的容器。容器可以理解为一些工具类，底层封装了各种数据结构。比如 ArrayList 底层就是数组，LinkedList 底层就是链表，HashMap 底层就是散列表等。这些容器我们可以拿来直接使用，不用从零开始开发，大大提高了编码的效率。具体的代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoA</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;User&gt; users;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    users.add(user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>Java 提供了异常这种出错处理机制。我们可以指直接使用 JDK 提供的现成的异常类，也可以自定义异常。在 Java 中，我们通过关键字 throw 来抛出一个异常，通过 throws 声明函数抛出异常，通过 try-catch-finally 语句来捕获异常。代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserNotFoundException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123; <span class="comment">// 自定义一个异常</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserNotFoundException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserNotFoundException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(message);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserNotFoundException</span><span class="params">(String message, Throwable e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(message, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> UserRepository userRepo;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">(UseRepository userRepo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userRepo = userRepo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(<span class="keyword">long</span> userId)</span> <span class="keyword">throws</span> UserNotFoundException </span>&#123;</span><br><span class="line">    User user = userRepo.findUserById(userId);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123; <span class="comment">// throw用来抛出异常</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> UserNotFoundException();<span class="comment">//代码从此处返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> UserService userService;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserController</span><span class="params">(UserService userService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userService = userService;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(<span class="keyword">long</span> userId)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">//捕获异常</span></span><br><span class="line">      user = userService.getUserById(userId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UserNotFoundException e) &#123;</span><br><span class="line">      System.out.println(<span class="string">"User not found: "</span> + userId);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; <span class="comment">//不管异常会不会发生，finally包裹的语句块总会被执行</span></span><br><span class="line">      System.out.println(<span class="string">"I am always printed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="package-包"><a href="#package-包" class="headerlink" title="package 包"></a>package 包</h2><p>Java 通过 pacakge 关键字来分门别类地组织类，通过 import 关键字来引入类或者 package。具体的代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*class DemoA*/</span></span><br><span class="line"><span class="keyword">package</span> com.xzg.cd; <span class="comment">// 包名com.xzg.cd</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoA</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*class DemoB*/</span></span><br><span class="line"><span class="keyword">package</span> com.xzg.alg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap; <span class="comment">// Java工具包JDK中的类</span></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> com.xzg.cd.DemoA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoB</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 08:48:17 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;Hello-World&quot;&gt;&lt;a href=&quot;#Hello-World&quot; class=&quot;headerlink&quot; title=&quot;Hello World
      
    
    </summary>
    
    
      <category term="Java学习" scheme="https://octopuslian.github.io/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://octopuslian.github.io/tags/Java/"/>
    
      <category term="语法" scheme="https://octopuslian.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2020年市场行情如何？我该跳槽吗？</title>
    <link href="https://octopuslian.github.io/2020/06/16/geekbang-live-2020-how-is-the-market-this-year-should-i-switch-jobs/"/>
    <id>https://octopuslian.github.io/2020/06/16/geekbang-live-2020-how-is-the-market-this-year-should-i-switch-jobs/</id>
    <published>2020-06-16T12:27:34.000Z</published>
    <updated>2020-06-16T13:23:31.611Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 08:48:17 GMT+0800 (CST) --><h2 id="直播介绍"><a href="#直播介绍" class="headerlink" title="直播介绍"></a>直播介绍</h2><p>直播嘉宾：Bendy PAN，资深技术猎头。</p><h2 id="如何正确地选择工作机会"><a href="#如何正确地选择工作机会" class="headerlink" title="如何正确地选择工作机会"></a>如何正确地选择工作机会</h2><ul><li>结合市场趋势和自身优点。</li><li>兼顾自己的兴趣爱好，抬头看天，脚踏实地，少走弯路。</li><li>对于暂时够不到的位置：定高目标，努力拼搏。</li><li>职位推荐渠道的选择：直投，内推和猎头</li></ul><h2 id="如何更好地准备面试"><a href="#如何更好地准备面试" class="headerlink" title="如何更好地准备面试"></a>如何更好地准备面试</h2><ul><li>针对目标公司要求做更加充分的准备；</li><li>有针对性地优化简历，理顺简历上所做过的任何一个项目，最好连上下游都要了解；</li><li>项目中可能遇到的技术细节着重复习（针对初级和中级岗位）。</li></ul><h2 id="如何更好地准备面试-1"><a href="#如何更好地准备面试-1" class="headerlink" title="如何更好地准备面试"></a>如何更好地准备面试</h2><ul><li>有针对性地刷题；</li><li>对于高级岗位，架构和设计也要列入复习的范围；</li><li>对于管理岗位，更加注重沟通和软技能。</li></ul><h2 id="如何优雅地谈薪资"><a href="#如何优雅地谈薪资" class="headerlink" title="如何优雅地谈薪资"></a>如何优雅地谈薪资</h2><ul><li>尽可能详细列出自己目前可能有的收入并提供相应的材料证明；</li><li>根据市场信息，结合整个面试的自我认知，综合给出一个自己的期望；</li><li>诚实稳重，守住自己的底线，但也不要好高骛远，漫天要价；</li><li>参考网上信息，但也要细分自己所处的细分领域职位。</li></ul><h2 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h2><h3 id="从二线和一线薪资涨幅怎么算"><a href="#从二线和一线薪资涨幅怎么算" class="headerlink" title="从二线和一线薪资涨幅怎么算"></a>从二线和一线薪资涨幅怎么算</h3><p>衣食住行算进去，再涨个30%~40%。</p><h3 id="一开始工资就很低怎么办"><a href="#一开始工资就很低怎么办" class="headerlink" title="一开始工资就很低怎么办"></a>一开始工资就很低怎么办</h3><p>看机会，只能尽可能让HR帮你涨薪。</p><h3 id="去银行之类可行吗"><a href="#去银行之类可行吗" class="headerlink" title="去银行之类可行吗"></a>去银行之类可行吗</h3><p>技术比较传统，因为还是要求稳。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>字节跳动，外企比较注重算法；</li><li>一般5-10年工作经验，涨幅在30~40%左右比较合适；</li><li>找一些同行里比较厉害的，帮你做下系统性的规划；</li><li>选择计算机行业就注定要不断、积极地努力学习；</li></ul><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 08:48:17 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;直播介绍&quot;&gt;&lt;a href=&quot;#直播介绍&quot; class=&quot;headerlink&quot; title=&quot;直播介绍&quot;&gt;&lt;/a&gt;直播介绍&lt;/h2&gt;&lt;p&gt;直播嘉
      
    
    </summary>
    
    
      <category term="直播分享" scheme="https://octopuslian.github.io/categories/%E7%9B%B4%E6%92%AD%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="职业规划" scheme="https://octopuslian.github.io/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/"/>
    
      <category term="市场行情" scheme="https://octopuslian.github.io/tags/%E5%B8%82%E5%9C%BA%E8%A1%8C%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>English_Article 3：Successful Remote Working</title>
    <link href="https://octopuslian.github.io/2020/06/14/geekbang-column-article-3-successful-remote-working/"/>
    <id>https://octopuslian.github.io/2020/06/14/geekbang-column-article-3-successful-remote-working/</id>
    <published>2020-06-14T06:50:26.000Z</published>
    <updated>2020-06-17T13:21:37.718Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 08:48:16 GMT+0800 (CST) --><p><a href="https://www.infoq.com/news/2020/03/successful-remote-working/" target="_blank" rel="noopener">Successful Remote Working</a><br>这篇文章主要探讨如何成功地进行远程工作。</p><h1 id="导读：如何逐渐培养阅读习惯，快速抓住文章大意？"><a href="#导读：如何逐渐培养阅读习惯，快速抓住文章大意？" class="headerlink" title="导读：如何逐渐培养阅读习惯，快速抓住文章大意？"></a>导读：如何逐渐培养阅读习惯，快速抓住文章大意？</h1><h2 id="文章背景"><a href="#文章背景" class="headerlink" title="文章背景"></a>文章背景</h2><p>远程工作这个话题最近比较火。新冠肺炎的疫情爆发之后，为保持社交距离（social distancing），压制病毒传播，很多企业都会要求员工在家办公（work from home）。但是，远程办公其实并不是一个新话题。出于各种目的，例如政府为缓解城市交通压力，企业为减少员工通勤成本（交通费用在其次，更宝贵的是时间）、个人为躲避雾霾等严重污染的环境，远程办公被越来越多的企业所接受。</p><p>在开始讲解这篇文章之前，我们来比较一下 work from home 和 work at home 这两个短语的区别。从某种意义上讲，这两个短语的区别其实就是远程工作和自由职业（self-employed）之间的区别。</p><p>work from home 给人的感觉是，工作的中心仍然还是公司，但出于各种原因我在家完成工作，但最后还是汇聚到公司这个中心去的。而 work at home 表示，我平时常态的工作地点就是家里，我的家就是我工作的中心。大部分没有固定工作的自由职业者基本就是这种状态，比如，自媒体作家、网红主播、翻译等等。</p><p>当然，work at home 也可以指，我有私人的一些事情，要在家干一些活。例如我打电话给朋友说：“Sorry dude, I cannot accompany you. I have work at home.”，指的就是“我没法陪你了，我在家有活要干”。这一语境下一般指临时性的一些 work，例如修水管、打扫卫生之类的。</p><h2 id="全篇通读"><a href="#全篇通读" class="headerlink" title="全篇通读"></a>全篇通读</h2><p><strong>首先，我们可以借鉴检索阅读（inspectionalreading）中的略读法（pre-reading or skim，也可以叫粗读法），来了解这篇文章的梗概。</strong></p><blockquote><p>For both <strong>employees and employers</strong>, remote work requires <strong>intentional design</strong> and implementation to be effective. People find remote work challenging because the <strong>established mindset</strong> says that being in an office is how work gets done. Remote workers also need to prioritize their mental health, by taking breaks, getting exercise, and having a social life. Despite the challenges, when remote work is done well, the <strong>advantages</strong> to employees and employer are sufficient to make it worthwhile.<br>无论对于<strong>雇员</strong>还是<strong>雇主</strong>，要想使远程工作有效，需要双方<strong>有心的设计</strong>和实施。人们感觉远程工作很有挑战性，是因为<strong>固有的思维模式</strong>都认为，去办公室上班才是完成工作的方式。远程工作者还需要通过休息、锻炼和社会生活，来优先保障他们的<strong>心理健康</strong>。尽管存在挑战，但只要安排得当，远程工作给雇员和雇主带来的<strong>好处</strong>都足以使其值得一试。</p></blockquote><p>第一段往往是文章的总起段落，通常会概述整篇文章的核心思想。我理解的关键思想包括下面 5 点：</p><ul><li>远程工作是老板和员工两方面的事情；</li><li>需要专门的设计；</li><li>要打破固有思维模式；</li><li>要关注心理健康问题；</li><li>利大于弊。</li></ul><p>接着来看下一段。</p><blockquote><p>These were some of the key takeaways expressed by Charles Humble during his presentation at QCon London 2020, titled “Remote Working Approaches That Worked (and Some That Didn’t).” Humble’s opinions are based on his experience working at C4 Media, a remote-only company, and the parent organization of InfoQ and QCon.</p></blockquote><p>看完这段我们可以知道，这篇文章是一个叫 Charles Humble 的人，在今年伦敦 QCon 软件开发大会上的一篇演讲，题目叫《远程工作好方法（和坏方法）》。接着，这段话还专门介绍了演讲者依据的是他在 C4 Media（InfoQ 和 QCon 的母公司）的工作经验提出的观点，而 C4 Media 又是一家全员远程工作的组织。</p><p>继续看下一段。这段讲了现在疫情要保持社交距离，使得更多人在家工作。</p><blockquote><p>Because many additional people are working from home due to social distancing, QCon has made the video recording of the presentation immediately available on InfoQ.</p></blockquote><p>我们可以看到，以上两段都是实用信息，不是文章的观点和内容。</p><blockquote><p><strong>The first starting point for remote employees is to have clear separation between home and work.</strong> This can be done through physical separation, by having a dedicated home office, or even working at a shared-work facility, such as Regus or WeWork. It is also helpful to have a transition point, something to replace a commute, that delineates the shift from being at home to being at work. Some people have found taking their dog for a walk, or simply going out the front door and coming in the back door of their house is enough to make the mental shift and start focusing on work.<br><strong>员工在家工作，第一要务就是把家和工作分开。</strong></p></blockquote><p>联系第一段里讲远程工作的挑战来自传统观念，即家不是工作的地方，所以远程工作者需要想办法把日常家庭生活和工作分开。后面的内容应该是这一问题的展开。</p><blockquote><p><strong>Successful remote work is not just up to the employees.</strong> Companies and managers must make extra effort to exhibit transparency and establish trust, because you don’t have benefits of casual conversation and body language like you would working in the same location. Psychological safety is needed for remote working, and this means managers must be prepared to be vulnerable. Once a manager shows they are comfortable sharing something difficult, then employees will be more comfortable reciprocating. Humble said, “You have to fundamentally trust people because you can’t see what they do. They have to tell you.”<br><strong>远程工作要想成功，不仅仅靠员工。</strong></p></blockquote><p>不仅靠员工，那就还要靠老板、靠公司。这段应该讨论公司的管理层在这个问题上应该怎么做，要扮演什么角色。</p><blockquote><p><strong>Establishing a high level of trust among remote managers and employees starts with having good meeting rituals.</strong> Meetings should be conducted on video if at all possible, and start with a “check in” for each team member. The check in lets people state how they are feeling that day, and what else is going on that may be affecting their mood or productivity. Managers must lead by example, because what you do is more important than what you say. For more suggestions on meeting rituals, Humble recommended the High-Performance Teams mini-book by Richard Kasperowski, author of The Core Protocols.<br><strong>经理和员工之间的高度信任，始于一套好的会议仪式。</strong></p></blockquote><p>这句话字面意思听着有点翻译腔，你可以猜一下这段的内容：首先要开会，尽管人在家不去公司了，但远程会议还是要开的；第二，开会要有仪式感，不能太随意。大方向应该逃不出这些内容。</p><blockquote><p><strong>An established calendar of regular meetings also helps create structure for distributed teams.</strong> A daily huddle takes the place of a “standup.” Because remote teams build a higher level of independence than co-located teams, this may only need to occur twice per week to keep everyone aligned.<br><strong>定期的会议日程安排有助于为分散的团队建立结构。</strong></p></blockquote><p>整个团队都在办公室，每天按部就班比较容易碰头和安排工作，很有组织感，但分散在各处自家办公，队伍容易散漫，日子也容易过糊涂，所以需要通过一些定期的安排来建立这种组织秩序。</p><blockquote><p><strong>One-on-one meetings between employee and manager are extremely important, and must be treated as sacrosanct.</strong> These meetings are for the employee, with discussions about their career and other personal concerns. Humble had two absolute rules: The one-on-one is not a status meeting, and managers should never be allowed to cancel the meeting.<br><strong>员工和经理一对一的会议也很重要。</strong></p></blockquote><p>前面两段讲的开大会，这段应该讲经理和员工一对一开小会。有效沟通是管理的核心，私密的沟通机制当然也是其中的重要一环。</p><blockquote><p><strong>Strategic discussions are very challenging to have remotely, so these will usually occur when everyone involved can meet in person, which is every four months for C4, and coincides with QCon scheduling.</strong> C4 has an annual “all hands” meeting that lasts for four days, which also involves flying everyone into one location. This is obviously very expensive and a logistical challenge, but is extremely valuable. While everyone does not need to be co-located all the time, there are some situations which are only really effective when a team is all together. These include strategic discussions and just help re-enforce the bonds between team members.<br>战略性的讨论很难远程进行，通常需要见面开会。</p></blockquote><p>前面几段说的都是日常管理，但特别重大的会议用视频的方式就不够了，需要专门安排正式的会议。这是很自然的，即使是远程工作，也不会一年都不见一次面的。</p><blockquote><p><strong>Humble shared a list of tools he and C4 have used.</strong> Slack for IM; Zoom for video conferencing; Workplace for “water cooler”-like chats; Google Docs for remote collaboration; and 15Five for private retrospectives. While these work for his team, many options exist. The important thing is to try and find what works effectively in your situation, because bad tooling can have a serious effect on remote working.<br><strong>Humble（演讲人）分享了一堆 C4 用的工具。</strong></p></blockquote><p>自然是远程工作的工具（Zoom 之类的），疫情之后，家喻户晓。据我所知，现在督促孙辈上网课的爷爷奶奶们都是“Zoom 专家”。</p><p>接下来，最后一段通常是总结段，我们全部通读一遍。我也在英文原文和中文翻译中标黑了我认为的关键内容。总结起来讲就是，远程工作有得有失，所以成本不是问题，心理健康才是关键问题。怎么样才能健康呢？要工作团队信任开放，要家庭社交克服孤独，还要有健康的生活方式。</p><blockquote><p>While remote work is very appealing to some employees, it does come with some trade-offs. Although the time and costs associated with commuting disappear, new costs may be incurred from premium high-speed internet, a good laptop, a nice desk, and especially a good office chair. A subject not often, or easily, discussed regarding remote work is mental health. Burnout is a real, serious issue, and is endemic in IT. Trust and openness is critically important, and allows team members to recognize when someone is struggling, and help them cope, including seeking professional help. Loneliness can also be a problem, and it takes active effort to make your family and your social life a real priority. Pets, exercise, and getting into nature can also help improve mental well-being.<br>虽然远程工作对某些员工非常有吸引力，但有得必有失。与上下班相关的时间和财务成本消失了，但是会产生新的成本去购置高速上网服务、好的笔记本电脑、漂亮的办公桌、特别是一张舒服的办公椅。远程工作的另一个不经常或不容易讨论的话题是心理健康。职业倦怠是一个现实而严重的问题，并且在 IT 行业普遍存在。信任和坦诚至关重要，只有这样团队成员才能够发现正在挣扎的同事，并及时帮助他们，包括寻求专业的帮助。孤独也是一个问题，让家庭和社交真正成为生活重心是需要你为之付出积极努力的。宠物、锻炼和亲近大自然也可以帮助改善心理健康。</p></blockquote><h1 id="为什么介词如此“烦人”？"><a href="#为什么介词如此“烦人”？" class="headerlink" title="为什么介词如此“烦人”？"></a>为什么介词如此“烦人”？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">For both employees and employers, remote work requires intentional design and implementation to be effective. People find remote work challenging because the established mindset says that being in an office is how work gets done. Remote workers also need to prioritize their mental health, by taking breaks, getting exercise, and having a social life. Despite the challenges, when remote work is done well, the advantages to employees and employer are sufficient to make it worthwhile.</span><br><span class="line">无论对于雇员还是雇主，要想使远程工作有效，需要双方有心地设计和实施。人们感觉远程工作很有挑战性，是因为固有的思维模式都认为，去办公室上班才是完成工作的方式。远程工作者还需要通过休息、锻炼和社会生活，来优先保障他们的心理健康。尽管存在挑战，但只要安排得当，远程工作给雇员和雇主带来的好处都足以使其值得一试。</span><br></pre></td></tr></table></figure><h2 id="知识讲解"><a href="#知识讲解" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="宾语补足语"><a href="#宾语补足语" class="headerlink" title="宾语补足语"></a>宾语补足语</h3><blockquote><p>For both employees and employers, remote work requires intentional design and implementation <strong>to be effective.</strong> People find remote work <strong>challenging because the established mindset says that being in an office is how work gets done.</strong></p></blockquote><p>所谓“宾语补足语”，就是谓语及物动词后面接了宾语，但意思仍然不完整，需要继续加一个补充说明，明确宾语的状态。这个补充说明的句子成分，就是宾语补足语。宾语和后面的补足语组成复合宾语。宾语一般是名词或代词。补足语可以是名词、形容词、副词、介词短语、现在分词、过去分词也可以是动词不定式或从句等。补足语英语叫 complement，to complete the meaning，使意思完整。</p><p>第一句话，主语是本篇的主题词 remote work，谓语动词是 requires，远程工作需要，需要什么呢？后面接了宾语 intentional design and implementation，有意（或有心）的设计和执行，之后还加了一个不定式 to be effective，使其有效。远程工作需要有心的设计和执行才能有效。例句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：Does he understand the need to keep everything secret?</span><br><span class="line">翻译：他知道所有这一切都要保密吗？</span><br></pre></td></tr></table></figure><p>第二句话，主语 people，谓语动词 find，宾语 remote work，人们发现远程工作，怎么样呢？需要补充说明，后面跟了一个分词 challenging（词性为形容词，类似于 interesting、exciting 等），很有挑战，意思才完整。我们再来看一个类似的例句，例句中的现在分词更具有动词性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：Shelly spends all her time gardening.</span><br><span class="line">翻译：雪莉把她所有的时间都花在园艺上。</span><br></pre></td></tr></table></figure><p>最后我们再来看一下 because 引导的状语从句。</p><p>首先，状语从句的主语是 established mindset，已经建立起来的思维，就是固有的思维或者传统的思维。谓语动词是 says，传统思维说，说什么呢？宾语是一个 that 引导的从句，宾语从句的主语是 being in an office，后面是系动词 is，一看就知道是系表结构。is 后面是最小的套娃，即表语从句，how work gets done，去办公室（去上班）才是工作的正确姿势。</p><p>英文结构分析起来觉得好复杂，但把这整句话翻译成中文之后，我们会发现，其实一点也不复杂，就是“传统思维认为去办公室上班才算工作”。</p><h3 id="介词-by"><a href="#介词-by" class="headerlink" title="介词 by"></a>介词 by</h3><blockquote><p>Remote workers also need to prioritize their mental health, by taking breaks, <strong>getting exercise, and having a social life.</strong></p></blockquote><p>这句话本身不复杂，主句的意思也很直白，“在家工作的人要把心理健康放在第一位”。但我们来看一下后面的介词短语by doing something，这里它来做主句的方式状语，这里好似强调实现心理健康的一些方式，例如劳逸结合、多做运动、社交生活等。</p><p>介词，英文叫 preposition。pre- 是表示“在前”的前缀。position 是位置。顾名思义，我们可以把它理解为“前置词”，后面可以跟名词性质的宾语。所谓名词性质，指的是名词、代词或者其他具有名词性质的词类、短语或从句。而介词和介词宾语共同组成介词短语。</p><p>介词非常重要，因为：</p><ul><li><p>第一，介词是英语中的高频词，几乎无处不在。</p></li><li><p>第二，介词在英语的句子里起到穿针引线的“桥梁”作用。介词的“介”，在汉语中第一个意思就是“在两者之间”，可以组成“媒介”“介绍”等词语，所以介词的本质在于表示对象间的关系。大多数英语介词的本源义都是用来描述空间关系，包括空间位置（例如 on、at、in 等，为静态）和空间运动（如 off、over、down 等，为动态）的关系。在空间关系的基础上，我们可以进一步引申出时间关系、抽象关系等。<br><img src="/2020/06/14/geekbang-column-article-3-successful-remote-working/jieci.png" alt></p></li><li><p>第三，介词使用范围广泛，变化繁多。</p></li></ul><p>介词和名词、动词、形容词等进行的搭配大多是约定俗成的，例如 the reason for、arrive at、angry with 等。</p><p>此外，介词和动词搭配后会产生丰富的含义。比如，out 可以和 600 多个动词搭配产生不同的含义。再比如，get、take、put、make、turn 等本身含义不是很明确的弱势动词，可以和十几个甚至数十个不同的介词搭配产生不同的短语。这些搭配产生的短语含义丰富，但大多数没有办法根据字面猜测其含义，必须理解并记忆整个短语。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：I wanted to know if she could put me up for a few days.</span><br><span class="line">翻译：我想知道她能否收留我住几天。（put up 在这里是“提供食宿”的意思，按字面我们很难猜出其含义。）</span><br></pre></td></tr></table></figure><p>回头我们来看这句话中 by 这个介词。前面我们说过，大多数英语介词的本源义都是用来描述空间关系，<strong>by 在静态的空间位置上有“在旁边、靠近”的意思，</strong>类似于 next to/near/beside 等，但意思相近的介词之间也有微妙的差别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例句：Stanley lives by the sea.</span><br><span class="line">翻译：斯坦利住在海边。（可以看得见海的那种）</span><br><span class="line"></span><br><span class="line">例句：Stanley lives near the sea.</span><br><span class="line">翻译：斯坦利家离海边不远。（差不多住在几公里以外）</span><br></pre></td></tr></table></figure><p><strong>by 在动态的空间运动上有“通过、经过（through or through the medium）”的意思。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：They came in by the back door.</span><br><span class="line">翻译：他们是从后门进来的。</span><br></pre></td></tr></table></figure><p>然后，我们可以进一步<strong>将 by 引申出时间关系，表示“不晚于某一时间（no later than; at or before）”。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：The application needs to be in by the 31st to be accepted.</span><br><span class="line">翻译：申请必须在 31 日前提交，才能被接受。</span><br></pre></td></tr></table></figure><p>进而，我们还可以再引申出一些抽象关系，例如下面这几个含义：</p><ul><li>凭借（某种交通工具 by air/bus/bike/boat）</li><li>通过（某种通讯手段 by telephone/post/email/fax、支付手段 by credit card/cheque）</li><li>以…的方式（例如本文中 by doing something）”</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例句：My parents have never travelled by plane before.</span><br><span class="line">翻译：我父母以前从未坐过飞机。</span><br><span class="line"></span><br><span class="line">例句：Can I pay by credit card？ No. You must pay in cash.</span><br><span class="line">翻译：我可以用信用卡付款吗? 不行，你必须付现金。（注意，付现金常用 pay in cash 而不是 by cash。这是固定搭配，也是介词为什么烦人的原因之一。）</span><br><span class="line"></span><br><span class="line">例句：I killed the cockroach by hitting it.</span><br><span class="line">翻译：我拍死了那只蟑螂。（强调的是用什么动作达到了结果）</span><br><span class="line"></span><br><span class="line">例句：I killed the cockroach with my shoe.</span><br><span class="line">翻译：我用鞋拍死了那只蟑螂。（强调的是用什么工具达到了结果）</span><br><span class="line"></span><br><span class="line">例句：I got where I am by hard work. No you didn’t. You got there with your wife’s money.</span><br><span class="line">翻译：我是靠努力工作才有今天的成就的。 才不是，你靠的是你老婆的钱。</span><br></pre></td></tr></table></figure><h3 id="介词-despite"><a href="#介词-despite" class="headerlink" title="介词 despite"></a>介词 despite</h3><blockquote><p><strong>Despite</strong> the challenges, when remote work is done well, the advantages to employees and employer are sufficient to make it worthwhile.</p></blockquote><p>介词 despite 是“即使、尽管”的意思，和我们前面讲过的 although、though 类似。但 despite 后面跟名词性的词或者短语，是介词；although 或 though 引导让步状语从句，属连词。</p><p>有一个常用短语 in spite of 和 despite 的意思基本一样，也在句子里发挥介词的作用，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：We understood him in spite of his accent. (=…although he had a strong accent.)</span><br><span class="line">翻译: 尽管他有口音，我们还是听得懂他的话。</span><br></pre></td></tr></table></figure><p>从意思上来看，despite、in spite of 和 because 的意思是相反的。你可以比较下列两句话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句 1：He passed his exams in spite of his teacher. （尽管他老师很烂，但他还是通过了考试。）</span><br><span class="line">例句 2：He passed his exams because of his teacher. （幸亏有他老师，他才通过了考试。）</span><br></pre></td></tr></table></figure><h3 id="介词-to"><a href="#介词-to" class="headerlink" title="介词 to"></a>介词 to</h3><blockquote><p>Despite the challenges, when remote work is done well, the advantages to employees and employer are sufficient <strong>to</strong> make it worthwhile.</p></blockquote><p>介词用来将一个名词与其他概念联系在一起，所以介词 to 后面一定是跟名词性的词或短语。而不定式 to do 是一个动词形式的整体， to 和后面紧跟的动词原形这两者是不可分的。例如，I would like to have some tea 这句话，to have 是一个整体，你可以把 to have 整个去掉，变成 I would like some tea. 也可以，但不可以说 I would like to some tea.。</p><p>基于这一区别，我们很容易分辨句子中的 to 到底是介词还是动词不定式，关键其实就是看 to 后面的词性。比如上面这句话里，to 后面跟的是 employees and employer，都是名词，显然 to 在这里是做介词用，整体做 advantages 的后置定语，对谁的好处？to 后面说了，对员工和雇主的好处。</p><p>介词 to 更多地是描述一种从空间某点向 A 点运动的动态空间概念，有明确的方向性或指向性。简单说就是，目的地 A 点就是 to 后面跟的具有名词属性的词组。比方说，我们学英语就是从 I go to school everyday 开始的。</p><p>从空间关系延伸到时间关系，我们会说 ten to ten，九点五十分，回到表盘上其实还是空间的概念，分针向着整点（十点）的方向再走十个刻度。</p><p>时空关系的基础之上，我们就可以引申出更加抽象的含义，但仍然逃不出最本源的空间关系指向性。例如我们经常讲 I look forward to meeting you soon（我期待着和您会面）。这里的 to 后面就是那个“目的地”，我们见面这个事情，具有名词属性，因此必须是 -doing 这样的动名词。我们现在是分离的状态，一段时间之后就可以变成团聚的状态，隔在两者之间的就是时空，就是这个介词 to。或许，连接一切被时空隔断的彼岸，才是中文“介”的本意。</p><h3 id="表语补足语"><a href="#表语补足语" class="headerlink" title="表语补足语"></a>表语补足语</h3><blockquote><p>Despite the challenges, when remote work is done well, the advantages to employees and employer are sufficient <strong>to make it worthwhile.</strong></p></blockquote><p>这句话的主句是系表结构。主语 advantages 后面是系动词 are，sufficient 是表语。表语的本质其实也是一种补足语，来说明主语的性质、特征和状态等。这句话里 sufficient 说明（远程工作）给员工和雇主带来的好处足够，但意思似乎还不是很完整，所以后面又用不定式 to do 来补充说明，强调“好处足够多，值得一试”，在形式上我们称之为表语补足语。</p><h1 id="同位语的两个重要作用"><a href="#同位语的两个重要作用" class="headerlink" title="同位语的两个重要作用"></a>同位语的两个重要作用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The first starting point for remote employees is to have clear separation between home and work. This can be done through physical separation, by having a dedicated home office, or even working at a shared-work facility, such as Regus or WeWork. It is also helpful to have a transition point, something to replace a commute, that delineates the shift from being at home to being at work. Some people have found taking their dog for a walk, or simply going out the front door and coming in the back door of their house is enough to make the mental shift and start focusing on work.</span><br><span class="line">员工在家远程工作，首先要把家和工作分开。要实现这一点，可以通过物理隔断，在家专设办公区或者干脆去共享工作空间（例如雷格斯或者 WeWork 等共创空间）。有时也可以人为设定一个取代通勤的转换点，作为从在家状态到工作状态的切换标志。有人发现，带狗出去散步，或者只是从前门出后门回，就足以使他们在心理上实现这种切换，并开始专注工作。</span><br><span class="line"></span><br><span class="line">Successful remote work is not just up to the employees. Companies and managers must make extra effort to exhibit transparency and establish trust, because you don’t have benefits of casual conversation and body language like you would working in the same location. Psychological safety is needed for remote working, and this means managers must be prepared to be vulnerable. Once a manager shows they are comfortable sharing something difficult, then employees will be more comfortable reciprocating. Humble said, “You have to fundamentally trust people because you can’t see what they do. They have to tell you.”</span><br><span class="line">远程工作的成功不仅仅取决于员工。公司和管理者们必须做出额外的努力来展示透明度和建立信任，因为不在同一屋檐下共事，就无法享受轻松面谈和肢体语言的便利。远程工作需要心理安全感，这意味着经理们必须做好准备展现自己的脆弱一面。如果管理者乐于分享自己的难处，那么员工也就会乐于敞开心扉。亨堡说：“你必须完全信任他人，因为你看不到他们在做什么，必须由他们告诉你才行。”</span><br></pre></td></tr></table></figure><h2 id="知识讲解-1"><a href="#知识讲解-1" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="介词-for、between、through、by、at"><a href="#介词-for、between、through、by、at" class="headerlink" title="介词 for、between、through、by、at"></a>介词 for、between、through、by、at</h3><blockquote><p>The first starting point for remote employees is to have clear separation between home and work.</p></blockquote><p>第一句是系表结构，不定式 to have 做表语，按字面意思翻译的话，就是“员工远程工作的起点是把家和工作清楚地分开”，但汉语重意合，没有表语，也不用这么别扭地说话，直接说“远程工作首先要分清楚家和工作”就好了。</p><blockquote><p>This can be done through physical separation, by having a dedicated home office, or even working at a shared-work facility, such as Regus or WeWork.</p></blockquote><p>第二句话的主句就更简单，主语 this，谓语动词 can be done，this 指代上一句话说的“家和工作分离”这件事，主句的意思是说这件事情能成，形式上看主句的意思已经完整了，但后面还有一大串状语，用介词短语 through 加上名词和介词短语 by 加上动名词，表示方式，通过什么方式，“家和工作”这事才能做成，具体包括物理隔断、在家专设办公区，或者去雷格斯、WeWork 这些共享空间工作。</p><h4 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h4><ul><li>第一，既然是空间关系，必然有很多相近的含义。我们要特别注意空间关系相似的介词，比较它们在含义和用法上的差别。有些词典会提醒这些近义词，千万不要放过举一反三的机会。</li></ul><p>例如上面提到的 between，在空间关系上是夹在 A 和 B 两个物体中间的位置，而意思和 between 近似的 among，在空间关系上是混在两个以上的多个物体中间的位置。这个很容易理解，但我们的思考不能止步于此。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例句 1：Our house is between the woods, the river and the village.</span><br><span class="line">翻译：我们的房子在树林、小河和村庄之间。</span><br><span class="line"></span><br><span class="line">例句 2：His house is hidden among the trees.</span><br><span class="line">翻译：他的房子隐藏在树林中。</span><br></pre></td></tr></table></figure><p>在例句 1 中，虽然空间里有超过两个的多个物体，我们用 A、B、C 来表示，只要我们仍然可以清楚地分辨出房子和 A、B、C 两两对应的关系，也就是说我们房子在树林和小河之间，又在小河和村庄之间，也在树林和村庄之间，这样的空间关系就需要用 between。在例句 2 中，空间里有多个物体且分不出个数，房子混在一堆物体中无法明确和其他物体的两两对应关系，我们才用介词 among。</p><p>从空间关系引申到抽象关系（比如国家之间的关系），用法也是类似的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例句 1：The trade negotiations between Brazil, Argentina, and Chile are going well.</span><br><span class="line">翻译：巴西、阿根廷和智利之间的贸易谈判进展顺利。（有明确的两两关系）</span><br><span class="line"></span><br><span class="line">例句 2：The trade negotiations among the countries of South America are going well.</span><br><span class="line">翻译：南美洲国家之间的贸易谈判进展顺利。（不存在明确的两两关系）</span><br></pre></td></tr></table></figure><ul><li>第二，空间的概念是相对的，所以介词的用法也灵活多变。</li></ul><p>例如，我们经常会比较 at、on、in 这三个常用的介词。如果用维度来解释的话，in 是立体的有长宽高的三维世界；on 是在一个平面上，是二维世界的概念；at 则是具体到某一点，是一个降维的过程。由空间可以引申到时间，也是一样从长到短的过程。</p><p><img src="/2020/06/14/geekbang-column-article-3-successful-remote-working/in-on-at.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：Shelly lives in a flat on the third floor of an apartment building at 756 Albert Street.</span><br><span class="line">翻译：雪莉住在阿尔伯特街 756 号一栋旧楼三层的一套公寓里。</span><br></pre></td></tr></table></figure><p>按照上图 in-on-at 倒金字塔从大到小的顺序，搭配到上面这句话里却是“公寓 - 楼层 - 整栋楼的地址”这样从小到大的顺序。句子里的介词是不是都用错了呢？如果我们从空间相对性的概念来理解，就比较容易理解这三个介词的正确用法了。“雪莉住在一套公寓里。”从她的角度看，这套公寓无疑是一个三维立体的空间，所以要用 in。而某栋楼里面的楼层，是一个又一个的平面，是一个二维的概念，所以用 on；而一个地址，某条街几号，从地图上看就是一个点，要用 at。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例句 1：The plane stops for an hour at Frankfurt. (a point on a journey)</span><br><span class="line">例句 2：She lives in Frankfurt. (somebody’s home)</span><br><span class="line">例句 3：Let’s meet at the club. (a meeting point)</span><br><span class="line">例句 4：It was warm and comfortable in the club. (a place to spend time)</span><br></pre></td></tr></table></figure><p>我们来比较一下例句 1 和例句 2，介词后面都是法兰克福，德国乃至欧洲的金融中心，但如果把法兰克福看成我们旅途中的一个点，就需要用 at，如果把法兰克福还原成大城市，就妥妥的要用 in；例句 3 和例句 4 也是一样的道理，如果俱乐部只是我们碰头的一个点，要用 at，如果我们在俱乐部里面坐着，喝酒听音乐，那就是一个三维空间，要用 in。</p><h3 id="同位语"><a href="#同位语" class="headerlink" title="同位语"></a>同位语</h3><blockquote><p>It is also helpful to have a transition point, <strong>something to replace a commute,</strong> that delineates the shift from being at home to being at work.</p></blockquote><p>这句话是由 it 做形式主语的句子，逻辑主语是后面的不定式 to have a transition point。当主语过长，为避免句子头重脚轻，通常会用 it 做形式主语，占个位置，而把较长的主语放在句末，其实应该是 to have a transition point is also helpful。</p><p>这句话还有一个值得一讲的语言现象，就是跟在逻辑主语后面、两个逗号中间的同位语 something to replace a commute，用来对 a transition point 进行解释或补充说明，用来强调“转换点”是 “用来取代上下班通勤”的。</p><p>所以，同位语可以是名词、名词短语或者从句，对前面的另一个名词进行解释说明。同位语有两个很重要的作用：</p><ul><li><strong>首先，在不改变句式结构的情况下，它可以非常灵活地增加丰富的补充说明信息。</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：In his 1835 paper published in the Magazine of Natural History, Edward Blyth, an acquaintance of Charles Darwin’s, had documented all the leading thoughts of Darwin’s work 24 years ahead of Darwin’s 1859 paper On the Origin of Species.</span><br><span class="line">翻译：爱德华·布莱斯和查尔斯·达尔文不过是泛泛之交，在他 1835 年发表在《自然历史杂志》上的论文中，就已经记录了达尔文著作的所有核心原则，这比达尔文 1859 年发表的论文《物种起源》整整早了 24 年。</span><br></pre></td></tr></table></figure><p>上面的例句中，加黑部分是同位语，插入到句子中不影响原句的结构，即使删除句子也是完整的。此外，和定语从句一样，同位语也可以分成非限定性同位语和限定性同位语。非限定性同位语只是起到补充说明、增加信息的作用，需要用逗号隔开。</p><p>例句中第一处加黑部分就是非限定性同位语，对爱德华·布莱斯这个人进行补充说明，强调一下他只是和达尔文认识而已。限定性同位语起到缩小范围的限定作用，不用逗号，直接跟着前面的名词。例如例句中第二处下划线，达尔文在 1859 年可能发表过多篇论文，但通过同位语缩小范围，特指《物种起源》那一篇。</p><ul><li><strong>其次，通过对前面名词的解释甚至重复，同位语还可以起到强调的作用。</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：This tale, this tragic tale, was full of cruel wars, savage devastation, unnecessary deaths and the inevitable search for bloody vengeance.</span><br><span class="line">翻译：这个故事，这个悲惨的故事，充满了残酷的战争、野蛮的破坏、无辜的的死亡和不可避免的血腥寻仇。</span><br></pre></td></tr></table></figure><p>同位语也可以以从句形式出现，同位语从句的形式和定语从句有些相似，需要注意区分。比较下面两个例句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例句 1：The rumor that he was married turned out to be true.</span><br><span class="line">翻译：关于他已婚的谣言竟是真的。</span><br><span class="line"></span><br><span class="line">例句 2：The rumor that you told me yesterday turned out to be true.</span><br><span class="line">翻译：你昨天和我讲的谣言竟是真的。</span><br></pre></td></tr></table></figure><p>例句 1 是同位语从句，名词和后面的同位语从句有着“同位关系”。that 只是起到引导从句的作用，在从句中不充当任何成分，和从句没有逻辑关系，且一般不能省略。换言之，同位语从句引导词 that 后面是一个完整的句子，从句“他结婚了”就是“谣言”的内容。</p><p>例句 2 是定语从句，修饰的先行词 rumor 和定语从句没有“同位关系”，定语从句的引导词 that 在从句中充当句子成分。此句中 that 作宾语，所以可以省略。</p><h3 id="宾语从句"><a href="#宾语从句" class="headerlink" title="宾语从句"></a>宾语从句</h3><blockquote><p>Some people have found <strong>taking their dog for a walk, or simply going out the front door and coming in the back door of their house is enough to make the mental shift and start focusing on work.</strong></p></blockquote><p>最后一句话主语和谓语动词都很短，主语是 some people，谓语动词是 have found，有人 + 发现，发现了啥？后面跟了一个长长的宾语从句，从句的主语比较长，taking their dog for a walk, or simply going out the front door and coming in the back door of their house，其实是名词化了的两个动作，出去遛狗或者前门出后门回，后面是系表结构 is enough，“就足够了”，但句子的意思还不完整，足够干什么？这就需要表语补足语来进一步说明，不定式 to make the mental shift and start focusing on work 做补足语，足以“在心理上实现切换”并“开始专注工作”。</p><h1 id="动词：英语宇宙的中心"><a href="#动词：英语宇宙的中心" class="headerlink" title="动词：英语宇宙的中心"></a>动词：英语宇宙的中心</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Establishing a high level of trust among remote managers and employees starts with having good meeting rituals. Meetings should be conducted on video if at all possible, and start with a “check in” for each team member. The check in lets people state how they are feeling that day, and what else is going on that may be affecting their mood or productivity. Managers must lead by example, because what you do is more important than what you say. For more suggestions on meeting rituals, Humble recommended the High-Performance Teams mini-book by Richard Kasperowski, author of The Core Protocols.</span><br><span class="line">在远程工作过程中，经理和员工之间的高度信任始于一套良好的会议仪式。只要可能，会议就应该通过视频方式进行，并从每个团队成员“报到”开始。报到的过程可以让大家陈述他们当天的感受，还有哪些事情可能影响他们的情绪或生产力。经理们必须以身作则，因为你的行动比你的言辞更重要。关于会议仪式方面的建议，Humble 推荐了《核心协议》作者 Richard Kasperowski 写的《高能团队迷你书》。</span><br><span class="line"></span><br><span class="line">An established calendar of regular meetings also helps create structure for distributed teams. A daily huddle takes the place of a “standup.” Because remote teams build a higher level of independence than co-located teams, this may only need to occur twice per week to keep everyone aligned.</span><br><span class="line">定期的会议日程安排也有助于为分散的团队创建组织秩序。每天的网络短会取代了每日“立会”。因为远程工作团队比同地点办公团队具有更高的独立性，所以每周可能只需要开两次例会，就可以让所有成员保持步调一致。</span><br><span class="line"></span><br><span class="line">One-on-one meetings between employee and manager are extremely important, and must be treated as sacrosanct. These meetings are for the employee, with discussions about their career and other personal concerns. Humble had two absolute rules: The one-on-one is not a status meeting, and managers should never be allowed to cancel the meeting.</span><br><span class="line">员工和经理之间的一对一会议非常重要，必须拥有神圣不可更改的地位。一对一会议是为员工安排的，用于讨论他们的职业生涯和其他个人问题。Humble 有两条铁律：一对一会议不是检查工作进度的会议，管理者永远不得取消一对一会议。</span><br></pre></td></tr></table></figure><h3 id="不及物动词-介词"><a href="#不及物动词-介词" class="headerlink" title="不及物动词 + 介词"></a>不及物动词 + 介词</h3><blockquote><p>Establishing a high level of trust among remote managers and employees <strong>starts with</strong> having good meeting rituals.</p></blockquote><p>英语动词分为及物动词和不及物动词。</p><ul><li><p>及物动词（transitive verb，缩写 vt.），就是动词后面可以直接跟“物”的动词。这个“物”就是动作的对象，也是动词的宾语。例如 I invited Tom.（我邀请了汤姆。）<br>汤姆这个人就是那个“物”，invite 是及物动词，后面可以直接跟宾语，而且必须有这个“物”，不然句子不完整，不能说 I invited 后面就没了。</p></li><li><p>不及物动词（intransitive verb，缩写 vi.）就是不能直接跟“物”（宾语）的动词。这类动词自身词义完整。例如 walk、smile、sleep，我走、我笑、我睡，都不用说明动作对象，也不能直接跟宾语。<br>如果不及物动词后面想要跟“物”（宾语）的话，例如要说“她对我笑”，怎么办呢？这时候，无处不在、无所不能的介词就要发挥作用了。不及物动词后面加上介词之后，就秒变“及物”动词，我们可以说“She smiled at me, and I smiled back.（她冲我笑笑，我也冲她笑笑。）”。从语法角度讲，smile at me，me 是 at 介词的宾语，at me 整个是 smile 的状语。</p></li></ul><p>积累一个常用的习语 smile from ear to ear，也是加了介词 from，字面意思是“从左边耳朵笑到右边耳朵”，其实就是“眉开眼笑”、“笑得合不拢嘴”的意思。</p><p>此外，需要特别说明一下，在不及物动词后面加的 up、down、in 等小词，并不一定都扮演介词的角色。换言之，只有 up、down、in 等这些小词后面跟了宾语的时候，它们才是介词。有“物”可“介”，才能称为介词。如果无“物”可“介”，也就是小词后面不跟宾语的时候，这些小词起到的是副词的作用，表示前面那个动词的状态，英语语法上也称其为副词小品词（adverb particles）。一个动词可以和副词小品词构成不同的动词短语，例如 break down、give up 等。</p><h3 id="被动语态"><a href="#被动语态" class="headerlink" title="被动语态"></a>被动语态</h3><blockquote><p>Meetings should <strong>be conducted</strong> on video if at all possible, and start with a “check in” for each team member.</p></blockquote><p>语态是用来说明主语和动词之间关系的动词形式。英语语法中的语态只有两种，主动语态（active voice）和被动语态（passive voice）。主动语态中主语是动作的执行者，被动语态中主语是动作的承受者。因此，只有及物动词才有被动语态。</p><p>被动语态由“助动词 be+ 及物动词的过去分词”构成，被动语态的时态变化只需要改变 be 的形式，过去分词部分不变。疑问式和否定式的变化也是如此。</p><p><strong>首先，当我们希望强调动作的承受着和动作或事件本身，而不想强调动作的执行者（或者根本不知道动作的执行者）的时候，往往会用被动语态。这样的叙述方式，可以使得句子听上去更加具有客观性，因此这种情况一般在科研、学术著作中较为常见。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：Too many books have been written about the Second World War.</span><br></pre></td></tr></table></figure><p><strong>其次，很多时候，我们讲话的时候，总是习惯先说已知的旧信息，把新的信息留在句末。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：Nice picture! ~Indeed. It was painted by my grandfather.</span><br><span class="line">翻译：这幅画画得真不错! ~ 的确，这是我爷爷画的。（这里要突出的新信息是画的作者，所以放在句子的末尾，其他信息都是已知的。）</span><br></pre></td></tr></table></figure><p><strong>此外，有时候为了保持一句话或者几句话里的主语不变，也需要使用被动语态。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：Joe left my house around 5 pm, and was hit by a car about 30 minutes later.</span><br><span class="line">翻译：乔下午五点左右离开我家，大约三十分钟后就被车撞了。（可以说 a car hit him，但主语就要发生变化了；主语不变更加自然。）</span><br></pre></td></tr></table></figure><p>Meetings should be conducted on video，会议尽量要通过视频方式来开，其实就是会议“被”开，但翻译成中文就听不出被动语态了。首先，这句话希望强调会议本身，而不是开会的人，句子听上去也比较有客观性；第二，meeting 同时充当前半句被动语态（be conducted）和后面半句话主动语态（start with）的主语，这样句子听上去会比较自然。</p><h3 id="宾语从句和定语从句"><a href="#宾语从句和定语从句" class="headerlink" title="宾语从句和定语从句"></a>宾语从句和定语从句</h3><blockquote><p>The check in lets people state how they are feeling that day, and what else is going on <strong>that may be affecting their mood or productivity.</strong></p></blockquote><p>这句话的主语是 the check in，动词短语名词化，指“点名”或“报到”这件事情，let 是谓语动词，后面跟宾语加上不带 to 的不定式。let…do…，你把这个当固定短语来记就好。</p><p>加黑部分是 state 的宾语从句，可以让团队成员谈一谈，一是他们当天有何感受 <em>，</em> 二是还有哪些事情。什么事情呢？后面还套了一个定语从句，就是下加黑部分，可能影响他们情绪或生产力的那些事情。串在一起就是“报到”这个形式，让团队成员能谈一谈上面讲的这两个问题。</p><h3 id="lead-by-example"><a href="#lead-by-example" class="headerlink" title="lead by example"></a>lead by example</h3><blockquote><p>Managers must <strong>lead by example</strong>, because what you do is more important than what you say. For more suggestions on meeting rituals, Humble recommended the High-Performance Teams mini-book by Richard Kasperowski, author of The Core Protocols.</p></blockquote><p>固定搭配 lead by example 很常用，指的是领导“身先士卒”“以身作则”。下面这句话是世界卫生组织前任总干事陈冯富珍演讲中说的一句话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：I must lead by example, and I must be held accountable to Member States.</span><br><span class="line">翻译：我必须以身作则，我也必须对会员国负责。</span><br></pre></td></tr></table></figure><p>为什么要以身作则呢？因为 what you do is more important than what you say。有一个英语成语也是这个意思：action speaks louder than words（行胜于言）。</p><h3 id="huddle-和-standup"><a href="#huddle-和-standup" class="headerlink" title="huddle 和 standup"></a>huddle 和 standup</h3><blockquote><p>An established calendar of regular meetings also helps create structure for distributed teams. A daily huddle takes the place of a “standup”. Because remote teams build a higher level of independence than co-located teams, this may only need to occur twice per week to keep everyone aligned.</p></blockquote><p>huddle，它原本的含义是“（因为寒冷或害怕）挤在一起或缩成一团”，英语解释是 to gather closely together, usually because of cold or fear。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：Tired and lost, we huddled together around the fire.</span><br><span class="line">翻译：我们疲惫不堪，又迷了路，于是都围着火堆挤作一团。</span><br></pre></td></tr></table></figure><p>后来这个词引申用到一些体育比赛中，指“队员靠拢在一起，磋商比赛战略战术的行为”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：In many sports like football and rugby, the team huddles before each play. The huddle is strategic: it keeps the team informed and connected throughout the game. For software teams, the stand-up is like the team’s huddle to keep everyone aware of the team’s landscape and progress.</span><br><span class="line">翻译：在许多运动中（例如足球和橄榄球），全体队员在每次比赛前都要靠拢在一起磋商战术。这一安排具有战略意义：它在整场比赛中保持全队信息和精神相通。对于软件开发团队来说，每日站会就像球队的赛前战术会，让每个成员都知道团队的最新情况和进展。</span><br></pre></td></tr></table></figure><p>“standup”顾名思义，就是大家站着开的会。这是敏捷开发（Agile Development）流程中必不可少的环节，其实就是开发团队全员参加的每日例会，定时定点，时间较短，或者说为了控制会议时间，要求大家站着开会，不说废话，不打瞌睡。团队成员在站会前一般都会准备好需要更新的内容，从而确保会议高效。每日站会的目的，在于预估并安排每日的工作计划，促进团队沟通合作，提高透明度，共享工作的进展和障碍（highlight progress and flag blockers），并得到快速响应。</p><h1 id="参透“主从分明”的树状结构，即可“庖丁解牛”"><a href="#参透“主从分明”的树状结构，即可“庖丁解牛”" class="headerlink" title="参透“主从分明”的树状结构，即可“庖丁解牛”"></a>参透“主从分明”的树状结构，即可“庖丁解牛”</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Strategic discussions are very challenging to have remotely, so these will usually occur when everyone involved can meet in person, which is every four months for C4, and coincides with QCon scheduling. C4 has an annual “all hands” meeting that lasts for four days, which also involves flying everyone into one location. This is obviously very expensive and a logistical challenge, but is extremely valuable. While everyone does not need to be co-located all the time, there are some situations which are only really effective when a team is all together. These include strategic discussions and just help re-enforce the bonds between team members.</span><br><span class="line">以远程的方式进行战略性讨论是非常具有挑战性的，所以这些会议通常需要参会者亲自到场。C4 每四个月举行一次现场战略讨论会，这与 QCon 会议的日程安排相吻合。C4 每年要举行一次“全员”大会，所有员工都需要飞到同一个地方参会。这样的会议成本显然很高，对后勤也是一大挑战，但却非常有价值。虽然大家不需要总在同一地点办公，但有些工作要想真正有效开展，只有把一个团队的所有人员都聚到一起，其中包括战略性讨论大会，同时还有助于加强团队成员之间的联系。</span><br><span class="line"></span><br><span class="line">Humble shared a list of tools he and C4 have used. Slack for IM; Zoom for video conferencing; Workplace for “water cooler”-like chats; Google Docs for remote collaboration; and 15Five for private retrospectives. While these work for his team, many options exist. The important thing is to try and find what works effectively in your situation, because bad tooling can have a serious effect on remote working.</span><br><span class="line">Humble 分享了他和 C4 使用过的工具清单。Slack 用于即时通讯；Zoom 用于视频会议；Workplace 用于同事闲聊；Google Docs 用于远程协作；15Five 用于个人回顾。虽然这些工具对他的团队很有用，但还有很多其他工具可供选择。重要的是要尝试找到适合自己情况的有效工具，因为不好的工具会对远程工作造成严重影响。</span><br><span class="line"></span><br><span class="line">While remote work is very appealing to some employees, it does come with some trade-offs. Although the time and costs associated with commuting disappear, new costs may be incurred from premium high-speed internet, a good laptop, a nice desk, and especially a good office chair. A subject not often, or easily, discussed regarding remote work is mental health. Burnout is a real, serious issue, and is endemic in IT. Trust and openness is critically important, and allows team members to recognize when someone is struggling, and help them cope, including seeking professional help. Loneliness can also be a problem, and it takes active effort to make your family and your social life a real priority. Pets, exercise, and getting into nature can also help improve mental well-being.</span><br><span class="line">虽然远程工作对一些员工来说很有吸引力，但也一定有得有失。虽然与通勤相关的时间和财务成本消失了，但需要高速网络、一台好的笔记本电脑、一张好的办公桌，尤其是一把舒服的办公椅，这些都可能带来新的成本。在远程工作中，心理健康是一个不经常或不容易讨论的话题。职业倦怠是真实存在的严重问题，在 IT 行业尤其普遍。信任和坦诚非常重要，它能让团队成员发觉有同事在挣扎，并帮助他们应对，包括寻求专业的帮助。孤独也可能成为问题，让家庭和社交真正成为你的生活重心是需要付出积极努力的。养宠物、运动和融入大自然也可以帮助改善心理健康。</span><br></pre></td></tr></table></figure><h2 id="知识讲解-2"><a href="#知识讲解-2" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="非限定性定语从句"><a href="#非限定性定语从句" class="headerlink" title="非限定性定语从句"></a>非限定性定语从句</h3><blockquote><p>Strategic discussions are very challenging to have remotely, so these will usually occur when everyone involved can meet in person, <strong>which is every four months for C4, and coincides with QCon scheduling.</strong></p></blockquote><p>我们先来找第一句话的主干，strategic discussions 是主语，战略性的讨论是相对于我们日常工作中的事务性讨论而言的，是公司或团队定方向、定目标的战略会议。主语后面是系动词 are，这一看就是我们熟悉的系表结构，后面的表语是形容词 challenging，“战略会是很有挑战的”。显然这个意思是不完整的，除此之外，我们还需要后面通过不定式 to have remotely 这个表语补足语，来补充说明，以远程的方式来开战略会议是很难的。</p><p>前半句分析完了之后，我们可以看到，逗号后面是 so。大部分情况下，so 是并列连词。也就是说，so 前后的两句话是平起平坐的并列关系，不存在很明确的附属关系（附属关系用 because 的情况较多）。</p><p>既然不是从句，我们就需要把后半句也当成主句来分析。主语是 these，指代的是前半句的主语 discussions，谓语动词是 will usually occur，“战略讨论会通常会发生”，什么时候发生呢？显然意思也没有说完整，需要后面 when 开头的表示时间的状语从句来补充说明，“当所有相关人员都能聚到一起开会的时候”。</p><p>把并列连词 so 前后的两个句子摆在一起，有点不那么强烈的因果关系，原因和结果之间有点引导和推测的意思。比如这句话，前半句讲“战略会远程开存在挑战”，后半句讲“一般都是要把人聚在一起才开”，两者之间的因果关系不那么直接和强烈，所以不构成从属关系。这就是因果关系的并列从句和表示直接原因的状语从句之间的微妙差别。</p><p>逗号的后面还有一个 which 引导的定语从句，一看带逗号和 which，可以判断是非限定性的定语从句，可以用来修饰前面讲的整件事情，而不是用于限定 which 前面的先行词。换句话说，后面的从句是补充说明的作用，而不是缩小范围的作用。</p><h3 id="限定性定语从句"><a href="#限定性定语从句" class="headerlink" title="限定性定语从句"></a>限定性定语从句</h3><blockquote><p>C4 has an annual “all hands” meeting <strong>that lasts for four days, which also involves flying everyone into one location.</strong></p></blockquote><p>看完上句的非限定性定语从句，我们马上可以看到下一句话里面的限定性定语从句。主句的“主谓宾”结构非常清晰，C4 是主语，谓语动词是 has。在这里，has 是实义动词而非助动词，宾语是 an annual “all hands” meeting，“C4 有年度全员大会”。宾语 meeting 后面跟的是限定性定语从句，强调是“为期四天”的年度大会。</p><p>前半句话后面是逗号和 which，又是一个非限定性定语从句，它最大的特点就是可以灵活地修饰前面讲的整件事情，而不像前面的限定性定语从句那样只能修饰先行词 meeting。非限定性定语从句补充说明，“年度会议也是需要把公司的所有人都飞到同一个地方”才能开的。</p><h3 id="all-hands-on-the-deck"><a href="#all-hands-on-the-deck" class="headerlink" title="all hands (on the deck)"></a>all hands (on the deck)</h3><p>英语里有一个固定说法叫 all hands on the deck，最初这是大船上让所有船员全部到甲板集合、各就各位的命令。例如，We’re under attack! All hands on deck!（我们受到攻击，全体上甲板！），之后慢慢从“全体船员”引申到“所有帮得上忙的人”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：Your grandmother arrives tomorrow and the house is still a mess—I need all hands on deck to help me clean!</span><br><span class="line">翻译：你们奶奶明天就到了，房子还是一团糟！我需要所有的人都来帮我打扫！</span><br></pre></td></tr></table></figure><p>很多地方干脆连 on the deck 都省略了，直接用 all hands 来指“全体人员”。句子里的 all hands meeting 指的就是“全体员工大会”。</p><p>另外，还有一个经常听到的词 town-hall meeting，最早是指“西方国家的竞选者定期在市政厅与当地选民进行的交流会”，通过 town-hall meeting 听取选民意见，回答选民问题，也叫“市政厅会议”，后来慢慢地也引申到企业的“全体员工大会”。</p><p>两个都是“全体员工大会，all hands 和 town-hall 有啥区别呢？我们来看下面这段英文解释：</p><blockquote><p>The term “Town Hall” meeting is often used interchangeably with All-Hands meeting however a Town Hall meeting is more question and answer based while All-Hands meetings are generally more focused on conveying a message and making a key presentation.</p></blockquote><p>这两个说法意思是差不多的，可以互换使用。如果实在要说差别，town-hall 以偏重回答员工问题为主要形式，而 all-hands 则以作报告、传达企业战略精神为主。</p><h3 id="复习并列句和复杂句"><a href="#复习并列句和复杂句" class="headerlink" title="复习并列句和复杂句"></a>复习并列句和复杂句</h3><blockquote><p>This is obviously very expensive and a logistical challenge, but is extremely valuable. While everyone does not need to be co-located all the time, there are some situations which are only really effective when a team is all together. These include strategic discussions and just help re-enforce the bonds between team members.</p></blockquote><p>logistical 这个词。它是名词 logistics 的形容词，最早在军事领域用得比较多，中国古代称为“粮草辎重”，到近代改称“军需后勤”，之后又把军事后勤的概念延伸到商业领域，形成现代的“物流”概念。不管说法怎么变，其本质都是一样的，都是讨论如何高效地进行物资生产、采购、运输、配给等活动，使得差别更低、速度更快、服务更好。句子里面指的是，全公司的人都要聚到某一个地方（比如迪拜）去开年会，不仅昂贵，而且后勤方面很有挑战。</p><h3 id="water-cooler-chat"><a href="#water-cooler-chat" class="headerlink" title="water cooler chat"></a>water cooler chat</h3><blockquote><p>Humble shared a list of tools he and C4 have used. Slack for IM; Zoom for video conferencing; Workplace for “water cooler”-like chats; Google Docs for remote collaboration; and 15Five for private retrospectives. While these work for his team, many options exist. The important thing is to try and find what works effectively in your situation, because bad tooling can have a serious effect on remote working.</p></blockquote><p>这一段演讲人介绍了一堆他推荐使用的远程工具，大部分大家都非常熟悉，只需要提一下两个词组。第一个是 water cooler chat，我们来看一段英文解释：</p><blockquote><p>Water cooler chat, or water cooler talk, or water cooler conversation (whatever you want to call it), is what happens when colleagues take a break from work-related tasks and discuss their hobbies, interests, and other things by gathering around the office water cooler.</p></blockquote><p>大一点的公司，每个办公楼层一般都有茶水间，再不济也有一个饮水机，就是这个 water cooler（老外喜欢喝冰水，我们喜欢喝热水）。工作间歇休息的时候，同事们会去接开水，闲聊几句和工作无关的事情。Workplace 则是 Facebook 推出的办公通讯软件，曾被国内媒体称为“企业微信”，Humble 推荐作为同事间的闲聊工具。</p><p>private retrospectives：英文解释 looking back on or dealing with past events or situations，这个词指的是对过去发生过的事情的回顾。以前我们提到过 Agile Development，敏捷开发的工作流程中一般都有 一项 retrospective meetings，开发团队定期召开的回顾会。句子里面的 private 指的是“个人私下的”，也可以用 individual 或者 personal retrospectives，是个人定期回顾自己的工作或者生活，而 15Five 则是团队或个人绩效管理工具，里面有不错的工作回顾功能。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li><p>“阵而后战，兵法之常，运用之妙，存乎一心。”方法的道理说起来都是比较容易的，但真正要用好，还需要你自己去练习和体会。</p></li><li><p>怎么学好介词呢？我们可以从它们的空间关系本源含义入手，进而引申出时间关系和抽象含义，通过例句体会介词变化繁多的用法。</p></li><li><p>大部分的介词都是有空间关系的本义，但也有一部分介词空间关系本义并不明显，例如我们上次讲的 despite，这次出现的 for。还是以前讲过的那句老话，所有的语法规则、规律、方法、诀窍，都是帮助我们理解语言含义的工具。我们要学会使用这些工具，但有时候碰到“规律”解释不通的地方，也不要被它们束缚，更不要去钻牛角尖。</p></li><li><p>熟练使用同位语，可以帮助我们增添写作的多样性，在不改变句子结构的情况下，能够灵活添加补充信息，使文章内容更加丰富详实，同时还能起到很好的“强调”修辞效果。</p></li><li><p>动词作为英语宇宙的中心，变化万千，要讲时态和语态，还能和不同的介词（或者副词小品词）搭配幻化出各种不同的意思，的确不是讲几个语法概念和读几个例句就能囊括的，同样也需要我们日积月累。掌握了动词并且能够运用自如，你就相当于站在宇宙的中心，洞悉万物一切的变化。</p></li></ul><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ul><li><a href="https://www.gartner.com/smarterwithgartner/with-coronavirus-in-mind-are-you-ready-for-remote-work/" target="_blank" rel="noopener">https://www.gartner.com/smarterwithgartner/with-coronavirus-in-mind-are-you-ready-for-remote-work/</a></li><li><a href="https://www.gartner.com/smarterwithgartner/coronavirus-cio-areas-of-focus-during-the-covid-19-outbreak/" target="_blank" rel="noopener">https://www.gartner.com/smarterwithgartner/coronavirus-cio-areas-of-focus-during-the-covid-19-outbreak/</a></li><li><a href="https://www.englishpage.com/prepositions/prepositions.html" target="_blank" rel="noopener">Prepositions</a></li><li><a href="https://dictionary.cambridge.org/us/grammar/british-grammar/for" target="_blank" rel="noopener">关于介词 for 的用法</a></li><li><a href="https://dictionary.cambridge.org/us/grammar/british-grammar/between-or-among?q=between" target="_blank" rel="noopener">Between or among?</a></li><li><a href="https://writingexplained.org/between-vs-among-difference" target="_blank" rel="noopener">Between vs. Among: What’s the Difference?</a></li><li><a href="https://dictionary.cambridge.org/us/grammar/british-grammar/across-over-or-through?q=through" target="_blank" rel="noopener">Across, over or through?</a></li><li><a href="https://www.grammarly.com/blog/appositive/" target="_blank" rel="noopener">Appositives—What They Are and How to Use Them</a></li><li><a href="https://literaryterms.net/appositive/" target="_blank" rel="noopener">Appositive</a></li><li><a href="https://www.grammar-monster.com/glossary/appositive_apposition.htm" target="_blank" rel="noopener">https://www.grammar-monster.com/glossary/appositive_apposition.htm</a></li></ul><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="关于及物动词和不及物动词"><a href="#关于及物动词和不及物动词" class="headerlink" title="关于及物动词和不及物动词"></a>关于及物动词和不及物动词</h2><ul><li><a href="https://www.grammarly.com/blog/transitive-and-intransitive-verbs/" target="_blank" rel="noopener">Transitive and Intransitive Verbs—What’s the Difference?</a></li><li><a href="https://www.gingersoftware.com/content/grammar-rules/verbs/action-verbs/" target="_blank" rel="noopener">Action Verbs-Transitive and Intransitive Verbs</a></li><li><a href="https://www.myenglishpages.com/site_php_files/grammar-exercise-transitive-intransitive-verbs.php" target="_blank" rel="noopener">Grammar Exercise - Transitive and Intransitive Verbs</a></li><li><a href="https://www.quia.com/quiz/653869.html" target="_blank" rel="noopener">Transitive or Intransitive Verbs?</a></li></ul><h2 id="关于被动语态"><a href="#关于被动语态" class="headerlink" title="关于被动语态"></a>关于被动语态</h2><ul><li><a href="https://advice.writing.utoronto.ca/revising/passive-voice/" target="_blank" rel="noopener">Passive Voice: When to Use It and When to Avoid It</a></li><li><a href="https://grammar.yourdictionary.com/grammar/writing/passive-voice-when-to-use-it.html" target="_blank" rel="noopener">Passive Voice: When to Use It</a></li><li><a href="https://www.englishgrammar.org/active-passive-voice-quiz/" target="_blank" rel="noopener">Active and Passive Voice Quiz</a></li><li><a href="https://www.proprofs.com/quiz-school/story.php?title=passive-voice" target="_blank" rel="noopener">English Grammar Quiz: Passive Voice!</a></li></ul><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 08:48:16 GMT+0800 (CST) --&gt;&lt;p&gt;&lt;a href=&quot;https://www.infoq.com/news/2020/03/successful-remote-working/&quot; target
      
    
    </summary>
    
    
      <category term="English-Study" scheme="https://octopuslian.github.io/categories/English-Study/"/>
    
    
      <category term="远程办公" scheme="https://octopuslian.github.io/tags/%E8%BF%9C%E7%A8%8B%E5%8A%9E%E5%85%AC/"/>
    
      <category term="介词" scheme="https://octopuslian.github.io/tags/%E4%BB%8B%E8%AF%8D/"/>
    
      <category term="同位语" scheme="https://octopuslian.github.io/tags/%E5%90%8C%E4%BD%8D%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>English_Article 2：Open Source Benefits to Innovation and Organizational Agility</title>
    <link href="https://octopuslian.github.io/2020/06/14/geekbang-column-article-2-open-source-benefits-to-innovation-and-organizational-agility/"/>
    <id>https://octopuslian.github.io/2020/06/14/geekbang-column-article-2-open-source-benefits-to-innovation-and-organizational-agility/</id>
    <published>2020-06-14T06:03:26.000Z</published>
    <updated>2020-06-17T13:11:25.218Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 08:48:16 GMT+0800 (CST) --><p><a href="https://www.infoq.com/news/2019/03/open-source-benefits/" target="_blank" rel="noopener">Open Source Benefits to Innovation and Organizational Agility</a></p><p>这篇文章出自 InfoQ 英文站，主要探讨了开源给科技创新能力和组织敏捷性带来的好处。</p><h1 id="导读：通过阅读序言段了解文章的背景知识"><a href="#导读：通过阅读序言段了解文章的背景知识" class="headerlink" title="导读：通过阅读序言段了解文章的背景知识"></a>导读：通过阅读序言段了解文章的背景知识</h1><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>通过这篇文章的序言段，了解一下文章的总体背景。</p><blockquote><p><strong>Capital One</strong> hosted their 3rd <strong>Agile Conference</strong> in December 2018 in Virginia. Among the <strong>guest speakers, Andrew Aitken</strong>, global open source strategy leader at <strong>Wipro</strong>, presented the state of open source and how it is becoming an industry-wide organizational <strong>keystone</strong> strategy in driving innovation and in retaining top talent.</p></blockquote><ul><li><p>Capital One，美国第一资本集团，做过互联网金融的小伙伴肯定都听说过这家企业。<br>Capital One 最开始只是美国弗吉尼亚州一家地区性小银行的信用卡中心。1995 年，它从集团独立出去并正式更名为 Capital One。作为后起的“小人物”，在短短二十多年的时间里，在一片市场已经高度饱和、几乎被老牌巨头们垄断、产品又相当同质化的“红海”之中，Capital One 利用多元化战略和信息技术创新，快速从一家名不见经传的小型地区银行崛起成为美国十大银行之一，同时也变成了美国排名前三的信用卡发卡机构和零售商。<br>Capital One 在后来也成为了中国新兴金融科技企业，特别是互联网金融、消费金融企业及信用卡中心学习和效仿的对象。行业内有一些企业，是那些从 Capital One 离职回国的创业者创立的，所以也有人将 Capital One 戏称为金融科技行业的“黄埔军校”。</p></li><li><p>Wipro（维布络）。它是和 Infosys、塔塔咨询等齐名的信息技术服务公司，总部位于有印度硅谷之称的班加罗尔，客户和业务遍布全球各地。这篇文章的作者 Andrew Aitken，就是维布络全球开源技术战略的负责人。每年 Capital One 都会举办一次“敏捷技术大会”（Agile Conference）。而我们要讲的这篇文章就是他作为特邀嘉宾，发表的关于开源技术战略的演讲稿。</p></li></ul><h2 id="知识讲解"><a href="#知识讲解" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="guest-speaker"><a href="#guest-speaker" class="headerlink" title="guest speaker"></a>guest speaker</h3><p>英文解释：A guest speaker is a person who is invited to speak at an event.</p><p>敏捷技术大会是 Capital One 组织的年度商务技术会议，大会会邀请类似 Wipro 这样的合作伙伴参加，所以，负责全球开源技术战略的负责人 Wipro，是会议主办方邀请来的客人。他是作为行业意见领袖之一来发表演讲。这样的人我们称之为 guest speaker，中文一般称为“特邀嘉宾”或“特邀演讲人”。</p><p>现在有很多软硬件厂商主办的研讨会，他们也经常会邀请一些重要客户的代表在会上现身说法，分享使用产品的经验，这些演讲者都属于 guest speaker。</p><h3 id="keynote"><a href="#keynote" class="headerlink" title="keynote"></a>keynote</h3><p>keynote speaker，他们发表的演讲叫作 keynote speech 或者 keynote address。</p><p>苹果公司的演示幻灯片软件就叫 Keynote，它的英文解释是 the fundamental or central fact, idea, or mood，“最基本或最核心的事实、思想或调性”，或者叫“要旨、主题、基调”等。</p><p>所以，keynote speech 是一场活动中最重要的演讲，keynote speaker 一般称为“主旨演讲人、主题报告人”等，可以是主办方的领导，也可以是特邀的重量级嘉宾。</p><p>既然提到 keynote，你肯定会联想到微软的 PowerPoint 或者 PPT。我们平时也会很习惯地说，“我在做 PPT“”或者“给大家演示一下我的 PPT”，但一打开软件用的其实是苹果公司的 Keynote 软件。</p><p>建议：多使用 slide 这个词。因为这个词是中性的，只是表示一页一页的幻灯片，并不涉及某家公司的产品。“I can’t wait to show you guys the slides,”比“I can’t wait to show you guys my PPT.”要更合适一些。</p><h3 id="agile"><a href="#agile" class="headerlink" title="agile"></a>agile</h3><p>英文解释：able to move quickly and easily；able to think quickly and in an intelligent way。前者指动作，“能够快速灵活地移动”；后者指思维，“能够敏锐机智地思考”。</p><p>“敏捷软件开发”（agile software development）这个词，你应该很熟悉。Capital One 作为一家金融服务企业，用“敏捷”来命名自己的年度商务技术大会，应该和“敏捷开发”的理念以及公司战略有着千丝万缕的联系。</p><p>在美国传统信用卡行业中，一般会根据美国个人消费信用评估公司的信用评分结果（FICO Score），把消费者分成两大类，分别是优质客户和次级客户。</p><p>所谓的“优质客户”（prime），信誉良好、几乎不欠款。这些客户的信用风险非常低。而信用评分偏低的客户（一般低于 670），或多或少存在逾期拖欠、随意透支甚至申请破产等各种财务困境历史。这些人会被归入“次级客户”（subprime）里。给他们发放贷款信用风险较高，所以这个也被称为“次级贷款”（subprime mortgage）。我们所知道的 2008 年全球金融危机，就是由次级贷款引发的，所以也被称为“次贷危机”。</p><p>前面我们提到过，在 Capital One 成立之初，信用卡市场已经相当成熟。传统意义上的“优质”信贷客户群体已经被运通、花旗等老牌金融机构瓜分殆尽，大的环境会逼迫后起的企业去开辟新的战场，打造新的竞争环境，建立全新的游戏规则。</p><p>Capital One 在矮子里面拔高个儿，首先将目标客户群体锁定“次级客户”中风险相对较低的那一群，例如循环借贷客户。这些人逾期概率较高，但是过一段时间之后又通常能够还清欠账，最终的实际坏账率较低，这些人对公司的利润率贡献却很高。</p><p>这一差异化竞争战略听上去非常靠谱，关键在于如何执行。俄国文学巨匠托尔斯泰在他的《安娜 卡列尼娜》(Anna Karenina）里这样开篇：幸福的家庭都是相似的，不幸的家庭各有各的不幸（All happy families resemble one another, each unhappy family is unhappy in its own way）。</p><p>同样的道理，优质客户都是相似的，次级客户各有各的问题。如何真正把“高个儿”从矮子群里拔出来，也就是如何在长尾市场中筛选出符合要求的高价值客户，保证他们给公司带来高收益的同时、又能确保风险可控，毫无疑问，需要强大的信息技术和深度的数据分析能力来提供支撑。</p><p>这一点在大数据家喻户晓的今天似乎很容易理解，但在互联网方兴未艾的上世纪九十年代，则需要独到的洞察力以及持续投入创新的决心。</p><p>除了吸引“次级”客户以外，Capital One 还打破了美国信用卡市场长期不变的“20+19.8”的收费模式（20 美元的年费和 19.8% 的年化利率）。他们采用“诱惑利率”（teaser rate）和“信用卡余额代偿”（balance transfer）等具有开创性的营销手段，去吸引其他银行的信用卡客户转网。</p><p>例如，Capital One 通过电话或邮件方式，用年化利率 8% 的贷款替客户还清其他银行的欠款，同时把该客户的贷款余额转移到 Capital One 的信用卡上。当然，诱惑客户转网的低息期结束之后，利率会调回到正常的市场水平。</p><p>Capital One 因此很快获得了大量新客户，然而这并不是这一战略的关键。关键在于，到底应该如何留住下了血本拉过来的这些新客户，自然还是要靠持续不断具有吸引力的产品。</p><p>我们前面介绍过，上世纪九十年代的美国信用卡市场的定价是统一僵化的，但每一个客户个体的利润率却千差万别。Capital One 成功地通过“边测试边学习”策略（Test-and-Learn），在数据分析的基础上实现有效的用户分层和差异化定价，设计出符合各类客户需求的产品，持续用低利率吸引并留住好客户，及时甄别和拒绝垃圾客户，最终使 Capital One 在激烈的市场竞争中脱颖而出。</p><h3 id="敏捷开发和-DevOps-理念的重要性"><a href="#敏捷开发和-DevOps-理念的重要性" class="headerlink" title="敏捷开发和 DevOps 理念的重要性"></a>敏捷开发和 DevOps 理念的重要性</h3><p>对于敏捷开发和所谓“瀑布式开发”（agile vs. waterfall）的讨论，已经持续了很多年。如果你是程序员的话，应该比较熟悉。维基百科也讲了这两种方法论的差别，表述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">One of the differences between agile software development methods and waterfall is the approach to quality and testing. In the waterfall model, there is always a separate testing phase after a build phase; however, in agile software development testing is completed in the same iteration as programming.</span><br><span class="line">Another difference is that traditional “waterfall” software development moves a project through various Software Development Lifecycle (SDLC) phases. One phase is completed in its entirety before moving on to the next phase.</span><br></pre></td></tr></table></figure><p>总结来说，敏捷软件开发打破了“瀑布式”分开发阶段的生命周期循环，把测试环节融入到了编程迭代中完成，从原本的一站一停变成了小步快跑，将原本一块又一块的大石头敲成了小碎石。这种方法论的实质就是 Capital One 所说的“边测试边学习” 策略，和我们上面分析的商业战略是高度匹配的。</p><p>无论是持续推出上千款不同产品，还是开发高效的个性化客服系统，以及先进的风险控制模型，Capital One 一旦有任何新的想法，立刻就会调集所掌握的客户数据，进行调整、测试然后以最快的速度推向市场，把传统的大里程碑转化成一个永无止境的产品优化过程。</p><p>有人觉得敏捷开发会影响系统稳定性，其实不然。小步快跑可以更快地交付产品给用户，可以更快地得到用户的反馈、更快地发现问题、更快地进行响应。同时，小步快跑带来的变化是比较小的，即使出现问题也不会太严重，修复起来也相对容易。</p><p>当然，所有这一切都需要长期的投入和持续的创新。<strong>任何的理想都需要实实在在的技术来支撑。</strong></p><p>DevOps 一词是将 Development 和 Operations 这两个词组合在一起构成的。顾名思义，就是试图把软件开发人员和运维人员之间的隔墙拆除，强调两者之间的沟通与协作。DevOps 十几年前就提出来了，但直到近些年才开始受到越来越多企业的重视，主要原因还是应为配套技术（enabling technology）的逐步成熟，例如云计算、容器技术、自动化运维工具、微服务架构等。</p><p>综上，Capital One 的战略始终是信息技术在驱动，通过“边测试边学习”策略来高频测试和开发最适合客户需求的金融产品，并在数据分析和科学实验的基础之上进行决策。市场中不少企业也试图复制这一成功模式。但为什么他们没有成功呢？其实看懂人家的战略不难，产品形态也容易模仿，但是 Capital one 数十年以来在信息技术和创新能力方面的积累形成的竞争优势却是难以复制的。</p><p>正如 Capital One 的董事会主席兼 CEO 瑞奇·菲尔班克（Rich Fairbank），在一次投资者会议上指出的那样：我们的思维应该更像那些高科技企业，而不是银行（We need to think more like technology companies and maybe a little less like banks）。</p><h1 id="一切始于“主干”，万变不离其宗"><a href="#一切始于“主干”，万变不离其宗" class="headerlink" title="一切始于“主干”，万变不离其宗"></a>一切始于“主干”，万变不离其宗</h1><p>文章的前三段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Based on numerous surveys and conversations conducted with experienced clients, analysts, subject matter experts and peers, Aitken identified five leading benefits from adopting company wide open source strategies.</span><br><span class="line">Most companies initiate their open source journey because of the perceived financial benefits, although this is almost never the reason why they keep using and scale open source. The main reason is what Aitken calls secondary innovation: once teams have ingested open source software, they naturally customize it to their needs and organizations by adding new features. These teams’ led customizations contribute to increasing the speed of new ideas and features to market.</span><br><span class="line">The second benefit is teams’ ability to safely experiment and fail fast. When buying proprietary enterprise software, management and teams are pressured to make these products work because of the upfront investment, even if they no longer fit the purpose. With open source, teams feel empowered to download and experiment with various solutions. If they realize that it’s not the right open source for their project, they can experiment with different open source solutions and even consider proprietary software. Open source enables organizations to empower teams and provides teams the ability to fail fast and cheaply.</span><br><span class="line"></span><br><span class="line">与经验丰富的客户、分析师、主题专家和同行进行了大量的调查和对话后，埃特金总结了全公司范围内推行开源策略的五大益处。</span><br><span class="line">大多数公司开始其开源之旅，往往是因为他们感觉可以省钱，但是，他们继续使用并推广开源战略的原因几乎都和财务方面的好处无关。最主要的原因是埃特金所说的二次创新是：一旦团队接受了开源软件，他们自然会定制新的功能，来满足他们和组织的个性化需求。这些由开发团队主导的个性化定制有助于加快新的想法和功能推向市场的速度。</span><br><span class="line">第二个好处是团队能够安全地进行实验并获得“快速失败”的能力。当公司购买企业级专有软件时，管理层和团队会因为前期投资而被迫使用这些产品，哪怕它们不再适合公司的商业目的。而通过开源，团队可以下载和试验各种解决方案。如果团队意识到这个开源软件不适合他们的项目，他们可以尝试不同的开源方案，甚至可以考虑转而购买专有软件。开源战略使组织能够赋能团队，为团队提供低成本快速失败的能力。</span><br></pre></td></tr></table></figure><h2 id="知识讲解-1"><a href="#知识讲解-1" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="复习句子结构和状语从句"><a href="#复习句子结构和状语从句" class="headerlink" title="复习句子结构和状语从句"></a>复习句子结构和状语从句</h3><blockquote><p><strong>Based on numerous surveys and conversations conducted with experienced clients, analysts, subject matter experts and peers,</strong> Aitken identified five leading benefits from adopting company wide open source strategies.</p></blockquote><p>这一句话相对比较长，但我们应该很快就能找到主语 Aitken 和谓语动词 identified，后面跟着宾语 five leading benefits，这样整个句子的骨架就很清楚了，那就是“埃特金（即作者）发现了五大好处”。什么带来的好处呢？benefit from 是英语里的固定搭配，是 from 后面的原因带来的好处，即公司推行开源战略带来的好处。</p><p>英语的句子都是一棵棵大树，我们可以先找到主干之后，再去添加枝叶。最常见的枝叶就是状语，用来描绘动作发生的状态，这个状态可以是时间、地点，也可以是目的、条件等。</p><p>这句话里的加黑部分，就是过去分词短语 based on 做状语。那埃特金是怎么发现这些好处的呢？他是根据和一大批人做的调查和访谈得出的结论。</p><h3 id="perceive"><a href="#perceive" class="headerlink" title="perceive"></a>perceive</h3><blockquote><p>Most companies initiate their open source journey because of the <strong>perceived</strong> financial benefits, although this is almost never the reason why they keep using and scale open source.</p></blockquote><p>英文解释，to come to an opinion about something, or have a belief about something，“形成某种意见或认识”，也就是“对某些事物的意识、感觉和认知”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例句：New technology was perceived to be a threat to employment.</span><br><span class="line">翻译：新技术被认为是对就业的一种威胁。</span><br><span class="line"></span><br><span class="line">例句：Stress is widely perceived as contributing to heart disease.</span><br><span class="line">翻译：压力被广泛认为是导致心脏病的诱因。</span><br></pre></td></tr></table></figure><p>从上面的例句中可以看出，perceive 强调的是一种主观的认识，也就是人的一种观点或看法，而不是强调客观事实。例如文章中说的 perceived financial benefits，强调的是大家感觉用开源软件能带来财务上的好处，也就是省钱。至于是不是真的省钱，作者其实没有说。</p><p>在市场营销中有一个概念，叫 perceived value（过去分词做形容词），即“感知价值”，强调的是消费者自己认为的价值，而并非测算产品的成本以及利润得出的客观真实价值，也就说这不是 real value。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：The fact that an e-book can’t be sold or given away after it’s read also reduces the perceived value of the product.</span><br><span class="line">翻译：电子书在读完后不能卖掉或送人，降低了这一产品在人们眼中的价值。</span><br></pre></td></tr></table></figure><p>教市场营销的老师经常会有两句话挂在嘴边：第一句话是 All values are perceived value（所有的价值其实都是感知价值）；第二句话是 Perception is reality（感知即现实）。这两句话表达的意思差不多，就是要强调在市场中，几乎没有消费者会关心某种产品或服务的真实价值，他们心理上感知到的价值在他们眼中就等同于真实价值，而市场营销的任务，就是去洞察消费者心里那个感知价值，并想办法提高感知价值。</p><h3 id="though-although-和表示让步的状语从句"><a href="#though-although-和表示让步的状语从句" class="headerlink" title="though/although 和表示让步的状语从句"></a>though/although 和表示让步的状语从句</h3><blockquote><p>Most companies initiate their open source journey because of the perceived financial benefits, <strong>although this is almost never the reason why they keep using and scale open source.</strong></p></blockquote><p>文中加黑部分是由 although 或 though 引导表示让步的状语从句。所谓“让步”，就是退一步讲，是一种以退为进的说话方式，相当于汉语中的“虽然”“即便”“就算”等词。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：Although I don’t like him, I agree he is a good manager.</span><br><span class="line">翻译：虽然我不喜欢他，但我承认他是一个出色的经理人。</span><br></pre></td></tr></table></figure><p>同样，文章中这句话在明确讲，大部分公司开始开源的原因主要为了省钱，然后踏上开源之路以后怎么样呢？作者话锋一转，退后一步，强调省钱从来不是公司继续使用开源并且扩大规模的原因，并由此引出采用开源战略给公司带来的比省钱更重要的好处，就是后面提到的二次创新。</p><h4 id="though-和-although-的细微差别"><a href="#though-和-although-的细微差别" class="headerlink" title="though 和 although 的细微差别"></a>though 和 although 的细微差别</h4><p>首先，这两个词都是连词。一般情况下，although 比 though 更为正式。though 更多用于非正式表达。</p><p>其次，大部分情况下，这两个词是可以互换的，但我们之前讲过 as though 的固定搭配，though 不可以替换成 although，不存在 as although 的说法。</p><p>此外，though 可以做副词，但是 although 不行。例如，A 说：“Nice day！（天气不错。）”，然后 B 回应说：“Yes. Bit cold, though. （是不错，就是有点冷。）”此处的 though 用作副词，不能替换成 although。</p><h3 id="表语从句"><a href="#表语从句" class="headerlink" title="表语从句"></a>表语从句</h3><blockquote><p>The main reason is <strong>what Aitken calls secondary innovation.</strong></p></blockquote><p>谓语动词如果是及物动词，之后跟着的结构就是宾语，表示动作的对象。例如，过海关的时候，工作人员让你出示护照，他会说“Show me your passport.”。show 是动词，passport 是直接宾语，出示这个动作的对象是什么呢，当然是护照，所以 me 是间接宾语。</p><p>那什么是表语呢？如果谓语动词是系动词（顾名思义，系动词指联系前后两种句子成分的动词。它的英文可能更加清楚一些，叫 linking verb），系动词前面是主语，后面是表述主语状态或性质的结构就称为表语。</p><p>例如，我们说 The weather is horrible，is 就是系动词，horrible 就是表语。翻译成中文“天气太糟糕了”之后，表语就不存在了，因为汉语里没有表语这个称谓。</p><p>常用的系动词数量不多，我这里总结了几个，主要有：be (is/am/are)、sound、smell、feel、taste、become、seem、keep、stay 等。</p><p>关于系动词的用法，只要注意我这两点即可：</p><ul><li>第一，系动词后面跟形容词，而不是副词。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句 1：Tom spoke intelligently. （副词修饰谓语动词，描述说话的状态，讲得很有智慧）</span><br><span class="line">例句 2：Tom seems intelligent. （形容词修饰主语，表示 Tom 这个人很智慧）</span><br></pre></td></tr></table></figure><ul><li>第二，将系动词替换成 be 之后，句子的意思一般不会发生改变。<br>如果我们将上面例句 2 的 seems 换成 is，基本意思没有变化。如果我们把上面表语位置上的单词换成句子，就是表语从句。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：The question is whether he can pass the exam.</span><br><span class="line">翻译：问题是他能否通过考试。</span><br></pre></td></tr></table></figure><h3 id="once-和表示条件的状语从句"><a href="#once-和表示条件的状语从句" class="headerlink" title="once 和表示条件的状语从句"></a>once 和表示条件的状语从句</h3><blockquote><p>The main reason is what Aitken calls secondary innovation: <strong>once teams have ingested open source software,</strong> they naturally customize it to their needs and organizations by adding new features.</p></blockquote><p>once 引导状语从句，既可以表示时间（=as soon as），也可以表示条件（=if, as long as），两者其实没什么差别，都是“一旦”的意思，一般配合完成时态使用。</p><h3 id="contribute-to-something"><a href="#contribute-to-something" class="headerlink" title="contribute to (something)"></a>contribute to (something)</h3><blockquote><p>These teams’ led customizations <strong>contribute to</strong> increasing the speed of new ideas and features to market.</p></blockquote><p>这句话的主语是 customizations，之前有一个 led，是过去分词短语做前置定语，表示“由开发团队主导的个性化定制”。</p><p>谓语动词 contribute to 是固定搭配。这里你需要特别注意，to 后面需要接名词或者现在分词。而 contribute to 除了“捐助”“做贡献”的含义外，更多地是表示“促成”“使得”“有助于”等含义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例句：I think you should keep Eric because he really contributes a lot to our team.</span><br><span class="line">翻译：我认为你应该留下埃里克，因为他对我们的团队贡献很大。</span><br><span class="line"></span><br><span class="line">例句：I’m sorry, I think sleep deprivation contributed to my outburst just then.</span><br><span class="line">翻译：抱歉，睡眠不足让我刚才情绪失控了。</span><br></pre></td></tr></table></figure><h3 id="fail-fast"><a href="#fail-fast" class="headerlink" title="fail fast"></a>fail fast</h3><blockquote><p>The second benefit is teams’ ability to safely experiment and <strong>fail fast.</strong></p></blockquote><p>如果你是 Java 工程师，那你对 fail fast 的功能应该很熟悉。迭代器在集合遍历时发现，元素在不知情的情况下莫名其妙地被修改了，系统就会抛出异常。广义来讲，fail fast 是一种植入系统的保护机制，当有异常发生时就会立刻启动，中断执行。</p><p>创新的过程当然要容许失败，但在整个创新的漏斗中，早失败要比晚失败要好，对于一个项目团队而言，最可怕的事情莫过于项目几乎快要完成的时候，突然发现致命的全局性错误，这会导致大量人、财、物、资源和时间的浪费。所以，“快速失败”要比未来出现不确定风险要好。</p><p>开源战略允许团队进行安全的实验，赢得快速失败、不断低成本试错的能力，的确是最重要的益处之一。</p><h3 id="状语从句和长句"><a href="#状语从句和长句" class="headerlink" title="状语从句和长句"></a>状语从句和长句</h3><blockquote><p><strong>When buying proprietary enterprise software</strong>, management and teams are pressured to make these products work because of the upfront investment, <strong>even if they no longer fit the purpose.</strong></p></blockquote><p>主语是 management and teams（管理层领导和开发团队），然后我们找到谓语动词 are pressured（有压力）。有什么压力呢？买了产品要用起来，因为已经花钱了。</p><p>句子的主干有了，我们再看枝叶。</p><p>前面半句是我们熟悉的现在分词短语做时间状语，“当你买了企业级专有软件之后”。后面半句也是状语从句，表示条件，“即使这些软件不合适、没法解决企业问题”。这样枝叶就和主干的意思就串在一起了：花钱买了付费软件，即使发现没啥用，但已经投资了，反正也得用，所以领导和团队都有压力。</p><h3 id="empower"><a href="#empower" class="headerlink" title="empower"></a>empower</h3><blockquote><p><strong>With open source,</strong> teams feel <strong>empowered</strong> to download and experiment with various solutions.</p></blockquote><p>empower 这个词最基本的意思是“授权”，to give official authority or legal power to。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：I empowered my agent to close the deal.</span><br><span class="line">翻译：我授权我的经纪人完成这笔交易。</span><br></pre></td></tr></table></figure><p>最近这些年，empower 或 empowerment 一词在一系列思想解放运动和职场管理变革中广泛使用。在这种情况下，它的英文的解释是 to promote the self-actualization，即“推动相关群体的自我实现”。说白了就是让各类弱势群体获得更多的权利，让他们获得独立自主的力量。中文一般翻译成“赋权”。</p><p>很多企业进行员工授权，因为各种考量，更喜欢把 empowerment 翻译成“赋能”，有些玩文字游戏的感觉。如果要说“赋能”，enablement 其实更恰当。无论是“赋权”还是“赋能”，其实都有点翻译腔。</p><p>一个新词的翻译，往往前人想出来一个翻法，即使效果不太理想，用的人多了，也就约定俗成地沿用下来，“区块链”就是一例。区块链的英文是 blockchain，这里面的 block 指的是“数据块”，而不是传统意义上一个四方街区的地理区块，翻译成“数块链”更为准确。但前人已经种好了树，就算有点歪，大家也都看顺眼、用习惯了，也就无需再改。</p><h3 id="状语从句里的宾语从句"><a href="#状语从句里的宾语从句" class="headerlink" title="状语从句里的宾语从句"></a>状语从句里的宾语从句</h3><blockquote><p><strong>If they realize that it’s not the right open source for their project,</strong>they can experiment with different open source solutions and even consider proprietary software. Open source enables organizations to empower teams and provides teams the ability to fail fast and cheaply.</p></blockquote><p>这里的加黑部分又是一个状语从句，表示条件，但状语从句里面又套了一个宾语从句 that it’s not the right open source for their project。这整个从句是 realize 的宾语，也就是“意识到”这个动词的对象，即“如果他们意识到这个开源软件不行，可以换其他开源方案或者回去买专有软件”。</p><p>为什么这么灵活呢？最后一句话进行了总结，因为开源战略“赋能”组织，使组织可以“赋权”开发团队，使他们获得快速、低成本试错的能力。</p><h1 id="并列句-简单句-并列连词-简单句"><a href="#并列句-简单句-并列连词-简单句" class="headerlink" title="并列句 = 简单句 + 并列连词 + 简单句"></a>并列句 = 简单句 + 并列连词 + 简单句</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The third benefit open source offers is a better way of building software. As organizations scale their teams and applications, they can create silos between product teams, which in turn can create equally as many development silos. When organizations strategically pair open source with inner-sourcing programs – creating internal networks of shared code, transparency, increased collective code ownership and collaboration – organizations and teams speed knowledge transfer, and produce greater quality code. This in turn leads to more reliable software.</span><br><span class="line">A bank headquartered on the west coast concluded after performing an analysis of their development that only 20 to 25 percent of their code was shared across the organization, and that 50 to 70 percent of their code was redundant, creating duplicate software. They selected six software development teams, created a shared code repository, and developed a process for exposing and sharing those code repositories to different groups within the </span><br><span class="line"></span><br><span class="line">开源的第三个好处是提高软件开发质量。随着一个组织的团队和应用不断拓展，产品团队之间会形成“孤岛”，进而形成同样多的开发孤岛。当组织战略性地将开源与内源项目（内源项目旨在创建一个组织内部网络，来共享代码、提高透明度、增加代码集体所有权和鼓励内部协作）结合起来之后，组织和团队就能加速知识转移，产生更高质量的代码，并最终发布更可靠的软件。</span><br><span class="line">一家总部设在美国西海岸的银行对其软件开发进行分析后得出结论，只有 20% 到 25% 的代码在整个组织内部共享，而 50% 到 70% 的代码是冗余的，结果产生重复的软件。他们选择了六个软件开发团队，创建了一个共享的代码库，并开发了一个将代码库公开分享给组织内不同团队的流程。立竿见影的结果是团队将开发和共享的代码量增加了一倍，直接减少了冗余代码的数量和成本。</span><br></pre></td></tr></table></figure><h2 id="知识讲解-2"><a href="#知识讲解-2" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="silo"><a href="#silo" class="headerlink" title="silo"></a>silo</h3><blockquote><p>As organizations scale their teams and applications, they can create silos between product teams, which in turn can create equally as many development silos.</p></blockquote><p>它的原意是“农场里储存粮食或草料的筒仓”，看起来很像一个又一个挨得很近的水桶，但每个都高耸、密闭，各自独立，互不相连。后来，商业管理领域的学者就利用 silo 的这个形象，引申出新的一层意思，中文翻译叫“谷仓现象”，用来比喻企业内不同部门各自为政、不愿分享信息和资源的现象。有的翻译怕中国读者不了解谷仓的比喻含义，也会翻译成“孤岛现象”。</p><h3 id="复习定语从句（包括非限定性定语从句）"><a href="#复习定语从句（包括非限定性定语从句）" class="headerlink" title="复习定语从句（包括非限定性定语从句）"></a>复习定语从句（包括非限定性定语从句）</h3><p>我们从第一句话开始看，首先来找主语和谓语动词。</p><p><img src="/2020/06/14/geekbang-column-article-2-open-source-benefits-to-innovation-and-organizational-agility/dingcong.jpg" alt></p><p>第一句话的主语里面藏了一个定语从句，而且省略了引导词 that 或者 which，写完整的话应该是 benefit that/which open source offers，开源带来的好处，动词是 is，我们上次讲过 be 是系动词，不是实义动词，所以后面跟着的结构是表语，核心词是 way，所以是一个名词短语做表语，一种更好的编程方式。</p><p>第二句话，我们同样先找主语和谓语动词。</p><p><img src="/2020/06/14/geekbang-column-article-2-open-source-benefits-to-innovation-and-organizational-agility/dingcong2.jpg" alt></p><p>一看到第一个词 As 开头，又是我们熟悉的时间状语从句，先放在一边。往下看到主语 they，他们是谁，一会儿回到从句里面去找；接下来我们看到情态动词 can，情态动词表示说话人的语气，这里的 can 表示一般的可能性，但情态动词不能单独做谓语，必须要和实义动词或者系动词连用构成谓语，所以这句话的谓语是 can create，表示非常有可能造成产品团队间的孤岛。</p><p>句子的主干找到之后，我们再回过头去看一下前面的状语从句，看看主语 they 指的是什么。从句里面的主语是 organizations，指各类组织（这样说比较全面，企业也是某一种组织），后面的 they 应该也是指的各类组织；谓语动词是 scale，意思是“扩大、拓展”。我们把状语从句的意思和主干连在一起，就很清楚了：随着一个组织的团队和应用不断拓展，组织内的产品团队之间就很有可能会形成“孤岛”（或者“谷仓”）。</p><p>从逗号和 which 我们可以判断出来，后面还跟着一个非限定性定语从句，。我们在前面讲座中说过，非限定性定语从句起到补充说明、增加信息的作用，从句既可以修饰先行词，也可以修饰整个事情。这里的从句就是修饰前面讲的“在组织内的产品团队之间就形成孤岛”整个事情，进而补充说明这个事情还能再进一步，在开发团队之间也形成同样多的孤岛。</p><h3 id="inner-source-program"><a href="#inner-source-program" class="headerlink" title="inner source program"></a>inner source program</h3><blockquote><p>When organizations strategically pair open source with inner-sourcing programs – creating internal networks of shared code, transparency, increased collective code ownership and collaboration – organizations and teams speed knowledge transfer, and produce greater quality code.</p></blockquote><p>inner source 的概念这几年提得越来越多，我们先来看一下维基百科的定义，了解下它的含义。除此之外呢，因为它是本世纪产生的新词，也有写成 innersource、InnerSource、inner-source 的，这几种写法都是可以的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InnerSource is the use of open source software development best practices and the establishment of an open source-like culture within organizations. The organization may still develop proprietary software, but internally opens up its development. The term was coined by Tim O’Reilly in 2000.</span><br></pre></td></tr></table></figure><p>简而言之，inner source 是用开源的开发方式来做一个组织内部的开发平台。说得更加直白一点，就是闭源代码平台在公司内部对内的“开源”。</p><p>所以，inner source 翻译成“内部开源”平台应该是准确的。</p><p><img src="/2020/06/14/geekbang-column-article-2-open-source-benefits-to-innovation-and-organizational-agility/juzi1.jpg" alt></p><p>第一个词就是 When，出现它一般就是时间状语从句，我们先放一边。然后是前后两个破折号（和两个逗号是一样的作用），一看就是插入语，也先放一边。我们先找到主语 organizations and teams，然后找谓语动词，speed 和 produce，这是两个并列动作。主干的意思非常清楚，组织和各团队加快了知识转移和改善了代码质量。</p><p>又快又好的编程是怎么实现的呢？我们回去看状语从句，里面的谓语动词是 pair，把两样东西配一起，也就是开源结合内源平台，而破折号里面的插入语对内源平台的概念做了补充说明。这样把前后意思一串，就非常清楚了：开源加内源，编程的活干得又快又好。</p><p>最后一个小短句就是结论，主语 this 指代前面一大堆，谓语动词 leads to，表示最后的成果，几乎是更为可靠的软件。</p><h3 id="宾语从句"><a href="#宾语从句" class="headerlink" title="宾语从句"></a>宾语从句</h3><p><img src="/2020/06/14/geekbang-column-article-2-open-source-benefits-to-innovation-and-organizational-agility/bingcong1.jpg" alt></p><p>这句话的主语和谓语动词都非常明显，主语就是 bank，带一个后置定语，一家总部在美国西海岸的银行；谓语动词是 concluded，得出结论。根据什么得出结论呢？谓语动词后面紧跟了一个分词短语做时间状语，我们知道这家银行就他们的软件开发进行了分析之后，得出了结论。</p><p>那么结论的内容是什么呢？也就是 concluded 的宾语，我们看到了 that 引导的两个并列的宾语从句，分别说明了分析研究的结论。第一个结论是共享代码只占 20% 到 25%，第二个结论是冗余代码高达 50% 到 70%。</p><p>在此基础上，这个句子还没有完，逗号后面还跟了一个分词短语来做结果状语。结果怎么样呢？结果就是重复劳动，产生了重复的软件。</p><h3 id="简单句和并列句"><a href="#简单句和并列句" class="headerlink" title="简单句和并列句"></a>简单句和并列句</h3><p><img src="/2020/06/14/geekbang-column-article-2-open-source-benefits-to-innovation-and-organizational-agility/juzi2.jpg" alt></p><p>所谓简单句，就是只有一个结构的句子，谁（主语）做了什么（谓语）。</p><p>虽然上面这句话看着也比较长，但它的结构其实很简单。主语就是 They，根据前面一句话，我们知道这里的 they，指的是美西那家银行里面的那些人。他们干了什么呢？后面可以找到并列的三个谓语动词，selected、created、developed，也就是美西银行的“他们”连续做了三个动作：选开发团队、建共享代码库、开发内源流程。</p><p>从内容看，这就是一个简单句。但是，按照英语语法里一个简单句只能有一个谓语动词的大原则，虽然是同一个主语，但既然做了三个动作，从形式上讲也可以算并列句。争论这句话究竟是简单句还是并列句没什么意思，你明白背后的道理即可。</p><p><strong>所谓并列句（compound sentence），是两个或多个简单句的并列，各简单句意义同等重要，相互之间是平行并列的关系，而没有从属关系。如果有从属关系，就有主句和从句，变成复杂句（complex sentence）。</strong></p><p>并列句由并列连词相连，基本结构就是：简单句 + 并列连词 + 简单句。并列连词只有下列七个，取每个并列连词的首字母拼成非常著名的“FANBOYS”。</p><ul><li>For - Explains reason or purpose (just like “because”)I go to the park every Sunday, for I long to see his face.</li><li>And - Adds one thing to anotherI like to read, and I write faithfully in my journal every night.</li><li>Nor - Used to present an alternative negative idea to an already stated negative ideaI neither love nor hate to watch TV.</li><li>But - Shows contrastTelevision is a wonderful escape, but it interferes with my writing.</li><li>Or - Presents an alternative or a choiceWould you rather read a book or watch a good TV show?</li><li>Yet - Introduces a contrasting idea that follows the preceding idea logically (similar to “but”)I always take a book to the beach, yet I never seem to turn a single page.</li><li>So - Indicates effect, result or consequenceI like to read, so my grammar is always on-point.</li></ul><h3 id="expose-to-exposure"><a href="#expose-to-exposure" class="headerlink" title="expose to/exposure"></a>expose to/exposure</h3><p>expose to 是固定搭配的动词短语，常用的意思有两个，第一个意思是“透露或揭露原本保密的信息”，英文的解释是 to reveal private information to someone or something。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：She was arrested for exposing state secrets to a foreign agent.</span><br><span class="line">翻译：她因为向外国特工泄露国家机密而被捕。</span><br></pre></td></tr></table></figure><p>expose to 的第二层意思是“暴露、接触（而遭受危险或不快）”，例如接触病毒、胶卷曝光等，英文的解释是 to bring someone, something, or oneself into contact with someone or something, often with negative consequences。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：Well, my mom is really sick, which means that we might have exposed the kids to the flu virus when we had her watch them last week.</span><br><span class="line">翻译：嗯，我妈妈病得很重，这意味着上周我们让她看孩子的时候，可能已经让他们接触了流感病毒。</span><br></pre></td></tr></table></figure><p>expose 的名词形式是 exposure。例如，an actor with much recent exposure in television，最近经常在电视上露面的演员。我们在投资领域经常会看到 risk exposure、FX exposure 等说法，指的是没有对冲保护的投资，因而存在风险，一般翻译成“风险敞口、外汇敞口”。</p><h3 id="as-an-immediate-result"><a href="#as-an-immediate-result" class="headerlink" title="as an immediate result"></a>as an immediate result</h3><blockquote><p>As an immediate result, their teams doubled the amount of code that was developed and shared, <strong>which directly reduced the amount and cost of redundant code.</strong></p></blockquote><p>as a result 也是常用的固定搭配，表示结果，中间加上一个 immediate，强调是“立竿见影立刻产生的结果”。</p><p>最后加黑部分又是一个非限定性定语从句，which 指代前面阐述的整件事情，即各团队开发和共享的代码数量翻番。只有非限定性定语从句的 which 才可以指代整个事情，强调正是这件事直接降低了重复代码的数量和成本。</p><h1 id="谓语动词永远是英语句子的核心"><a href="#谓语动词永远是英语句子的核心" class="headerlink" title="谓语动词永远是英语句子的核心"></a>谓语动词永远是英语句子的核心</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">According to Aitken, the quality of the code increased dramatically because it was exposed to everyone inside the organization. This led to software developers taking more care in the software they were writing. Additionally, with new cross-functional teams contributing to the code base, there were some direct benefits from the product innovation perspective: teams developed new functionalities that they haven’t thought about previously.</span><br><span class="line">The next two benefits relate to talent retention and competency development. 80% of the organizations Aitken talked to shared that one of the key reasons why they got into open source is specifically to attract and retain the best software developer talent. Open source is evolving at a rapid pace, and developers learn new open source technologies every few years. In the competition for the best software development talent, companies now must advertise and show candidates that they are open source shops, and that they contribute to and open source their own software. Additionally, several studies showed that, through open source development and collaboration, developers become proficient faster, reducing the number of defects in their code base.</span><br><span class="line"></span><br><span class="line">按照埃特金的说法，由于代码对组织内每一个人开放，代码的质量得以大幅提升。这也使得软件开发人员在编写软件时更加用心。此外，随着新的跨职能团队持续不断丰富代码库，团队开发出了以前从未考虑过的新功能，这也是从产品创新的角度产生的直接成果。</span><br><span class="line">接下来的两个好处是保留人才和发展能力。在埃特金调研过的组织中，有 80% 认为他们采用开源的主要原因之一就是吸引和留住最优秀的软件开发人才。开源软件发展迅猛，开发人员每隔几年就要学习新的开源技术。在抢夺优秀程序员的竞争中，公司现在必须向应聘者宣传并展示自己的开源战略，公司自己开发软件并推广开源。此外，一些研究表明，通过开源发展和协作，开发人员的技能更为娴熟，其代码库中的缺陷数量也大为减少。</span><br></pre></td></tr></table></figure><h2 id="知识讲解-3"><a href="#知识讲解-3" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="简单句、并列句、复合句、复杂句"><a href="#简单句、并列句、复合句、复杂句" class="headerlink" title="简单句、并列句、复合句、复杂句"></a>简单句、并列句、复合句、复杂句</h3><p><img src="/2020/06/14/geekbang-column-article-2-open-source-benefits-to-innovation-and-organizational-agility/juzi3.jpg" alt></p><p>这句话的主语是 quality，谓语动词是 increase，所以句子的主干是 quality increased（质量提升）。然后我们再看一下枝叶，丰富一下主干。按照作者的说法，代码的质量大幅度提升，最后还有一个表示原因的状语从句来解释，为什么代码质量会大幅提升呢？因为代码对内部每一个人开放了。</p><h4 id="英语句式结构的整体框架整体梳理"><a href="#英语句式结构的整体框架整体梳理" class="headerlink" title="英语句式结构的整体框架整体梳理"></a>英语句式结构的整体框架整体梳理</h4><ul><li><p>第一，无论句子有多长，主干永远是一个简单句，谓语动词永远是句子的核心。</p></li><li><p>第二，大树主干以外都是枝叶，都是从属于主句的“挂件”，这样可以使得英语句子“主从分明”。</p></li><li><p>第三，语法概念永远是为理解意思服务的，不要被概念和规则束缚住手脚。</p></li></ul><h3 id="复习独立主格结构"><a href="#复习独立主格结构" class="headerlink" title="复习独立主格结构"></a>复习独立主格结构</h3><p><img src="/2020/06/14/geekbang-column-article-2-open-source-benefits-to-innovation-and-organizational-agility/juzi4.jpg" alt></p><p>独立主格是一个“格” ，属于短语性质，而不是一个“句子”或“从句”。因为独立主格结构没有真正的主语和谓语动词，它由名词或代词作为逻辑主语，加上分词、形容词、副词、动词不定式或介词短语作为逻辑谓语构成，前后两部分具有逻辑主谓关系。</p><p>从形式上看，独立主格结构与主句没有关系，但功能上相当于一个带有独立逻辑主语的状语从句。这句话里，加黑处就是独立主格结构。</p><p>这是独立主格结构做介词宾语，句子的主语是 this，是指示代词，指代前面提到过的事情（代码质量提高），谓语动词 led to（通向、造成什么结果），结果是什么呢？是后面跟着的独立主格结构，逻辑主语是 software developers，和句子本身的主语没有关系；用现在分词 taking care 作为逻辑谓语，和逻辑主语“软件工程师”形成逻辑主谓关系，“软件工程师对他们写的软解更上心”成为 led to 的宾语。</p><p><img src="/2020/06/14/geekbang-column-article-2-open-source-benefits-to-innovation-and-organizational-agility/juzi5.jpg" alt></p><p>这句话的主句是 there be 句型，属于主谓倒装。主语在后面，是 benefits，其实应该是 benefits were there，但已经约定俗成为 there be 的句型，表示有什么。所以主干就是有好处，从产品创新的角度看有好处。前面的独立主格结构用 with 引导（with 也可以省略），做状语，逻辑主语 new cross-functional teams 和逻辑谓语 contributing 构成逻辑主谓关系，“随着新的跨部门团队纷纷给代码库做贡献”作为伴随的状态。具体有什么好处呢，冒号后面进一步解释了：开发出以前想都没有想过的功能。</p><h3 id="从句套从句的复杂句"><a href="#从句套从句的复杂句" class="headerlink" title="从句套从句的复杂句"></a>从句套从句的复杂句</h3><p>最后一段，讲开源的而最后两个好处：留住人才、发展能力。这句话不长，但出现了三个从句。</p><p><img src="/2020/06/14/geekbang-column-article-2-open-source-benefits-to-innovation-and-organizational-agility/juzi6.jpg" alt></p><p>第一步还是找主干，主句的主语是 organizations，主语带了一个定语从句，如果加上省略的先行词应该是 organizations which Aitken talked to，即 80% 埃特金访谈过的那些组织；谓语动词是 shared，分享了什么内容呢？后面跟着一个宾语从句，而宾语从句的主语又套了一个定语从句，用表示原因的关系副词 why 引导，修饰从句的主语 key reasons，表示“最初开源的主要原因”；主要原因是什么呢？吸引和留住最优秀的软件开发人才。</p><p>组合：主句是 80% 埃特金访谈过的那些组织（主语）分享认为（谓语动词）他们最初开源的主要原因（宾语从句的主语）是吸引和留住最优秀的软件开发人才（宾语从句）。意思已经很清楚了，还不满意的话可以再改写一下，让它更加符合汉语的习惯。</p><h3 id="两个简单句组成的并列句"><a href="#两个简单句组成的并列句" class="headerlink" title="两个简单句组成的并列句"></a>两个简单句组成的并列句</h3><blockquote><p>Open source is evolving at a rapid pace, <strong>and</strong> developers learn new open source technologies every few years.</p></blockquote><p>这句话就是我们前面讲的，两个简单句用并列连词 and 连接成并列句（也叫并列复合句）。讲了两件事情，第一件事情是开源软件发展快，第二件事情是开发人员要经常学习开源技术。这两件事情互相之间没有附属关系，A 和 B 地位同等重要，属于并列句。</p><h3 id="两个并列的宾语从句"><a href="#两个并列的宾语从句" class="headerlink" title="两个并列的宾语从句"></a>两个并列的宾语从句</h3><p><img src="/2020/06/14/geekbang-column-article-2-open-source-benefits-to-innovation-and-organizational-agility/juzi7.jpg" alt></p><p>首先我们还是先找句子的主干。一看到 in the competition for，就知道是介词短语做状语，表示“在抢人的时候……”。主语是 companies，公司的复数，表示大部分公司；谓语动词是 must advertise and show，must 是情态动词，是来帮忙的，它自己不能做谓语动词，必须和实义动词 advertise and show 一起成为谓语。谓语动词后面跟了双宾语，紧跟其后的 candidates 是间接宾语，是“广告”和“秀”的对象，直接宾语是“广告”和“秀”的内容，通过两个 that 引导的宾语从句来体现：第一个“广告”要讲公司是开源名厂，第二个要“秀”公司自己开源写软件。</p><p>“在各大公司抢人的时候”，“公司都要大力宣传并且秀给应聘者看”，“此地是开源名厂”，而且“自己开源写软件”，潜台词就是，你们来对地方了，到本厂广阔天地、大有可为。</p><blockquote><p>Additionally, several studies showed <strong>that, through</strong> open source development and collaboration, developers become proficient faster, <strong>reducing</strong> the number of defects in their code base.</p></blockquote><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li><p>中文的句式结构相对比较松散，多为“意合”。我们经常将其比喻成一列火车或一盘珍珠。说话的人根据自己想要表达的意思，可以连绵不断地说出一连串没有连接成分的句子，犹如一条小溪，潺潺流水向前推进，一波又一波似分似合，彼此相像又各不相同。例如宝玉对黛玉说：“你死了，我做和尚。”</p></li><li><p>英文的句式结构则多为“形合”，更为强调外在逻辑，我们经常把英语的句子比喻为一棵大树或者一串葡萄——主干和枝叶（挂果）是非常分明的。我们分析句子时，通常可以先找到主干，再去添枝加叶。主干永远是主谓结构的简单句，找主干就是找到句子的主语（物质）和谓语动词（运动）。最常见的枝叶是我们已经非常熟悉的状语，来描绘动作发生的状态，可以是时间、地点，也可以是目的、条件等。所以，<strong>英语的句子，一切始于主干，万变不离其宗。领会这一点，英语的句法就会了大半。</strong></p></li></ul><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ul><li><a href="https://www.quickanddirtytips.com/business-career/public-speaking/how-to-be-a-great-guest-speaker" target="_blank" rel="noopener">How to Be a Great Guest Speaker</a></li><li><a href="https://www.forbes.com/sites/peterhigh/2016/12/12/how-capital-one-became-a-leading-digital-bank/#3da32d7815ee" target="_blank" rel="noopener">How Capital One Became A Leading Digital Bank</a></li><li><a href="https://grammar.yourdictionary.com/parts-of-speech/conjunctions/what-is-a-conjunction.html" target="_blank" rel="noopener">https://grammar.yourdictionary.com/parts-of-speech/conjunctions/what-is-a-conjunction.html</a></li><li><a href="https://grammar.yourdictionary.com/parts-of-speech/conjunctions/conjunctions.html" target="_blank" rel="noopener">https://grammar.yourdictionary.com/parts-of-speech/conjunctions/conjunctions.html</a></li><li><a href="https://www.mentalfloss.com/article/49238/7-sentences-sound-crazy-are-still-grammatical" target="_blank" rel="noopener">7 Sentences That Sound Crazy But Are Still Grammatical</a></li><li><a href="https://grammar.yourdictionary.com/sentences/writing-complex-compound-sentences.html" target="_blank" rel="noopener">Writing Compound-Complex Sentences</a></li></ul><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 08:48:16 GMT+0800 (CST) --&gt;&lt;p&gt;&lt;a href=&quot;https://www.infoq.com/news/2019/03/open-source-benefits/&quot; target=&quot;_bl
      
    
    </summary>
    
    
      <category term="English-Study" scheme="https://octopuslian.github.io/categories/English-Study/"/>
    
    
      <category term="并列句" scheme="https://octopuslian.github.io/tags/%E5%B9%B6%E5%88%97%E5%8F%A5/"/>
    
      <category term="定语从句" scheme="https://octopuslian.github.io/tags/%E5%AE%9A%E8%AF%AD%E4%BB%8E%E5%8F%A5/"/>
    
      <category term="宾语从句" scheme="https://octopuslian.github.io/tags/%E5%AE%BE%E8%AF%AD%E4%BB%8E%E5%8F%A5/"/>
    
  </entry>
  
  <entry>
    <title>English_Article 1：The Product-Minded Software Engineer</title>
    <link href="https://octopuslian.github.io/2020/06/14/geekbang-column-article-1-the-product-minded-software-engineer/"/>
    <id>https://octopuslian.github.io/2020/06/14/geekbang-column-article-1-the-product-minded-software-engineer/</id>
    <published>2020-06-14T03:33:14.000Z</published>
    <updated>2020-06-17T13:05:33.769Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 08:48:17 GMT+0800 (CST) --><p><a href="https://blog.pragmaticengineer.com/the-product-minded-engineer/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website" target="_blank" rel="noopener">The Product-Minded Software Engineer</a></p><h1 id="导读：背景知识对于理解文章究竟有多重要？"><a href="#导读：背景知识对于理解文章究竟有多重要？" class="headerlink" title="导读：背景知识对于理解文章究竟有多重要？"></a>导读：背景知识对于理解文章究竟有多重要？</h1><h2 id="背景知识的重要性"><a href="#背景知识的重要性" class="headerlink" title="背景知识的重要性"></a>背景知识的重要性</h2><p>这个标题“The Product-Minded Software Engineer”中有两个关键词，product-minded（产品思维）和 engineer（工程师）。这篇文章的主题是产品思维，那我们就要先去了解一些背景知识。</p><h2 id="核心词汇：minded"><a href="#核心词汇：minded" class="headerlink" title="核心词汇：minded"></a>核心词汇：minded</h2><p>我们一般会在 minded 前面加一个形容词或名词，用连字符连接，通过连用构成复合形容词，表示“具有某种（前面形容词定义的）思维（或态度、性格）”。我们通过几个例句，来感受一下 minded 这个词的使用场景。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例句：The United States is a sports-minded country, with millions of fans who follow football, baseball, basketball and hockey, among other sports.</span><br><span class="line">翻译：美国是一个体育意识很强的国家，有数以百万计的球迷关注足球、棒球、篮球和曲棍球等体育运动。</span><br><span class="line"></span><br><span class="line">例句：Two dozen states have asked the D.C. Circuit to block a new climate-change-minded federal law that they say will inflate electricity bills for families.</span><br><span class="line">翻译：二十多个州要求华盛顿特区巡回法院阻止一项新的关注气候变化的联邦法律，他们说这项法律将增加家庭的电费账单。</span><br><span class="line"></span><br><span class="line">例句：They are business-minded yet warm-hearted when it comes to those less fortunate, and prove that they can transform their theoretical academic knowledge into sustainable business practices through social projects.</span><br><span class="line">翻译：对于那些不幸的人，他们既有商业头脑，又有古道热肠。他们证明自己能够通过社会项目，将理论上的学术知识转化为可持续的商业实践。</span><br></pre></td></tr></table></figure><h1 id="什么时候适合用“词根词缀法”来背单词？"><a href="#什么时候适合用“词根词缀法”来背单词？" class="headerlink" title="什么时候适合用“词根词缀法”来背单词？"></a>什么时候适合用“词根词缀法”来背单词？</h1><p>先来精读文章第一段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Proactive with product ideas/opinions</span><br><span class="line">Product-minded engineers don’t settle for getting a specification and jumping to implement it. They think about other ideas and approach the product manager with these. They often challenge existing specifications, suggesting alternative product approaches, that might work better.  </span><br><span class="line"></span><br><span class="line">1. 积极主动地对待产品理念或观点</span><br><span class="line">具有产品思维的工程师不会满足于拿到设计说明后就匆匆忙忙地立即执行。他们会思考其他的创意，并找产品经理提出这些想法。他们经常挑战现有的设计规范，建议可能更优的替代性方法。</span><br></pre></td></tr></table></figure><h2 id="知识讲解"><a href="#知识讲解" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="proactive"><a href="#proactive" class="headerlink" title="proactive"></a>proactive</h3><p>它的意思是“积极、主动的”，它的反义词是 reactive，“消极、被动的”。</p><p>我们先来看一个例句，通过这个例句我们来学习这两个词的含义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例句：The difference between proactive people and reactive people is that proactive people take initiative, and they come up with ideas to get things done despite the conditions they are in. Reactive people, on the other hand, usually are the ones to react to a situation rather than take initiative to create a situation.  </span><br><span class="line"></span><br><span class="line">翻译：积极主动的人和消极被动的人之间的区别在于，积极主动的人会采取主动，无论他们所处的环境如何，都会想出办法来完成任务；而消极被动型的人通常只会对形势做出被动的反应，而不会主动采取行动去创造形势。</span><br></pre></td></tr></table></figure><p>讲到 reactive， 想到了 reactive programming（响应式编程）。</p><p>同样道理，Pro- 和 Re- 这一对反义前缀，能够帮助我们更好地理解和记忆其他单词。例如 progress（前进、进化）和 regress（后退、退化）。它们的英语解释如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Progress is to move, go, or proceed forward; to advance.</span><br><span class="line"></span><br><span class="line">Regress is to move backwards to an earlier stage; to devolve.</span><br></pre></td></tr></table></figure><h3 id="settle-for-settle"><a href="#settle-for-settle" class="headerlink" title="settle for / settle"></a>settle for / settle</h3><p>英文解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">settle for (something):</span><br><span class="line"></span><br><span class="line">to accept something less ideal or worse than what one really wanted;</span><br><span class="line">to agree to accept something (even though something else would be better);</span><br><span class="line">accept or be satisfied with as a compromise.</span><br></pre></td></tr></table></figure><p>简单来说，settle for 就是“勉强同意接受，将就或者凑合”的意思。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例句：He demanded a bigger raise but decided to settle for what they offered.</span><br><span class="line">翻译：他原本要求更高的涨薪，但最后决定人家给多少拿多少，凑合一下算了。</span><br><span class="line"></span><br><span class="line">例句：I could never settle for such a quiet life; I want excitement.</span><br><span class="line">翻译：我不能将就如此单调的生活。我需要刺激。</span><br></pre></td></tr></table></figure><p>同样，settle 这个动词有“停留、安顿”的含义，也可以衍生出“将就、凑合、妥协”的意思。苹果公司创始人乔布斯在他著名的斯坦福大学毕业典礼演讲中就有这么一段，你可以感受一下：</p><blockquote><p>And that is as true for your work as it is for your lovers. Your work is going to fill a large &gt;part of your life, and the only way to be truly satisfied is to do what you believe is great &gt;work. And the only way to do great work is to love what you do. If you haven’t found it yet, &gt;keep looking. <strong>Don’t settle</strong>. As with all matters of the heart, you’ll know when you find it. &gt;And, like any great relationship, it just gets better and better as the years roll on. So &gt;keep looking until you find it. <strong>Don’t settle</strong>.</p></blockquote><p>在这段话里，乔帮主两次提到“Don’t settle”，就是让我们跟随自己的内心，去寻找我们倾心的工作或爱情，找到了，你的心会告诉你，往后的日子历久弥新会越来越好；还没找到的话，千万不要放弃，不要妥协，不可以将就和凑合。</p><h3 id="specification"><a href="#specification" class="headerlink" title="specification"></a>specification</h3><p>在工程中，指的是“设计说明书、设计规范”的意思：a detailed description of the design and materials used to make something.</p><h3 id="jump-to"><a href="#jump-to" class="headerlink" title="jump to"></a>jump to</h3><p>顾名思义是“匆匆忙忙、很快，甚至有些草率”的意思。</p><h4 id="第一种用法：jump-to-conclusions-to-guess-the-facts-about-a-situation-without-having-enough-information"><a href="#第一种用法：jump-to-conclusions-to-guess-the-facts-about-a-situation-without-having-enough-information" class="headerlink" title="第一种用法：jump to conclusions: to guess the facts about a situation without having enough information."></a>第一种用法：jump to conclusions: to guess the facts about a situation without having enough information.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：Don’t jump to conclusions! Perhaps it was his daughter he was dancing with.</span><br><span class="line">翻译：别匆忙下结论，和他跳舞的没准是他女儿呢。</span><br></pre></td></tr></table></figure><h4 id="第二种用法：jump-to-it-informal-used-to-tell-someone-to-do-something-quickly"><a href="#第二种用法：jump-to-it-informal-used-to-tell-someone-to-do-something-quickly" class="headerlink" title="第二种用法：jump to it (informal): used to tell someone to do something quickly."></a>第二种用法：jump to it (informal): used to tell someone to do something quickly.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：I told you to tidy this room - now jump to it!</span><br><span class="line">翻译：（俚语）早就让你打扫房间，怎么还这样乱！快去！</span><br></pre></td></tr></table></figure><h4 id="第三种用法：jump-to-sb’s-defence-to-quickly-defend-someone"><a href="#第三种用法：jump-to-sb’s-defence-to-quickly-defend-someone" class="headerlink" title="第三种用法：jump to sb’s defence: to quickly defend someone."></a>第三种用法：jump to sb’s defence: to quickly defend someone.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：Whenever anyone criticizes her husband, she immediately jumps to his defence.</span><br><span class="line">翻译：每当有人批评她的丈夫时，她会立即为他辩护。</span><br></pre></td></tr></table></figure><h3 id="approach"><a href="#approach" class="headerlink" title="approach"></a>approach</h3><p>这一段出现了两次 approach，分别有不同的意思。第一处是动词，意思是“找（某人）谈话、与（某人）打交道”，第二处是名词，意思是“（处理）方法”。这些都是最早从 to go or come near in place or in time 或者 come near in quality or character, resemble, become similar 等含义中衍生出来的意思。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例句：The workers approached the manager with a request for shorter working hours.</span><br><span class="line">翻译：工人们找经理要求减少工作时间。</span><br><span class="line"></span><br><span class="line">例句：Those officials were approached with bribes.</span><br><span class="line">翻译：这些官员是被贿赂买通的。在特定语境中，approach a government officer 本身就有企图贿赂政府官员的意思。</span><br><span class="line"></span><br><span class="line">例句：His sober approach to the crisis averted a catastrophe.</span><br><span class="line">翻译：他对危机的冷静处理避免了一场大灾难。</span><br></pre></td></tr></table></figure><h1 id="到底要不要学语法？什么时候学比较好？"><a href="#到底要不要学语法？什么时候学比较好？" class="headerlink" title="到底要不要学语法？什么时候学比较好？"></a>到底要不要学语法？什么时候学比较好？</h1><p>精读文章的第二段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2. Interest in the business, user behavior and data on this</span><br><span class="line">When coming with ideas, product-minded engineers don&apos;t just get these from thin air. They take the time to understand how the business works, how the product fits in, and what its goals are. They are also empathetic about how the product makes users feel and how those users benefit from using this product. They often dive straight to data about business and user metrics, getting their hands on this data however they can. They might access it directly - if this is possible - or approach the product manager or data scientists to get this kind of information. They do this because of their curious nature. This is the next trait I&apos;ve observed.</span><br><span class="line"></span><br><span class="line">2. 工程师对业务、用户行为和数据的兴趣</span><br><span class="line">具有产品思维的工程师们的想法和创意都不是凭空得来的。他们会花时间去了解企业是如何商业运作的，产品又是如何配合商业运作，以及最终要达到什么样的商业目标。此外，他们也会去换位思考，试图理解产品将给用户带来什么感受，以及用户如何从使用产品中受益。他们通常会直接去深入研究商业数据和用户测量指标，并尽其所能获取这些数据。如果可能的话，他们会直接访问相关数据，或者找产品经理、数据专家去要这些信息。工程师们这样做，往往是出于他们好奇的天性。这也是我观察到的下一个特征。</span><br></pre></td></tr></table></figure><p>所有的英语句子，无论长短多少、变态与否，都可以归入三类：简单句、并列句和复合句。</p><h2 id="知识讲解-1"><a href="#知识讲解-1" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="状语（分词短语做时间状语）"><a href="#状语（分词短语做时间状语）" class="headerlink" title="状语（分词短语做时间状语）"></a>状语（分词短语做时间状语）</h3><blockquote><p>When coming with ideas, product-minded engineers don’t just get these from thin air.</p></blockquote><p>这段话的第一句就是分词短语做时间状语。<strong>所谓状语，顾名思义，就是对动作的状态进行描述的句子成分，可以是单词（副词）、短语（分词短语）或句子（状语从句）。状语可以用来说明地点、时间、原因、目的、结果、条件、方向、程度、频率、方式、伴随等等。</strong></p><p>看几个分词短语做时间状语的超级简单的例句，一般都带有引导时间状语的关系连词，例如 before、after、when 等，分词短语紧随其后。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例句：She normally boils the water before drinking it.</span><br><span class="line">翻译：她喝水之前通常会把水烧开。</span><br><span class="line"></span><br><span class="line">例句：After talking to you I always feel better.</span><br><span class="line">翻译：每次和你聊完之后，我都感觉心里舒服多了。</span><br><span class="line"></span><br><span class="line">例句：When opened, keep in refrigerator.</span><br><span class="line">翻译：开罐之后，需要冷藏。</span><br></pre></td></tr></table></figure><h3 id="thin-air"><a href="#thin-air" class="headerlink" title="thin air"></a>thin air</h3><p>英文解释：nowhere to be found in a giant void；nihility; nothingness; nullity; void; the state of nonexistence。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例句：You need to work hard—opportunities don’t just come out of thin air.</span><br><span class="line">翻译：你得努力啦，机会不会凭空产生 / 天上不会掉馅饼。</span><br><span class="line"></span><br><span class="line">例句：The magician pulled a bouquet of flowers out of thin air.</span><br><span class="line">翻译：魔术师妙手空空变出一捧花来。</span><br><span class="line"></span><br><span class="line">例句：With her children almost grown up, she found herself having to conjure a career from thin air.</span><br><span class="line">翻译：孩子们都快长大了，她发现自己需要凭空变出个工作来。</span><br></pre></td></tr></table></figure><p>和 thin air 搭配的介词，通常是 out of 或者 from。</p><h3 id="动词宾语从句"><a href="#动词宾语从句" class="headerlink" title="动词宾语从句"></a>动词宾语从句</h3><blockquote><p>They take the time to understand how the business works, how the product fits in, and what its goals are.</p></blockquote><p>这句话首先是用不定式 to do 做状语，表示目的。程序员花时间干什么？to understand，是一个及物动词，去了解，了解什么？后面跟的就是宾语从句，而且是三个并列的宾语从句。</p><h3 id="take-time"><a href="#take-time" class="headerlink" title="take (time)"></a>take (time)</h3><p>take the time 是非常地道的搭配，如果非要说 spend the time，当然别人也能理解，但一听就是不地道的英语。另外，take 还可以和具体的时间搭配在一起，你可以把 the time 换成具体的事情，表示“做什么事情需要花多少时间”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例句：I took three hours to get home last night.</span><br><span class="line">翻译：昨天晚上回家花了我三个小时。</span><br><span class="line"></span><br><span class="line">例句：The journey home last night took me three hours.</span><br><span class="line"></span><br><span class="line">例句：It took me three hours to get home last night.</span><br></pre></td></tr></table></figure><h3 id="fit-in"><a href="#fit-in" class="headerlink" title="fit in"></a>fit in</h3><p>fit in 的第一个意思是“融入”，英文解释是：To become assimilated into and accepted by a group。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：I just don’t fit in with any of the kids at my new school.</span><br><span class="line">翻译：我和新学校的小孩们都合不来。</span><br></pre></td></tr></table></figure><p>fit in 的第二个意思是“适合”，英文解释是：To blend or work harmoniously with something。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：Working in a research lab really fits in with my shy personality.</span><br><span class="line">翻译：在科研实验室工作非常适合我腼腆的性格。</span><br></pre></td></tr></table></figure><h3 id="介词宾语从句"><a href="#介词宾语从句" class="headerlink" title="介词宾语从句"></a>介词宾语从句</h3><blockquote><p>They are also empathetic about how the product makes users feel and how those users benefit &gt;from using this product. They often dive straight to data about business and user metrics, &gt;getting their hands on this data however they can.</p></blockquote><p>这句话说，他们会共情，会去换位思考。思考什么？about 这个介词后面跟了两个并列的宾语从句。第一，思考产品将给用户带来什么感受；第二，思考用户如何从使用产品中受益。</p><p>最后半句是分词短语做状语，这个街角我们已经走过好几次了。这里的状语表示伴随状态，程序员们会直接去研究商业数据和用户指标，getting hands on，表示“同时动手获取这些数据”。</p><h3 id="empathy-和-sympathy"><a href="#empathy-和-sympathy" class="headerlink" title="empathy 和 sympathy"></a>empathy 和 sympathy</h3><p>empathy 和 sympathy 这两个单词的拼写很相像，含义似乎相似，但其实完全不一样。</p><p>empathy 表示“感同身受”，它的英文解释是：an individual’s ability to understand what another person is going through, by perceiving himself in the same situation，指一个人通过把自己放到相同的情境中感知自己，来理解另一个人正在经历的事情的能力。而有时候我们说“共情”，是强调“理解、共鸣”的意思。你可以通过下面这个例句再感受一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：He is empathetic with the jobless youth, as he was also struggling for a job in his early years.</span><br><span class="line">翻译：他对失业的年轻人感同身受，因为他自己早年也为找工作挣扎过。</span><br></pre></td></tr></table></figure><p>而 Sympathy 表示“同情”，它的英文解释是：the feeling of sorrow for the hardships, problems and pain caused to another person，指“对另一个人造成的困难、问题和痛苦感到悲伤或怜悯”，更强调“同情、悲悯”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：All Tony’s friends joined in sending their sympathies to his widow Jean.</span><br><span class="line">翻译：托尼的所有朋友都向他的遗孀琼表示了同情。</span><br></pre></td></tr></table></figure><h3 id="dive"><a href="#dive" class="headerlink" title="dive"></a>dive</h3><p>dive 的本意是“跳水”，就是头和两臂先入水的那种，plunge head first into water。它也可以指“鱼类、潜水艇或人类，借助呼吸设备潜水到更深的水下，(of a fish, a submarine, or a vessel used for underwater exploration) go to a deeper level in water (using breathing equipment)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：The fish dive down to about 1,400 feet and then swim southwest.</span><br><span class="line">翻译：那条鱼潜到大约 1400 英尺的深度，然后向西南方向游去。</span><br></pre></td></tr></table></figure><p>除此之外，dive 还可以指“飞机或鸟类在空中俯冲”，(of an aircraft or bird) plunge steeply downward through the air。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：The aircraft dove for the ground to avoid the attack.</span><br><span class="line">翻译：飞机向地面俯冲以躲避攻击。</span><br></pre></td></tr></table></figure><p>在此基础上，我们可以通过“一头扎进去”这个意思，进一步引申出“立即开始采取行动、深入分析研究”等含义。例如本段话里的 dive to，就有程序员“立刻开始深入挖掘数据”的意思。比较常见的搭配还有 deep dive。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例句：Although this article does not provide a deep dive into the programming language, some Objective-C fundamentals are provided below.</span><br><span class="line">翻译：尽管本文没有深入介绍编程语言，但是下面提供了一些 Objective-C 的基础知识。</span><br><span class="line"></span><br><span class="line">例句：Each article will dive deep into these concepts, with lots of detail and source code.</span><br><span class="line">翻译：每篇文章都将深入探讨这些概念，包括大量细节和源代码。</span><br></pre></td></tr></table></figure><h3 id="user-metrics"><a href="#user-metrics" class="headerlink" title="(user) metrics"></a>(user) metrics</h3><p>software metrics 即“软件测量 / 度量”，有时候也叫 software measurements。</p><p>要想真正跳脱出软件开发的暗箱，除了定性评估以外，还需要一系列基于数值的度量指标来进行测评。同样道理，对于一个产品的用户体验，也有相应的用户测量指标。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例句：Software metrics are numerical ratings to measure the complexity and reliability of source code, the length and quality of the development process and the performance of the application when completed.</span><br><span class="line">翻译：软件度量使用数值评级来衡量源代码的复杂性和可靠性、开发过程的长度和质量以及应用程序完成后的性能。</span><br><span class="line"></span><br><span class="line">例句：Social media technologies have given companies access to an unprecedented flood of new analytics, metrics and user data.</span><br><span class="line">翻译：有了社交网络之后，企业获取了空前大量的新分析方法、度量指标和用户数据。</span><br></pre></td></tr></table></figure><h3 id="插入语"><a href="#插入语" class="headerlink" title="插入语"></a>插入语</h3><blockquote><p>They might access it directly - if this is possible - or approach the product manager or data &gt;scientists to get this kind of information. They do this because of their curious nature. This &gt;is the next trait I’ve observed.</p></blockquote><p>在这句话里，if this is possible 是插入语。在阅读的过程中，如果感觉句子偏长或者偏复杂，我们完全可以先忽略插入语。插入语通常夹在两个破折号或者两个逗号之间。</p><h1 id="从那些不规范的表达中，我们可以学到什么？"><a href="#从那些不规范的表达中，我们可以学到什么？" class="headerlink" title="从那些不规范的表达中，我们可以学到什么？"></a>从那些不规范的表达中，我们可以学到什么？</h1><p>文章的第三段和第四段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3. Curiosity and a keen interest in &quot;why?&quot;</span><br><span class="line">Product-minded engineers like to understand the &quot;why?&quot; behind all things. Why build this feature for the product, why not the other one? Why ship this first milestone, instead of choosing another one, that&apos;s a lot simpler to build? How will things be measured - why don&apos;t we choose a more thorough way to measure things?</span><br><span class="line">They are autonomous in finding answers they can, by themselves. They turn to the product manager and other people in the business for other, product-related questions. Even though they ask many questions, doing this frequently, they manage not to annoy people, as they&apos;ve built up strong relationships with them.</span><br><span class="line">4. Strong communicators and great relationships with non-engineers</span><br><span class="line">Product-minded engineers like talking with people outside engineering, learning about what and why they do. They are smooth communicators, making it clear they&apos;re interested in learning more about how other disciplines work. I frequently see them grabbing coffee, lunch, or doing a hallway chat with non-engineers.</span><br><span class="line"></span><br><span class="line">软件工程师的好奇心和对“为什么”的浓厚兴趣。具有产品意识的工程师喜欢去理解所有事物背后的那个“为什么? ”。为什么产品要开发这个功能、而不开发另一个功能呢？为什么要首先发布这一里程碑，而不是选择另一个更简单的里程碑呢？如何进行测量——为什么我们不选择一种更全面彻底的度量方式来测量呢？</span><br><span class="line">他们能够自主地找到他们能够找到的答案。他们也会向产品经理和其他业务人员寻求帮助，找寻其他与产品相关问题的答案。尽管他们经常会问很多问题，但是他们都会设法不让其他人觉得不爽，因为他们已经与那些同事建立起了牢固的关系。</span><br><span class="line"></span><br><span class="line">强大的沟通能力，建立与非工程师同事良好的关系。具有产品意识的工程师喜欢与软件工程领域外的同事们交谈，了解他们在做什么、为什么做。他们善于沟通，充分显示他们对于学习其他学科工作方式的浓厚兴趣。我经常看到他们和其他专业的同事们一起喝咖啡、吃午饭或者在走廊上聊天。</span><br></pre></td></tr></table></figure><p>这几段话的意思比较直白，但存在几处写作不规范的地方，可以作为反面教材，供我们分析。</p><p><strong>首先，口语交流和书面写作对于语言精确和严谨程度的预期要求是不同的。</strong>如果只是作为口语交流，只要不影响意思的表达，出现一些语法错误或者不规范之处，并无大碍；但对于那些需要正式发表的书面稿件，例如学术论文、合约、新闻稿等，写作过程中的语言就要力求规范。</p><p><strong>其次，我们不要迷信那些英语是母语的外国人，觉得他们说的或写的每句话都一定是正确的。</strong>有时候因为各种原因，英语母语国家的人在口头和书面表达中都会出现或多或少的错误用法，其随意性甚至超过外语学习者。</p><h2 id="知识讲解-2"><a href="#知识讲解-2" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="curiosity-keen-interest"><a href="#curiosity-keen-interest" class="headerlink" title="curiosity/keen interest"></a>curiosity/keen interest</h3><ul><li><p>curiosity killed the cat，“好奇害死猫”，说的就是好奇心容易惹祸上身，即便猫有九条命都不够死，告诫别人不要多管闲事，不要到处打听和自己无关的事情。<br>Inquisitiveness can lead one into dangerous situations.</p></li><li><p>Keen interest，意思是“浓厚的兴趣”。有一个常用的英语成语也可以表示同样的意思，但是非常形象生动，(as) keen as mustard，“像芥末一样浓烈”，表示 very excited and interested；very enthusiastic。mustard 是黄芥末，由芥菜种子碾磨而成，在西方国家比较常见，一般和热狗搭配。日本料理使用的是绿芥末，wasabi，其实是山葵酱。</p></li></ul><p>类似 as X as Y 这样的英语成语还有不少，例如 as hard as nail，as hot as hell 等，第一个 as 在口语或非正式表达中可以省略。很多成语是约定俗成的传统表达方式，其中有些比喻涉及特定的文化背景。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：I gave him the job because he was willing to learn and seemed as keen as mustard.</span><br><span class="line">翻译：我给他这份工作，是因为他学习愿望强烈，兴趣（如同芥末一样）浓厚。</span><br></pre></td></tr></table></figure><h3 id="why-not-do-结构"><a href="#why-not-do-结构" class="headerlink" title="why (not) do 结构"></a>why (not) do 结构</h3><blockquote><p>Product-minded engineers like to understand the “why?” behind all things. Why build this &gt;feature for the product, why not the other one? Why ship this first milestone, instead of &gt;choosing another one, that’s a lot simpler to build? How will things be measured - why don’t ?&gt;we choose a more thorough way to measure things?</p></blockquote><p>第一句话“具有产品意识的工程师喜欢去理解所有事物背后的那个为什么”的后面，跟了三组并列的问句，来举例说明具有产品思维的工程师通常会问的问题。</p><p>注意 why+do 和 why not+do 的结构和用法。why+do 通常表示“该动作没有必要、无意义”。why not+do 通常表示“建议采取该动作”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Why build this feature for the product? = Why do we build this feature for the product?</span><br><span class="line"></span><br><span class="line">why not the other one? = Why not build the other one? = Why don’t we build the other one?</span><br><span class="line"></span><br><span class="line">例句：Why argue with him？He will never change his mind. （注意不能说 why arguing with him?）</span><br><span class="line">翻译：干嘛和他争？他永远不会改主意的。</span><br><span class="line"></span><br><span class="line">例句：Sandy’s in bad mood. Why not give her some flowers?</span><br><span class="line">翻译：桑迪心情不好，何不送她一些花呢？</span><br><span class="line"></span><br><span class="line">例句：Why don’t you give her some flowers?</span><br><span class="line">翻译：你为什么不给她送些花呢？</span><br></pre></td></tr></table></figure><h3 id="ship-the-milestone"><a href="#ship-the-milestone" class="headerlink" title="ship the milestone"></a>ship the milestone</h3><p>“发布某一阶段的成果”或者“上市某一版产品”的意思。</p><p>ship 做动词的时候，基本含义是“船运”“运输”，在此基础上引申出“发货”“上市” “发布”等含义。milestone 由“里程碑”（a stone pillar that shows the distance in miles to or from a place）引申出了“重大事件”“阶段性成果”“重要时间节点”等含义。因此，除非你讲的是物流（例如航运行业）的事情，其他大部分语境下 ship 都是指“产品上市、发布或者发货”的意思。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例句：Apple will unveil a 10-inch touchscreen tablet device in January, and ship the product in March.</span><br><span class="line">翻译：苹果将于一月份推出 10 英寸触屏平板电脑，并于三月份发货。</span><br><span class="line"></span><br><span class="line">例句：We define an iteration as a phase or a milestone.</span><br><span class="line">翻译：我们将一次迭代定义为一个阶段或一个里程碑。</span><br></pre></td></tr></table></figure><h3 id="不规范的定语从句"><a href="#不规范的定语从句" class="headerlink" title="不规范的定语从句"></a>不规范的定语从句</h3><blockquote><p>Why ship this first milestone, instead of choosing another one, that’s a lot simpler to build?</p></blockquote><p>此句标黑处为限定性定语从句，修饰先行词 another one，所以这里应该去掉逗号。如果是非限定性定语从句，要保留逗号，但 that 必须改为 which。</p><h3 id="autonomous"><a href="#autonomous" class="headerlink" title="autonomous"></a>autonomous</h3><blockquote><p>They are autonomous in finding answers they can, by themselves. They turn to the product manager and &gt;other people in the business for other product-related questions.</p></blockquote><p>autonomous 一般指“地区或组织享有自治权”，英文意思是 governs or controls itself rather than being controlled by anyone else，或者指“个人独立自主、自发做一些事情（例如本句）”，英文意思是 able to do things and make decisions without help from anyone else。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A self-driving car, also known as an autonomous vehicle (AV), driverless car or robotic car, is a vehicle that can sense its environment and moving safely with little or no human input.</span><br><span class="line">自动驾驶汽车也被称为无人驾驶汽车或机器人汽车，是一种能够感知周围环境并在几乎没有人类干预的情况下安全行驶的交通工具。</span><br></pre></td></tr></table></figure><p>需要指出的是，互联网公司研发自动驾驶汽车比较喜欢用 driverless 这个词，突出无人驾驶，表示未来要取消驾驶员。而传统的汽车行业更坚持使用 autonomous 这个词，淡化“无人”的概念，并强调非由机器还是人类来驾驶汽车，这个决定最终要由人类做出，不能剥夺人类的驾驶乐趣。<strong>所以，一个简单的单词背后，代表的可能是不同行业对同一件事的不同态度。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Oracle Autonomous Database is a cloud-based technology designed to automate many of the routine tasks required to manage Oracle databases, which Oracle says can free up DBAs to do higher-level and more strategic work.</span><br><span class="line">甲骨文自治数据库是一种基于云的技术，旨在自动化管理甲骨文数据库所需的许多日常任务。甲骨文公司表示，这可以让数据库管理员们腾出时间来做更高层次、更具战略性的工作。</span><br></pre></td></tr></table></figure><h3 id="定语从句"><a href="#定语从句" class="headerlink" title="定语从句"></a>定语从句</h3><blockquote><p>They are autonomous in finding answers <strong>they can</strong>, by themselves.</p></blockquote><p>此句标黑处为定语从句，修饰 answers，完整形式为 that they can find，也可省略 that（that 或 which 做从句谓语动词的宾语时，可省略）和 find （和前文主句中的动词 find 重合）。</p><p>此句中的定语从句和 by themselves 插入语均为冗余信息，autonomous 的含义已经非常清楚，作者一而再、再而三重复相同的意思，这就属于不规范写作。</p><h3 id="turn-to-somebody"><a href="#turn-to-somebody" class="headerlink" title="turn to (somebody)"></a>turn to (somebody)</h3><p>turn to 本身就含有“寻求帮助”的意思，我们在使用的时候可以不用再说 turn to someone for help/advise。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例句：Sometimes young lads just need to turn to a mother figure for a bit of a chat and reassurance.</span><br><span class="line">翻译：有时候年轻小伙子只是需要找一个母亲式的人物聊一聊，从中获得安慰。</span><br><span class="line"></span><br><span class="line">例句：Her husband was unsympathetic and she felt she had no one to turn to.</span><br><span class="line">翻译：她的丈夫不懂得体恤人，她觉得无人可以依靠。</span><br></pre></td></tr></table></figure><h3 id="分词短语做插入语（语法关系不规范）"><a href="#分词短语做插入语（语法关系不规范）" class="headerlink" title="分词短语做插入语（语法关系不规范）"></a>分词短语做插入语（语法关系不规范）</h3><blockquote><p>Even though they ask many questions, doing this frequently, they manage not to annoy people, as &gt;they’ve built up strong relationships with them.</p></blockquote><p>如果是口语表达，此句没有任何问题，意思也是明确的。但严格来讲，比较规范、符合语法的说法是 Even though they ask many questions frequently.</p><h3 id="manage-not-to"><a href="#manage-not-to" class="headerlink" title="manage (not) to"></a>manage (not) to</h3><blockquote><p>If you manage to do something, especially something difficult, you succeed in doing it.</p></blockquote><p>需要提醒特别注意的是，manage to 并不是指“试图去做”一件事情，而是强调“<strong>成功做到一件比较困难的事情</strong>”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例句：Somehow, he’d managed to persuade Kay to buy one for him.</span><br><span class="line">翻译：不知用了什么方法，他成功说服凯给他买了一个。</span><br><span class="line"></span><br><span class="line">例句：How do you manage not to tell your boss to f*** off to his face?</span><br><span class="line">翻译：你是怎么做到不当着你老板的面让他滚蛋的？</span><br></pre></td></tr></table></figure><h3 id="communicator"><a href="#communicator" class="headerlink" title="communicator"></a>communicator</h3><blockquote><p>Strong communicators and great relationships with non-engineers</p></blockquote><p>英文解释是：( rather formal ) a person who is able to describe their ideas and feelings clearly to others。在本文中指“（善于）交际者、交流者”，也可以泛指“通信器材”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例句：Steve Jobs was a gifted communicator, and he used this skill to capture the attention of millions.翻译：乔布斯是一个有天赋的沟通者，他用这种技巧吸引了数百万人的注意力。</span><br></pre></td></tr></table></figure><h3 id="分词短语做状语（不规范用法）"><a href="#分词短语做状语（不规范用法）" class="headerlink" title="分词短语做状语（不规范用法）"></a>分词短语做状语（不规范用法）</h3><blockquote><p>Product-minded engineers like talking with people outside engineering, learning about what and why &gt;they do. They are smooth communicators, <strong>making it clear they’re interested in</strong> learning more about how &gt;other disciplines work. I frequently see them grabbing coffee, lunch, or doing a hallway chat with &gt;non-engineers.</p></blockquote><p>此句的加黑部分是上一讲我们讲过的分词短语做状语，但它的主句 They are smooth communicators 是描写状态的系表结构，只有系动词 are，没有具体的动作，因此这种情况下用分词短语做状语在此处是不恰当的。</p><p>我们可以把这句话改写成：They communicate smoothly and show their interest in learning more about how other disciplines work。这样的话，这句话就符合语法规范了。</p><p>最后一句话，就是任正非说的，要善于用一杯咖啡去吸收宇宙的能量。</p><h1 id="tradeoff-还是-trade-off？用连字符到底对不对？"><a href="#tradeoff-还是-trade-off？用连字符到底对不对？" class="headerlink" title="tradeoff 还是 trade-off？用连字符到底对不对？"></a>tradeoff 还是 trade-off？用连字符到底对不对？</h1><p>文章的第五段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">5. Offering product/engineering tradeoffs upfront</span><br><span class="line">Because they have a strong understanding of the product &quot;why,&quot; as well as the engineering side of things, they can bring suggestions that few other people can. For example, when scoping the effort to build the product, the engineering effort to build a key feature might be significant. Many engineers would start to look for ways to reduce the effort and try to figure out what the impact of the reduced effort would mean for the feature itself.</span><br><span class="line">Product-minded engineers attack this problem from both angles: both looking for engineering tradeoffs and what the product impact is. They also start making product tradeoffs, evaluating the engineering impact. They often go back to the product manager, suggesting a completely different feature to be built, given the product impact would be similar, but the engineering effort vastly smaller.</span><br><span class="line">Juggling both the product and engineering tradeoffs and the impact of each is a unique strength product-minded engineers have. They can quickly go back-and-forth between the two sides of the same coin: product features and engineering effort and tradeoffs. Because they do it all in their head, using their engineering and product insights, they get to valuable conclusions remarkably quickly.</span><br><span class="line"></span><br><span class="line">5. 提前在产品和工程两方面做出权衡</span><br><span class="line">因为具有产品思维的工程师们对产品的原理以及软件工程都有深刻的理解，他们可以提出非常独到的建议，而很少有别人可以做到。例如，在确定产品构建的工作范围时，打造产品某项关键功能的编程工作量可能非常巨大。许多工程师会开始寻找减少工作量的方法，并试图明确减少工作量对该项关键功能可能会产生的影响。</span><br><span class="line">具有产品意识的工程师会从两个角度来解决这个问题：一方面在工程方面进行取舍，明确可能对产品产生的影响；同时在另一方面，他们还会开始对产品功能进行取舍，评估对工程工作量的影响。他们经常会去找产品经理，在保持产品体验相似的前提下，建议构建一个完全不同的功能，从而使得编程的工作量大幅降低。</span><br><span class="line">兼顾产品和工程、平衡两者的影响，是具有产品意识的工程师们拥有的独特优势。他们可以快速地在同一枚硬币的两面之间来回切换：产品特性、工程工作量和两者的平衡。由于他们利用其工程和产品两方面的洞察力，在头脑中快速完成上述权衡，所以他们能够很快得出有价值的结论。</span><br></pre></td></tr></table></figure><h2 id="知识讲解-3"><a href="#知识讲解-3" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="tradeoff"><a href="#tradeoff" class="headerlink" title="tradeoff"></a>tradeoff</h3><p>这是一个复合名词，由动词和介词 / 副词小品词直接相连构成，你也可以写成 trade-off。同时，这是一个可数名词，可以加 s 变成复数形式 tradeoffs。无疑，这个词在文章中反复出现，所以肯定是整段的关键词，也是中心思想。</p><p>所谓 tradeoff，顾名思义，首先是“交易”的意思。有交易就有讨价还价，就有妥协，就有得有失，就有鱼和熊掌不可兼得。所以这个词指的是一种取舍、一种权衡，最后达成折中平衡。英文解释：A trade-off is a situation where you make a compromise between two things, or where you exchange all or part of one thing for another.</p><p>平时我们有各种利弊要取舍，不能西瓜也要，芝麻也要。一个手机，续航也要，但是不能太厚；屏幕要最好的，但不能太贵；要安全性，但不能太麻烦；要黑科技，但系统不能不稳定、不可靠。这条英文解释进一步诠释了 tradeoff 这一层的意思：A trade-off is a balance between two opposing things, that you are willing to accept in order to achieve something.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：Life is full of trade-offs. You cannot have your cake and eat it too.</span><br><span class="line">翻译：生活充满了取舍。鱼和熊掌不可兼得。</span><br></pre></td></tr></table></figure><p>补充：“You cannot have your cake and eat it (too)”或者“You can’t eat your cake and [then still] have it (too)”是很常用的英语谚语，类似于“you can’t have the best of both worlds”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：Depending on your system resources, there will always be some trade-offs between CPU, memory, and I/O in your tuning decisions.</span><br><span class="line">翻译：根据你的系统资源进行调优决策时，CPU、内存和 I/O 之间总是需要进行权衡。</span><br></pre></td></tr></table></figure><h3 id="复合名词"><a href="#复合名词" class="headerlink" title="复合名词"></a>复合名词</h3><p>复合名词构成的方法比较多，它可以由动词和介词 / 副词小品词组成，这在英语中很是常见。这种方式构成的复合名词与相关联的短语动词之间，意义基本相近。我们以短语动词 break out 为例来看下。</p><p>动词短语 break out 指“（战争、瘟疫）爆发、越狱”，由此我们可以引申出“摆脱局限的状态、突破”等含义。如果把 break 和 out 之间的空格去掉，这个动词短语就变成了复合名词 breakout。下面是三个例句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例句：Bubble economy usually starts with false prosperity and ends in a breakout of financial crises.</span><br><span class="line">翻译：泡沫经济通常以虚假繁荣开始，以金融危机爆发告终。</span><br><span class="line"></span><br><span class="line">例句：Point Break was a breakout film for Kathryn Bigelow in 1991.</span><br><span class="line">翻译：凯瑟琳·毕格罗于 1991 年拍摄了《惊爆点》，该片突破了她之前的风格。</span><br><span class="line"></span><br><span class="line">例句：Breakout session is a relatively short meeting where a small group of attendees, drawn from a large conference or convention, discusses specific subjects or aspects of the broad theme of the main gathering.</span><br><span class="line">翻译：分组会议是大会中一个相对较短的小会，由部分与会者讨论大会主题下的某个具体议题。</span><br></pre></td></tr></table></figure><p>注意，颠倒两个单词的次序之后，还可以构成另外一个复合名词 outbreak，但这个词更多地特指“（战争、瘟疫）突然爆发、蔓延”。同时，outbreak 偶尔也可用作动词。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：Fears are growing of avian influenza outbreak following the appearance of several cases in the city.</span><br><span class="line">翻译：随着该市出现若干病例，人们对禽流感大爆发的担忧日益加剧。</span><br></pre></td></tr></table></figure><h3 id="a-few-a-little"><a href="#a-few-a-little" class="headerlink" title="(a) few/(a) little"></a>(a) few/(a) little</h3><blockquote><p>Because they have a strong understanding of the product “why,” as well as the engineering side of &gt;things, they can bring suggestions that few other people can.</p></blockquote><p>作为限定词，little 用于修饰不可数名词，few 用于修饰可数名词的复数。</p><p>需要特别注意的是，little 和 few 在不带 a 的情况下，表达的是否定的意思，表示“几乎没有”或者“很少”。比如 We have little time，表示“我们没时间了”。如果带 a，则表示肯定，“虽然不多，但有一些”。比如 We have a little time，表示“我们还有一些时间”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例句：Few people can say they always tell the truth.</span><br><span class="line">翻译：几乎没有人敢说自己从不撒谎。</span><br><span class="line"></span><br><span class="line">例句：We don’t need to go shopping today. We’ve got a few potatoes and some steak.</span><br><span class="line">翻译：我们今天不需要去购物。 我们还有一些土豆和牛排。</span><br><span class="line"></span><br><span class="line">例句：I have little knowledge of computer and business, can I still learn Navisio？</span><br><span class="line">翻译：我对计算机和商业知之甚少，我还能学习 Navision 系统吗？</span><br><span class="line"></span><br><span class="line">例句：Just because she painted her room by herself, now she thinks she can do the entire house—inside and out! A little knowledge is a dangerous thing.</span><br><span class="line">翻译：仅仅因为她自己粉刷了自己的房间，现在她认为可以把整个房子里里外外都粉刷一遍！ 一知半解害死人。</span><br></pre></td></tr></table></figure><p>这一句中，“A little knowledge is a dangerous thing”是一句英语谚语，按照字面的意思来说就是，“危险的不是一个人没有知识，而是有了一点点知识之后的过度自信和膨胀”。</p><h3 id="figure-out"><a href="#figure-out" class="headerlink" title="figure out"></a>figure out</h3><blockquote><p>Many engineers would start to look for ways to reduce the effort and try to figure out what the impact &gt;of the reduced effort would mean for the feature itself.</p></blockquote><p>这是个很常用的动词短语，意思是 find the solution to (a problem or question) or understand the meaning of…，“找到问题的解决办法、搞清楚、弄明白”。这个很简单，我就不多说了，我们直接通过例句来感受使用场景。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：By 2020, scientists will figure out how to control robots via brain-machine interfaces.</span><br><span class="line">翻译：到 2020 年，科学家们将解决如何通过脑机接口来控制机器人的问题。</span><br></pre></td></tr></table></figure><h3 id="打破语言形式看实质含义"><a href="#打破语言形式看实质含义" class="headerlink" title="打破语言形式看实质含义"></a>打破语言形式看实质含义</h3><blockquote><p>Product-minded engineers attack this problem from both angles: <strong>both looking for engineering &gt;tradeoffs and what the product impact is. They also start making product tradeoffs, evaluating the &gt;engineering impact.</strong></p></blockquote><p>第一句话。作者明确说了，具有产品思维的工程师们会从两个角度来解决问题，而且后面加了冒号，那我们必然预期，冒号后面会解释这两个角度分别是什么。</p><p>接下来，冒号后面又出现了第二个 both，我们的预期就更加明确了。both…and…这个平衡的结构你肯定知道。那前面提到过的两个角度肯定会工整地在 both 后面放一个，and 后面再放一个，就像下面这几个例句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">She is both pretty  and clever. （形容词）</span><br><span class="line">I talked to both the Director and his secretary. （名词）</span><br><span class="line">You can both borrow the flat and use our car. （动词）</span><br></pre></td></tr></table></figure><p>在 both 后面跟了一个现在分词短语，做主句中 from 的介词宾语，意思是在工程方面进行取舍。但是，and 后面却跟了一个从句，单纯从语法角度看这是 from 这个介词的宾语从句，显然形式不对等。形式不对等没关系，只要内容或者逻辑对等并列也行，我们可以解释主句讲的两个角度。但是，and 后面说的“对产品产生的影响”，是之前工程方面取舍的结果，逻辑上看并没有并列关系。</p><p>句子在这里就结束了，仿佛话说了半句，我们掉进了作者挖的坑里。从坑里爬出来，我们接着往下读，你会突然发现，原来作者另起炉灶讲的下一句话，才是前文讲的第二个角度 They also start making product tradeoffs, evaluating the engineering impact.，要在产品功能方面进行取舍，并评估对工程工作量的影响。</p><p>即便是非常严谨的学术著作，写作都有可能存在不严密的地方，更何况是这种相对随意一些的博客专栏。<strong>虽然语法上有些小瑕疵，但这种文章可以训练我们突破语言的形式外壳，去分析句子之间的逻辑关系，领会作者想要表达的实质含义。</strong></p><h3 id="独立主格结构"><a href="#独立主格结构" class="headerlink" title="独立主格结构"></a>独立主格结构</h3><blockquote><p>They often go back to the product manager, suggesting a completely different feature to be built, &gt;given the product impact would be similar, <strong>but the engineering effort vastly smaller.</strong></p></blockquote><p>工程师们经常去找产品经理，去干什么呢？后面是我们已经非常熟悉的现在分词做状语，来表示目的，去找他们提建议，建议改产品的功能，而且还是完全不同的功能。产品经理刚要急，工程师马上就接上说，当然前提条件（given 后面跟的是从句）是产品的用户体验相似，然后话锋一转，但是工程师的工作量会大幅度下降。</p><p>这里我们需要讲解一下 but 后面的<strong>独立主格结构</strong>，英文叫作 Absolute Construction。所谓独立主格，首先它是一个“格”，属于短语性质的成分，而不是一个“句子”或“从句”，因为英语中任何一个句子都要有主谓结构。例如，我们将本段最后一句话改成 but the engineering effort would be vastly smaller 的话，这就变成了一个单独的句子。</p><p>而独立主格结构没有真正的主语和谓语动词，它由名词或代词作逻辑主语，再加上分词、形容词、副词、动词不定式或介词短语作逻辑谓语来构成的，前后两部分具有逻辑主谓关系。</p><p>独立主格结构形式上与主句没有关系，但功能上相当于一个带有独立逻辑主语的状语从句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：The wind failing, we lowered the sail. 风力减弱，我们放下了船帆。</span><br><span class="line">比较：When the wind failed, we lowered the sail. 意思相同，但属于状语从句。</span><br></pre></td></tr></table></figure><p>The wind failing 带有自己的主语 wind，从语法结构上和主句的主语 we 不发生关系。但是，所谓的“独立”并非真正独立，它从逻辑或者意思上看，还是一种从属结构，在句中通常起状语的作用，常用来表示时间、原因、条件、行为方式或伴随情况等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">例句：Weather permitting, we will have a barbecue tomorrow.</span><br><span class="line">翻译：如果天气好的话，明天我们一起烤肉。（表示条件）</span><br><span class="line"></span><br><span class="line">例句：The night dark and frosty, he wrapped her up with great care.</span><br><span class="line">翻译：夜又黑又冷，所以他把她裹得严严实实的。（表示原因）</span><br><span class="line"></span><br><span class="line">例句：Evenings he read aloud, his wife sewing by his side.</span><br><span class="line">翻译：晚上他朗声读书，妻子在他身边缝衣服。（表示伴随情况）</span><br><span class="line"></span><br><span class="line">例句：Almost all metals are good conductors, silver being the best of all.</span><br><span class="line">翻译：几乎所有的金属都是良导体，而银则是最好的导体。（表示补充说明）</span><br></pre></td></tr></table></figure><p>最著名（也最臭名昭著）的“独立主格结构”应该就是美国宪法修正案第二条了，它授予了美国公民合法持枪的权利。</p><blockquote><p>A well-regulated militia, being necessary to the security of a free State, the right of the people to &gt;keep and bear Arms, shall not be infringed.纪律优良之民众武装乃自由邦国安全所必需，故，人民持有并携带武器之权不受侵&gt;犯。</p></blockquote><h3 id="juggle"><a href="#juggle" class="headerlink" title="juggle"></a>juggle</h3><blockquote><p>Juggling both the product and engineering tradeoffs and the impact of each is a unique strength &gt;product-minded engineers have.</p></blockquote><p>juggle 这个词的原意是“玩杂耍的时候接连抛接几个物体”，英文解释是 to throw a set of three or more objects such as balls into the air and catch and throw them again quickly, one at a time，同时它也可以引申出“同时应付几件事情，一心多用、兼顾”等含义。我们还是通过几个例句来感受使用场景。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例句：I was juggling books, shopping bags and the baby.</span><br><span class="line">翻译：我手里又是书，又是购物袋，还抱着孩子，跟演杂技一样。</span><br><span class="line"></span><br><span class="line">例句：The management team meets several times a week to juggle budgets and resources.</span><br><span class="line">翻译：管理团队一周碰头几次，来兼顾预算和资源。</span><br></pre></td></tr></table></figure><p>juggle 还有一个近义词 multitask，也是指“同时做几件事情、多任务处理”。但是，和 juggle 不同的是，multitask 是不及物动词，后面不跟宾语。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：According to a study published by the American Psychological Association, you spend between 20 and 40 percent more time when you multitask.</span><br><span class="line">翻译：根据美国心理协会发表的一项研究，当你一心多用同时处理多项工作时，你所花费的时间会多 20% 到 40%。</span><br></pre></td></tr></table></figure><h3 id="back-and-forth"><a href="#back-and-forth" class="headerlink" title="back-and-forth"></a>back-and-forth</h3><blockquote><p>They can quickly go back-and-forth between the two sides of the same coin: product features and &gt;engineering effort and tradeoffs.</p></blockquote><p>back-and-forth 的意思是“来来回回”，英文解释是：moving first in one direction and then in the opposite one。但是，backward and forward 不能表示同样的意思。back 强调的是目的地、回到什么地方，比如 back home（回家）；而 backward 只是一个方向，表示“倒退”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：I will drive back to Shanghai this weekend.</span><br><span class="line">翻译：这周末我开车回上海。</span><br></pre></td></tr></table></figure><p>至于你的车是正着开还是倒着开，这句话并不关心，只是强调要“回去”，表示目的地而不是方向。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：This lessens the back-and-forth remote traffic and can reduce deployment times.</span><br><span class="line">翻译：这样可以减少来回的远程传输，并缩短部署时间。</span><br></pre></td></tr></table></figure><h3 id="two-sides-of-the-coin"><a href="#two-sides-of-the-coin" class="headerlink" title="two sides of the coin"></a>two sides of the coin</h3><p>“一个硬币的两面”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">If two things are two sides of the same coin or opposite sides of the same coin, they are closely related to each other and cannot be separated, even though they seem to be completely different.</span><br><span class="line"></span><br><span class="line">I’ve always felt that tragedy and comedy are two sides of the same coin. Love and hate are the opposite sides of the same coin. 祸福相依、爱恨交织。/ 塞翁失马焉知非福。</span><br><span class="line"></span><br><span class="line">例句：WCF and WF are really two sides of the same coin: WCF is the interface and hosting environment for the service, while WF implements its processing logic.</span><br><span class="line">翻译：WCF 和 WF 实际上是同一枚硬币的两面：WCF 是服务的接口和托管环境，而 WF 实现其处理逻辑。</span><br></pre></td></tr></table></figure><h3 id="insight"><a href="#insight" class="headerlink" title="insight"></a>insight</h3><blockquote><p>Because they do it all in their head, using their engineering and product insights, they get to &gt;valuable conclusions remarkably quickly.</p></blockquote><p>insight 有个现成的译法叫“洞察”。“洞”字非常准确生动，有“透彻、清楚”的意思，和英文中对 insight 的解释非常吻合：If you gain insight or an insight into a complex situation or problem, you gain an accurate and deep understanding of it.</p><p>所谓洞察，简单讲就是透过现象看到本质。</p><h1 id="小心那些平淡无奇、人畜无害的简单小词！"><a href="#小心那些平淡无奇、人畜无害的简单小词！" class="headerlink" title="小心那些平淡无奇、人畜无害的简单小词！"></a>小心那些平淡无奇、人畜无害的简单小词！</h1><p>文章的第六段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">6. Pragmatic handling of edge cases</span><br><span class="line">Edge cases are a funny thing. On one extreme, engineers often forget about many of these, having to come back to addressing them, after getting feedback from people testing the product or end users. On the other hand, handling all possible edge cases in a new product or feature can take a lot of time.  </span><br><span class="line">Product-minded engineers quickly map out edge cases and think of ways to reduce work on them: often bringing solutions that require no engineering work. They are focused on the &quot;minimum lovable product concept&quot; and evaluate the impact of an edge case and the effort of handling it. They come with good middle-ground suggestions: mapping out most things that can go wrong and bring suggestions on what edge cases need to be addressed, before shipping even an early version.  </span><br><span class="line">For example, if one in a thousand users might be hit by an error, they will consider the effort to fix it and think about what happens if they don&apos;t do anything. Can customer support help the person in this case, during validation? Can the user just retry and succeed the next time? Can the product be slightly modified, so this edge case won&apos;t occur?</span><br><span class="line"></span><br><span class="line">6. 以务实的方式处理边缘案例</span><br><span class="line">边缘案例是一件很有意思的事情。有的工程师经常会忘记边缘案例的存在，最后从产品测试人员或最终用户那里得到反馈之后，才不得不回过头来解决这些问题。这是一个极端，而另一方面，如果在一个新产品或功能中试图处理所有可能的边缘情况，则可能会耗费大量的时间。</span><br><span class="line">具有产品意识的工程师会很快制定出关于边缘案例的计划，并思考如何减少工作量，并经常会找到不需要额外工作量的解决方案。他们专注于“最小可爱产品”的概念，评估边缘案例的影响和处理所需的工作量。他们会提供很好的折衷建议: 在发布早期版本之前，列出大多数可能出错的地方，并提出需要解决哪些边缘案例的建议。</span><br><span class="line">例如，对于一个千分之一的用户可能会遇到的错误，他们会考虑修复这一错误涉及的工作量，以及如果什么都不做会发生的后果。在产品验证过程中，客服专员是否可以在这个案例中帮助用户？用户下一次再遇到同样问题可以自己尝试成功解决吗？对产品进行略微调整，是否就可以避免边缘案例？</span><br></pre></td></tr></table></figure><h2 id="知识讲解-4"><a href="#知识讲解-4" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="edge-case"><a href="#edge-case" class="headerlink" title="edge case"></a>edge case</h3><p>维基百科对这个词的定义是：Edge case occurs at an extreme (maximum or minimum) operating parameter.</p><p>edge case 较为常见的译法为“边缘案例”，指“一个运行参数或条件为极值（最大值或最小值）的情况”。类似的，我们来看下 corner case 这个词。</p><p><strong>Corner case</strong> occurs outside of normal operating parameters, specifically when multiple environmental variables or conditions are simultaneously at extreme levels, even though each parameter is within the specified range for that parameter.</p><p>“边角案例”一词应该来自边缘案例，两个边缘的交叉点构成角，所以边角案例就是多个参数或条件均为极值的情形。如果音量调到最大，声音失真，这属于边缘案例；如果问题在音量最大、周边环境高湿、且同时一万人以上同时在线时才会出现，这属于边角案例。边角案例一般在复杂系统的测试或除错过程中才会出现。</p><p>Boundary case occurs when one of inputs is at or just beyond maximum or minimum limits.</p><p>还有一个词 boundary case，我们也叫“边界案例”或者“边界条件”，也是指系统输入刚好在上下限或是恰好超过上下限一点点的状态。</p><h3 id="pragmatic"><a href="#pragmatic" class="headerlink" title="pragmatic"></a>pragmatic</h3><p>它既可以强调“一种务实的态度”（A pragmatic way of dealing with something is based on practical considerations, rather than theoretical ones.），也可以用来说“一个人非常务实”（A pragmatic person deals with things in a practical way.）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：Incorporating both risk-based and customer-based analysis into your solution will yield a more pragmatic test plan.</span><br><span class="line">翻译：将基于风险和基于客户的分析整合到您的解决方案中，将会产生一个更加务实的测试计划。</span><br></pre></td></tr></table></figure><h3 id="funny"><a href="#funny" class="headerlink" title="funny"></a>funny</h3><blockquote><p>Edge cases are a funny thing.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">例句：</span><br><span class="line">A: Sorry I’m late. My car broke down half way here.</span><br><span class="line">B: Oh, very funny. Tell me another!</span><br><span class="line">翻译：</span><br><span class="line">A：抱歉我迟到了，我的车半路抛锚了。</span><br><span class="line">B：你得了吧，接着编。（有点类似于“呵呵”的口气）</span><br><span class="line"></span><br><span class="line">例句：It’s not funny! Someone could have been hurt.</span><br><span class="line">翻译：这不好玩（这太危险了）！没人受伤算是运气好。</span><br><span class="line"></span><br><span class="line">例句：If there has been any funny business, we’ll soon find out.</span><br><span class="line">翻译：如果这里面有任何猫腻（非法勾当），我们很快会发现的。</span><br><span class="line"></span><br><span class="line">例句：My computer keeps going funny.</span><br><span class="line">翻译：我的计算机老出故障。</span><br></pre></td></tr></table></figure><p>另外，还有一些可以用来夸人的词汇，也比较常用。这些词不含负面意思，在交流的时候，你可以放心使用。这些词有：hilarious、humorous、amusing、entertaining 等。</p><p>除了 funny 外，还有很多类似的词，使用的时候也要特别小心。例如 interesting，其实它也是“呵呵”的意思。以下是一些工作和生活中非常常见的表达：</p><ul><li>Could we consider some other options？能否考虑其他方案？（你的方案是狗屎）</li><li>It was a bit disappointing that…我感到有些失望……（你们 XXX 干的叫什么事！！！）</li><li>Oh, by the way…顺便提一句……（下面要说的可能是谈话里最重要的一件事……）</li><li>It is quite good. 还行吧。（不咋地。）</li><li>It is not bad. 不坏。（真心不错，但不要骄傲。）</li><li>With all due/the greatest respect…恕我冒昧，恕我直言……（后面跟的话就是要骂人了。）</li><li>I hear what you say…你的意见我听到了……（你给我闭嘴吧！）</li><li>It is a very brave proposal. 这真是个勇敢的提议。（我看这个愣头青大概是疯了吧！）</li><li>I almost agree…我基本同意？（同意个鬼，基本不同意。）</li></ul><h3 id="现在分词短语（做状语和主语）"><a href="#现在分词短语（做状语和主语）" class="headerlink" title="现在分词短语（做状语和主语）"></a>现在分词短语（做状语和主语）</h3><blockquote><p>On one extreme, engineers often forget about many of these, <strong>having to come back to addressing them, &gt;after getting feedback from people testing the product or end users.</strong> On the other hand, <strong>handling all &gt;possible edge cases in a new product or feature</strong> can take a lot of time.</p></blockquote><p>们用这两句话来复习一下现在分词短语做状语和做主语的情况。</p><p>这两句话讲了两个极端，一个是程序员完全忘了边缘案例这回事（一定是新手干的），还有一个就是在这个事情上花太多的时间和精力。</p><ul><li><p>第一个极端，有的工程师经常健忘。结果怎么样呢？having to come back to addressing them，现在分词做状语，表示结果，结果不得不回过头来解决这些问题。什么时候发生的事情呢？after getting feedback from people testing the product or end users， 还是现在分词做状语，表示时间，从产品测试人员或最终用户那里得到反馈之后。</p></li><li><p>另外一个极端，handling all possible edge cases in a new product or feature can take a lot of time。从 handling 这个现在分词开始一直到 feature，这整个短语都是句子的主语，表示在一个新产品或功能中试图处理所有可能的边缘情况，can take 情态动词加上实义动词做谓语，可能会耗费大量的时间。</p></li></ul><h3 id="map-out"><a href="#map-out" class="headerlink" title="map out"></a>map out</h3><blockquote><p>Product-minded engineers quickly <strong>map out</strong> edge cases and think of ways to reduce work on them: &gt;often &gt;bringing solutions that require no engineering work.</p></blockquote><p>map out 是“计划、规划、提前安排”的意思。例如，map out the future 的意思是“筹划未来”。它的英文解释是：If you map out something that you are intending to do, you work out in detail how you will do it.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例句：With the whole IT picture in hand, we can map out how the information flows from start to finish.</span><br><span class="line">翻译：掌握了整个 IT 蓝图之后，我们就可以规划信息从头到尾的流动方式。</span><br><span class="line"></span><br><span class="line">例句：It is important to map out the big picture first so that we can systematically identify user requirements.</span><br><span class="line">翻译：为了系统地识别用户的需求，我们首先需要制定一个全局规划。</span><br></pre></td></tr></table></figure><h3 id="focus-和-focused"><a href="#focus-和-focused" class="headerlink" title="focus 和 focused"></a>focus 和 focused</h3><blockquote><p>They are focused on the “<strong>minimum lovable product</strong> concept” and evaluate the impact of an edge case and &gt;the effort of handling it.</p></blockquote><p>focus 是动词，表示“（某人）集中精力于某件事情上”。focused 是过去分词，可作形容词，表示“（注意力、眼神、焦点、光线等）集中的，（论文、计划等）目标明确的”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例句：I am exhausted, and just can’t focus on the work anymore.</span><br><span class="line">翻译：我筋疲力尽了，实在难以集中注意力工作了。</span><br><span class="line"></span><br><span class="line">例句：I think it is time you woke up and focused your thoughts on more worldly matters.</span><br><span class="line">翻译：我认为该是你清醒过来把思想集中到更为现实的问题上的时候了。</span><br><span class="line"></span><br><span class="line">例句：Every eye at the conference was focused on the rostrum.</span><br><span class="line">翻译：代表们的眼光都集中在大会主席台上。</span><br><span class="line"></span><br><span class="line">例句：Focused light rays can set something afire.</span><br><span class="line">翻译：聚焦光线可以点燃东西。</span><br><span class="line"></span><br><span class="line">例句：I spent the next year just wandering. I wasn’t focused.</span><br><span class="line">翻译：接下来的一年我一直在闲逛。没有什么明确的目标。</span><br></pre></td></tr></table></figure><p>由上面这些例句我们可以看出，本段中的 They are focused on the “minimum lovable product concept”，改为 They focus on the “minimum lovable product concept”，其实会更好一点，直接用 focus 做 They 这个主语即程序员们的谓语动词。当然，如果非要说 They are focused on（focused 做形容词）意思也勉强说得通，不能算错。</p><h3 id="minimum-lovable-product"><a href="#minimum-lovable-product" class="headerlink" title="minimum lovable product"></a>minimum lovable product</h3><p>MVP 指的是 Minimum Viable Product，按照字面含义可以直译为“最小可行产品”。这种产品只包含最简单的基本核心功能。</p><p>MLP 指的是 Minimum Lovable Product，可以直译为“最小可爱产品”。</p><p>两者之间的本质区别究竟在哪里？</p><ul><li><p>MVP is the version of a new product that brings back the maximum amount of validated learning about your customers with the least effort. （强调以最小的努力换回最大数量的经过验证的客户反馈数据；目标在于了解用户体验。）</p></li><li><p>MLP is the version of a new product that brings back the maximum amount of love from your early tribe members with the least effort. （强调以最小的努力换回最大数量的首批部落成员的爱；目标在于直接开始圈粉。）</p></li></ul><h3 id="middle-ground"><a href="#middle-ground" class="headerlink" title="middle ground"></a>middle ground</h3><blockquote><p>They come with good middle-ground suggestions: mapping out most things that can go wrong and bring bringing suggestions on what edge cases need to be addressed, before shipping even an early version.</p></blockquote><p>middle ground 的意思是“中间地带”，表示“折中、妥协之后的立场、观点、决定、协议”等等。字典里的解释是：a set of opinions, decisions, etc. that two or more groups who oppose each other can agree on; a position that is not extreme.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：More and more in this age of social media, it seems like people of differing views are unwilling to attempt to find a middle ground.</span><br><span class="line">翻译：在这个社交媒体时代，越来越多持不同观点的人似乎不愿意尝试找到一个中间立场。</span><br></pre></td></tr></table></figure><p>注意：最后一句话的 bring 应该改成 bringing。</p><h1 id="为什么虚拟语气一看就懂、一用就忘？"><a href="#为什么虚拟语气一看就懂、一用就忘？" class="headerlink" title="为什么虚拟语气一看就懂、一用就忘？"></a>为什么虚拟语气一看就懂、一用就忘？</h1><p>文章的第七、八段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">7. Quick product validation cycles</span><br><span class="line">Even before the feature they are working on is production-ready, product-minded engineers find creative ways to get early feedback. This could be doing hallway testing with colleagues, showing the work-in-progress feature to the product manager, organizing a team bug bash on the beta build, and many other, creative ways. They are continuously thinking:&quot;how can we validate that people will use this feature, the way we think they will?&quot;</span><br><span class="line"></span><br><span class="line">7. 快速的产品验证周期</span><br><span class="line">甚至在开发的产品功能可以上线之前，具有产品思维的工程师们早就已经找到创造性的方法来获取早期的反馈意见。他们可以和同事一起进行走廊测试，可以向产品经理演示尚在开发中的功能，也可以在 Beta 版本发布前组织整个团队来一场“漏洞大扫荡”，当然还有许多其他创造性的方法。他们会一直思考这个问题：“我们怎样才能验证用户们会像我们预期的那样来使用这个功能？”</span><br></pre></td></tr></table></figure><p>首先，我们从整体看一下这段话。这段话中有两个从句，第一句的前半部分 Even before the feature they are working on is production-ready，是时间状语从句，表示“在功能上线之前”。其中，even 表示“高于预期，甚至”。主语 the feature 后面跟了一个定语从句，强调是“工程师们正在开发的”。在功能上线之前，工程师们就已经找到了创造性的方法来获取早期的反馈意见。</p><p>最后一句的标黑处 people will use this feature, the way we think they will?，这是比较随意的说法，相对规范一点的说法为：people will use this feature in the way we think they will. 当然原文并不影响意思的表达和理解，无伤大雅。但是一般我看到不太规范的地方，总是忍不住要去修改，或许这也是一种“语言洁癖”的症状吧……</p><h2 id="知识讲解-5"><a href="#知识讲解-5" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="work-in-progress"><a href="#work-in-progress" class="headerlink" title="work-in-progress"></a>work-in-progress</h3><blockquote><p>This could be doing hallway testing with colleagues, showing the work-in-progress feature to the product manager, &gt;organizing a team bug bash on the beta build, and many other, creative ways.</p></blockquote><p>work-in-progress 是一个不可数名词，指“半成品、在制品、在建项目”，有时会缩写为 WIP。在文章中指“尚在开发过程中的应用软件”。这里是名词作形容词来修饰 feature，即“在开发中的软件的某项功能”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：You are strongly encouraged to save your document frequently, back-up regularly, and print your work-in-progress periodically.</span><br><span class="line">翻译：强烈建议你们经常保存和备份，并且定期把写作过程中的文稿打印出来。</span><br></pre></td></tr></table></figure><h3 id="bug-bash"><a href="#bug-bash" class="headerlink" title="bug bash"></a>bug bash</h3><p>这里的 bash，原意是“猛烈击打”。我们先来看维基百科给出的 bug bash 的定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In software development, a bug bash is a procedure where all the developers, testers, program managers, usability researchers, designers, documentation folks, and even sometimes marketing people, put aside their regular day-to-day duties and “pound on the product”—that is, each exercises the product in every way they can think of. Because each person will use the product in slightly different (or very different) ways, and the product is getting a great deal of use in a short amount of time, this approach may reveal bugs relatively quickly.</span><br><span class="line"></span><br><span class="line">在软件开发过程中，所有开发人员、测试人员、项目经理，还有负责可研、设计、文档管理甚至营销的同事，把他们的日常工作放在一边，一起来开“捉虫大会”。换言之，每个人都用他们能想到的方式来操作产品。因为每个人使用产品的方式略有不同（或非常不同），从而使得产品在很短的时间内得到了大量的使用，有助于团队相对较快地发现产品缺陷。</span><br></pre></td></tr></table></figure><p>文章第八大段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8. End-to-end product feature ownership</span><br><span class="line">Most experienced engineers own their work end-to-end: from getting the specification, through implementing it, all the way to rolling it out and validating that it works correctly. Product-minded engineers often go a step beyond this.</span><br><span class="line">They consider their work done only after getting results on user behavior and business metrics. After rollout, they still actively engage with product managers, data scientists, and customer support channels, to learn how the feature is being used in the real world. It can take weeks to get enough reliable data to draw conclusions. Even though they might be working on a new project, they make checking on the results one of their top priorities. It’s not a time-consuming activity, but it needs that additional persistence from someone wanting to know: how is my work really doing?</span><br><span class="line">When a feature performs worse than expected, they are curious to understand where the mismatch was. They are just as interested in finding the root cause between the product plan and the real world result, as they are to debug a hard-to-reproduce bug in the codebase. They’ll often spend a good amount of time debating hypothesizes and learnings with the product manager and data scientists.</span><br><span class="line"></span><br><span class="line">8.对产品功能从头至尾负责到底</span><br><span class="line">经验丰富的工程师们都会对他们的工作从头至尾负责到底：从拿到产品规范到部署实施，再到发布产品并最终验证产品能否正常工作。除了上述这些工作以外，具有产品意识的工程师通常会举一反三、再进一步。</span><br><span class="line">他们坚信，只有在获得用户行为和商业指标的结果之后，他们的工作才算全部完成。产品上线后，他们仍然会积极与产品经理、数据专家和客户支持渠道保持密切沟通，以便了解产品功能在现实世界中的使用情况。要获得足够得出结论的可靠数据通常需要几周时间。即使他们可能已经接手下一个新项目，他们仍然会把检查上一项目的成果作为首要任务之一。这并不是一项特别耗时的活动，但是特别需要一种锲而不舍的精神，推动那些想要知道自己的辛勤劳动究竟效果如何的工程师们，去坚持探寻答案。</span><br><span class="line">当开发的某项功能表现得不如预期时，他们会特别好奇问题出在哪里？他们对于找到产品计划和现实世界结果之间存在差距的根本原因怀有浓厚的兴趣，程度不亚于他们在代码库中找到难以复现的缺陷并成功除错。他们经常会花费大量的时间，就某些假设和心得与产品经理和数据专家展开辩论。</span><br></pre></td></tr></table></figure><h3 id="ownership"><a href="#ownership" class="headerlink" title="ownership"></a>ownership</h3><p>它由 owner（物主、所有权人）加上 ship（表示地位、状态、关系的后缀，例如 leadership/friendship/dictatorship/partnership 等等）组成，本意是“物主身份、产权关系”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例句：On January 23rd, America decided to relax its rules on the foreign ownership of its airlines.</span><br><span class="line">翻译：1 月 23 日，美国决定放宽对外国持有美国航空公司所有权的管制规定。</span><br><span class="line"></span><br><span class="line">例句：Major breakthroughs have been made in the reform of China’s ownership structure.</span><br><span class="line">翻译：中国所有制结构改革也取得了重大突破。</span><br></pre></td></tr></table></figure><p>这里的 ownership 指的是“产权体制”。</p><h4 id="普及两类特别容易混淆的企业概念"><a href="#普及两类特别容易混淆的企业概念" class="headerlink" title="普及两类特别容易混淆的企业概念"></a>普及两类特别容易混淆的企业概念</h4><ul><li>在国内，论及所有制（即 ownership）的时候，我们会区分国有企业、集体企业和非公有制企业（包括私营企业）等。而西方国家在对市场中的企业类型进行划分时，更常用的是 private company 和 public company 这两个相对的概念。初学者看到这组词的时候，容易望文生义，认为 private company 是“私营企业或者民营企业”，那么 public company 一定是“公有体制下的国有企业”。如果这么理解的话，那就大错特错啦。国有企业现在约定俗成的说法叫 state-owned-enterprise，缩写是 SOE。</li></ul><p>那private company 和 public company 到底是什么意思呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Privately held companies are—no surprise here—privately held. This means that, in most cases, the company is owned by its founders, management, or a group of private investors. A public company, on the other hand, is a company that has sold all or a portion of itself to the public via an initial public offering (IPO), meaning shareholders have a claim to part of the company’s assets and profits.</span><br></pre></td></tr></table></figure><p>根据这段解释，我们可以看出，private company 或者 privately held company 指的是“私人控股或持股公司”，一般由创始人、管理层或一群私人投资者拥有产权。</p><p>而 public company 其实指的是“公众持股公司”，大多数时候我们也可以称为“上市公司（listed company）”，指通过股权首次公开发行（或简称 IPO）向公众出售公司全部或部分资产的公司，当然持有股票的公众股东理论上可分享上市公司一定比例的资产和利润。</p><p>所以，在西方，区分公众公司和私人公司的标准并非对应中国的所有制形式，也不取决于规模大小（很多世界级的大型企业，例如美国的科氏工业集团、玛氏集团、彭博有限合伙企业等，都是不上市的私人企业），而是取决于公司的股份是否面向公众公开发行、是否可以自由转让。</p><p>最重要的是，一旦一个私人公司成为公众公司（英文可以叫 goes public），就不能再享有闭门经营、少数几个经营者说了算的自由，公众公司必须接受证券交易监督管理委员会的监管，满足定期向股东和公众进行信息披露的要求。公众公司也可以进行“私有化”（privatization，如果是一家上市公司，就是“退市”），私有化和公募上市是一个反向的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">One of the biggest differences between the two types of companies is how they deal with public disclosure. If it’s a public U.S. company, which means it is trading on a U.S. stock exchange, it is typically required to file quarterly earnings reports (among other things) with the Securities and Exchange Commission (SEC). This information is made available to shareholders and the public. Private companies, however, are not required to disclose their financial information to anyone, since they do not trade stock on a stock exchange.</span><br></pre></td></tr></table></figure><p>由财产权引申出来，我们经常会听到 Kate owns this project 这样的话，表面意思是“凯特拥有这个项目”，指的是“这个项目的负责人是凯特”。</p><p>文章中 ownership 的意思其实也是负责某个项目或某项工作的状态。字面上看，就是把公司的事情真正当作自己的，做事一跟到底，对结果负责。这一段小标题里面的 end-to-end（端到端），也是进一步强调了 ownership 这个意思。所以，ownership 其实也用来表示一个人有责任心，有主人翁精神，是一种可贵的、自发投入的工作状态。很多企业都会在自己的公司文化中倡导员工的 ownership 意识，和公司同心同德。</p><h3 id="from…through…-all-the-way-to…"><a href="#from…through…-all-the-way-to…" class="headerlink" title="from…through… (all the way) to…"></a>from…through… (all the way) to…</h3><blockquote><p>Most experienced engineers own their work end-to-end: from getting the specification, through implementing it, all the way to rolling it out and validating that it works correctly.</p></blockquote><p>这是一个从 A 经过 B 到 C 的句型。all the way 表示“一直、自始至终”。ABC 可以是“时间、地点、一连串先后发生的事件”。此外，all the way through 也是一个惯用成语。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：I slept all the way through the film.</span><br><span class="line">翻译：整部电影我都在睡觉。</span><br></pre></td></tr></table></figure><h3 id="beyond"><a href="#beyond" class="headerlink" title="beyond"></a>beyond</h3><blockquote><p>Product-minded engineers often go a step beyond this.</p></blockquote><p>介词 beyond 在英语日常表达中很常用，是充分体现英语语言效率的高能小词。它最核心的含义就是“超出范围”。在时间、空间、能力范围以外，基本都可以用这个词。</p><p>前几年北京雾霾比较严重的日子，AQI（Air Quality Index，空气质量指数）超过 500，我们会说“爆表了”，英文表述就是 beyond index（超出了正常的指数计量范围）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例句：The night session will go beyond midnight.</span><br><span class="line">翻译：夜间会议将持续到午夜以后。</span><br><span class="line"></span><br><span class="line">例句：Jenna always wondered what was beyond the horizon.</span><br><span class="line">翻译：洁娜总是纳闷地平线的那一边是什么。</span><br><span class="line"></span><br><span class="line">例句：What Jock had done was beyond my comprehension.</span><br><span class="line">翻译：我无法理解乔克的所作所为。</span><br></pre></td></tr></table></figure><h3 id="过去分词做宾语补足语"><a href="#过去分词做宾语补足语" class="headerlink" title="过去分词做宾语补足语"></a>过去分词做宾语补足语</h3><blockquote><p>They consider their work <strong>done</strong> only <strong>after getting results on user behavior and business metrics.</strong></p></blockquote><p>这句话的前半句是典型的过去分词做宾语补足语的句型，后半句则是我们已经很熟悉的状语从句，表示时间，“只有在拿到…之后，他们的工作才算完成”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例句：They keep the door locked for the whole day.（过去分词做宾语补足语）</span><br><span class="line">翻译：他们把门锁了一整天。</span><br><span class="line"></span><br><span class="line">例句：I find learning Japanese difficult.（形容词做宾语补足语）</span><br><span class="line">翻译：我发现学习日语很难。</span><br></pre></td></tr></table></figure><h3 id="even-if-though"><a href="#even-if-though" class="headerlink" title="even if/though"></a>even if/though</h3><blockquote><p>Even though they might be working on a new project, they make checking on the results one of their top priorities.</p></blockquote><p>even if 和 even though 意思相近，都可用于引导表示让步的状语从句，但它们的用法存在微妙差别。</p><p><strong>even if 引导的从句一般是假设性的，并不符合真实的状况，表示“即使、就算、哪怕”等含义</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：I wouldn’t marry you even if you were the last man in the world.</span><br><span class="line">翻译：即使你是世界上最后一个男人，我也不会嫁给你。</span><br></pre></td></tr></table></figure><p><strong>even though 引导的从句，往往是在说真实发生的情况，表示“尽管、虽然”的意思。大部分情况下，我们可以直接用 though 或 although 代替，但是不可以说 even although。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：Thomas is awarded the best teacher of the year even though he has the least experience.</span><br><span class="line">翻译：托马斯被授予年度最佳教师，尽管他的经验最少。</span><br></pre></td></tr></table></figure><p>当 even if 或 even though 引导让步状语从句时，后面可以是真实的条件句，也可以是虚拟语气。</p><p>用一句话来说，虚拟语气用来<strong>表示虚假的、与事实相反或难以实现的情况，也可以用来表示某种不确定的情形，体现主观愿望或某种强烈情感。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例句 1：If it rains tomorrow, we will cancel the event.</span><br><span class="line">例句 2：If I were you I should go to see the doctor.</span><br><span class="line">例句 3：I wish it were Sundy today.</span><br><span class="line">例句 4：I should have called Emily this morning, but I forgot.</span><br></pre></td></tr></table></figure><h3 id="priority"><a href="#priority" class="headerlink" title="priority"></a>priority</h3><p>priority 源于形容词 prior，意思是“优先的、前面的、更重要的事项”。有时候为了表示强调，我们会在 priority 前面加上 top 或者 number one，表示“重中之重、第一优先事项”。</p><p>它的词根 pri/prim/prin，表示“首先、第一、重要”等含义，我们所熟悉的 primary、prime minister/premier、prince/princess、principal、principle、primate 都带有这个前缀。</p><h3 id="persistence"><a href="#persistence" class="headerlink" title="persistence"></a>persistence</h3><blockquote><p>It’s not a time-consuming activity, but it needs that additional persistence from someone wanting to know: how is my work really doing?</p></blockquote><p>persistence 源于形容词 persistent 和动词 persist。从词根的角度看，per=through，是“从头至尾、贯穿始终”的意思（例如 permanent、perpetual 等）；sist=to stand，是“站立”的意思。例如，consist（站在一起 = 组成）、resist（站到反面 = 抵抗）。所以，合在一起这个词就是“始终站立、坚持到底”的意思。</p><p>动词 persist 一般和介词 in 搭配，意思要看上下文，较多情况下偏贬义，有“顽固坚持、执迷不悟”的意思。</p><p>几条词典的解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">to try to do or continue doing something in a determined but often unreasonable way. (Cambridge Advanced Learners’ Dictionary）</span><br><span class="line">if you persist in doing something, you continue to do it, even though it is difficult or other people are against it. (Collins Cobuild Essential English Dictionary)</span><br><span class="line">to go on resolutely or stubbornly in spite of opposition, importunity, or warning. (Merriam-Webster Online)</span><br></pre></td></tr></table></figure><p>通过上面来自不同词典的解释可以看到，persist 一词有褒义的含义，但更多的语境下是偏贬义的，因此需要我们根据上下文来辨别它的具体含义。你可以理解为“坚持不懈”，更多语境下它带有“不顾别人的反对、执迷不悟”的意思。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例句：We join, we persist, we win.</span><br><span class="line">翻译：我们参与了，我们坚持了，我们最终胜利了。</span><br><span class="line"></span><br><span class="line">例句：Why do you persist in blaming yourself for what happened?</span><br><span class="line">翻译：你何必为已发生的事没完没了地自责？</span><br><span class="line"></span><br><span class="line">例句：She had turned him down for a date before, but he persisted and asked her again.</span><br><span class="line">翻译：她以前拒绝过他的约会，但他坚持要再约她一次。</span><br></pre></td></tr></table></figure><p>同样，形容词 persistent 和名词 persistence 的含义也要看上下文，也有褒义也有贬义。褒义的时候形容坚持不懈。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：Skill comes only with practice, patience and persistence.</span><br><span class="line">翻译：只有不断练习，有耐心，有毅力，才能学会一门技艺。</span><br></pre></td></tr></table></figure><p>不过，它的近义词 persevere、perseverant 和 perseverance 则永远是褒义的，表示“孜孜以求、锲而不舍”，不用管上下文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：By perseverance the crippled boy learned how to swim.</span><br><span class="line">翻译：由于锲而不舍，那个腿部残疾的男孩学会了游泳。</span><br></pre></td></tr></table></figure><h3 id="as…as…"><a href="#as…as…" class="headerlink" title="as…as…"></a>as…as…</h3><blockquote><p>They are just as interested in finding the root cause between the product plan and the real world result, as they are to debug a hard-to-reproduce bug in the codebase.</p></blockquote><p>as X as Y，比较活动 X 和 Y。</p><p>活动 X（即 finding…）做 interested in 的介词宾语，活动 Y 跟在第二个 as 后面，是表示比较的状语从句。句子虽然长，但框架结构很明确，强调“工程师们对活动 X（找产品问题的根源）的兴趣和活动 Y（捉虫，即找技术问题的根源）一样大”。</p><h1 id="带你一次性搞懂非限定性和限定性定语从句"><a href="#带你一次性搞懂非限定性和限定性定语从句" class="headerlink" title="带你一次性搞懂非限定性和限定性定语从句"></a>带你一次性搞懂非限定性和限定性定语从句</h1><p>文章的第九段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">9. Strong product instincts through repeated cycles of learning</span><br><span class="line">A typical project for a product-minded engineer usually goes like this:</span><br><span class="line">1.They ask a lot of questions to understand exactly why the product feature is being built.</span><br><span class="line">2.They bring suggestions and tradeoffs to the table, some of which are included in the revised spec.</span><br><span class="line">3.They build the feature quickly, getting early feedback, as they do.</span><br><span class="line">4.After shipping the feature, they actively follow up to understand if the feature lives up to the expectation.</span><br><span class="line">5.When it does not, they dig deep, to understand why it did not and learn something new about product usage in the real world.</span><br><span class="line">After each project, their product understanding deepens, and they start to develop better and better product instincts. The next time, they’ll bring even more relevant suggestions to the table. Over time, they become a goto person for product managers, their advice being sought well before projects are kicked off. They build a strong reputation outside the team, opening more doors for their continued career growth.</span><br><span class="line"></span><br><span class="line">9.通过反复循环的学习，形成强大的产品本能</span><br><span class="line">对于有产品意识的工程师来说，一个典型的项目通常是这样的：</span><br><span class="line">1. 他们会提出很多问题，来准确理解构建产品功能的原因；</span><br><span class="line">2. 他们会提供建议和取舍方案，其中某些建议会反映在修订后的产品设计规范中；</span><br><span class="line">3. 他们会很快开发出相关功能，以便尽早得到反馈意见；</span><br><span class="line">4. 在产品发布之后，他们会积极跟进了解相关产品功能是否符合预期；</span><br><span class="line">5. 如果没有达到预期，他们会深入挖掘原因，并学到产品在现实世界中使用的新知识。</span><br><span class="line">每完成一个项目，他们对产品的理解就会加深，他们开始培养起越来越好的产品直觉。等到下一个项目，他们会贡献更多有价值的建议。随着时间推移，他们会成为产品经理最愿意去讨教的大专家，在新的项目还未开始之前就会提前去征求他们的意见。他们将名声在外，为持续的职业发展打开更多的大门。</span><br></pre></td></tr></table></figure><h2 id="知识详解"><a href="#知识详解" class="headerlink" title="知识详解"></a>知识详解</h2><h3 id="instinct"><a href="#instinct" class="headerlink" title="instinct"></a>instinct</h3><p>英文解释：An inborn pattern of behavior that is characteristic of a species and is often a response to specific environmental stimuli，一种天生的行为模式，作为一个物种的群体特征，通常是对特定环境刺激的反应。</p><p>这里涉及一个常见的词根，sting/stinct/stimul=thorn/to prick，即“刺 / 刺激”的意思。in-stinct 就是“内在的刺激反应”，也就是“一种与生俱来的天性、天赋”，或者叫“本能、直觉”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例句：Children do not know by instinct the difference between right and wrong.</span><br><span class="line">翻译：儿童并非生来就会分辨是非。</span><br><span class="line"></span><br><span class="line">例句：Even at school, he showed he had an instinct for business.</span><br><span class="line">翻译：他早在求学时期就表现出优秀的商业直觉（或经商天赋）。</span><br><span class="line"></span><br><span class="line">例句：Farmers are increasingly losing touch with their instinct for managing the land.</span><br><span class="line">翻译：农民正在逐渐失去经营土地的本领。</span><br></pre></td></tr></table></figure><h3 id="过去分词做前置定语"><a href="#过去分词做前置定语" class="headerlink" title="过去分词做前置定语"></a>过去分词做前置定语</h3><p>标题中的另一个词 repeated cycles，这是典型的过去分词做前置定语。需要注意的是，它有被动的含义，相当于 the cycles that are repeated。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：She says she’s got a broken heart. (=a heart that has been broken).</span><br><span class="line">翻译：她说她的心碎了。</span><br></pre></td></tr></table></figure><p>这里就是被动的含义，但是也有一些过去分词在做前置定语的时候，带有主动的含义，例如：</p><ul><li>a fallen leaf=a leaf that has fallen 一片落叶</li><li>a retired general =a general who has retired 一名退休的将军</li></ul><p>还有一些过去分词在做前置定语的时候，也带有主动的含义，但必须和副词一起使用才可以。例如下面这些：</p><ul><li>a much-travelled man = a man who travelled much 一个经常出远门的人（不可以说 a travelled man）</li><li>recently-arrived immigrants = immigrants who arrived recently 新来的移民（不可以说 arrived immigrants）</li></ul><p>下一段话中有一句 Bring well-backed product suggestions to the table。其中的 well-backed suggestions 也是同样的用法，表示工程师提的建议有充分的依据，但是直接说 backed suggestions 而不带副词 well，那就错啦。</p><p>还有些过去分词，前置定语和后置定语的意思会发生变化，例如：</p><ul><li>an adopted child=a child who is brought up by people who are not his/her biological parents 一个被收养的孩子</li><li>the solution adopted=the solution that is/was chosen 所采取的解决方案</li></ul><h3 id="bring-something-to-the-table"><a href="#bring-something-to-the-table" class="headerlink" title="bring (something) to the table"></a>bring (something) to the table</h3><blockquote><p>2.They bring suggestions and tradeoffs to the table, some of which are included in the revised spec.</p></blockquote><p>这个词组的字面含义是“把…放到桌上”，一般可以引申出“提供（意见、建议等）、贡献（技能、经验等）”的意思，to provide or offer a useful skill or attribute，表示一般提供或贡献的是能拿得出手、上得了台面、有价值的东西。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例句：He brings years of leadership experience to the table.</span><br><span class="line">翻译：他贡献了多年的领导经验。</span><br><span class="line"></span><br><span class="line">例句：Tell us what you bring to the table, not just what you want.</span><br><span class="line">翻译：告诉我们你能给公司带来什么，而不仅仅是你想要什么。</span><br></pre></td></tr></table></figure><h3 id="非限定性定语从句"><a href="#非限定性定语从句" class="headerlink" title="非限定性定语从句"></a>非限定性定语从句</h3><blockquote><p>They bring suggestions and tradeoffs to the table, <strong>some of which are included in the revised spec.</strong></p></blockquote><p><strong>所谓限定性，就是从句要对前面修饰的内容进行限制，缩小范围。</strong></p><p>例如，在“What is the name of the tall man who/that just came in? ”这句话中，说话的人问那个刚刚进来的高个男生叫什么名字？ “刚刚进来的”就是限定，不可以省略，否则就会变成问所有的高个男生叫什么名字了，影响前面整个句子意思的完整性。</p><p><strong>而非限定性定语从句，则是对前面的内容进行补充，增加信息。</strong></p><p>刚才文中的那句话，逗号后面的 some of which…补充说明工程师提出了建议，而且有的还会加到新版的设计规范文件里面去。逗号后面这部分信息可有可无，即使省略，也不影响前面主句意思的完整性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">She married a man that she met on a bus.</span><br><span class="line">She married a very nice young engineer from Chicago, whom she met on a bus.</span><br></pre></td></tr></table></figure><p>从形式上看，限定性定语从句的先行词可以用 that 引导，主句与从句不需要用逗号隔开，引导词有时可以省略；而非限定性定语从句的先行词不可以用 that 引导，主句与从句需要用逗号隔开，引导词不可以省略。</p><p>我们看下面这两组句子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一组：</span><br><span class="line">Have you got a book which/that is really easy to read? （可以用 that 引导，没有逗号）</span><br><span class="line">I lent him the Old Man and the Sea, which is really easy to read. （不可以用 that 代替 which，必须有逗号隔开）</span><br><span class="line"></span><br><span class="line">第二组：</span><br><span class="line">Did you like the wine we drank last night? （引导词可以省略）</span><br><span class="line">I poured him a glass of wine, which he drank at once. （引导词不可以省略）</span><br></pre></td></tr></table></figure><p>此外，限定性定语从句只能修饰先行词，遵循就近原则。非限定性定语从句既可以修饰先行词，也可以修饰整个句子或句子的一部分。你可以比较下面这两句话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">We had some ice-cream which was very unusual.</span><br><span class="line">We had some ice-cream, which was very unusual.</span><br></pre></td></tr></table></figure><p>第一句话是限定性定语从句，只能修饰先行词 ice-cream ，说明这个冰激凌不一般、很难得。<br>第二句非限定性定语从句，既可以修饰先行词，也可以修饰整个句子。所以这里就有可能产生歧义，一种理解和第一句一样，还有一种理解就是从句修饰 We had some ice-cream 这件事，强调我们不太吃冰激凌，所以吃冰激凌这件事情很少见、非同寻常。但是既然专门用了非限定性定语从句，一般作者的意图就是第二种解释，来强调吃冰激凌这件事。</p><h3 id="live-up-to"><a href="#live-up-to" class="headerlink" title="live up to"></a>live up to</h3><blockquote><p>4.After shipping the feature, they actively follow up to understand if the feature <strong>lives up to</strong> the expectation.</p></blockquote><p>live up to 是一个很常用也很地道的动词短语，表示 to be as good as or have the qualities that someone predicted, expected, or hoped for，即“遵守（诺言）、符合（预期）、不辜负（期望）”等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例句：We’d heard so many good things about the new restaurant, but the food didn’t live up to our expectations at all.</span><br><span class="line">翻译：我们听说很多关于这家新餐馆的赞誉，但餐食却远远没有达到我们的期望。</span><br><span class="line"></span><br><span class="line">例句：I’ve delivered the cash as you instructed. Now you must live up to your end of the bargain!</span><br><span class="line">翻译：我已经按照你说的把钱送来了。现在该你履行承诺了！</span><br></pre></td></tr></table></figure><h3 id="动词后缀-en"><a href="#动词后缀-en" class="headerlink" title="动词后缀 -en"></a>动词后缀 -en</h3><blockquote><p>After each project, their product understanding deepens, and they start to develop better and better product instincts.</p></blockquote><p>-en 是常用的动词后缀，形容词加上 -en 后缀，构成动词，表示“使得、变得”（make, become）。</p><p>例如，本句中 their product understanding deepens，deep 是形容词，表示“深、深刻”，加上 -en 后缀之后，变成动词 deepen，表示“变深、加深、使深刻”等含义，也就是工程师们对产品的理解加深了。</p><p>使用相同构词法构成的动词还有很多，例如 deaf（耳聋）加上 -en，就变成了 deafen（声音响得让人耳朵都要聋掉了）。这里列了一些类似的单词：</p><ul><li>broaden v 加宽（broad 宽）</li><li>darken 变黑（dark 黑）</li><li>dampen 使潮湿；使沮丧（damp 潮湿）</li><li>hasten 促进（haste 匆忙）</li><li>hearten 鼓励（heart 心）</li><li>sharpen 削尖（sharp 尖）</li><li>shorten 缩短（short 短）</li></ul><p>deafening silence，”震耳欲聋的安静“。这是英语里常用的矛盾修饰法（oxymoron）。</p><p>另外，-en 后缀还可以和名词一起组成形容词，例如名词 gold 加上 -en 变成 golden，成为形容词，表示“黄金的、金色的”。类似的词还有 wooden、woolen 等等。</p><p>除了 -en 之外，常用的动词后缀还有 -ate/-ify/-ise/-ize 等。</p><h3 id="relevant-irrelevant"><a href="#relevant-irrelevant" class="headerlink" title="relevant/irrelevant"></a>relevant/irrelevant</h3><blockquote><p>The next time, they’ll bring even more relevant suggestions to the table.</p></blockquote><p>这个词看似简单，只是表示“有意义的、密切相关的”（having significant and demonstrable bearing on the matter at hand），似乎没什么实质意义。类似，汉语里“有关部门”“相关问题”，听上去感觉含义很隐晦，所以很多中国同学经常会忽略这个词。但在英语中，relevant 这个词的含义一点都不隐晦哦，在很多场合，它的语气还很明确而强烈。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例句：These comments are not even relevant to this enquiry.</span><br><span class="line">翻译：这些意见简直文不对题，与这项调查没有关联。</span><br><span class="line"></span><br><span class="line">例句：I don’t see the relevance of your question. （名词形式）</span><br><span class="line">翻译：我不懂你提的这个问题有什么意义。（口气非常强烈甚至不礼貌）</span><br></pre></td></tr></table></figure><p>而反义词 irrelevant 的含义则更加直白，“不相关”的意思就是“无关紧要、有没有都一样”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：Their old hard-won skills now become irrelevant.</span><br><span class="line">翻译：他们以往辛苦学会（来自不易）的技能现如今已经没什么用处了。</span><br></pre></td></tr></table></figure><h3 id="a-go-to-person"><a href="#a-go-to-person" class="headerlink" title="a go-to person"></a>a go-to person</h3><blockquote><p>Over time, they become a goto person for product managers, their advice being sought well before projects are kicked off.</p></blockquote><p>a go-to person 这个词比较口语化，意思是“一个组织里的多面手、大拿、牛人”。每个公司或多或少都有这样几个人，你遇到棘手的问题都会去咨询他或她，这些人就是 goto person。</p><h3 id="kick-off"><a href="#kick-off" class="headerlink" title="kick off"></a>kick off</h3><p>kick off 这个动词短语，最初的意思是指“足球比赛中的开球”，(of a football game, soccer game, etc.) be started or resumed after a score by a player kicking the ball from a designated spot。现在用得更多的是它的引申义，表示“（会议）开始、（项目）启动”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例句：We’re going to kick off the new year with a huge party.</span><br><span class="line">翻译：我们将以一个盛大的晚会来开始新的一年。</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li><p>要善于“用一杯咖啡吸收宇宙能量”，其实都是一样的意思。因此，我们学英语绝非学习语言本身，在兴趣和好奇心的驱使下，广泛涉猎五花八门的百科知识，然后通过相同话题的外语“平行文本（parallel text）”的阅读或视听，来进行语言学习，是事半功倍的好方法。</p></li><li><p>培养好的态度和好的习惯。所谓好的态度，就是不要放过生活中碰到的任何一个疑问。<strong>心中苟有所开，即便札记。不则还塞之矣</strong>，意思就是说，你要是有了灵感，必须要马上记下来，不然很快就没了。</p></li><li><p>语言学习有方法但无捷径，语法如此，词根词缀也是如此。每天坚持听和读，有机会的时候加上一些说和写，不论多少，贵在坚持，细水长流，金石可断。</p></li><li><p>把学习外语想成你去一个陌生的地方旅行，别人的学习心得就是旅行攻略，而语法就是地图。无论你把地图研究得多么透彻，把街道名称倒背如流，都比不上真的踏上那片土地，亲自去挤一下当地的公交车，用脚丈量一下从酒店到山顶的几条步道，或者偶遇一家当地著名的苍蝇馆子，哪怕在街巷中迷失方向，都是非常好的体验。<strong>但请你一定不要急着想要把所有的语法规则记住背熟，现阶段跟我一起欣赏街景就好。</strong></p></li><li><p>在英语学习的过程中，我们除了要学习一个一个的单词以外，更加重要的是，要多学固定搭配和短语。就像我们学习汉语的时候，光识字是不够的，认识了单个的汉字之后，我们其实更多的在学习词语、词组或者成语。</p></li><li><p>学习语言的唯一目的就是交流，只要这个目的达到了，不管白猫黑猫，都是好猫。如果反过来，关起门来对自己很宽松，到人前又瞻前顾后、不敢开口，就很难学好外语。</p></li><li><p><strong>Stay hungry, stay foolish.”</strong>意在告诉人们，在自己精进的时候，要如饥似渴，始终保持“入口”的开放，做个吃货；但一旦付诸行动去实现自己认准的人生理想时，要如同赤子一般天真大胆，不怕别人耻笑，敢于在别人误解的目光里孤独前行，做个“傻缺”。</p></li><li><p>People don’t want to buy a quarter-inch drill. They want a quarter-inch hole（顾客不是想买一个 1/4 英寸的电钻，他们想要的是 1/4 英寸的洞！）。这句话想说的就是，顾客对产品本身不感兴趣，他们感兴趣的是产品能给他们带来什么好处。</p></li><li><p><strong>语法永远是为意思服务的。</strong>数据本身是没有价值的，就如同语言文字千变万化，浩如烟海，慢慢地获得将数据转化为洞察力的本事，才能先行一步。正如《指环王》的作者托尔金在《汉姆的农夫吉尔斯》（Farmer Giles of Ham）里提到先知的牧师时说：He was a grammarian and could doubtless see further into the future than others.（他是一个语法学家，无疑他比其他人更能预见未来。）</p></li><li><p>平时自己在阅读的时候可以慢慢养成的一些习惯——首先，阅读过程中碰到不认识的词，在不影响大意理解的前提下，我们要勇敢地无视生词，直接碾压过去。千万不要每一个词都去查，否则除了效率降低以外，阅读的乐趣也会大打折扣；其次，如果发现这个词绕不过去，影响核心内容的理解，那就一定要查了。但是也不要只查一个中文的意思就结束了，顺便做三件事情：第一，查阅英英字典，了解一下英文的解释；第二，比较全面地了解一下这个词的几个不同意思，想一想这几个意思之间的关联性；第三，多读几个例句，了解这个词活生生的用法；最后，要善于去发现一些你似乎认得，但并不真正了解的“小词”。</p></li><li><p>在英语学习的过程，我们固然希望保持精益求精的态度，少犯低级的语法错误，但也不能因噎废食，因为害怕出错就畏惧开口。</p></li><li><p><strong>词汇学习一定不能脱离上下文，背单词不如背例句，背例句不如自己模仿写例句。</strong>凡学英语，必学整句，不觉中将其句法音调整个吸入。每日选二三句，回环熟诵，此数句读音必正，出口必熟。如此半年，操英语能力必大进。</p></li></ul><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ul><li><a href="https://tech.qq.com/a/20111006/000132.htm" target="_blank" rel="noopener">斯坦福大学演讲（英文）</a></li><li><a href="https://time.geekbang.org/column/article/237837" target="_blank" rel="noopener">What are Similes?</a></li><li><a href="https://www.englishpractice.com/grammar/adverb-particles/?pdf=1004" target="_blank" rel="noopener">What are Adverb Particles?</a></li><li><a href="https://www.grammar-monster.com/glossary/compound_nouns.htm" target="_blank" rel="noopener">compound_nouns</a></li><li><a href="https://medium.com/the-happy-startup-school/beyond-mvp-10-steps-to-make-your-product-minimum-loveable-51800164ae0c" target="_blank" rel="noopener">beyond-mvp-10-steps-to-make-your-product-minimum-loveable</a></li><li><a href="http://englishplus.com/grammar/00000031.htm" target="_blank" rel="noopener">http://englishplus.com/grammar/00000031.htm</a></li><li><a href="https://www.grammar-monster.com/glossary/subjunctive_mood.htm" target="_blank" rel="noopener">https://www.grammar-monster.com/glossary/subjunctive_mood.htm</a></li><li><a href="https://www.forbes.com/sites/jeffschmitt/2013/10/31/the-go-to-person-what-you-need-to-become-one/#b31f871522ee" target="_blank" rel="noopener">The Go-To Person: What You Need To Become One</a></li><li><a href="https://learnenglish.britishcouncil.org/grammar/intermediate-to-upper-intermediate/relative-clauses-non-defining-relative-clauses" target="_blank" rel="noopener">Relative clauses – non-defining relative clauses</a></li></ul><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 08:48:17 GMT+0800 (CST) --&gt;&lt;p&gt;&lt;a href=&quot;https://blog.pragmaticengineer.com/the-product-minded-engineer/?utm_s
      
    
    </summary>
    
    
      <category term="English-Study" scheme="https://octopuslian.github.io/categories/English-Study/"/>
    
    
      <category term="语法" scheme="https://octopuslian.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="程序员" scheme="https://octopuslian.github.io/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="产品" scheme="https://octopuslian.github.io/tags/%E4%BA%A7%E5%93%81/"/>
    
      <category term="阅读" scheme="https://octopuslian.github.io/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="词汇" scheme="https://octopuslian.github.io/tags/%E8%AF%8D%E6%B1%87/"/>
    
  </entry>
  
  <entry>
    <title>编程入门项目一点五：升级自己的测试框架</title>
    <link href="https://octopuslian.github.io/2020/06/13/geekbang-column-upgrade-your-own-testing-framework/"/>
    <id>https://octopuslian.github.io/2020/06/13/geekbang-column-upgrade-your-own-testing-framework/</id>
    <published>2020-06-13T09:45:07.000Z</published>
    <updated>2020-06-13T12:12:59.431Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 08:48:17 GMT+0800 (CST) --><h2 id="完善测试框架的功能与提示"><a href="#完善测试框架的功能与提示" class="headerlink" title="完善测试框架的功能与提示"></a>完善测试框架的功能与提示</h2><h3 id="温故知新，gtest-的输出结果"><a href="#温故知新，gtest-的输出结果" class="headerlink" title="温故知新，gtest 的输出结果"></a>温故知新，gtest 的输出结果</h3><p>第一部分，一套单元测试的相关信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[==========] Running 2 tests from 1 test suite.</span><br><span class="line">[----------] Global test environment set-up.</span><br><span class="line">[----------] 2 tests from test_is_prime</span><br></pre></td></tr></table></figure><p>第二部分，是每个单元测试运行信息的输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[ RUN      ] test_is_prime.test1</span><br><span class="line">[       OK ] test_is_prime.test1 (1 ms)</span><br><span class="line">[ RUN      ] test_is_prime.test2</span><br><span class="line">gtest_test.cpp:25: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  is_prime(4)</span><br><span class="line">    Which is: 1</span><br><span class="line">  0</span><br><span class="line">gtest_test.cpp:26: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  is_prime(0)</span><br><span class="line">    Which is: 1</span><br><span class="line">  0</span><br><span class="line">gtest_test.cpp:27: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  is_prime(1)</span><br><span class="line">    Which is: 1</span><br><span class="line">  0</span><br><span class="line">[  FAILED  ] test_is_prime.test2 (0 ms)</span><br></pre></td></tr></table></figure><p>如上所示，第一个单元测试 test_is_prime.test1 运行结果正确，所用时间是 1ms；第二个单元测试 test_is_prime.test2 中，有三个判等 EXPECT 断言的结果是错误的，也就是 is_prime 函数的返回值，和测试用例中期望的返回值不符，这说明 is_prime 函数存在 Bug。</p><p>第三部分，就是这套单元测试的总结信息，以及整个程序单元测试结果的汇总信息。这段信息，有兴趣的小伙伴可以自己理解着看一下，由于不是咱们今天课程的重点，就不展开介绍了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[----------] 2 tests from test_is_prime (1 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global test environment tear-down</span><br><span class="line">[==========] 2 tests from 1 test suite ran. (1 ms total)</span><br><span class="line">[  PASSED  ] 1 test.</span><br><span class="line">[  FAILED  ] 1 test, listed below:</span><br><span class="line">[  FAILED  ] test_is_prime.test2</span><br><span class="line"></span><br><span class="line"> 1 FAILED</span><br></pre></td></tr></table></figure><h3 id="从哪些方面来完善测试框架？"><a href="#从哪些方面来完善测试框架？" class="headerlink" title="从哪些方面来完善测试框架？"></a>从哪些方面来完善测试框架？</h3><p>通过观察第二部分的输出，我们基本要从三个方面完善测试框架的输出信息。</p><ul><li>在每个测试用例运行之前，要先行输出相关测试用例的名字；</li><li>每个测试用例运行结束以后，要输出测试用例的运行时间与运行结果（OK 或者 FAILED）；</li><li>若测试用例中的 EXPECT 断言出错，需要输出错误提示信息。</li></ul><h3 id="测试用例的名字输出"><a href="#测试用例的名字输出" class="headerlink" title="测试用例的名字输出"></a>测试用例的名字输出</h3><p>首先是如何输出测试用例的名字。我们先回忆一下上节课设计的注册函数，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST(test_name, func_name) \</span></span><br><span class="line"><span class="keyword">void</span> test_name##_##func_name(); \</span><br><span class="line">__attribute__((constructor)) \</span><br><span class="line"><span class="keyword">void</span> register_##test_name##_##func_name() &#123; \</span><br><span class="line">    test_function_arr[test_function_cnt] = test_name##_##func_name; \</span><br><span class="line">    test_function_cnt++; \</span><br><span class="line">&#125; \</span><br><span class="line"><span class="keyword">void</span> test_name##_##func_name()</span><br></pre></td></tr></table></figure><p>注册函数是随着 TEST 展开的，从展开的代码逻辑中可以看到，它只是将测试用例的函数地址记录在了函数指针数组中。要想 RUN_ALL_TESTS 函数后续能够输出测试用例的函数名称的话，我们只需要修改注册函数的功能逻辑即可，也就是让注册函数在记录函数信息的时候，增加记录对应测试用例的名称。</p><p>而这个名称信息，应该记录在哪里呢？有两种代码实现方式：</p><ul><li>1，另外开辟一个记录测试用例名称的字符串数组；</li><li>2，修改 test_function_arr 数组中的元素类型，将新增的测试用例名称以及函数地址信息打包成一个数据元素。</li></ul><p>显然，相较于第一种实现方式，第二种代码实现方式会使程序具有更好的封装特性。</p><p>面就是我们将函数指针信息和测试用例名称信息，封装成的一个新的结构体类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_function_info_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">test_function_t</span> func;  <span class="comment">// 测试用例函数指针，指向测试用例函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 指向测试用例名称</span></span><br><span class="line">&#125; test_function_arr[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> test_function_cnt = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>如代码所示，我们定义了一种新的数据类型，叫做 test_function_info_t。这种结构体类型包含了指向测试用例的函数指针 func 字段， 与指向测试用例名称的字符串指针 name 字段，并且我们将这种结构体类型，作为 test_function_arr 数组新的元素类型。</p><p>既然测试用例信息的存储区 test_function_arr 的数据类型发生了改变，那么负责存储信息的注册函数，与使用信息的 RUN_ALL_TESTS 函数的相关逻辑都需要作出改变。</p><p>首先，我们来看注册函数的改变。想要修改注册函数的逻辑，就是修改 TEST 宏，从功能上来说，注册函数中需要额外记录一个测试用例名称信息，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST(test_name, func_name) \</span></span><br><span class="line"><span class="keyword">void</span> test_name##_##func_name(); \</span><br><span class="line">__attribute__((constructor)) \</span><br><span class="line"><span class="keyword">void</span> register_##test_name##_##func_name() &#123; \</span><br><span class="line">    test_function_arr[test_function_cnt].func = test_name##_##func_name; \</span><br><span class="line">    test_function_arr[test_function_cnt].name = #func_name <span class="string">"."</span> #test_name; \</span><br><span class="line">    test_function_cnt++; \</span><br><span class="line">&#125; \</span><br><span class="line"><span class="keyword">void</span> test_name##_##func_name()</span><br></pre></td></tr></table></figure><p>代码中主要是增加了第 6 行的逻辑，这一行的代码将 TEST 宏参数的两部分，拼成一个字符串，中间用点 (.) 连接，例如 TEST(test1, test_is_prime) 宏调用中，拼凑的字符串就是 test_is_prime.test1，和 gtest 中的输出的测试用例名称信息格式是一致的。</p><p>改完了注册函数的逻辑以后，最后调整一下 RUN_ALL_TESTS 中使用 test_function_arr 数组的逻辑代码即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RUN_ALL_TESTS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test_function_cnt; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[ RUN      ] %s\n"</span>, test_function_arr[i].name);  <span class="comment">//仿照 gtest 的输出格式进行调整的，在输出测试用例名称之前，先输出一段包含 RUN 英文的标志信息。</span></span><br><span class="line">        test_function_arr[i].func();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"RUN TEST DONE\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们就完成了输出测试用例名字的框架功能改造。</p><h3 id="输出测试用例的运行结果信息"><a href="#输出测试用例的运行结果信息" class="headerlink" title="输出测试用例的运行结果信息"></a>输出测试用例的运行结果信息</h3><p>以下是我们示例代码中的 2 个测试用例，在 gtest 框架下的运行结果信息输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[     OK ] test_is_prime.test1 (1 ms)</span><br><span class="line">[ FAILED ] test_is_prime.test2 (0 ms)</span><br></pre></td></tr></table></figure><p>根据输出的信息，我们可知 gtest 会统计每个测试用例运行的时间，并以毫秒为计量单位，输出此时间信息。不仅如此，gtest 还会输出与测试用例是否正确相关的信息，如果测试用例运行正确，就会输出一行包含 OK 的标志信息，否则就输出一行包含 FAILED 的标志信息。</p><p>根据我们自己测试框架的设计，这行信息只有可能是在 RUN_ALL_TESTS 函数的 for 循环中，执行完每一个测试用例函数以后输出的信息。</p><p>由此，我们面临的是两个需要解决的问题：</p><ul><li><p>1，如何统计函数过程的运行时间？<br>函数 clock() 。它的返回值代表了：从运行程序开始，到调用 clock() 函数时，经过的 CPU 时钟计时单元。并且，这个 clock() 函数的返回值，实际上反映的是我们程序的运行时间。那这个 CPU 时钟计时单元究竟是什么呢？你可以把 1 个 CPU 时钟计时单元，简单的理解成是一个单位时间长度，只不过这个单位时间长度，不是我们常说的 1 秒钟。<br>宏 CLOCKS_PER_SEC 。它实际上是一个整型值，代表多少个 CPU 时钟计时单元是 1 秒。</p></li><li><p>2，如何确定获得每一个测试用例函数的测试结果是否正确？<br>记录一个全局变量，代表测试用例结果正确与否。当测试用例中的 EXPECT_EQ 断言发生错误时，就修改这个全局变量的值，这样我们的 RUN_ALL_TESTS 函数，就可以在测试用例函数执行结束以后，得知执行过程是否有错。</p></li></ul><p>综合以上所有信息，我们可以重新设计 RUN_ALL_TESTS 函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> test_run_flag;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPECT_EQ(a, b) test_run_flag &amp;= ((a) == (b))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RUN_ALL_TESTS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test_function_cnt; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[ RUN      ] %s\n"</span>, test_function_arr[i].name);</span><br><span class="line">        test_run_flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> t1 = clock();</span><br><span class="line">        test_function_arr[i].func();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> t2 = clock();</span><br><span class="line">        <span class="keyword">if</span> (test_run_flag) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[       OK ] "</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[  FAILED  ] "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, test_function_arr[i].name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" (%.0lf ms)\n\n"</span>, <span class="number">1.0</span> * (t2 - t1) / CLOCKS_PER_SEC * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的第 8 行是在测试用例运行之前，记录一个开始时间值 t1；代码中的第 10 行是在测试用例函数执行完后，记录一个结束时间值 t2；在代码的第 17 行，根据 t1 、t2 以及 CLOCKS_PER_SEC 的值，计算得到测试用例函数实际运行的时间，并输出得到的结果。</p><p>这段代码中增加了一个全局变量“test_run_flag”，这个变量每次在测试用例执行之前，都会被初始化为 1，当测试用例结束执行以后，RUN_ALL_TESTS 函数中，根据 test_run_flag 变量的值，选择输出 OK 或者 FAILED 的标志信息。同时，我们可以看到，test_run_flag 变量的值只有在 EXPECT_EQ 断言中，才可能被修改。</p><h3 id="EXPECT-EQ-断言的实现"><a href="#EXPECT-EQ-断言的实现" class="headerlink" title="EXPECT_EQ 断言的实现"></a>EXPECT_EQ 断言的实现</h3><p>首先，EXPECT_EQ(a, b) 在 a，b 两部分值相等的时候，不会产生额外的输出信息，而当 a，b 两部分不相等的时候，就会输出相应的提示信息。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gtest_test.cpp:25: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  is_prime(4)</span><br><span class="line">    Which is: 1</span><br><span class="line">  0</span><br></pre></td></tr></table></figure><p>这段输出信息，对应的是源代码中的 “EXPECT_EQ(is_prime(4), 0); ”的输出。如你所见，第 1 行的输出内容包含了源文件名（gtest_test.cpp），EXPECT_EQ 宏所在的代码位置（25），以及一个提示结果（Failure）。</p><p>对于函数调用部分，EXPECE_EQ 会输出这个函数的调用形式及返回值信息，也就是输出中的 “is_prime(4)”“Which is: 1” 这段内容。而对于数值信息，只会输出数值信息本身，也就是输出信息中第 5 行的那个 0。</p><p>实际上，要想在宏中实现类似于这种根据传入参数类型，选择输出形式的功能，对于现在的你来说可能有点困难。所以，我们可以重新设计一种输出形式，只要能够清晰地展示错误信息就可以。<br>重新设计的输出提示，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gtest_test.cpp:25: Failure</span><br><span class="line">Expected (is_prime(4) == 0):</span><br><span class="line">    Which is: (1 == 0)</span><br></pre></td></tr></table></figure><p>修改完以后的输出信息，你可以看到，第 2 行就是传入 EXPECT_EQ 宏两部分的比较，第 3 行是这两部分实际输出值的比较。<br>重新设计了输出信息以后，就可以来看看 EXPECT_EQ 宏的实现了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPECT(a, b, comp) &#123; \</span></span><br><span class="line">    __typeof(a) val_a = (a), val_b = (b); \</span><br><span class="line">    <span class="keyword">if</span> (!(val_a comp val_b)) &#123; \</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s:%d: Failure\n"</span>, __FILE__, __LINE__); \</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Expected (%s %s %s):\n"</span>, #a, #comp, #b); \</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"    Which is: (%d %s %d)\n"</span>, val_a, #comp, val_b); \</span><br><span class="line">        test_run_flag = <span class="number">0</span>; \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPECT_EQ(a, b) EXPECT(a, b, ==)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPECT_LT(a, b) EXPECT(a, b, &lt;)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPECT_GT(a, b) EXPECT(a, b, &gt;)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPECT_NE(a, b) EXPECT(a, b, !=)</span></span><br></pre></td></tr></table></figure><p>在这段实现中，你会发现，我们不仅实现了 EXPECT_EQ，还额外实现了 EXPECT_LT、EXPECT_GT、EXPECT_NE 等用于比较的宏。其中，LT 是英文 little 的缩写，是判断小于关系的；GT 是 great 的缩写，是判断大于关系的；NE 是 not equal 的缩写，是判断不等于关系的。而这些所有的宏，都是基于 EXPECT 宏实现的。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>工程开发中的一个基本原则：功能迭代，数据先行。也就是说，无论我们做什么样的功能开发，首先要考虑的是与数据相关的部分。</p><h2 id="链表知识在测试框架中的应用"><a href="#链表知识在测试框架中的应用" class="headerlink" title="链表知识在测试框架中的应用"></a>链表知识在测试框架中的应用</h2><h3 id="用链表存储测试用例"><a href="#用链表存储测试用例" class="headerlink" title="用链表存储测试用例"></a>用链表存储测试用例</h3><p>重新审视下面这段函数指针数组 test_function_arr 的代码设计，来思考一下这个测试框架中还有没有可以优化的地方。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_function_info_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">test_function_t</span> func;  <span class="comment">// 测试用例函数指针，指向测试用例函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 指向测试用例名称</span></span><br><span class="line">&#125; test_function_arr[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> test_function_cnt = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这段代码中，我们使用了数组来定义存储测试函数信息的存储区，这个数组的大小有 100 位，也就是说，最多可以存储 100 个测试用例函数信息。</p><h3 id="要是有程序中定义了-1000-个测试用例，怎么办呢？"><a href="#要是有程序中定义了-1000-个测试用例，怎么办呢？" class="headerlink" title="要是有程序中定义了 1000 个测试用例，怎么办呢？"></a>要是有程序中定义了 1000 个测试用例，怎么办呢？</h3><p>第一步，我们需要改变 test_function_info_t 的结构定义，也就是把原先存储测试用例函数信息的结构体类型，改装成链表结构。最简单的方法，就是在结构体的定义中，增加一个指针字段，指向下一个 test_function_info_t 类型的数据，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_function_info_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">test_function_t</span> func;  <span class="comment">// 测试用例函数指针，指向测试用例函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 指向测试用例名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_function_info_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_function_info_t</span> <span class="title">head</span>, *<span class="title">tail</span> = &amp;<span class="title">head</span>;</span></span><br></pre></td></tr></table></figure><p>可以看到，我们给 test_function_info_t 结构体类型增加了一个链表中的 next 字段，除此之外，我们还定义了一个虚拟头节点 head 和一个指针变量 tail。这里你需要注意，head 是虚拟头节点，后续我们会向 head 所指向链表中插入链表节点，tail 指针则指向了整个链表的最后一个节点的地址。</p><p>第二步，在准备好了数据存储结构以后，需要改写的就是函数注册的逻辑了。在改写 TEST 宏中的注册函数逻辑之前呢，我们先准备一个工具函数 add_test_function，这个工具函数的作用，就是根据传入的参数，新建一个链表节点，并且插入到整个链表的末尾：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_test_function</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">test_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_function_info_t</span> *<span class="title">node</span>;</span></span><br><span class="line">    node = (struct <span class="keyword">test_function_info_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct <span class="keyword">test_function_info_t</span>));</span><br><span class="line">    node-&gt;func = func;</span><br><span class="line">    node-&gt;name = name;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    tail-&gt;next = node;</span><br><span class="line">    tail = node;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改写 TEST 宏中注册函数的逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST(test_name, func_name) \</span></span><br><span class="line"><span class="keyword">void</span> test_name##_##func_name(); \</span><br><span class="line">__attribute__((constructor)) \</span><br><span class="line"><span class="keyword">void</span> register_##test_name##_##func_name() &#123; \</span><br><span class="line">    add_test_function(#func_name <span class="string">"."</span> #test_name, \</span><br><span class="line">                      test_name##_##func_name); \</span><br><span class="line">&#125; \</span><br><span class="line"><span class="keyword">void</span> test_name##_##func_name()</span><br></pre></td></tr></table></figure><p>最后一步，处理完了数据写入的过程以后，来让我们修改一下使用这份数据的代码逻辑，那就是 RUN_ALL_TESTS 函数中的相关逻辑。之前，RUN_ALL_TESTS 函数中，循环遍历数组中的每一个测试用例，并且执行相关的测试用例函数，对这一部分，修改成针对于链表结构的遍历方式即可，代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RUN_ALL_TESTS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_function_info_t</span> *<span class="title">p</span> = <span class="title">head</span>.<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (; p; p = p-&gt;next) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[ RUN      ] %s\n"</span>, p-&gt;name);</span><br><span class="line">        test_run_flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> t1 = clock();</span><br><span class="line">        p-&gt;func();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> t2 = clock();</span><br><span class="line">        <span class="keyword">if</span> (test_run_flag) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[       OK ] "</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[  FAILED  ] "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, p-&gt;name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" (%.0lf ms)\n\n"</span>, <span class="number">1.0</span> * (t2 - t1) / CLOCKS_PER_SEC * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就彻底完成了测试用例函数信息存储部分的“链表”改造过程。</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 08:48:17 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;完善测试框架的功能与提示&quot;&gt;&lt;a href=&quot;#完善测试框架的功能与提示&quot; class=&quot;headerlink&quot; title=&quot;完善测试框架的功能
      
    
    </summary>
    
    
      <category term="编程入门" scheme="https://octopuslian.github.io/categories/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="项目" scheme="https://octopuslian.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="框架" scheme="https://octopuslian.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="测试" scheme="https://octopuslian.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>编程入门项目一：实现一个自己的测试框架</title>
    <link href="https://octopuslian.github.io/2020/06/13/geekbang-column-implement-your-own-testing-framework/"/>
    <id>https://octopuslian.github.io/2020/06/13/geekbang-column-implement-your-own-testing-framework/</id>
    <published>2020-06-13T09:44:04.000Z</published>
    <updated>2020-06-14T02:31:50.339Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Jul 31 2020 08:48:16 GMT+0800 (CST) --><h2 id="实现测试框架前的准备"><a href="#实现测试框架前的准备" class="headerlink" title="实现测试框架前的准备"></a>实现测试框架前的准备</h2><h3 id="初识：Google-测试框架"><a href="#初识：Google-测试框架" class="headerlink" title="初识：Google 测试框架"></a>初识：Google 测试框架</h3><p>Google 开发的单元测试框架 Google Test，我们一般称它为 gtest。</p><p>测试代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个数字 x 是否是素数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt; x; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个测试用例</span></span><br><span class="line">TEST(test1, test_is_prime) &#123;</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">3</span>), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">5</span>), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">7</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个测试用例</span></span><br><span class="line">TEST(test2, test_is_prime) &#123;</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">4</span>), <span class="number">0</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RUN_ALL_TESTS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[==========] Running 2 tests from 1 test suite.</span><br><span class="line">[----------] Global test environment set-up.</span><br><span class="line">[----------] 2 tests from test_is_prime</span><br><span class="line">[ RUN      ] test_is_prime.test1</span><br><span class="line">[       OK ] test_is_prime.test1 (1 ms)</span><br><span class="line">[ RUN      ] test_is_prime.test2</span><br><span class="line">gtest_test.cpp:25: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  is_prime(4)</span><br><span class="line">    Which is: 1</span><br><span class="line">  0</span><br><span class="line">gtest_test.cpp:26: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  is_prime(0)</span><br><span class="line">    Which is: 1</span><br><span class="line">  0</span><br><span class="line">gtest_test.cpp:27: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  is_prime(1)</span><br><span class="line">    Which is: 1</span><br><span class="line">  0</span><br><span class="line">[  FAILED  ] test_is_prime.test2 (0 ms)</span><br><span class="line">[----------] 2 tests from test_is_prime (1 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global test environment tear-down</span><br><span class="line">[==========] 2 tests from 1 test suite ran. (1 ms total)</span><br><span class="line">[  PASSED  ] 1 test.</span><br><span class="line">[  FAILED  ] 1 test, listed below:</span><br><span class="line">[  FAILED  ] test_is_prime.test2</span><br><span class="line"></span><br><span class="line"> 1 FAILED TEST</span><br></pre></td></tr></table></figure><p>先看输出内容的第 4 行和第 6 行，意思是说，执行测试用例 test_is_prime.test1 和 test_is_prime.test2，这不就是上面两个以 TEST 开头的两段代码相关的输出内容么？</p><p>接下来从第 7 行到第 21 行是一段报错信息，意思就是说 is_prime(4)，is_prime(0) 与 is_prime(1) 函数返回值错误，也就意味着 is_prime 函数实现有错误，这段错误所涉及的信息，在源代码中的第二个测试用例中有涉及。</p><h3 id="对于-gtest-的三个思考"><a href="#对于-gtest-的三个思考" class="headerlink" title="对于 gtest 的三个思考"></a>对于 gtest 的三个思考</h3><p>面对刚才的演示代码和输出内容，你可能会产生如下三个问题：</p><ul><li>1，代码中的 EXPECT_EQ 是做什么的？</li><li>2，以 TEST 开头的代码段，和我们学习的函数很不一样，那它究竟是什么？</li><li>3，主函数中只调用了 RUN_ALL_TESTS 函数，为什么好像是执行了程序中所有的 TEST 代码段？这个功能是怎么实现的？</li></ul><p>第一个问题不难，查看相关 gtest 的文档资料，你就可以知道，EXPECT_EQ 是 gtest 里面自带的宏，主要作用是判断传入的两部分的值是否相等。如果不相等，就会产生类似于输出内容中第 7 行到第 21 行的输出内容。</p><p>第二个问题，以 TEST 开头的这段代码，明显不符合我们对 C 语言的语法认知，我们确实没有见过不用规定返回值类型，也不用规定参数类型的函数定义方式。关于 TEST 究竟是个什么的问题，更加合理的猜测，就是 TEST 实际上是一个宏。</p><p><strong>宏的作用，是做简单的替换。</strong>正是因为 TEST(test_is_prime, test1) 这段代码实际上是一个宏，所以展开以后，和后面的大括号中的内容一起组成了一段合法的代码内容。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>测试行为，不是测试工程师的专属，你应该把它作为一个开发工程师的习惯。</li><li>单元测试属于白盒测试范畴，Google 的 gtest 就是一种辅助我们编写单元测试的框架。</li><li>gtest 中的 TEST 本质上是一个宏，而这个宏应该展开成怎样的代码内容，还需要你认真思考，这个思考过程对你来说是很有价值的。</li></ul><h2 id="实现一个自己的测试框架"><a href="#实现一个自己的测试框架" class="headerlink" title="实现一个自己的测试框架"></a>实现一个自己的测试框架</h2><h3 id="初步实现-TEST-宏"><a href="#初步实现-TEST-宏" class="headerlink" title="初步实现 TEST 宏"></a>初步实现 TEST 宏</h3><p>我们实现的所有代码，都会写在一个名字为 <code>geek_test.h</code>的头文件中。(注意：将声明和定义写在一起，在大型工程中是会出现严重的编译错误，在实际的工程开发中，我们并不会这么做。)</p><p>我们的目的，是在不改变这份源代码的前提下，通过在 geek_test.h 中添加一些源码，使得这份代码的运行效果，能够类似于 gtest 的运行效果。</p><p>想要完成这个目标，我们就要先来思考 TEST 宏这里的内容，请你仔细观察这段由 TEST 宏定义的测试用例的相关代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TEST(test1, test_is_prime) &#123;</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">3</span>), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">5</span>), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">7</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TEST(test1, test_is_prime) 这部分应该是在调用 TEST 宏，而这部分被预处理器展开以后的内容，只有和后面大括号里的代码组合在一起，才是一段合法的 C 语言代码，也只有这样，这份代码才能通过编译。既然如此，我们就不难想到，TEST 宏展开以后，它应该是一个函数定义的头部，后面大括号里的代码，就是这个展开以后的函数头部的函数体部分，这样一切就都说得通了。</p><p>在实现 TEST 宏之前，我们还需要想清楚一个问题：由于程序中可以定义多个 TEST 测试用例，如果每一个 TEST 宏展开都是一个函数头部的话，那这个展开的函数的名字是什么呢？如果每一个 TEST 宏展开的函数名字都一样，那程序一定无法通过编译，编译器会报与函数名重复相关的错误，所以， TEST 宏是如何确定展开函数的名字呢？</p><p>注意，TEST 宏需要传入两个参数，这两个参数在输出信息中与测试用例的名字有关。那我们就该想到，可以使用这两个参数拼接出一个函数名，只要 TEST 传入的这两个参数不一样，那扩展出来的函数名就不同。最后，我们就可以初步得到如下的 TEST 宏的一个实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST(test_name, func_name) \</span></span><br><span class="line"><span class="keyword">void</span> test_name##_##func_name()</span><br></pre></td></tr></table></figure><p>如代码所示的 TEST 宏实现，我们将 TEST 宏的两个参数内容使用 ## 连接在一起，中间用一个额外的下划线连接，组成一个函数名字，这个函数的返回值类型是 void，无传入参数。根据这个实现，预处理器会将源代码中两处 TEST 宏的内容，替换成如下代码所示内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1_test_is_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">3</span>), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">5</span>), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">7</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2_test_is_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">4</span>), <span class="number">0</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="attribute：让其它函数先于主函数执行"><a href="#attribute：让其它函数先于主函数执行" class="headerlink" title="attribute：让其它函数先于主函数执行"></a><strong>attribute</strong>：让其它函数先于主函数执行</h3><p>先，我们先来看如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello geek!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello main!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行以后，会输出一行字符串 “hello main!”。</p><p>接下来呢，我们对上述代码稍微修改，在 pre_output 函数前面加上<strong>attribute</strong>((constructor)) 。这样，pre_output 函数就会先于主函数执行，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello geek!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello main!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码执行以后，程序会输出两行内容，第 1 行是 pre_output 函数输出的内容 “hello geek!”，第 2 行才是主函数的执行输出内容 “hello main!”。</p><p>从输出内容可以看出，<strong>加了<strong>attribute</strong>((constructor)) 以后，pre_output 函数会先于 main 主函数执行。</strong></p><h3 id="RUN-ALL-TESTS-函数设计"><a href="#RUN-ALL-TESTS-函数设计" class="headerlink" title="RUN_ALL_TESTS 函数设计"></a>RUN_ALL_TESTS 函数设计</h3><p>从主函数中调用 RUN_ALL_TESTS 函数的方式来看，RUN_ALL_TESTS 函数应该是一个返回值为整型的函数。这样，我们可以得到这样的函数声明形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RUN_ALL_TESTS</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>从测试框架的执行输出结果中看，RUN_ALL_TESTS 函数可以依次性地执行每一个 TEST 宏扩展出来的测试用例函数，这是怎么做到的呢？</p><p>我们可以这样认为：在主函数执行 RUN_ALL_TESTS 函数之前，有一些函数过程，就已经把测试用例函数的相关信息，记录在了一个 RUN_ALL_TESTS 函数可以访问到的地方，等到 RUN_ALL_TESTS 函数执行的时候，就可以根据这些记录的信息，依次性地执行这些测试用例函数。整个过程，如下图所示：</p><p><img src="/2020/06/13/geekbang-column-implement-your-own-testing-framework/run-all-test.jpg" alt></p><p>图中红色部分，就是我们推测的，某些完成测试用例函数信息注册的函数，它们先于主函数执行，将测试用例的信息，写入到一个公共存储区中。</p><p>接下来，我们需要考虑的就是这些注册函数，究竟将什么信息存储到了公共存储区中，才能使得 RUN_ALL_TESTS 函数可以调用到这些测试用例？你自己也可以想想是什么。答案就是这个信息是测试用例函数的函数地址，因为只有把函数地址存储到这个存储区中，才能保证 RUN_ALL_TESTS 函数可以调用它们。所以，这片公共存储区，就应该是一个函数指针数组。</p><p>那如何解决注册函数问题呢？最简单直接的设计方法，就是每多一个由 TEST 宏定义的测试用例，就配套一个注册函数，所以这个注册函数的逻辑，可以设计在 TEST 宏展开的内容中。这就需要我们对 TEST 宏进行重新设计。</p><p>我们先来完成 RUN_ALL_TESTS 函数从存储区中，读取并执行测试用例的过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">test_function_t</span>)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">test_function_t</span> test_function_arr[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> test_function_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RUN_ALL_TESTS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test_function_cnt; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"RUN TEST : %d\n"</span>, i + <span class="number">1</span>);</span><br><span class="line">        test_function_arr[i]();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"RUN TEST DONE\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中用到了函数指针相关的技巧，其中 test_function_t 是我们定义的函数指针类型，这种函数指针类型的变量，可以用来指向返回值是 void，传入参数为空的函数。</p><p>之后，定义了一个有 100 位的函数指针数组 test_function_arr，数组中的每个位置，都可以存储一个函数地址，数组中元素数量，记录在整型变量 test_function_cnt 中。这样，RUN_ALL_TESTS 函数中的逻辑就很简单了，就是依次遍历函数指针数组中的每个函数，然后依次执行这些函数，这些函数每一个都是一个测试用例。</p><h3 id="重新设计：TEST-宏"><a href="#重新设计：TEST-宏" class="headerlink" title="重新设计：TEST 宏"></a>重新设计：TEST 宏</h3><p>根据前面的分析，TEST 扩展出来的内容，不仅要有测试用例的函数头部，还需要有先于主函数执行的注册函数，主要用于注册 TEST 扩展出来的测试用例函数。由此，我们可以得出如下示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST(test_name, func_name) \</span></span><br><span class="line"><span class="keyword">void</span> test_name##_##func_name(); \</span><br><span class="line">__attribute__((constructor)) \</span><br><span class="line"><span class="keyword">void</span> register_##test_name##_##func_name() &#123; \</span><br><span class="line">    test_function_arr[test_function_cnt] = test_name##_##func_name; \</span><br><span class="line">    test_function_cnt++; \</span><br><span class="line">&#125; \</span><br><span class="line"><span class="keyword">void</span> test_name##_##func_name()</span><br></pre></td></tr></table></figure><p>这个新设计的 TEST 宏，除了末尾保留了原 TEST 宏内容以外，在扩展的测试用例函数头部添加了一段扩展内容，这段新添加的扩展内容，会扩展出来一个函数声明，以及一个以 register 开头的会在主函数执行之前执行的注册函数；注册函数内部的逻辑很简单，就是将测试函数的函数地址，存储在函数指针数组 test_function_arr 中，这部分区域中的数据，后续会被 RUN_ALL_TESTS 函数使用。</p><p>如果以如上 TEST 宏作为实现，原程序中的两个测试用例代码，会被展开成如下样子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1_test_is_prime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_test1_test_is_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test_function_arr[test_function_cnt] = test1_test_is_prime; </span><br><span class="line">    test_function_cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1_test_is_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">3</span>), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">5</span>), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">7</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2_test_is_prime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_test2_test_is_prime</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    test_function_arr[test_function_cnt] = test2_test_is_prime; </span><br><span class="line">    test_function_cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2_test_is_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">4</span>), <span class="number">0</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们就算是初步完成了测试框架中关键的两个部分的设计：一个是 TEST 宏，另外一个就是 RUN_ALL_TESTS 函数。它们同时也是串起测试框架流程最重要的两部分。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li><strong>attribute</strong>((constructor)) 可以修饰函数，使修饰的函数先于主函数执行。</li><li>RUN_ALL_TESTS 之所以可以获得程序中所有测试用例的函数信息，是因为有一批注册函数，将测试用例函数记录下来了。</li><li>通过测试框架这个项目，我们再一次看到，宏可以将原本看似不合理的代码，变得合理。</li></ul><p><a href="https://github.com/geektime-practice/mygtest" target="_blank" rel="noopener">项目地址</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Jul 31 2020 08:48:16 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;实现测试框架前的准备&quot;&gt;&lt;a href=&quot;#实现测试框架前的准备&quot; class=&quot;headerlink&quot; title=&quot;实现测试框架前的准备&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="编程入门" scheme="https://octopuslian.github.io/categories/%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="项目" scheme="https://octopuslian.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="框架" scheme="https://octopuslian.github.io/tags/%E6%A1%86%E6%9E%B6/"/>
    
      <category term="测试" scheme="https://octopuslian.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>

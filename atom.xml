<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>以写作调身心</title>
  
  <subtitle>熟能生巧，勤能补拙；念念不忘，必有回响。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://octopuslian.github.io/"/>
  <updated>2021-05-05T13:53:16.096Z</updated>
  <id>https://octopuslian.github.io/</id>
  
  <author>
    <name>Neo Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go进阶-网络编程</title>
    <link href="https://octopuslian.github.io/2021/05/05/goatc-9-network-programming-practice/"/>
    <id>https://octopuslian.github.io/2021/05/05/goatc-9-network-programming-practice/</id>
    <published>2021-05-05T14:00:45.000Z</published>
    <updated>2021-05-05T13:53:16.096Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --><h2 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h2><p>互联网的核心是一系列协议，总称为”互联网协议”（Internet Protocol Suite），正是这一些协议规定了电脑如何连接和组网。</p><p>主要协议分为：</p><ul><li>Socket：接口抽象层</li><li>TCP / UDP：面向连接(可靠) / 无连接(不可靠)</li><li>HTTP1.1 / HTTP2 / QUIC（HTTP3）：超文本传输协议</li></ul><h3 id="Socket-抽象层"><a href="#Socket-抽象层" class="headerlink" title="Socket 抽象层"></a>Socket 抽象层</h3><p>应用程序通常通过“套接字”向网络发出请求或者应答网络请求。</p><p>一种通用的面向流的网络接口</p><p>主要操作：</p><ul><li>建立、接受连接</li><li>读写、关闭、超时</li><li>获取地址、端口</li></ul><h3 id="TCP-可靠连接，面向连接的协议"><a href="#TCP-可靠连接，面向连接的协议" class="headerlink" title="TCP 可靠连接，面向连接的协议"></a>TCP 可靠连接，面向连接的协议</h3><p>TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一种面向连接（连接导向）的、可靠的、基于字节流的传输层（Transport layer）通信协议，因为是面向连接的协议。</p><p>服务端流程：</p><ul><li>监听端口</li><li>接收客户端请求建立连接</li><li>创建 goroutine 处理连接</li></ul><p>客户端流程：</p><ul><li>建立与服务端的连接</li><li>进行数据收发</li><li>关闭连接</li></ul><h3 id="UDP-不可靠连接，允许广播或多播"><a href="#UDP-不可靠连接，允许广播或多播" class="headerlink" title="UDP 不可靠连接，允许广播或多播"></a>UDP 不可靠连接，允许广播或多播</h3><p>UDP 协议（User Datagram Protocol）中文名称是用户数据报协议，是 OSI（Open System Interconnection，开放式系统互联）参考模型中一种无连接的传输层协议。</p><p>一个简单的传输层协议：</p><ul><li>不需要建立连接</li><li>不可靠的、没有时序的通信</li><li>数据报是有长度（65535-20=65515）</li><li>支持多播和广播</li><li>低延迟，实时性比较好</li><li>应用于用于视频直播、游戏同步</li></ul><h3 id="HTTP-超文本传输协议"><a href="#HTTP-超文本传输协议" class="headerlink" title="HTTP 超文本传输协议"></a>HTTP 超文本传输协议</h3><p>HTTP(HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议，它详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。</p><p>请求报文：</p><ul><li>Method: HEAD/GET/POST/PUT/DELETE</li><li>Accept：text/html、application/json</li><li>Content-Type:</li><li>application/json</li><li>application/x-www-form-urlencoded</li><li>请求正文</li></ul><p>响应报文：</p><ul><li>状态行(200/400/500)</li><li>响应头(Response Header)</li><li>响应正文</li></ul><h3 id="HTTP-超文本传输协议-演进"><a href="#HTTP-超文本传输协议-演进" class="headerlink" title="HTTP 超文本传输协议-演进"></a>HTTP 超文本传输协议-演进</h3><p>HTTP 发展史：</p><ul><li>1991 年发布初代 HTTP/0.9 版</li><li>1996 年发布 HTTP/1.0 版</li><li>1997 年是 HTTP/1.1 版，是到今天为止传输最广泛的版本</li><li>2015 年发布了 HTTP/2.0 版，优化了 HTTP/1.1 的性能和安全性</li><li>2018 年发布的 HTTP/3.0 版，使用 UDP 取代 TCP 协议</li></ul><p>HTTP2：<br>二进制分帧，按帧方式传输<br>多路复用，代替原来的序列和阻塞机制<br>头部压缩，通过 HPACK 压缩格式<br>服务器推送，服务端可以主动推送资源</p><p>HTTP3：<br>连接建立延时低，一次往返可建立HTTPS连接<br>改进的拥塞控制，高效的重传确认机制<br>切换网络保持连接，从4G切换到WIFI不用重建连接</p><h2 id="Go-网络编程基础"><a href="#Go-网络编程基础" class="headerlink" title="Go 网络编程基础"></a>Go 网络编程基础</h2><p>基础概念：</p><ul><li>Socket：数据传输</li><li>Encoding：内容编码</li><li>Session：连接会话状态</li><li>C/S模式：通过客户端实现双端通信</li><li>B/S模式：通过浏览器即可完成数据的传输</li></ul><p>简单例子<br>• 通过TCP/UDP实现网络通信</p><p>网络轮询器</p><ul><li>多路复用模型</li><li>多路复用模块</li><li>文件描述符</li><li>Goroutine 唤醒</li></ul><h3 id="TCP简单例子"><a href="#TCP简单例子" class="headerlink" title="TCP简单例子"></a>TCP简单例子</h3><h3 id="UDP简单例子"><a href="#UDP简单例子" class="headerlink" title="UDP简单例子"></a>UDP简单例子</h3><h3 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h3><p>Linux下主要的IO模型分为:</p><ul><li>Blocking IO - 阻塞IO</li><li>Nonblocking IO - 非阻塞IO</li><li>IO multiplexing - IO 多路复用</li><li>Signal-driven IO - 信号驱动式IO（异步阻塞）</li><li>Asynchronous IO - 异步IO</li></ul><p>同步：调用端会一直等待服务端响应，直到返回结果<br>异步：调用端发起调用之后不会立刻返回，不会等待服务端响应<br>阻塞：服务端返回结果之前，客户端线程会被挂起，此时线程不可被 CPU 调度，线程暂停运行<br>非阻塞：在服务端返回前，函数不会阻塞调用端线程，而会立刻返回</p><p><img src="/2021/05/05/goatc-9-network-programming-practice/io.png" alt></p><h3 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h3><p>Go 语言在采用 I/O 多路复用 模型处理 I/O 操作，但是他没有选择最常见的系统调用 select。虽然 select 也可以提供 I/O 多路复用的能力，但是使用它有比较多的限制：</p><ul><li>监听能力有限 — 最多只能监听 1024 个文件描述符；</li><li>内存拷贝开销大 — 需要维护一个较大的数据结构存储文件描述符，该结构需要拷贝到内核中；</li><li>时间复杂度 𝑂(𝑛) — 返回准备就绪的事件个数后，需要遍历所有的文件描述符；</li></ul><p>I/O多路复用：进程阻塞于 select，等待多个 IO 中的任一个变为可读，select调 用返回，通知相应 IO 可以读。 它可以支持单线程响应多个请求这种模式。</p><p><img src="/2021/05/05/goatc-9-network-programming-practice/iomm.png" alt></p><h3 id="多路复用模块"><a href="#多路复用模块" class="headerlink" title="多路复用模块"></a>多路复用模块</h3><p>为了提高 I/O 多路复用的性能<br>不同的操作系统也都实现了自己的 I/O 多路复用函数，例如：epoll、kqueue 和 evport 等<br>Go 语言为了提高在不同操作系统上的 I/O 操作性能，使用平台特定的函数实现了多个版本的网络轮询模块：</p><p>src/runtime/netpoll_epoll.go<br>src/runtime/netpoll_kqueue.go<br>src/runtime/netpoll_solaris.go<br>src/runtime/netpoll_windows.go<br>src/runtime/netpoll_aix.go<br>src/runtime/netpoll_fake.go</p><h2 id="Goim-长连接-TCP-编程"><a href="#Goim-长连接-TCP-编程" class="headerlink" title="Goim 长连接 TCP 编程"></a>Goim 长连接 TCP 编程</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul><li><p>Comet<br>长连接管理层，主要是监控外网 TCP/Websocket端口，并且通过设备 ID 进行绑定 Channel实 现，以及实现了 Room 合适直播等大房间消息广播。</p></li><li><p>Logic<br>逻辑层，监控连接 Connect、Disconnect 事件，可自定义鉴权，进行记录 Session 信息（设备 ID、ServerID、用户 ID），业务可通过设备 ID、用户 ID、RoomID、全局广播进行消息推送。</p></li><li><p>Job<br>通过消息队列的进行推送消峰处理，并把消息推送到对应 Comet 节点。</p></li></ul><p><strong>各个模块之间通过 gRPC 进行通信。</strong></p><p><img src="/2021/05/05/goatc-9-network-programming-practice/long-tcp-gai-lan.png" alt></p><h3 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h3><p>主要以包/针方式：<br>Package Length，包长度<br>Header Length，头长度<br>Protocol Version，协议版本<br>Operation，操作码<br>Sequence 请求序号 ID<br>Body，包内容</p><p>Operation:</p><ul><li>Auth</li><li>Heartbeat</li><li>Message</li></ul><p>Sequence</p><ul><li>按请求、响应对应递增 ID</li></ul><h3 id="边缘节点"><a href="#边缘节点" class="headerlink" title="边缘节点"></a>边缘节点</h3><p>Comet 长连接连续节点，通常部署在距离用户比较近，通过 TCP 或者 Websocket 建立连接，并且通过应用层 Heartbeat 进行保活检测，保证连接可用性。</p><p>节点之间通过云 VPC 专线通信，按地区部署分布。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>长连接负载均衡比较特殊，需要按一定的负载算法进行分配节点，可以通过 HTTPDNS 方式，请求获致到对应的节点 IP 列表，例如，返回固定数量 IP，按一定的权重或者最少连接数进行排序，客户端通过 IP 逐个重试连接；</p><ul><li>Comet 注册 IP 地址，以及节点权重，定时 Renew当前节点连接数量；</li><li>Balancer 按地区经纬度计算，按最近地区（经纬度）提供 Comet 节点 IP 列表，以及权重计算排序；</li><li>BFF 返回对应的长连接节点 IP，客户端可以通过 IP直接连；</li><li>客户端 按返回IP列表顺序，逐个连接尝试建立长连接</li></ul><h3 id="心跳保活机制"><a href="#心跳保活机制" class="headerlink" title="心跳保活机制"></a>心跳保活机制</h3><p>长连接断开的原因：<br>长连接所在进程被杀死<br>NAT 超时<br>网络状态发生变化，如移动网络 &amp; Wifi 切换、断开、重连<br>其他不可抗因素（网络状态差、DHCP 的租期等等 ）</p><p>高效维持长连接方案：<br>进程保活（防止进程被杀死）<br>心跳保活（阻止 NAT 超时）<br>断线重连（断网以后重新连接网络）</p><p>自适应心跳时间：<br>心跳可选区间，[min=60s，max=300s]<br>心跳增加步长，step=30s<br>心跳周期探测，success=current + step、fail=current - step</p><h3 id="用户鉴权和-Session-信息"><a href="#用户鉴权和-Session-信息" class="headerlink" title="用户鉴权和 Session 信息"></a>用户鉴权和 Session 信息</h3><p>用户鉴权，在长连接建立成功后，需要先进行连接鉴权，并且绑定对应的会话信息；</p><p>Connect，建立连接进行鉴权，保存Session信息：</p><ul><li>DeviceID，设备唯一 ID</li><li>Token，用户鉴权 Token，认证得到用户 ID</li><li>CometID，连接所在 comet 节点</li></ul><p>Disconnect，断开连接，删除对应Session信息：</p><ul><li>DeviceID，设备唯一 ID</li><li>CometID，连接所在 Comet 节点</li><li>UserID，用户 ID</li></ul><p>Session，会话信息通过Redis保存连接路由信息：</p><ul><li>连接维度，通过 设备 ID 找到所在 Comet 节点</li><li>用户维度，通过 用户 ID 找到对应的连接和 Comet所在节点</li></ul><h3 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h3><p>Comet 长连接层，实现连接管理和消息推送：</p><p>Protocol，TCP/Websocket 协议监听；</p><ul><li>Packet，长连接消息包，每个包都有固定长度；</li><li>Channel，消息管道相当于每个连接抽象，最终TCP/Websocket 中的封装，进行消息包的读写分发；</li><li>Bucket，连接通过 DeviceID 进行管理，用于读写锁拆散，并且实现房间消息推送，类似 Nginx Worker；</li><li>Room，房间管理通过 RoomID 进行管理，通过链表进行Channel遍历推送消息；</li></ul><p>每个 Bucket 都有独立的 Goroutine 和读写锁优化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Buckets &#123;  channels <span class="keyword">map</span>[<span class="keyword">string</span>]*Channel</span><br><span class="line">  rooms <span class="keyword">map</span>[<span class="keyword">string</span>]*Room&#125;</span><br></pre></td></tr></table></figure><h3 id="Logic"><a href="#Logic" class="headerlink" title="Logic"></a>Logic</h3><p>Logic 业务逻辑层，处理连接鉴权、消息路由，用户会话管理；</p><p>主要分为三层：</p><ul><li>sdk，通过 TCP/Websocket 建立长连接，进行重连、心跳保活；</li><li>goim，主要负责连接管理，提供消息长连能力；</li><li>backend，处理业务逻辑，对推送消息过虑，以及持久化相关等；</li></ul><h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>业务通过对应的推送方式，可以对连接设备、房间、用户ID进行推送，通过Session信息定位到所在的Comet连接节点，并通过Job推送消息；</p><p>通过Kafka进行推送消峰，保证消息逐步推送成功；</p><p>支持的多种推送方式：</p><ul><li>Push(DeviceID, Message)</li><li>Push(UserID, Message)</li><li>Push(RoomID, Message)</li><li>Push(Message)</li></ul><h3 id="推拉结合"><a href="#推拉结合" class="headerlink" title="推拉结合"></a>推拉结合</h3><p>在长连接中，如果想把消息通知所有人，主要有两种模式：一种是自己拿广播通知所有人，这叫“推”模式；一种是有人主动来找你要，这叫“拉”模式。；</p><p>在业务系统中，通常会有三种可能的做法：</p><ul><li>推模式，有新消息时服务器主动推给客户端；</li><li>拉模式，由前端主动发起拉取消息的请求；</li><li>推拉结合模式，有新消息实时通知，客户端再进行新的消息摘取；</li></ul><h3 id="读写扩散"><a href="#读写扩散" class="headerlink" title="读写扩散"></a>读写扩散</h3><p>一般消息系统中，通常会比较关注消息存储；<br>主要进行考虑“读”、“写”扩散，也就是性能问题；<br>在不同场景，可能选择不同的方式：</p><p>读扩散，在IM系统里的读扩散通常是每两个相关联的人就有一个信箱，或者每个群一个信箱。<br>优点：写操作（发消息）很轻量，只用写自己信箱<br>缺点：读操作（读消息）很重，需要读所有人信箱<br>写扩散，每个人都只从自己的信箱里读取消息，但写（发消息）的时候需要所有人写一份<br>优点：读操作很轻量<br>缺点：写操作很重，尤其是对于群聊来说</p><h3 id="唯一-ID-设计"><a href="#唯一-ID-设计" class="headerlink" title="唯一 ID 设计"></a>唯一 ID 设计</h3><p>唯一 ID，需要保证全局唯一，绝对不会出现重复的 ID，且 ID 整体趋势递增。<br>通常情况下，ID 的设计主要有以下几大类：</p><ul><li>UUID</li><li>基于 Snowflake 的 ID 生成方式</li><li>基于申请 DB 步长的生成方式</li><li>基于 Redis 或者 DB 的自增 ID生成方式</li><li>特殊的规则生成唯一 ID</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/" target="_blank" rel="noopener">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/</a><br><a href="https://www.liwenzhou.com/posts/Go/15_socket/" target="_blank" rel="noopener">https://www.liwenzhou.com/posts/Go/15_socket/</a><br><a href="https://hit-alibaba.github.io/interview/basic/network/HTTP.html" target="_blank" rel="noopener">https://hit-alibaba.github.io/interview/basic/network/HTTP.html</a><br><a href="https://cloud.tencent.com/developer/article/1030660" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1030660</a><br><a href="https://juejin.cn/post/6844903827536117774" target="_blank" rel="noopener">https://juejin.cn/post/6844903827536117774</a><br><a href="https://xie.infoq.cn/article/19e95a78e2f5389588debfb1c" target="_blank" rel="noopener">https://xie.infoq.cn/article/19e95a78e2f5389588debfb1c</a><br><a href="https://tech.meituan.com/2019/03/07/open-source-project-leaf.html" target="_blank" rel="noopener">https://tech.meituan.com/2019/03/07/open-source-project-leaf.html</a><br><a href="https://mp.weixin.qq.com/s/8WmASie_DjDDMQRdQi1FDg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/8WmASie_DjDDMQRdQi1FDg</a><br><a href="https://www.imooc.com/article/265871" target="_blank" rel="noopener">https://www.imooc.com/article/265871</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;网络通信协议&quot;&gt;&lt;a href=&quot;#网络通信协议&quot; class=&quot;headerlink&quot; title=&quot;网络通信协议&quot;&gt;&lt;/a&gt;网络通
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="golang" scheme="https://octopuslian.github.io/tags/golang/"/>
    
      <category term="网络编程" scheme="https://octopuslian.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-播放历史架构设计</title>
    <link href="https://octopuslian.github.io/2021/05/05/goatc-7-play-history-architecture-design/"/>
    <id>https://octopuslian.github.io/2021/05/05/goatc-7-play-history-architecture-design/</id>
    <published>2021-05-05T13:05:21.000Z</published>
    <updated>2021-05-05T13:32:19.163Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --><h2 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h2><p>为了大部分用户的基本功能体验，满足用户需求，例如播放历史查看、播放进度同步等。离线型用户，app 本地保留历史记录数据。<br>同样的，也要考虑平台化，视频、文章、漫画等业务扩展接入。</p><ul><li>变更功能：添加记录、删除记录、清空历史。</li><li>读取功能：按照 timeline 返回 top N，点查获取进度信息。</li><li>其他功能：暂停/恢复记录，首次观察增加经验等。</li></ul><p><strong>历史记录类型的业务，是一个极高 tps 写入，高 qps 读取的业务服务。分析清楚系统的 hot path，投入优化，而不是哪哪都去优化。</strong></p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul><li><p>BFF: app-interface、history<br>历史 BFF 层接受来自外部用户的读请求，依赖其他例如稿件、漫画服务来组装完整的面向历史业务（页面）需要的数据的组合。同时接受来自内部其他业务线的写请求，通常都是业务方自己进行业务 ID 的判定，然后投递到历史服务的 BFF 写接口中。最终 BFF 是打包在 app-interface 大杂烩 BFF 中，考虑到隔离性，读写流量很大，独立成 history BFF 服务。</p></li><li><p>Service: history-service<br>服务层，去平台业务的逻辑，专注在历史数据的持久化上(因为对于播放类业务，BFF 专注平台业务数据组织，service 负责数据的读、写、删、清理等操作。播放进度是非常高频同步的，需要考虑性能优化)。</p></li></ul><p><strong>使用 write-back 的思路，把状态数据先入分布式缓存，再回写数据库。</strong></p><ul><li><p>Job: history-job<br>job 消费上游 kafka 的数据，利用消息队列的堆积能力，对于存储层的差速(消费能力跟不上生产速度时)，可以进行一定的数据反压。配合上游 service 批量打包过来的数据持久化。</p></li><li><p>Upstream: some-app，some-api<br>整个历史服务还会被一些外部 gRPC 服务所依赖，所以 history 还充当了内网的 gRPC Provider，这些上游服务，使用历史服务的写接口，把自己业务的数据进行持久化。</p></li></ul><p><strong>历史服务最重要的设计，就是批量打包(pipeline)聚合数据。将高频、密集的写请求先入缓存(write-back)，批量消费减少对存储的直接压力，类似的设计随处可见。</strong></p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/gai-lan.png" alt></p><h3 id="history-service"><a href="#history-service" class="headerlink" title="history service"></a>history service</h3><p>专注在历史数据处理。</p><p>写的核心逻辑:<br>用户观看的稿件、漫画等，带有进度信息的数据，同一个 id 最后一次的数据即可，即 last-write win，高频的用户端同步逻辑，只需要最后一次数据持久化即可。我们可以在 in-process 内存中，定时定量来聚合不同用户的“同一个对象的最后一次进度”，使用 kafka 消息队列来消除写入峰值。但同时我们需要保证用户数据可以实时被观察到，不能出现上报进度后，需要一阵子才能体现进度变化。所以我们即在内存中打包数据，同时实时写入到 redis 中，这样即保证了实时，又避免海量写入冲击存储。</p><p>kafka 是为高吞吐设计，超高频的写入并不是最优，所以内存聚合和分片算法比较重要，按照 uid 来sharding 数据，写放大仍然很大，这里我们使用 region sharding，打包一组数据当作一个 kafka message(比如 uid % 100数据打包)。</p><p>写逻辑的数据流向: 实时写 redis -&gt; 内存维护用户数据 -&gt; 定时/定量写入到 kafka。</p><p>读的核心逻辑:<br>历史数据，实时写入 redis 后，不会无限制的存储，会按量截断，所以分布式缓存中数据不是完整数据，历史数据从 redis sortedset 中读取后，如果发现尾部数据不足，会触发 cache-aside 模式，从存储中回捞数据，但是不会重新回填缓存，因为拉取过去更久远的数据，属于用户纬度的低频度行为。历史数据通常是按照 timeline 来组织，游标的 key 可以使用时间戳进行翻页或者下拉。</p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/history-service.png" alt></p><h3 id="history-job"><a href="#history-job" class="headerlink" title="history job"></a>history job</h3><p>获取打包好的用户数据，进行批量持久化。</p><p>上游 history-service 按照 uid region sharding 聚合好的数据，在 job 中消费取出，为了节约传输过程，以及 history-service 的 in-process cache 的内存使用，我们只维护了用户的 uid 以及 id 列表，最小化存储和传输。因为数据是不完整的，我们额外需要从 redis 中按照 id 对应的数据内容，再持久化。从原来的 N 条记录变为一个用户一条记录。</p><p>对于存储的选型，我们认为 HBase 非常合适高密度写入。后续我们会单独讨论我们经历过的几次存储迭代和选型。</p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/history-job.png" alt></p><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>history 作为 BFF，对用户端提供统一的用户记录记录入口接口，同时也对内提供 gRPC 写入历史接口。如果业务场景中不存在统一的用户入口访问历史记录，可以去掉 BFF 层，直接使用 history-service 提供读接口，这样需要每个业务方自己实现自己的数据组装。</p><p>我们也有类似用户首次播放、观看等加经验或者奖励积分类似的操作，所以我们这里依赖 redis，进行判定用户当天是否是首次访问，我们比较容易想到使用 bitmap 或者 bloom filter 来进行判断，然后往下游 kafka 投递消息，而不直接依赖业务的某个服务。</p><p>Q：因为我们有关闭历史记录的功能，这样每次写入操作都需要前置读取一次，是否打开了开关，同样的每次首次发送奖励也是一样，你有更好的办法吗？</p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/history.png" alt></p><h2 id="存储设计"><a href="#存储设计" class="headerlink" title="存储设计"></a>存储设计</h2><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p>我们最早的主力存储选型是: HBase。</p><p>数据写入: PUT mid, values，只需要写入到 column_family 的 info 列簇，rowkey 使用用户 id md5 以后的头两位 + 用户，避免 rowkey 热点密集到一个 region 中，导致写/读热点。 对于 column_family: info，存储一个列 obj_id + obj_type，例如 稿件业务:1、稿件ID: 100，100_1 作为列名，对于 value 使用 protobuf 序列化一个结构体接入。所以只需要单次更新 kv store。另外我们使用 HBase TTL 的能力，只需要保存90天的用户数据即可。(删除同理)</p><p>数据读取: 列表获取为 GET mid，直接获取1000条，在内存中排序和翻页。点查 GET mid columns，在茫茫多视频查看当前视频的阅读进度，cache miss 会非常严重，虽然支持点查，但是对于上层 cache miss 后，不再回源请求 HBase。</p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/database-design.png" alt></p><h3 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h3><p>数据写入: 每次产生的历史数据，需要立马更新 redis，使用 sorted set 基于时间排序的列表，member 为业务 ID。同时存储一份数据到 redis string 中，使用 protobuf 序列化完整的数据内容。为了避免 redis 中单个用户数据无限增长，需要超过一定量后对数据进行截断。<br>数据读取: 分为两个场景，一个是历史页面，这时候使用 sorted set，排序查找即可，拿到列表后，mget 批量获取history_content 内容。<br>另外一个是点查进度，比如我们点击进入一个视频详情页，这时候直接查找 history_content 进行点查，不再回源 HBase，因为命中率太低。</p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/cache-design.png" alt></p><p>首次触发某行为，增加经验的，我们在缓存设计中，经常使用 bitmap(roaring bitmap)、bloom filter 缓存加速访问，但是在使用缓存时，需要注意规避热点问题，某个key sharding 命中 node 是固定的，因此我们可以利用构建多组 bitmap 或 bloom filter，来进行打散。</p><p>prefix_key = hash(mid) % 1000</p><p>根据 prefix_key 找到对应的 cache 再进行操作，这样 1000 个 key 尽可能均匀的分布到更小集合的 node，而不会产生数据热点。</p><p>Q：但是仍然每次触发行为，都为前置判定，有更好的优化方案吗？</p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/cache-design2.png" alt></p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/cache-design3.png" alt></p><h2 id="可用性设计"><a href="#可用性设计" class="headerlink" title="可用性设计"></a>可用性设计</h2><h3 id="Write-Back"><a href="#Write-Back" class="headerlink" title="Write Back"></a>Write Back</h3><p>在 history-service 中实时写入 redis 数据，因此只需要重点优化缓存架构中，扛住峰值的流量写入。之后在服务内存中，使用 map[int]map[int]struct{} 聚合数据，之后利用 chan 在内部发送每个小消息，再聚合成一个大map，在 sendproc 中，使用 timer 和 定量判定逻辑，发送到下游 kafka 中。</p><p>在 history-job 中，获取消息后，重新去 redis 中回捞数据即: history-content，然后构建完整的数据批量写入到 HBase 中。</p><p>这里存在两个风险:<br>1、history-service 重启过程中，预聚合的消息丢失；<br>2、history-job 读取 redis 构建数据，但 redis 丢失；</p><p><strong>我们在这里进行了 trade-off，高收敛比的设计，意味着存在数据丢失的风险，对于历史场景，非 L0 的业务服务/数据，我们认为极端情况下可接受。</strong></p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/wb.png" alt></p><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>经过 BFF history 的流量 per-request 都会发送给 history-service，我们最容易想到的优化就是聚合上移来减少发送给下游的 rpc。但是按照 mid region sharding 的思路非常具有业务的耦合性，所以不应该把逻辑上移，而只是数据上移，所以可以考虑简单 batch put 请求，做一个无逻辑的数据聚合再发送给 history-service，这样可以大大的减少内网的流量，节约资源。</p><p>我们发现经过 API Gateway 的流量都会触发高频的 per-rpc auth，给内网的 identify-service 带来了不少压力。我们认为大部分历史行为通过心跳的方式同步进度，为何不连接一个长连接，长连接服务再握手后先进行用户级的身份验证，之后维持身份信息，而不是每次发送 request 都进行验证，这样可以大大减少内网的 identify-service 的流量。</p><p>我们内网使用 boardcast(goim) 服务维护长连接，长连接一次验证，不断使用。</p><h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>用户首次触发的行为，需要发送消息给下游系统进行触发其他奖励等。如何减少这类一天只用一次的标记位缓存请求？</p><p>使用 in-process localcache，只有高频的用户访问，带来的收益就越大，我们很容易想到使用 LRU 维护这个集合，但用户分布很广，很难覆盖，命中率很低。</p><p>越源头解决架构问题，通常越简单，效率越高。</p><p>我们在写操作(高频请求)中，把当前的 flag 返回到 API 协议中，作为一个日期值，客户端保存到本地，下次请求的时候带上，如果发现该值在，获取以后直接使用不再请求缓存，例如: 2021-1-1，发现当前时间还是2021-1-1，直接不再请求 redis，如果发现当前时间是2021-1-2，需要触发一次 redis 访问，返回新的 flag 到客户端，这样把状态广播同步到任何其他设备，可以大大减少判定缓存。</p><p>实现成本在于，你认为的代价高低。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://en.wikipedia.org/wiki/Cache#Writing_Policies" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Cache#Writing_Policies</a><br><a href="https://blog.csdn.net/jiaomeng/article/details/1495500" target="_blank" rel="noopener">https://blog.csdn.net/jiaomeng/article/details/1495500</a><br><a href="https://blog.csdn.net/yizishou/article/details/78342499" target="_blank" rel="noopener">https://blog.csdn.net/yizishou/article/details/78342499</a><br><a href="https://blog.csdn.net/caoshangpa/article/details/78783749" target="_blank" rel="noopener">https://blog.csdn.net/caoshangpa/article/details/78783749</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;功能模块&quot;&gt;&lt;a href=&quot;#功能模块&quot; class=&quot;headerlink&quot; title=&quot;功能模块&quot;&gt;&lt;/a&gt;功能模块&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="架构设计" scheme="https://octopuslian.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="golang" scheme="https://octopuslian.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-微服务可用性设计</title>
    <link href="https://octopuslian.github.io/2021/05/05/goatc-5-microservice-availability-design/"/>
    <id>https://octopuslian.github.io/2021/05/05/goatc-5-microservice-availability-design/</id>
    <published>2021-05-05T04:43:20.000Z</published>
    <updated>2021-05-05T12:43:22.864Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --><h2 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h2><p>隔离，本质上是对系统或资源进行分割，从而实现当系统发生故障时能限定传播范围和影响范围，即发生故障后只有出问题的服务不可用，保证其他服务仍然可用。</p><p>服务隔离：动静分离、读写分离<br>轻重隔离：核心、快慢、热点<br>物理隔离:线程、进程、集群、机房</p><h3 id="服务隔离"><a href="#服务隔离" class="headerlink" title="服务隔离"></a>服务隔离</h3><h4 id="动静隔离"><a href="#动静隔离" class="headerlink" title="动静隔离:"></a>动静隔离:</h4><p>小到 CPU 的 cacheline false sharing、数据库 mysql 表设计中避免 bufferpool 频繁过期，隔离动静表，大到架构设计中的图片、静态资源等缓存加速。本质上都体现的一样的思路，即加速/缓存访问变换频次小的。比如 CDN 场景中，将静态资源和动态 API 分离，也是体现了隔离的思路:</p><ul><li>降低应用服务器负载，静态文件访问负载全部通过CDN。</li><li>对象存储存储费用最低。</li><li>海量存储空间，无需考虑存储架构升级。</li><li>静态CDN带宽加速，延迟低。</li></ul><h4 id="读写分离：主从、Replicaset、CQRS。"><a href="#读写分离：主从、Replicaset、CQRS。" class="headerlink" title="读写分离：主从、Replicaset、CQRS。"></a>读写分离：主从、Replicaset、CQRS。</h4><h3 id="轻重隔离"><a href="#轻重隔离" class="headerlink" title="轻重隔离"></a>轻重隔离</h3><h4 id="核心隔离"><a href="#核心隔离" class="headerlink" title="核心隔离"></a>核心隔离</h4><p>业务按照 Level 进行资源池划分(L0/L1/L2)。</p><ul><li>核心/非核心的故障域的差异隔离(机器资源、依赖资源)。</li><li>多集群，通过冗余资源来提升吞吐和容灾能力。</li></ul><h4 id="快慢隔离"><a href="#快慢隔离" class="headerlink" title="快慢隔离"></a>快慢隔离</h4><p>我们可以把服务的吞吐想象为一个池，当突然洪流进来时，池子需要一定时间才能排放完，这时候其他支流在池子里待的时间取决于前面的排放能力，耗时就会增高，对小请求产生影响。</p><p>日志传输体系的架构设计中，整个流都会投放到一个 kafka topic 中(早期设计目的: 更好的顺序IO)，流内会区分不同的 logid，logid 会有不同的 sink 端，它们之前会出现差速，比如 HDFS 抖动吞吐下降，ES 正常水位，全局数据就会整体反压。</p><ul><li>按照各种纬度隔离：sink、部门、业务、logid、重要性(S/A/B/C)。</li></ul><p>业务日志也属于某个 logid，日志等级就可以作为隔离通道。</p><h4 id="热点隔离"><a href="#热点隔离" class="headerlink" title="热点隔离"></a>热点隔离</h4><p>何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行缓存。比如：</p><ul><li>小表广播: 从 remotecache 提升为 localcache，app 定时更新，甚至可以让运营平台支持广播刷新 localcache。</li><li>主动预热: 比如直播房间页高在线情况下bypass 监控主动防御。</li></ul><h3 id="物理隔离"><a href="#物理隔离" class="headerlink" title="物理隔离"></a>物理隔离</h3><h4 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h4><p>主要通过线程池进行隔离，也是实现服务隔离的基础。把业务进行分类并交给不同的线程池进行处理，当某个线程池处理一种业务请求发生问题时，不会讲故障扩散和影响到其他线程池，保证服务可用。</p><p>对于 Go 来说，所有 IO 都是 Nonblocking，且托管给了 Runtime，只会阻塞Goroutine，不阻塞 M，我们只需要考虑 Goroutine 总量的控制，不需要线程模型语言的线程隔离。</p><h4 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h4><p>容器化(docker)，容器编排引擎(k8s)。</p><h4 id="集群隔离"><a href="#集群隔离" class="headerlink" title="集群隔离"></a>集群隔离</h4><p>逻辑上是一个应用，物理上部署多套应用，通过 cluster 区分。</p><h3 id="Case-Stduy"><a href="#Case-Stduy" class="headerlink" title="Case Stduy"></a>Case Stduy</h3><ul><li>早期转码集群被超大视频攻击，导致转码大量延迟。</li><li>入口Nginx(SLB)故障，影响全机房流量入口故障。</li><li>缩略图服务，被大图实时缩略吃完所有 CPU，导致正常的小图缩略被丢弃，大量503。</li><li>数据库实例 cgroup 未隔离，导致大 SQL 引起的集体故障。</li><li>INFO 日志量过大，导致异常 ERROR 日志采集延迟。</li></ul><h2 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h2><p>超时控制，我们的组件能够快速失效(fail fast)，因为我们不希望等到断开的实例直到超时。没有什么比挂起的请求和无响应的界面更令人失望。这不仅浪费资源，而且还会让用户体验变得更差。我们的服务是互相调用的，所以在这些延迟叠加前，应该特别注意防止那些超时的操作。</p><ul><li>网路传递具有不确定性。</li><li>客户端和服务端不一致的超时策略导致资源浪费。</li><li>“默认值”策略。</li><li>高延迟服务导致 client 浪费资源等待，使用超时传递: 进程间传递 + 跨进程传递。</li></ul><h3 id="Case-Stduy-1"><a href="#Case-Stduy-1" class="headerlink" title="Case Stduy"></a>Case Stduy</h3><ul><li>SLB 入口 Nginx 没配置超时导致连锁故障。</li><li>服务依赖的 DB 连接池漏配超时，导致请求阻塞，最终服务集体 OOM。</li><li>下游服务发版耗时增加，而上游服务配置超时过短，导致上游请求失败。</li></ul><h2 id="过载保护"><a href="#过载保护" class="headerlink" title="过载保护"></a>过载保护</h2><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。令牌桶算法的描述如下：</p><ul><li>假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌。</li><li>桶中最多存放 b 个令牌，当桶满时，新添加的令牌被丢弃或拒绝。</li><li>当一个 n 个字节大小的数据包到达，将从桶中删除n 个令牌，接着数据包被发送到网络上。</li><li>如果桶中的令牌不足 n 个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。</li></ul><h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>作为计量工具(The Leaky Bucket Algorithm as a Meter)时，可以用于流量整形(Traffic Shaping)和流量控制(TrafficPolicing)，漏桶算法的描述如下：</p><ul><li>一个固定容量的漏桶，按照常量固定速率流出水滴。</li><li>如果桶是空的，则不需流出水滴。</li><li>可以以任意速率流入水滴到漏桶。</li><li>如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的。</li></ul><h3 id="如何计算接近峰值时的系统吞吐？"><a href="#如何计算接近峰值时的系统吞吐？" class="headerlink" title="如何计算接近峰值时的系统吞吐？"></a>如何计算接近峰值时的系统吞吐？</h3><ul><li>CPU: 使用一个独立的线程采样，每隔 250ms 触发一次。在计算均值时，使用了简单滑动平均去除峰值的影响。</li><li>Inflight: 当前服务中正在进行的请求的数量。</li><li>Pass&amp;RT: 最近5s，pass 为每100ms采样窗口内成功请求的数量，rt 为单个采样窗口中平均响应时间。</li></ul><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>限流是指在一段时间内，定义某个客户或应用可以接收或处理多少个请求的技术。例如，通过限流，你可以过滤掉产生流量峰值的客户和微服务，或者可以确保你的应用程序在自动扩展(Auto Scaling)失效前都不会出现过载的情况。</p><ul><li>令牌桶、漏桶 针对单个节点，无法分布式限流。</li><li>QPS 限流</li><li>不同的请求可能需要数量迥异的资源来处理。</li><li>某种静态 QPS 限流不是特别准。</li></ul><p>给每个用户设置限制</p><ul><li>全局过载发生时候，针对某些“异常”进行控制。</li><li>一定程度的“超卖”配额。</li><li>按照优先级丢弃。</li><li>拒绝请求也需要成本。</li></ul><h3 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h3><p>分布式限流，是为了控制某个应用全局的流量，而非真对单个节点纬度。</p><ul><li>单个大流量的接口，使用 redis 容易产生热点。</li><li>pre-request 模式对性能有一定影响，高频的网络往返。</li></ul><p>Q：如何来分配资源？<br>A：“最大最小公平分享”(Max-Min Fairness)。</p><p>最大最小公平分配算法的形式化定义如下：</p><ul><li>资源按照需求递增的顺序进行分配。</li><li>不存在用户得到的资源超过自己的需求。</li><li>未得到满足的用户等价的分享资源。</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><a href="./goatc-5-microservice-availability-design/fen-bu-shi-xian-liu.png"></a></p><h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>每个接口配置阈值，运营工作繁重，最简单的我们配置服务级别 quota，更细粒度的，我们可以根据不同重要性设定 quota，我们引入了重要性(criticality):</p><ul><li>最重要 CRITICAL_PLUS，为最终的要求预留的类型，拒绝这些请求会造成非常严重的用户可见的问题。</li><li>重要 CRITICAL，生产任务发出的默认请求类型。拒绝这些请求也会造成用户可见的问题。但是可能没那么严重。</li><li>可丢弃的 SHEDDABLE_PLUS 这些流量可以容忍某种程度的不可用性。这是批量任务发出的请求的默认值。这些请求通常可以过几分钟、几小时后重试。</li><li>可丢弃的 SHEDDABLE 这些流量可能会经常遇到部分不可用情况，偶尔会完全不可用。</li></ul><p>gRPC 系统之间，需要自动传递重要性信息。如果后端接受到请求 A，在处理过程中发出了请求 B 和 C 给其他后端，请求 B 和 C 会使用与 A 相同的重要性属性。</p><ul><li>全局配额不足时，优先拒绝低优先级的。</li><li>全局配额，可以按照重要性分别设置。</li><li>过载保护时，低优先级的请求先被拒绝。</li></ul><h3 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h3><p>断路器(Circuit Breakers): 为了限制操作的持续时间，我们可以使用超时，超时可以防止挂起操作并保证系统可以响应。因为我们处于高度动态的环境中，几乎不可能确定在每种情况下都能正常工作的准确的时间限制。断路器以现实世界的电子元件命名，因为它们的行为是都是相同的。断路器在分布式系统中非常有用，因为重复的故障可能会导致雪球效应，并使整个系统崩溃。</p><ul><li>服务依赖的资源出现大量错误。</li><li>某个用户超过资源配额时，后端任务会快速拒绝请求，返回“配额不足”的错误，但是拒绝回复仍然会消耗一定资源。有可能后端忙着不停发送拒绝请求，导致过载。</li></ul><h3 id="Gutter"><a href="#Gutter" class="headerlink" title="Gutter"></a>Gutter</h3><p>基于熔断的 gutter kafka ，用于接管自动修复系统运行过程中的负载，这样只需要付出10%的资源就能解决部分系统可用性问题。</p><p>我们经常使用 failover 的思路，但是完整的 failover 需要翻倍的机器资源，平常不接受流量时，资源浪费。高负载情况下接管流量又不一定完整能接住。所以这里核心利用熔断的思路，是把抛弃的流量转移到 gutter 集群，如果 gutter 也接受不住的流量，重新回抛到主集群，最大力度来接受。</p><h3 id="客户端流控"><a href="#客户端流控" class="headerlink" title="客户端流控"></a>客户端流控</h3><p>positive feedback: 用户总是积极重试，访问一个不可达的服务。</p><ul><li>客户端需要限制请求频次，retry backoff 做一定的请求退让。</li><li>可以通过接口级别的error_details，挂载到每个 API 返回的响应里。</li></ul><h3 id="Case-Study"><a href="#Case-Study" class="headerlink" title="Case Study"></a>Case Study</h3><ul><li><p>二层缓存穿透、大量回源导致的核心服务故障。</p></li><li><p>异常客户端引起的服务故障(query of death)<br>(1)请求放大。<br>(2)资源数放大。</p></li><li><p>用户重试导致的大面积故障。</p></li></ul><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>通过降级回复来减少工作量，或者丢弃不重要的请求。而且需要了解哪些流量可以降级，并且有能力区分不同的请求。我们通常提供降低回复的质量来答复减少所需的计算量或者时间。我们自动降级通常需要考虑几个点：</p><ul><li>确定具体采用哪个指标作为流量评估和优雅降级的决定性指标(如，CPU、延迟、队列长度、线程数量、错误等)。</li><li>当服务进入降级模式时，需要执行什么动作？</li><li>流量抛弃或者优雅降级应该在服务的哪一层实现？是否需要在整个服务的每一层都实现，还是可以选择某个高层面的关键节点来实现？</li></ul><p>同时我们要考虑一下几点：</p><ul><li>优雅降级不应该被经常触发 - 通常触发条件现实了容量规划的失误，或者是意外的负载。</li><li>演练，代码平时不会触发和使用，需要定期针对一小部分的流量进行演练，保证模式的正常。</li><li>应该足够简单。</li></ul><p>降级本质为: <strong>提供有损服务。</strong></p><ul><li><p>UI 模块化，非核心模块降级。<br>BFF 层聚合 API，模块降级。</p></li><li><p>页面上一次缓存副本。</p></li><li><p>默认值、热门推荐等。</p></li><li><p>流量拦截 + 定期数据缓存(过期副本策略)。</p></li><li><p>处理策略<br>页面降级、延迟服务、写/读降级、缓存降级<br>抛异常、返回约定协议、Mock 数据、Fallback 处理</p></li></ul><h3 id="Case-Study-1"><a href="#Case-Study-1" class="headerlink" title="Case Study"></a>Case Study</h3><ul><li>客户端解析协议失败，app 奔溃。</li><li>客户端部分协议不兼容，导致页面失败。</li><li>local cache 数据源缓存，发版失效 + 依赖接口故障，引起的白屏。</li><li>没有 playbook，导致的 MTTR 上升。</li></ul><h2 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h2><p>当请求返回错误(例: 配额不足、超时、内部错误等)，对于 backend 部分节点过载的情况下，倾向于立刻重试，但是需要留意重试带来的流量放大:</p><ul><li>限制重试次数和基于重试分布的策略(重试比率: 10%)。</li><li>随机化、指数型递增的重试周期: exponential ackoff + jitter。</li><li>client 测记录重试次数直方图，传递到 server，进行分布判定，交由 server 判定拒绝。</li><li>只应该在失败的这层进行重试，当重试仍然失败，全局约定错误码“过载，无须重试”，避免级联重试。</li></ul><h3 id="Case-Study-2"><a href="#Case-Study-2" class="headerlink" title="Case Study"></a>Case Study</h3><ul><li><p>Nginx upstream retry 过大，导致服务雪崩。</p></li><li><p>业务不幂等，导致的重试，数据重复。<br>(1)全局唯一 ID: 根据业务生成一个全局唯一 ID，在调用接口时会传入该 ID，接口提供方会从相应的存储系统比如 redis 中去检索这个全局 ID 是否存在，如果存在则说明该操作已经执行过了，将拒绝本次服务请求；否则将相应该服务请求并将全局 ID 存入存储系统中,之后包含相同业务 ID 参数的请求将被拒绝。<br>(2)去重表: 这种方法适用于在业务中有唯一标识的插入场景。比如在支付场景中，一个订单只会支付一次，可以建立一张去重表,将订单 ID 作为唯一索引。把支付并且写入支付单据到去重表放入一个事务中了，这样当出现重复支付时，数据库就会抛出唯一约束异常,操作就会回滚。这样保证了订单只会被支付一次。<br>(3)多版本并发控制: 适合对更新请求作幂等性控制,比如要更新商品的名字，这是就可以在更新的接口中增加一个版本号来做幂等性控制。</p></li><li><p>多层级重试传递，放大流量引起雪崩。</p></li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>数据中心内部的负载均衡</p><p>在理想情况下，某个服务的负载会完全均匀地分发给所有的后端任务。在任何时刻，最忙和最不忙的节点永远消耗同样数量的CPU。</p><p>目标：</p><ul><li>均衡的流量分发。</li><li>可靠的识别异常节点。</li><li>scale-out，增加同质节点扩容。</li><li>减少错误，提高可用性。</li></ul><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul><li>变更管理:<br>70％的问题是由变更引起的，恢复可用代码并不总是坏事。</li><li>避免过载:<br>过载保护、流量调度等。</li><li>依赖管理:<br>任何依赖都可能故障，做 chaos monkey testing，注入故障测试。</li><li>优雅降级:<br>有损服务，避免核心链路依赖故障。</li><li>重试退避:<br>退让算法，冻结时间，API retry detail 控制策略。</li><li>超时控制:<br>进程内 + 服务间 超时控制。</li><li>极限压测 + 故障演练。</li><li>扩容 + 重启 + 消除有害流量。</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="http://www.360doc.com/content/16/1124/21/31263000_609259745.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/16/1124/21/31263000_609259745.shtml</a><br><a href="http://www.infoq.com/cn/articles/basis-frameworkto-implement-micro-service/" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/basis-frameworkto-implement-micro-service/</a><br><a href="http://www.infoq.com/cn/news/2017/04/linkerd-celebrates-one-year" target="_blank" rel="noopener">http://www.infoq.com/cn/news/2017/04/linkerd-celebrates-one-year</a><br><a href="https://medium.com/netflix-techblog/netflix-edge-load-balancing-695308b5548c" target="_blank" rel="noopener">https://medium.com/netflix-techblog/netflix-edge-load-balancing-695308b5548c</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAwNjQwNzU2NQ==&amp;mid=402841629&amp;idx=1&amp;sn=f598fec9b370b8a6f2062233b31122e0&amp;mpshare=1&amp;scene=23&amp;srcid=0404qP0fH8zRiIiFzQBiuzuU#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAwNjQwNzU2NQ==&amp;mid=402841629&amp;idx=1&amp;sn=f598fec9b370b8a6f2062233b31122e0&amp;mpshare=1&amp;scene=23&amp;srcid=0404qP0fH8zRiIiFzQBiuzuU#rd</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzIzMzk2NDQyMw==&amp;mid=2247486641&amp;idx=1&amp;sn=1660fb41b0c5b8d8d6eacdfc1b26b6a6&amp;source=41#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzIzMzk2NDQyMw==&amp;mid=2247486641&amp;idx=1&amp;sn=1660fb41b0c5b8d8d6eacdfc1b26b6a6&amp;source=41#wechat_redirect</a><br><a href="https://blog.acolyer.org/2018/11/16/overload-control-for-scaling-wechat-microservices/" target="_blank" rel="noopener">https://blog.acolyer.org/2018/11/16/overload-control-for-scaling-wechat-microservices/</a><br><a href="https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf" target="_blank" rel="noopener">https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf</a><br><a href="https://github.com/alibaba/Sentinel/wiki/系统负载保护" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel/wiki/系统负载保护</a><br><a href="https://blog.csdn.net/okiwilldoit/article/details/81738782" target="_blank" rel="noopener">https://blog.csdn.net/okiwilldoit/article/details/81738782</a><br><a href="http://alex-ii.github.io/notes/2019/02/13/predictive_load_balancing.html" target="_blank" rel="noopener">http://alex-ii.github.io/notes/2019/02/13/predictive_load_balancing.html</a><br><a href="https://blog.csdn.net/m0_38106113/article/details/81542863" target="_blank" rel="noopener">https://blog.csdn.net/m0_38106113/article/details/81542863</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;隔离&quot;&gt;&lt;a href=&quot;#隔离&quot; class=&quot;headerlink&quot; title=&quot;隔离&quot;&gt;&lt;/a&gt;隔离&lt;/h2&gt;&lt;p&gt;隔离，本质
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="微服务" scheme="https://octopuslian.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="架构设计" scheme="https://octopuslian.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="golang" scheme="https://octopuslian.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-评论系统架构设计</title>
    <link href="https://octopuslian.github.io/2021/05/04/goatc-6-comment-system-architecture-design/"/>
    <id>https://octopuslian.github.io/2021/05/04/goatc-6-comment-system-architecture-design/</id>
    <published>2021-05-04T14:41:57.000Z</published>
    <updated>2021-05-05T13:05:49.627Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --><p><strong>架构设计最重要的就是理解整个产品体系在系统中的定位。搞清楚系统背后的背景，才能做出最佳的设计和抽象。不要做需求的翻译机，先理解业务背后的本质，事情的初衷。</strong></p><h2 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h2><p>评论系统，我们往小里做就是视频评论系统，往大里做就是评论平台，可以接入各种业务形态。</p><ul><li>发布评论: 支持回复楼层、楼中楼。</li><li>读取评论: 按照时间、热度排序。</li><li>删除评论: 用户删除、作者删除。</li><li>管理评论: 作者置顶、后台运营管理(搜索、删除、审核等)。</li></ul><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul><li><p>BFF: comment<br>复杂评论业务的服务编排，比如访问账号服务进行等级判定，同时需要在 BFF 面向移动端/WEB场景来设计 API，这一层抽象把评论的本身的内容列表处理(加载、分页、排序等)进行了隔离，关注在业务平台化逻辑上。</p></li><li><p>Service: comment-service<br>服务层，去平台业务的逻辑，专注在评论功能的 API 实现上，比如发布、读取、删除等，关注在稳定性、可用性上，这样让上游可以灵活组织逻辑把基础能力和业务能力剥离。</p></li><li><p>Job: comment-job<br>消息队列的最大用途是消峰处理。</p></li></ul><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/gai-lan.png" alt></p><h3 id="comment-service"><a href="#comment-service" class="headerlink" title="comment service"></a>comment service</h3><p>专注在评论数据处理。</p><p>读的核心逻辑:<br>Cache-Aside 模式，先读取缓存，再读取存储。早期 cache rebuild 是做到服务里的，对于重建逻辑，一般会使用 read ahead 的思路，即预读，用户访问了第一页，很有可能访问第二页，所以缓存会超前加载，避免频繁 cache miss。当缓存抖动是否，特别容易引起集群 hundering herd 现象，大量的请求会触发 cache rebuild，因为使用了预加载，容易导致服务 OOM。所以我们开到回源的逻辑里，我们使用了消息队列来进行逻辑异步化，对于当前请求只返回 mysql 中部分数据即止。</p><p>写的核心逻辑:<br>我们担心类似“明星出轨”等热点事件的发生，而且写和读相比较，写可以认为是透穿到存储层的，系统的瓶颈往往就来自于存储层，或者有状态层。对于写的设计上，我们认为刚发布的评论有极短的延迟(通常小于几 ms)对用户可见是可接受的，把对存储的直接冲击下放到消息队列，按照消息反压的思路，即如果存储 latency 升高，消费能力就下降，自然消息容易堆积，系统始终以最大化方式消费。</p><p>Kafka 是存在 partition 概念的，可以认为是物理上的一个小队列，一个 topic 是由一组 partition 组成的，所以 Kafka 的吞吐模型理解为: 全局并行，局部串行的生产消费方式。对于入队的消息，可以按照 hash(comment_subject) % N(partitions) 的方式进行分发。那么某个 partition 中的 评论主题的数据一定都在一起，这样方便我们串行消费。<br>同样的，我们处理回源消息也是类似的思路。</p><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/comment-service.png" alt></p><h3 id="comment-admin"><a href="#comment-admin" class="headerlink" title="comment admin"></a>comment admin</h3><p>mysql binlog 中的数据被 canal 中间件流式消费，获取到业务的原始 CRUD 操作，需要回放录入到 es 中，但是 es 中的数据最终是面向运营体系提供服务能力，需要检索的数据维度比较多，在入 es 前需要做一个异构的 joiner，把单表变宽预处理好 join 逻辑，然后倒入到 es 中。<br>一般来说，运营后台的检索条件都是组合的，使用 es 的好处是避免依赖 mysql 来做多条件组合检索，同时 mysql 毕竟是 oltp 面向线上联机事务处理的。通过冗余数据的方式，使用其他引擎来实现。<br>es 一般会存储检索、展示、primary key 等数据，当我们操作编辑的时候，找到记录的 primary key，最后交由 comment-admin 进行运营测的 CRUD 操作。</p><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/comment-admin.png" alt></p><h3 id="comment"><a href="#comment" class="headerlink" title="comment"></a>comment</h3><p>comment 作为 BFF，是面向端，面向平台，面向业务组合的服务。所以平台扩展的能力，我们都在 comment 服务来实现，方便统一和准入平台，以统一的接口形式提供平台化的能力。</p><ul><li>依赖其他 gRPC 服务，整合统一平台测的逻辑(比如发布评论用户等级限定)。</li><li>直接向端上提供接口，提供数据的读写接口，甚至可以整合端上，提供统一的端上 SDK。</li><li>需要对非核心依赖的 gRPC 服务进行降级，当这些服务不稳定时。</li></ul><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/comment.png" alt></p><h2 id="存储设计"><a href="#存储设计" class="headerlink" title="存储设计"></a>存储设计</h2><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p>数据写入: 事务更新 comment_subject，comment_index，comment_content 三张表，其中 content 属于非强制需要一致性考虑的。可以先写入 content，之后事务更新其他表。即便 content 先成功，后续失败仅仅存在一条 ghost 数据。</p><p>数据读取: 基于 obj_id + obj_type 在 comment_index 表找到评论列表，WHERE root = 0 ORDER BY floor。之后根据 comment_index 的 id 字段捞出 comment_content 的评论内容。对于二级的子楼层，WHERE parent/root IN (id…)。</p><p>因为产品形态上只存在二级列表，因此只需要迭代查询两次即可。对于嵌套层次多的，产品上，可以通过二次点击支持。</p><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/database-design.png" alt></p><h3 id="索引内容分离"><a href="#索引内容分离" class="headerlink" title="索引内容分离"></a>索引内容分离</h3><p>comment_index: 评论楼层的索引组织表，实际并不包含内容。comment_content: 评论内容的表，包含评论的具体内容。其中 comment_index 的 id 字段和 comment_content 是1对1的关系，这里面包含几种设计思想。</p><ul><li>表都有主键，即 cluster index，是物理组织形式存放的，comment_content 没有 id，是为了减少一次 二级索引查找，直接基于主键检索，同时 comment_id 在写入要尽可能的顺序自增。</li><li>索引、内容分离，方便 mysql datapage 缓存更多的 row，如果和 context 耦合，会导致更大的 IO。长远来看 content 信息可以直接使用 KV storage 存储。</li></ul><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/suo-yin-nei-rong-fen-li.png" alt></p><h3 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h3><p>comment_subject_cache: 对应主题的缓存，value 使用 protobuf 序列化的方式存入。我们早期使用 memcache 来进行缓存，因为 redis 早期单线程模型，吞吐能力不高。</p><p>comment_index_cache: 使用 redis sortedset 进行索引的缓存，索引即数据的组织顺序，而非数据内容。参考过百度的贴吧，他们使用自己研发的拉链存储来组织索引，我认为 mysql 作为主力存储，利用 redis 来做加速完全足够，因为 cache miss 的构建，我们前面讲过使用 kafka 的消费者中处理，预加载少量数据，通过增量加载的方式逐渐预热填充缓存，而 redis sortedset skiplist 的实现，可以做到 O(logN) + O(M) 的时间复杂度，效率很高。</p><p>sorted set 是要增量追加的，因此必须判定 key 存在，才能 zdd。</p><p>comment_content_cache: 对应评论内容数据，使用 protobuf 序列化的方式存入。类似的我们早期使用 memcache 进行缓存。</p><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/cache-design.png" alt></p><h2 id="可用性设计"><a href="#可用性设计" class="headerlink" title="可用性设计"></a>可用性设计</h2><h3 id="Singleflight"><a href="#Singleflight" class="headerlink" title="Singleflight"></a>Singleflight</h3><p>对于热门的主题，如果存在缓存穿透的情况，会导致大量的同进程、跨进程的数据回源到存储层，可能会引起存储过载的情况，如何只交给同进程内，一个人去做加载存储?</p><p>使用归并回源的思路:<br><a href="https://pkg.go.dev/golang.org/x/sync/singleflight" target="_blank" rel="noopener">https://pkg.go.dev/golang.org/x/sync/singleflight</a></p><p>同进程只交给一个人去获取 mysql 数据，然后批量返回。同时这个 lease owner 投递一个 kafka 消息，做 index cache 的 recovery 操作。这样可以大大减少 mysql 的压力，以及大量透穿导致的密集写 kafka 的问题。</p><p>更进一步的，后续连续的请求，仍然可能会短时 cache miss，我们可以在进程内设置一个 short-lived flag，标记最近有一个人投递了 cache rebuild 的消息，直接 drop。</p><p>Q：为什么我们不用分布式锁之类的思路？</p><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/singleflight.png" alt></p><h3 id="热点"><a href="#热点" class="headerlink" title="热点"></a>热点</h3><p>流量热点是因为突然热门的主题，被高频次的访问，因为底层的 cache 设计，一般是按照主题 key 进行一致性 hash 来进行分片，但是热点 key 一定命中某一个节点，这时候 remote cache 可能会变为瓶颈，因此做 cache 的升级 local cache 是有必要的，我们一般使用单进程自适应发现热点的思路，附加一个短时的 ttl local cache，可以在进程内吞掉大量的读请求。<br>在内存中使用 hashmap 统计每个 key 的访问频次，这里可以使用滑动窗口统计，即每个窗口中，维护一个 hashmap，之后统计所有未过去的 bucket，汇总所有 key 的数据。<br>之后使用小堆计算 TopK 的数据，自动进行热点识别。</p><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/hot.png" alt></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;架构设计最重要的就是理解整个产品体系在系统中的定位。搞清楚系统背后的背景，才能做出最佳的设计和抽象。不要做需求的翻译机，先理解业
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="架构设计" scheme="https://octopuslian.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="golang" scheme="https://octopuslian.github.io/tags/golang/"/>
    
      <category term="评论系统" scheme="https://octopuslian.github.io/tags/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-工程化实践</title>
    <link href="https://octopuslian.github.io/2021/05/04/goatc-4-go-engineering-practice/"/>
    <id>https://octopuslian.github.io/2021/05/04/goatc-4-go-engineering-practice/</id>
    <published>2021-05-04T08:26:13.000Z</published>
    <updated>2021-05-04T14:36:47.120Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --><h1 id="工程项目结构"><a href="#工程项目结构" class="headerlink" title="工程项目结构"></a>工程项目结构</h1><h2 id="Standard-Go-Project-Layout"><a href="#Standard-Go-Project-Layout" class="headerlink" title="Standard Go Project Layout"></a>Standard Go Project Layout</h2><h3 id="cmd"><a href="#cmd" class="headerlink" title="/cmd"></a>/cmd</h3><p>本项目的主干。<br>每个应用程序的目录名应该与你想要的可执行文件的名称相匹配(例如，/cmd/myapp)。<br>不要在这个目录中放置太多代码。如果你认为代码可以导入并在其他项目中使用，那么它应该位于 /pkg 目录中。如果代码不是可重用的，或者你不希望其他人重用它，请将该代码放到 /internal 目录中。</p><h3 id="internal"><a href="#internal" class="headerlink" title="/internal"></a>/internal</h3><p>私有应用程序和库代码。这是你不希望其他人在其应用程序或库中导入代码。请注意，这个布局模式是由 Go 编译器本身执行的。有关更多细节，请参阅Go 1.4 release notes。</p><p>注意，你并不局限于顶级 internal 目录。在项目树的任何级别上都可以有多个内部目录。</p><p>你可以选择向 internal 包中添加一些额外的结构，以分隔共享和非共享的内部代码。这不是必需的(特别是对于较小的项目)，但是最好有有可视化的线索来显示预期的包的用途。你的实际应用程序代码可以放在 /internal/app 目录下(例如 /internal/app/myapp)，这些应用程序共享的代码可以放在 /internal/pkg 目录下(例如 /internal/pkg/myprivlib)。</p><h3 id="pkg"><a href="#pkg" class="headerlink" title="/pkg"></a>/pkg</h3><p>外部应用程序可以使用的库代码(例如 /pkg/mypubliclib)。其他项目会导入这些库，所以在这里放东西之前要三思:-)注意，internal 目录是确保私有包不可导入的更好方法，因为它是由 Go 强制执行的。/pkg 目录仍然是一种很好的方式，可以显式地表示该目录中的代码对于其他人来说是安全使用的好方法。</p><p>/pkg 目录内，可以参考 go 标准库的组织方式，按照功能分类。/internla/pkg 一般用于项目内的 跨多个应用的公共共享代码，但其作用域仅在单个项目工程内。</p><p><strong>当根目录包含大量非 Go 组件和目录时，这也是一种将 Go 代码分组到一个位置的方法，这使得运行各种 Go 工具变得更加容易组织。</strong></p><h2 id="Kit-Project-Layout"><a href="#Kit-Project-Layout" class="headerlink" title="Kit Project Layout"></a>Kit Project Layout</h2><p>基础库 kit 为独立项目，公司级建议只有一个，按照功能目录来拆分会带来不少的管理工作，因此建议合并整合。</p><p>by [Package Oriented Design]</p><blockquote><p>“To this end, the Kit project is not allowed to have a vendor folder. If any of packages are dependent on 3rd party packages, they must always build against the latest version of those dependences.”</p></blockquote><p>kit 项目必须具备的特点:</p><ul><li>统一</li><li>标准库方式布局</li><li>高度抽象</li><li>支持插件</li></ul><h2 id="Service-Application-Project-Layout"><a href="#Service-Application-Project-Layout" class="headerlink" title="Service Application Project Layout"></a>Service Application Project Layout</h2><h3 id="api"><a href="#api" class="headerlink" title="/api"></a>/api</h3><p>API 协议定义目录，xxapi.proto protobuf 文件，以及生成的 go 文件。我们通常把 api 文档直接在 proto 文件中描述。</p><h3 id="configs"><a href="#configs" class="headerlink" title="/configs"></a>/configs</h3><p>配置文件模板或默认配置。</p><h3 id="test"><a href="#test" class="headerlink" title="/test"></a>/test</h3><p>额外的外部测试应用程序和测试数据。你可以随时根据需求构造 /test 目录。对于较大的项目，有一个数据子目录是有意义的。例如，你可以使用 /test/data 或 /test/testdata (如果你需要忽略目录中的内容)。请注意，Go 还会忽略以“.”或“_”开头的目录或文件，因此在如何命名测试数据目录方面有更大的灵活性。<br>不应该包含：/src</p><p>有些 Go 项目确实有一个 src 文件夹，但这通常发生在开发人员有 Java 背景，在那里它是一种常见的模式。不要将项目级别 src 目录与 Go 用于其工作空间的 src 目录。</p><p>一个 gitlab 的 project 里可以放置多个微服务的app(类似 monorepo)。也可以按照 gitlab 的 group 里建立多个 project，每个 project 对应一个 app。<br>多 app 的方式，app 目录内的每个微服务按照自己的全局唯一名称，比如 “account.service.vip” 来建立目录，如: account/vip/*。<br>和 app 平级的目录 pkg 存放业务有关的公共库（非基础框架库）。如果应用不希望导出这些目录，可以放置到 myapp/internal/pkg 中。</p><h1 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h1><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p>“A high-performance, open-source universal RPC framework”</p><ul><li>多语言：语言中立，支持多种语言。</li><li>轻量级、高性能：序列化支持 PB(Protocol Buffer)和 JSON，PB 是一种语言无关的高性能序列化框架。<br>可插拔</li><li>IDL：基于文件定义服务，通过 proto3 工具生成指定语言的数据结构、服务端接口以及客户端 Stub。</li></ul><p>设计理念</p><ul><li><p>移动端：基于标准的 HTTP2 设计，支持双向流、消息头压缩、单 TCP 的多路复用、服务端推送等特性，这-些特性使得 gRPC 在移动端设备上更加省电和节省网络流量。</p></li><li><p>服务而非对象、消息而非引用：促进微服务的系统间粗粒度消息交互设计理念。</p></li><li><p>负载无关的：不同的服务需要使用不同的消息类型和编码，例如 protocol buffers、JSON、XML和Thrift。</p></li><li><p>流: Streaming API。</p></li><li><p>阻塞式和非阻塞式：支持异步和同步处理在客户端和服务端间交互的消息序列。</p></li><li><p>元数据交换：常见的横切关注点，如认证或跟踪，依赖数据交换。</p></li><li><p>标准化状态码：客户端通常以有限的方式响应 API 调用返回的错误。</p></li></ul><p><strong>不要过早关注性能问题，先标准化。</strong></p><p>为了统一检索和规范 API，我们内部建立了一个统一的 bapis 仓库，整合所有对内对外 API。</p><p>API 仓库，方便跨部门协作。<br>版本管理，基于 git 控制。<br>规范化检查，API lint。<br>API design review，变更 diff。<br>权限管理，目录 OWNERS。</p><h2 id="API-Compatibility"><a href="#API-Compatibility" class="headerlink" title="API Compatibility"></a>API Compatibility</h2><p>向后兼容(非破坏性)的修改<br>给 API 服务定义添加 API 接口<br>从协议的角度来看，这始终是安全的。</p><p>给请求消息添加字段<br>只要客户端在新版和旧版中对该字段的处理不保持一致，添加请求字段就是兼容的。</p><p>给响应消息添加字段<br>在不改变其他响应字段的行为的前提下，非资源（例如，ListBooksResponse）的响应消息可以扩展而不必破坏客户端的兼容性。即使会引入冗余，先前在响应中填充的任何字段应继续使用相同的语义填充。</p><p>向后不兼容(破坏性)的修改<br>删除或重命名服务，字段，方法或枚举值<br>从根本上说，如果客户端代码可以引用某些东西，那么删除或重命名它都是不兼容的变化，这时必须修改major 版本号。<br>修改字段的类型<br>即使新类型是传输格式兼容的，这也可能会导致客户端库生成的代码发生变化，因此必须增加major版本号。 对于编译型静态语言来说，会容易引入编译错误。<br>修改现有请求的可见行为<br>客户端通常依赖于 API 行为和语义，即使这样的行为没有被明确支持或记录。 因此，在大多数情况下，修改 API 数据的行为或语义将被消费者视为是破坏性的。如果行为没有加密隐藏，您应该假设用户已经发现它，并将依赖于它。<br>给资源消息添加 读取/写入 字段</p><h2 id="API-Naming-Conventions"><a href="#API-Naming-Conventions" class="headerlink" title="API Naming Conventions"></a>API Naming Conventions</h2><p>包名为应用的标识(APP_ID)，用于生成 gRPC 请求路径，或者 proto 之间进行引用 Message。文件中声明的包名称应该与产品和服务名称保持一致。带有版本的 API 的软件包名称必须以此版本结尾。<br>my.package.v1，为 API 目录，定义service相关接口，用于提供业务使用。</p><p>// RequestURL: /<package_name>.<version>.<service_name>/{method}<br>package<package_name>.<version>;</version></package_name></service_name></version></package_name></p><h2 id="API-Primitive-Fields"><a href="#API-Primitive-Fields" class="headerlink" title="API Primitive Fields"></a>API Primitive Fields</h2><p>gRPC 默认使用 Protobuf v3 格式，因为去除了 required 和 optional 关键字，默认全部都是 optional 字段。如果没有赋值的字段，默认会基础类型字段的默认值，比如 0 或者 “”。<br>Protobuf v3 中，建议使用：<a href="https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wrappers.proto" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wrappers.proto</a><br>Warpper 类型的字段，即包装一个 message，使用时变为指针。</p><p>Protobuf 作为强 schema 的描述文件，也可以方便扩展，是不是用于配置文件定义也可？</p><h2 id="API-Errors"><a href="#API-Errors" class="headerlink" title="API Errors"></a>API Errors</h2><p>使用一小组标准错误配合大量资源<br>例如，服务器没有定义不同类型的“找不到”错误，而是使用一个标准 google.rpc.Code.NOT_FOUND 错误代码并告诉客户端找不到哪个特定资源。状态空间变小降低了文档的复杂性，在客户端库中提供了更好的惯用映射，并降低了客户端的逻辑复杂性，同时不限制是否包含可操作信息(/google/rpc/error_details)。<br>错误传播<br>如果您的 API 服务依赖于其他服务，则不应盲目地将这些服务的错误传播到您的客户端。在翻译错误时，我们建议执行以下操作：<br>隐藏实现详细信息和机密信息。<br>调整负责该错误的一方。例如，从另一个服务接收 INVALID_ARGUMENT 错误的服务器应该将 INTERNAL 传播给它自己的调用者。</p><p>全局错误码<br>全局错误码，是松散、易被破坏契约的，基于我们上述讨论的，在每个服务传播错误的时候，做一次翻译，这样保证每个服务 + 错误枚举，应该是唯一的，而且在 proto 定义中是可以写出来文档的。</p><h2 id="API-Design"><a href="#API-Design" class="headerlink" title="API Design"></a>API Design</h2><h1 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h1><h2 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/gomods/athens</span><br><span class="line">https://goproxy.cn</span><br><span class="line"></span><br><span class="line">https://blog.golang.org/modules2019</span><br><span class="line">https://blog.golang.org/using-go-modules</span><br><span class="line">https://blog.golang.org/migrating-to-go-modules</span><br><span class="line">https://blog.golang.org/module-mirror-launch</span><br><span class="line">https://blog.golang.org/publishing-go-modules</span><br><span class="line">https://blog.golang.org/v2-go-modules</span><br><span class="line">https://blog.golang.org/module-compatibility</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="Unittest"><a href="#Unittest" class="headerlink" title="Unittest"></a>Unittest</h2><p>小型测试带来优秀的代码质量、良好的异常处理、优雅的错误报告；大中型测试会带来整体产品质量和数据验证。<br>不同类型的项目，对测试的需求不同，总体上有一个经验法则，即70/20/10原则：70%是小型测试，20%是中型测试，10%是大型测试。<br>如果一个项目是面向用户的，拥有较高的集成度，或者用户接口比较复杂，他们就应该有更多的中型和大型测试；如果是基础平台或者面向数据的项目，例如索引或网络爬虫，则最好有大量的小型测试，中型测试和大型测试的数量要求会少很多。</p><p>“自动化实现的，用于验证一个单独函数或独立功能模块的代码是否按照预期工作，着重于典型功能性问题、数据损坏、错误条件和大小差一错误（译注：大小差一(off-by-one)错误是一类常见的程序设计错误）等方面的验证”<br>- 《Google软件测试之道》</p><p>单元测试的基本要求：<br>快速<br>环境一致<br>任意顺序<br>并行</p><p>基于 docker-compose 实现跨平台跨语言环境的容器依赖管理方案，以解决运行 unittest 场景下的(mysql, redis, mc)容器依赖问题:<br>本地安装 Docker。<br>无侵入式的环境初始化。<br>快速重置环境。<br>随时随地运行(不依赖外部服务)。<br>语义式 API 声明资源。</p><p>真实外部依赖，而非 in-process 模拟。<br>正确的对容器内服务进行健康检测，避免unittest 启动时候资源还未 ready。<br>应该交由 app 自己来初始化数据，比如 db 的scheme，初始的 sql 数据等，为了满足测试的一致性，在每次结束后，都会销毁容器。<br>在单元测试开始前，导入封装好的 testing 库，方便启动和销毁容器。<br>对于 service 的单元测试，使用 gomock 等库把 dao mock 掉，所以在设计包的时候，应该面向抽象编程。<br>在本地执行依赖 Docker，在 CI 环境里执行Unittest，需要考虑在物理机里的 Docker 网络，或者在 Docker 里再次启动一个 Docker。</p><p>利用 go 官方提供的: Subtests + Gomock 完成整个单元测试。<br>/api<br>比较适合进行集成测试，直接测试 API，使用 API 测试框架(例如: yapi)，维护大量业务测试 case。<br>/data<br>docker compose 把底层基础设施真实模拟，因此可以去掉 infra 的抽象层。<br>/biz<br>依赖 repo、rpc client，利用 gomock 模拟 interface 的实现，来进行业务单元测试。<br>/service<br>依赖 biz 的实现，构建 biz 的实现类传入，进行单元测试。<br>基于 git branch 进行 feature 开发，本地进行 unittest，之后提交 gitlab merge request 进行 CI 的单元测试，基于 feature branch 进行构建，完成功能测试，之后合并 master，进行集成测试，上线后进行回归测试。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html</a><br><a href="https://www.ardanlabs.com/blog/2017/02/design-philosophy-on-packaging.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2017/02/design-philosophy-on-packaging.html</a><br><a href="https://github.com/golang-standards/project-layout" target="_blank" rel="noopener">https://github.com/golang-standards/project-layout</a><br><a href="https://github.com/golang-standards/project-layout/blob/master/README_zh.md" target="_blank" rel="noopener">https://github.com/golang-standards/project-layout/blob/master/README_zh.md</a><br><a href="https://www.cnblogs.com/zxf330301/p/6534643.html" target="_blank" rel="noopener">https://www.cnblogs.com/zxf330301/p/6534643.html</a><br><a href="https://blog.csdn.net/k6T9Q8XKs6iIkZPPIFq/article/details/109192475?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160561008419724839224387%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=160561008419724839224387&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-6-109192475.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=阿里技术专家详解DDD系列&amp;spm=1018.2118.3001.4449" target="_blank" rel="noopener">https://blog.csdn.net/k6T9Q8XKs6iIkZPPIFq/article/details/109192475?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160561008419724839224387%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=160561008419724839224387&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-6-109192475.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=阿里技术专家详解DDD系列&amp;spm=1018.2118.3001.4449</a><br><a href="https://blog.csdn.net/chikuai9995/article/details/100723540?biz_id=102&amp;utm_term=阿里技术专家详解DDD系列&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-100723540&amp;spm=1018.2118.3001.4449" target="_blank" rel="noopener">https://blog.csdn.net/chikuai9995/article/details/100723540?biz_id=102&amp;utm_term=阿里技术专家详解DDD系列&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-100723540&amp;spm=1018.2118.3001.4449</a><br><a href="https://blog.csdn.net/Taobaojishu/article/details/101444324?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160561008419724838528569%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160561008419724838528569&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-101444324.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=阿里技术专家详解DDD系列&amp;spm=1018.2118.3001.4449" target="_blank" rel="noopener">https://blog.csdn.net/Taobaojishu/article/details/101444324?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160561008419724838528569%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160561008419724838528569&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-101444324.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=阿里技术专家详解DDD系列&amp;spm=1018.2118.3001.4449</a><br><a href="https://blog.csdn.net/taobaojishu/article/details/106152641" target="_blank" rel="noopener">https://blog.csdn.net/taobaojishu/article/details/106152641</a><br><a href="https://cloud.google.com/apis/design/errors" target="_blank" rel="noopener">https://cloud.google.com/apis/design/errors</a><br><a href="https://kb.cnblogs.com/page/520743/" target="_blank" rel="noopener">https://kb.cnblogs.com/page/520743/</a><br><a href="https://zhuanlan.zhihu.com/p/105466656" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/105466656</a><br><a href="https://zhuanlan.zhihu.com/p/105648986" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/105648986</a><br><a href="https://zhuanlan.zhihu.com/p/106634373" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/106634373</a><br><a href="https://zhuanlan.zhihu.com/p/107347593" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/107347593</a><br><a href="https://zhuanlan.zhihu.com/p/109048532" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/109048532</a><br><a href="https://zhuanlan.zhihu.com/p/110252394" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/110252394</a><br><a href="https://www.jianshu.com/p/dfa427762975" target="_blank" rel="noopener">https://www.jianshu.com/p/dfa427762975</a><br><a href="https://www.citerus.se/go-ddd/" target="_blank" rel="noopener">https://www.citerus.se/go-ddd/</a><br><a href="https://www.citerus.se/part-2-domain-driven-design-in-go/" target="_blank" rel="noopener">https://www.citerus.se/part-2-domain-driven-design-in-go/</a><br><a href="https://www.citerus.se/part-3-domain-driven-design-in-go/" target="_blank" rel="noopener">https://www.citerus.se/part-3-domain-driven-design-in-go/</a><br><a href="https://www.jianshu.com/p/dfa427762975" target="_blank" rel="noopener">https://www.jianshu.com/p/dfa427762975</a><br><a href="https://www.jianshu.com/p/5732b69bd1a1" target="_blank" rel="noopener">https://www.jianshu.com/p/5732b69bd1a1</a></p><p><a href="https://www.cnblogs.com/qixuejia/p/10789612.html" target="_blank" rel="noopener">https://www.cnblogs.com/qixuejia/p/10789612.html</a><br><a href="https://www.cnblogs.com/qixuejia/p/4390086.html" target="_blank" rel="noopener">https://www.cnblogs.com/qixuejia/p/4390086.html</a><br><a href="https://www.cnblogs.com/qixuejia/p/10789621.html" target="_blank" rel="noopener">https://www.cnblogs.com/qixuejia/p/10789621.html</a><br><a href="https://zhuanlan.zhihu.com/p/46603988" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46603988</a><br><a href="https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wrappers.proto" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wrappers.proto</a><br><a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis" target="_blank" rel="noopener">https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis</a><br><a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html" target="_blank" rel="noopener">https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html</a><br><a href="https://blog.csdn.net/taobaojishu/article/details/106152641" target="_blank" rel="noopener">https://blog.csdn.net/taobaojishu/article/details/106152641</a></p><p><a href="https://apisyouwonthate.com/blog/creating-good-api-errors-in-rest-graphql-and-grpc" target="_blank" rel="noopener">https://apisyouwonthate.com/blog/creating-good-api-errors-in-rest-graphql-and-grpc</a><br><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="noopener">https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html</a><br><a href="https://www.youtube.com/watch?v=oL6JBUk6tj0" target="_blank" rel="noopener">https://www.youtube.com/watch?v=oL6JBUk6tj0</a><br><a href="https://github.com/zitryss/go-sample" target="_blank" rel="noopener">https://github.com/zitryss/go-sample</a><br><a href="https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md" target="_blank" rel="noopener">https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md</a><br><a href="https://medium.com/@eminetto/clean-architecture-using-golang-b63587aa5e3f" target="_blank" rel="noopener">https://medium.com/@eminetto/clean-architecture-using-golang-b63587aa5e3f</a><br><a href="https://hackernoon.com/golang-clean-archithecture-efd6d7c43047" target="_blank" rel="noopener">https://hackernoon.com/golang-clean-archithecture-efd6d7c43047</a><br><a href="https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1" target="_blank" rel="noopener">https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1</a><br><a href="https://medium.com/wtf-dial/wtf-dial-domain-model-9655cd523182" target="_blank" rel="noopener">https://medium.com/wtf-dial/wtf-dial-domain-model-9655cd523182</a><br><a href="https://hackernoon.com/golang-clean-archithecture-efd6d7c43047" target="_blank" rel="noopener">https://hackernoon.com/golang-clean-archithecture-efd6d7c43047</a><br><a href="https://hackernoon.com/trying-clean-architecture-on-golang-2-44d615bf8fdf" target="_blank" rel="noopener">https://hackernoon.com/trying-clean-architecture-on-golang-2-44d615bf8fdf</a><br><a href="https://manuel.kiessling.net/2012/09/28/applying-the-clean-architecture-to-go-applications/" target="_blank" rel="noopener">https://manuel.kiessling.net/2012/09/28/applying-the-clean-architecture-to-go-applications/</a><br><a href="https://github.com/katzien/go-structure-examples" target="_blank" rel="noopener">https://github.com/katzien/go-structure-examples</a><br><a href="https://www.youtube.com/watch?v=MzTcsI6tn-0" target="_blank" rel="noopener">https://www.youtube.com/watch?v=MzTcsI6tn-0</a><br><a href="https://www.appsdeveloperblog.com/dto-to-entity-and-entity-to-dto-conversion/" target="_blank" rel="noopener">https://www.appsdeveloperblog.com/dto-to-entity-and-entity-to-dto-conversion/</a><br><a href="https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/" target="_blank" rel="noopener">https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/</a><br><a href="https://github.com/google/wire/blob/master/docs/best-practices.md" target="_blank" rel="noopener">https://github.com/google/wire/blob/master/docs/best-practices.md</a><br><a href="https://github.com/google/wire/blob/master/docs/guide.md" target="_blank" rel="noopener">https://github.com/google/wire/blob/master/docs/guide.md</a><br><a href="https://blog.golang.org/wire" target="_blank" rel="noopener">https://blog.golang.org/wire</a><br><a href="https://github.com/google/wire" target="_blank" rel="noopener">https://github.com/google/wire</a><br><a href="https://www.ardanlabs.com/blog/2019/03/integration-testing-in-go-executing-tests-with-docker.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2019/03/integration-testing-in-go-executing-tests-with-docker.html</a><br><a href="https://www.ardanlabs.com/blog/2019/10/integration-testing-in-go-set-up-and-writing-tests.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2019/10/integration-testing-in-go-set-up-and-writing-tests.html</a><br><a href="https://blog.golang.org/examples" target="_blank" rel="noopener">https://blog.golang.org/examples</a><br><a href="https://blog.golang.org/subtests" target="_blank" rel="noopener">https://blog.golang.org/subtests</a><br><a href="https://blog.golang.org/cover" target="_blank" rel="noopener">https://blog.golang.org/cover</a><br><a href="https://blog.golang.org/module-compatibility" target="_blank" rel="noopener">https://blog.golang.org/module-compatibility</a><br><a href="https://blog.golang.org/v2-go-modules" target="_blank" rel="noopener">https://blog.golang.org/v2-go-modules</a><br><a href="https://blog.golang.org/publishing-go-modules" target="_blank" rel="noopener">https://blog.golang.org/publishing-go-modules</a><br><a href="https://blog.golang.org/module-mirror-launch" target="_blank" rel="noopener">https://blog.golang.org/module-mirror-launch</a><br><a href="https://blog.golang.org/migrating-to-go-modules" target="_blank" rel="noopener">https://blog.golang.org/migrating-to-go-modules</a><br><a href="https://blog.golang.org/using-go-modules" target="_blank" rel="noopener">https://blog.golang.org/using-go-modules</a><br><a href="https://blog.golang.org/modules2019" target="_blank" rel="noopener">https://blog.golang.org/modules2019</a><br><a href="https://blog.codecentric.de/en/2017/08/gomock-tutorial/" target="_blank" rel="noopener">https://blog.codecentric.de/en/2017/08/gomock-tutorial/</a><br><a href="https://pkg.go.dev/github.com/golang/mock/gomock" target="_blank" rel="noopener">https://pkg.go.dev/github.com/golang/mock/gomock</a><br><a href="https://medium.com/better-programming/a-gomock-quick-start-guide-71bee4b3a6f1" target="_blank" rel="noopener">https://medium.com/better-programming/a-gomock-quick-start-guide-71bee4b3a6f1</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;工程项目结构&quot;&gt;&lt;a href=&quot;#工程项目结构&quot; class=&quot;headerlink&quot; title=&quot;工程项目结构&quot;&gt;&lt;/a&gt;工程项
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="项目" scheme="https://octopuslian.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="golang" scheme="https://octopuslian.github.io/tags/golang/"/>
    
      <category term="工程" scheme="https://octopuslian.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-并行编程</title>
    <link href="https://octopuslian.github.io/2021/05/02/goatc-3-concurrency/"/>
    <id>https://octopuslian.github.io/2021/05/02/goatc-3-concurrency/</id>
    <published>2021-05-02T13:32:19.000Z</published>
    <updated>2021-05-04T08:18:32.895Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --><h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><h3 id="Processes-and-Threads"><a href="#Processes-and-Threads" class="headerlink" title="Processes and Threads"></a>Processes and Threads</h3><p>操作系统会为该应用程序创建一个进程。作为一个应用程序，它像一个为所有资源而运行的容器。这些资源包括内存地址空间、文件句柄、设备和线程。<br>线程是操作系统调度的一种执行路径，用于在处理器执行我们在函数中编写的代码。一个进程从一个线程开始，即主线程，当该线程终止时，进程终止。这是因为主线程是应用程序的原点。然后，主线程可以依次启动更多的线程，而这些线程可以启动更多的线程。</p><p>无论线程属于哪个进程，操作系统都会安排线程在可用处理器上运行。每个操作系统都有自己的算法来做出这些决定。</p><h2 id="Goroutines-and-Parallelism"><a href="#Goroutines-and-Parallelism" class="headerlink" title="Goroutines and Parallelism"></a>Goroutines and Parallelism</h2><p>Go 语言层面支持的 go 关键字，可以快速的让一个函数创建为 goroutine，我们可以认为 main 函数就是作为 goroutine 执行的。操作系统调度线程在可用处理器上运行，Go运行时调度 goroutines 在绑定到单个操作系统线程的逻辑处理器中运行(P)。即使使用这个单一的逻辑处理器和操作系统线程，也可以调度数十万 goroutine 以惊人的效率和性能并发运行。</p><p><strong>Concurrency is not Parallelism.（并行不意味着并发）</strong></p><p>并发(可以同时做)不是并行(不同的执行单元)。</p><p>并行是指两个或多个线程同时在不同的处理器执行代码。如果将运行时配置为使用多个逻辑处理器，则调度程序将在这些逻辑处理器之间分配 goroutine，这将导致 goroutine 在不同的操作系统线程上运行。但是，要获得真正的并行性，您需要在具有多个物理处理器的计算机上运行程序。否则，goroutines 将针对单个物理处理器并发运行，即使 Go 运行时使用多个逻辑处理器。</p><h3 id="Keep-your-busy-or-do-the-work-yourself"><a href="#Keep-your-busy-or-do-the-work-yourself" class="headerlink" title="Keep your busy or do the work yourself"></a>Keep your busy or do the work yourself</h3><p>空的select语句将永远堵塞：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Sprintln(w, <span class="string">"Hello，GopherCon SG"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":8000"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Incomplete-Work"><a href="#Incomplete-Work" class="headerlink" title="Incomplete Work"></a>Incomplete Work</h3><h2 id="Memory-model"><a href="#Memory-model" class="headerlink" title="Memory model"></a>Memory model</h2><p><a href="https://golang.org/ref/mem" target="_blank" rel="noopener">https://golang.org/ref/mem</a></p><p>如何保证在一个 goroutine 中看到在另一个 goroutine 修改的变量的值，如果程序中修改数据时有其他 goroutine 同时读取，那么必须将读取串行化。为了串行化访问，请使用 channel 或其他同步原语，例如 sync 和 sync/atomic 来保护数据。</p><h3 id="Happen-Before"><a href="#Happen-Before" class="headerlink" title="Happen-Before"></a>Happen-Before</h3><p>在一个 goroutine 中，读和写一定是按照程序中的顺序执行的。即编译器和处理器只有在不会改变这个 goroutine 的行为时才可能修改读和写的执行顺序。由于重排，不同的goroutine 可能会看到不同的执行顺序。例如，一个goroutine 执行 a = 1;b = 2;，另一个 goroutine 可能看到 b 在 a 之前更新。</p><h3 id="Memory-Reordering"><a href="#Memory-Reordering" class="headerlink" title="Memory Reordering"></a>Memory Reordering</h3><p>用户写下的代码，先要编译成汇编代码，也就是各种指令，包括读写内存的指令。CPU 的设计者们，为了榨干 CPU 的性能，无所不用其极，各种手段都用上了，你可能听过不少，像流水线、分支预测等等。其中，为了提高读写内存的效率，会对读写指令进行重新排列，这就是所谓的 内存重排，英文为 MemoryReordering。</p><h2 id="Package-sync"><a href="#Package-sync" class="headerlink" title="Package sync"></a>Package sync</h2><p>传统的线程模型(通常在编写 Java、C++ 和Python 程序时使用)程序员在线程之间通信需要使用共享内存。通常，共享数据结构由锁保护，线程将争用这些锁来访问数据。在某些情况下，通过使用线程安全的数据结构(如Python的Queue)，这会变得更容易。</p><p>Go 的并发原语 goroutines 和 channels 为构造并发软件提供了一种优雅而独特的方法。Go 没有显式地使用锁来协调对共享数据的访问，而是鼓励使用 chan 在 goroutine 之间传递对数据的引用。这种方法确保在给定的时间只有一个goroutine 可以访问数据。</p><p>Do not communicate by sharing memory; instead, share memory by communicating.</p><h3 id="Detecting-Race-Conditions-With-Go"><a href="#Detecting-Race-Conditions-With-Go" class="headerlink" title="Detecting Race Conditions With Go"></a>Detecting Race Conditions With Go</h3><p>data race 是两个或多个 goroutine 访问同一个资源(如变量或数据结构)，并尝试对该资源进行读写而不考虑其他 goroutine。这种类型的代码可以创建您见过的最疯狂和最随机的 bug。通常需要大量的日志记录和运气才能找到这些类型的bug。</p><p>早在6月份的Go 1.1中，Go 工具引入了一个 race detector。竞争检测器是在构建过程中内置到程序中的代码。然后，一旦你的程序运行，它就能够检测并报告它发现的任何竞争条件。它非常酷，并且在识别罪魁祸首的代码方面做了令人难以置信的工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3/8.go</span><br><span class="line">go build -race</span><br><span class="line">go test -race</span><br></pre></td></tr></table></figure><h3 id="sync-atomic"><a href="#sync-atomic" class="headerlink" title="sync.atomic"></a>sync.atomic</h3><h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><h3 id="errgroup"><a href="#errgroup" class="headerlink" title="errgroup"></a>errgroup</h3><h3 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a>sync.Pool</h3><h2 id="chan"><a href="#chan" class="headerlink" title="chan"></a>chan</h2><h3 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h3><p>channels 是一种类型安全的消息队列，充当两个 goroutine 之间的管道，将通过它同步的进行任意资源的交换。chan 控制 goroutines 交互的能力从而创建了 Go 同步机制。当创建的 chan 没有容量时，称为无缓冲通道。反过来，使用容量创建的 chan 称为缓冲通道。</p><h3 id="Unbuffered-Channels"><a href="#Unbuffered-Channels" class="headerlink" title="Unbuffered Channels"></a>Unbuffered Channels</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>无缓冲 chan 没有容量，因此进行任何交换前需要两个 goroutine 同时准备好。当 goroutine 试图将一个资源发送到一个无缓冲的通道并且没有goroutine 等待接收该资源时，该通道将锁住发送 goroutine 并使其等待。当 goroutine 尝试从无缓冲通道接收，并且没有 goroutine 等待发送资源时，该通道将锁住接收 goroutine 并使其等待。</p><p>无缓冲信道的本质是保证同步。</p><h3 id="Buffered-Channels"><a href="#Buffered-Channels" class="headerlink" title="Buffered Channels"></a>Buffered Channels</h3><p>buffered channel 具有容量，因此其行为可能有点不同。当 goroutine 试图将资源发送到缓冲通道，而该通道已满时，该通道将锁住 goroutine并使其等待缓冲区可用。如果通道中有空间，发送可以立即进行，goroutine 可以继续。当goroutine 试图从缓冲通道接收数据，而缓冲通道为空时，该通道将锁住 goroutine 并使其等待资源被发送。</p><h3 id="Latencies-due-to-under-sized-buffer"><a href="#Latencies-due-to-under-sized-buffer" class="headerlink" title="Latencies due to under-sized buffer"></a>Latencies due to under-sized buffer</h3><p>我们在 chan 创建过程中定义的缓冲区大小可能会极大地影响性能。我将使用密集使用 chan 的扇出模式来查看不同缓冲区大小的影响。在我们的基准测试中，一个 producer 将在通道中注入百万个整数元素，而5个 worker 将读取并将它们追加到一个名为 total 的结果变量中。</p><h3 id="Go-Concurrency-Patterns"><a href="#Go-Concurrency-Patterns" class="headerlink" title="Go Concurrency Patterns"></a>Go Concurrency Patterns</h3><ul><li><p>Timing out</p></li><li><p>Moving on</p></li><li><p>Pipeline</p></li><li><p>Fan-out, Fan-in</p></li><li><p>Cancellation<br>Close 先于 Receive 发生(类似 Buffered)。<br>不需要传递数据，或者传递 nil。<br>非常适合去掉和超时控制。</p></li><li><p>Contex<br><a href="https://blog.golang.org/concurrency-timeouts" target="_blank" rel="noopener">https://blog.golang.org/concurrency-timeouts</a><br><a href="https://blog.golang.org/pipelines" target="_blank" rel="noopener">https://blog.golang.org/pipelines</a><br><a href="https://talks.golang.org/2013/advconc.slide#1" target="_blank" rel="noopener">https://talks.golang.org/2013/advconc.slide#1</a><br><a href="https://github.com/go-kratos/kratos/tree/master/pkg/sync" target="_blank" rel="noopener">https://github.com/go-kratos/kratos/tree/master/pkg/sync</a></p></li></ul><h2 id="Package-context"><a href="#Package-context" class="headerlink" title="Package context"></a>Package context</h2><h3 id="Request-scoped-context"><a href="#Request-scoped-context" class="headerlink" title="Request-scoped context"></a>Request-scoped context</h3><p>在 Go 服务中，每个传入的请求都在其自己的goroutine 中处理。请求处理程序通常启动额外的 goroutine 来访问其他后端，如数据库和 RPC服务。处理请求的 goroutine 通常需要访问特定于请求(request-specific context)的值，例如最终用户的身份、授权令牌和请求的截止日期(deadline)。当一个请求被取消或超时时，处理该请求的所有 goroutine 都应该快速退出(fail fast)，这样系统就可以回收它们正在使用的任何资源。</p><p>Go 1.7 引入一个 context 包，它使得跨 API 边界的请求范围元数据、取消信号和截止日期很容易传递给处理请求所涉及的所有 goroutine(显示传递)。</p><h3 id="Do-not-store-Contexts-inside-a-struct-type"><a href="#Do-not-store-Contexts-inside-a-struct-type" class="headerlink" title="Do not store Contexts inside a struct type"></a>Do not store Contexts inside a struct type</h3><h3 id="context-WithValue"><a href="#context-WithValue" class="headerlink" title="context.WithValue"></a>context.WithValue</h3><h3 id="Debugging-or-tracing-data-is-safe-to-pass-in-a-Context"><a href="#Debugging-or-tracing-data-is-safe-to-pass-in-a-Context" class="headerlink" title="Debugging or tracing data is safe to pass in a Context"></a>Debugging or tracing data is safe to pass in a Context</h3><h3 id="When-a-Context-is-canceled-all-Contexts-derived-from-it-are-also-canceled"><a href="#When-a-Context-is-canceled-all-Contexts-derived-from-it-are-also-canceled" class="headerlink" title="When a Context is canceled, all Contexts derived from it are also canceled"></a>When a Context is canceled, all Contexts derived from it are also canceled</h3><h3 id="All-blocking-long-operations-should-be-cancelable"><a href="#All-blocking-long-operations-should-be-cancelable" class="headerlink" title="All blocking/long operations should be cancelable"></a>All blocking/long operations should be cancelable</h3><h2 id="Final-Notes"><a href="#Final-Notes" class="headerlink" title="Final Notes"></a>Final Notes</h2><ul><li>Incoming requests to a server should create a Context.</li><li>Outgoing calls to servers should accept a Context.</li><li>Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it.</li><li>The chain of function calls between them must propagate the Context.</li><li>Replace a Context using WithCancel, WithDeadline, WithTimeout, or WithValue.</li><li>When a Context is canceled, all Contexts derived from it are also canceled.</li><li>The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines.</li><li>Do not pass a nil Context, even if a function permits it. Pass a TODO context if you are unsure about which Context to use.</li><li>Use context values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html</a><br><a href="https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html</a><br><a href="https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html</a><br><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_concurrency" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html#_concurrency</a><br><a href="https://golang.org/ref/mem" target="_blank" rel="noopener">https://golang.org/ref/mem</a><br><a href="https://blog.csdn.net/caoshangpa/article/details/78853919" target="_blank" rel="noopener">https://blog.csdn.net/caoshangpa/article/details/78853919</a><br><a href="https://blog.csdn.net/qcrao/article/details/92759907" target="_blank" rel="noopener">https://blog.csdn.net/qcrao/article/details/92759907</a><br><a href="https://cch123.github.io/ooo/" target="_blank" rel="noopener">https://cch123.github.io/ooo/</a><br><a href="https://blog.golang.org/codelab-share" target="_blank" rel="noopener">https://blog.golang.org/codelab-share</a><br><a href="https://dave.cheney.net/2018/01/06/" target="_blank" rel="noopener">https://dave.cheney.net/2018/01/06/</a></p><p><code>if-aligned-memory-writes-are-atomic-why-do-we-need-the-sync-atomic-package</code></p><p><a href="http://blog.golang.org/race-detector" target="_blank" rel="noopener">http://blog.golang.org/race-detector</a><br><a href="https://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races" target="_blank" rel="noopener">https://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races</a><br><a href="https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html</a><br><a href="https://medium.com/a-journey-with-go/" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/</a></p><p><code>go-how-to-reduce-lock-contention-with-the-atomic-package-ba3b2664b549</code></p><p><a href="https://medium.com/a-journey-with-go/go-discovery-of-the-trace-package-e5a821743c3c" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-discovery-of-the-trace-package-e5a821743c3c</a><br><a href="https://medium.com/a-journey-with-go/go-mutex-and-starvation-3f4f4e75ad50" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-mutex-and-starvation-3f4f4e75ad50</a><br><a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html</a><br><a href="https://medium.com/a-journey-with-go/go-buffered-and-unbuffered-channels-29a107c00268" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-buffered-and-unbuffered-channels-29a107c00268</a><br><a href="https://medium.com/a-journey-with-go/go-ordering-in-select-statements-fd0ff80fd8d6" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-ordering-in-select-statements-fd0ff80fd8d6</a><br><a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html</a><br><a href="https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html</a><br><a href="https://www.ardanlabs.com/blog/2013/10/my-channel-select-bug.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2013/10/my-channel-select-bug.html</a><br><a href="https://blog.golang.org/io2013-talk-concurrency" target="_blank" rel="noopener">https://blog.golang.org/io2013-talk-concurrency</a><br><a href="https://blog.golang.org/waza-talk" target="_blank" rel="noopener">https://blog.golang.org/waza-talk</a><br><a href="https://blog.golang.org/io2012-videos" target="_blank" rel="noopener">https://blog.golang.org/io2012-videos</a><br><a href="https://blog.golang.org/concurrency-timeouts" target="_blank" rel="noopener">https://blog.golang.org/concurrency-timeouts</a><br><a href="https://blog.golang.org/pipelines" target="_blank" rel="noopener">https://blog.golang.org/pipelines</a><br><a href="https://www.ardanlabs.com/blog/2014/02/running-queries-concurrently-against.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/02/running-queries-concurrently-against.html</a><br><a href="https://blogtitle.github.io/go-advanced-concurrency-patterns-part-3-channels/" target="_blank" rel="noopener">https://blogtitle.github.io/go-advanced-concurrency-patterns-part-3-channels/</a><br><a href="https://www.ardanlabs.com/blog/2013/05/thread-pooling-in-go-programming.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2013/05/thread-pooling-in-go-programming.html</a><br><a href="https://www.ardanlabs.com/blog/2013/09/pool-go-routines-to-process-task.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2013/09/pool-go-routines-to-process-task.html</a><br><a href="https://blogtitle.github.io/categories/concurrency/" target="_blank" rel="noopener">https://blogtitle.github.io/categories/concurrency/</a><br><a href="https://medium.com/@cep21/how-to-correctly-use-context-context-in-go-1-7-8f2c0fafdf39" target="_blank" rel="noopener">https://medium.com/@cep21/how-to-correctly-use-context-context-in-go-1-7-8f2c0fafdf39</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Goroutine&quot;&gt;&lt;a href=&quot;#Goroutine&quot; class=&quot;headerlink&quot; title=&quot;Goroutine
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="Golang" scheme="https://octopuslian.github.io/tags/Golang/"/>
    
      <category term="并行" scheme="https://octopuslian.github.io/tags/%E5%B9%B6%E8%A1%8C/"/>
    
      <category term="并发" scheme="https://octopuslian.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="goroutine" scheme="https://octopuslian.github.io/tags/goroutine/"/>
    
      <category term="channel" scheme="https://octopuslian.github.io/tags/channel/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-异常处理</title>
    <link href="https://octopuslian.github.io/2021/05/02/goatc-2-error/"/>
    <id>https://octopuslian.github.io/2021/05/02/goatc-2-error/</id>
    <published>2021-05-02T13:12:25.000Z</published>
    <updated>2021-05-02T14:47:44.274Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --><h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>Golang的<code>error</code>就是普通的一个接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span>&#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Error-vs-Exception"><a href="#Error-vs-Exception" class="headerlink" title="Error vs Exception"></a>Error vs Exception</h2><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>单返回值，一般通过传递指针作为入参，返回值为 int 表示成功还是失败。</p><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><p>引入了 exception，但是无法知道被调用方会抛出什么异常。</p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>引入了 checked exception，方法的所有者必须申明，调用者必须处理。在启动时抛出大量的异常是司空见惯的事情，并在它们的调用堆栈中尽职地记录下来。Java 异常不再是异常，而是变得司空见惯了。它们从良性到灾难性都有使用，异常的严重性由函数的调用者来区分。</p><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p>Go 的处理异常逻辑是不引入 exception，支持多参数返回，所以你很容易的在函数签名中带上实现了 error interface 的对象，交由调用者来判定。</p><p>如果一个函数返回了 value, error，你不能对这个 value 做任何假设，必须先判定 error。唯一可以忽略 error 的是，如果你连 value 也不关心。</p><p>Go 中有 panic 的机制，如果你认为和其他语言的 exception 一样，那你就错了。当我们抛出异常的时候，相当于你把 exception 扔给了调用者来处理。</p><p>比如，你在 C++ 中，把 string 转为 int，如果转换失败，会抛出异常。或者在 java 中转换 string 为 date 失败时，会抛出异常。</p><p>Go panic 意味着 fatal error(就是挂了)。不能假设调用者来解决 panic，意味着代码不能继续运行。<br>使用多个返回值和一个简单的约定，Go 解决了让程序员知道什么时候出了问题，并为真正的异常情况保留了 panic。</p><p>对于真正意外的情况，那些表示不可恢复的程序错误，例如索引越界、不可恢复的环境问题、栈溢出，我们才使用 panic。对于其他的错误情况，我们应该是期望使用 error 来进行判定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">you only need to check the error value if you care about the result.  -- Dave  </span><br><span class="line">This blog post from Microsoft’s engineering blog in 2005 still holds true today, namely:  </span><br><span class="line">My point isn’t that exceptions are bad. My point is that exceptions are too hard and I’m not smart enough to handle them.</span><br></pre></td></tr></table></figure><ul><li>简单。</li><li>考虑失败，而不是成功(Plan for failure, not success)。</li><li>没有隐藏的控制流。</li><li>完全交给你来控制 error。</li><li>Error are values。</li></ul><h2 id="Error-Type"><a href="#Error-Type" class="headerlink" title="Error Type"></a>Error Type</h2><h3 id="Sentinel-Error"><a href="#Sentinel-Error" class="headerlink" title="Sentinel Error"></a>Sentinel Error</h3><p>预定义的特定错误，我们叫为 sentinel error，这个名字来源于计算机编程中使用一个特定值来表示不可能进行进一步处理的做法。所以对于 Go，我们使用特定的值来表示错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err == ErrSomething &#123; … &#125;</span><br></pre></td></tr></table></figure><p>类似的 io.EOF，更底层的 syscall.ENOENT。</p><p>使用 sentinel 值是最不灵活的错误处理策略，因为调用方必须使用 == 将结果与预先声明的值进行比较。当您想要提供更多的上下文时，这就出现了一个问题，因为返回一个不同的错误将破坏相等性检查。</p><p>甚至是一些有意义的 fmt.Errorf 携带一些上下文，也会破坏调用者的 == ，调用者将被迫查看 error.Error() 方法的输出，以查看它是否与特定的字符串匹配。</p><ul><li><p>不依赖检查 error.Error 的输出。<br>不应该依赖检测 error.Error 的输出，Error 方法存在于 error 接口主要用于方便程序员使用，但不是程序(编写测试可能会依赖这个返回)。这个输出的字符串用于记录日志、输出到 stdout 等。</p></li><li><p>Sentinel errors 成为你 API 公共部分<br>如果您的公共函数或方法返回一个特定值的错误，那么该值必须是公共的，当然要有文档记录，这会增加 API 的表面积。<br>如果 API 定义了一个返回特定错误的 interface，则该接口的所有实现都将被限制为仅返回该错误，即使它们可以提供更具描述性的错误。<br>比如 io.Reader。像 io.Copy 这类函数需要 reader 的实现者比如返回 io.EOF 来告诉调用者没有更多数据了，但这又不是错误。</p></li><li><p>Sentinel errors 在两个包之间创建了依赖<br>sentinel errors 最糟糕的问题是它们在两个包之间创建了源代码依赖关系。例如，检查错误是否等于 io.EOF，您的代码必须导入 io 包。这个特定的例子听起来并不那么糟糕，因为它非常常见，但是想象一下，当项目中的许多包导出错误值时，存在耦合，项目中的其他包必须导入这些错误值才能检查特定的错误条件(in the form of an import loop)。</p></li><li><p>结论: 尽可能避免 sentinel errors<br>我的建议是避免在编写的代码中使用 sentinel errors。在标准库中有一些使用它们的情况，但这不是一个您应该模仿的模式。</p></li></ul><p><strong>Error type 是实现了 error 接口的自定义类型。</strong></p><h3 id="Opaque-errors"><a href="#Opaque-errors" class="headerlink" title="Opaque errors"></a>Opaque errors</h3><p>在我看来，这是最灵活的错误处理策略，因为它要求代码和调用者之间的耦合最少。<br>我将这种风格称为不透明错误处理，因为虽然您知道发生了错误，但您没有能力看到错误的内部。作为调用者，关于操作的结果，您所知道的就是它起作用了，或者没有起作用(成功还是失败)。<br>这就是不透明错误处理的全部功能–只需返回错误而不假设其内容。</p><ul><li>Assert errors for behaviour, not type<br>在少数情况下，这种二分错误处理方法是不够的。例如，与进程外的世界进行交互(如网络活动)，需要调用方调查错误的性质，以确定重试该操作是否合理。在这种情况下，我们可以断言错误实现了特定的行为，而不是断言错误是特定的类型或值。</li></ul><h2 id="Handling-Error"><a href="#Handling-Error" class="headerlink" title="Handling Error"></a>Handling Error</h2><h3 id="Indented-flow-is-for-errors"><a href="#Indented-flow-is-for-errors" class="headerlink" title="Indented flow is for errors"></a>Indented flow is for errors</h3><p>无错误的正常流程代码，将成为一条直线，而不是缩进的代码。</p><h3 id="Eliminate-error-handling-by-eliminating-errors"><a href="#Eliminate-error-handling-by-eliminating-errors" class="headerlink" title="Eliminate error handling by eliminating errors"></a>Eliminate error handling by eliminating errors</h3><p>(后面再细说)</p><h3 id="Wrap-erros"><a href="#Wrap-erros" class="headerlink" title="Wrap erros"></a>Wrap erros</h3><p>在程序的顶部，程序的主体将把错误打印到屏幕或日志文件中，打印出来的只是：没有这样的文件或目录。</p><p>没有生成错误的 file:line 信息。没有导致错误的调用堆栈的堆栈跟踪。这段代码的作者将被迫进行长时间的代码分割，以发现是哪个代码路径触发了文件未找到错误。</p><p>这种模式与 sentinel errors 或 type assertions 的使用不兼容，因为将错误值转换为字符串，将其与另一个字符串合并，然后将其转换回 fmt.Errorf 破坏了原始错误，导致等值判定失败。</p><p>Go 中的错误处理契约规定，在出现错误的情况下，不能对其他返回值的内容做出任何假设。由于 JSON 序列化失败，buf 的内容是未知的，可能它不包含任何内容，但更糟糕的是，它可能包含一个半写的 JSON 片段。</p><p>由于程序员在检查并记录错误后忘记 return，损坏的缓冲区将被传递给 WriteAll，这可能会成功，因此配置文件将被错误地写入。但是，该函数返回的结果是正确的。</p><p>日志记录与错误无关且对调试没有帮助的信息应被视为噪音，应予以质疑。记录的原因是因为某些东西失败了，而日志包含了答案。</p><ul><li>错误要被日志记录。</li><li>应用程序处理错误，保证100%完整性。</li><li>之后不再报告当前错误。</li></ul><h2 id="Go-1-13-errors"><a href="#Go-1-13-errors" class="headerlink" title="Go 1.13 errors"></a>Go 1.13 errors</h2><p>最简单的错误检查：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">//something went wrong</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><p>我们在数据库操作的时候，比如 dao 层中当遇到一个 sql.ErrNoRows 的时候，是否应该 Wrap 这个 error，抛给上层。为什么，应该怎么做请写出代码？</p><h2 id="Go-2-Error-Inspection"><a href="#Go-2-Error-Inspection" class="headerlink" title="Go 2 Error Inspection"></a>Go 2 Error Inspection</h2><p><a href="https://go.googlesource.com/proposal/+/master/design/29934-error-values.md" target="_blank" rel="noopener">https://go.googlesource.com/proposal/+/master/design/29934-error-values.md</a></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://dave.cheney.net/2012/01/18/why-go-gets-exceptions-right" target="_blank" rel="noopener">https://dave.cheney.net/2012/01/18/why-go-gets-exceptions-right</a><br><a href="https://dave.cheney.net/2015/01/26/errors-and-exceptions-redux" target="_blank" rel="noopener">https://dave.cheney.net/2015/01/26/errors-and-exceptions-redux</a><br><a href="https://dave.cheney.net/2014/11/04/error-handling-vs-exceptions-redux" target="_blank" rel="noopener">https://dave.cheney.net/2014/11/04/error-handling-vs-exceptions-redux</a><br><a href="https://rauljordan.com/2020/07/06/why-go-error-handling-is-awesome.html" target="_blank" rel="noopener">https://rauljordan.com/2020/07/06/why-go-error-handling-is-awesome.html</a><br><a href="https://morsmachine.dk/error-handling" target="_blank" rel="noopener">https://morsmachine.dk/error-handling</a><br><a href="https://blog.golang.org/error-handling-and-go" target="_blank" rel="noopener">https://blog.golang.org/error-handling-and-go</a><br><a href="https://www.ardanlabs.com/blog/2014/10/error-handling-in-go-part-i.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/10/error-handling-in-go-part-i.html</a><br><a href="https://www.ardanlabs.com/blog/2014/11/error-handling-in-go-part-ii.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/11/error-handling-in-go-part-ii.html</a><br><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully</a><br><a href="https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html" target="_blank" rel="noopener">https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html</a><br><a href="https://blog.golang.org/errors-are-values" target="_blank" rel="noopener">https://blog.golang.org/errors-are-values</a><br><a href="https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package" target="_blank" rel="noopener">https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package</a><br><a href="https://www.ardanlabs.com/blog/2017/05/design-philosophy-on-logging.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2017/05/design-philosophy-on-logging.html</a><br><a href="https://crawshaw.io/blog/xerrors" target="_blank" rel="noopener">https://crawshaw.io/blog/xerrors</a><br><a href="https://blog.golang.org/go1.13-errors" target="_blank" rel="noopener">https://blog.golang.org/go1.13-errors</a><br><a href="https://medium.com/gett-engineering/error-handling-in-go-53b8a7112d04" target="_blank" rel="noopener">https://medium.com/gett-engineering/error-handling-in-go-53b8a7112d04</a><br><a href="https://medium.com/gett-engineering/error-handling-in-go-1-13-5ee6d1e0a55c" target="_blank" rel="noopener">https://medium.com/gett-engineering/error-handling-in-go-1-13-5ee6d1e0a55c</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Error&quot;&gt;&lt;a href=&quot;#Error&quot; class=&quot;headerlink&quot; title=&quot;Error&quot;&gt;&lt;/a&gt;Error&lt;
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="Golang" scheme="https://octopuslian.github.io/tags/Golang/"/>
    
      <category term="error" scheme="https://octopuslian.github.io/tags/error/"/>
    
      <category term="异常" scheme="https://octopuslian.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 42.trapping-rain-water | 接雨水</title>
    <link href="https://octopuslian.github.io/2021/04/25/leetcode-42-trapping-rain-water/"/>
    <id>https://octopuslian.github.io/2021/04/25/leetcode-42-trapping-rain-water/</id>
    <published>2021-04-25T05:57:53.000Z</published>
    <updated>2021-04-25T05:59:55.292Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left, right, leftMax, rightMax, res <span class="keyword">int</span></span><br><span class="line">right = <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line"><span class="keyword">if</span> height[left] &lt; height[right] &#123;</span><br><span class="line"><span class="keyword">if</span> height[left] &gt;= leftMax &#123;</span><br><span class="line"><span class="comment">//设置左边最高柱子</span></span><br><span class="line">leftMax = height[left]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//右边必定有柱子挡水，所以，遇到所有值小于等于leftMax的，全部加入水池</span></span><br><span class="line">res += leftMax - height[left]</span><br><span class="line">&#125;</span><br><span class="line">left++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> height[right] &gt; rightMax &#123; </span><br><span class="line"><span class="comment">//设置右边最高柱子</span></span><br><span class="line">rightMax = height[right] </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//左边必定有柱子挡水，所以，遇到所有值小于等于rightMax的，全部加入水池</span></span><br><span class="line">res += rightMax - height[right] </span><br><span class="line">&#125;</span><br><span class="line">right--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 12. 矩阵中的路径</title>
    <link href="https://octopuslian.github.io/2021/04/25/leetcode-lcof-12-ju-zhen-zhong-de-lu-jing/"/>
    <id>https://octopuslian.github.io/2021/04/25/leetcode-lcof-12-ju-zhen-zhong-de-lu-jing/</id>
    <published>2021-04-25T05:52:34.000Z</published>
    <updated>2021-04-27T09:50:44.097Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>题目同<a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">leetcode 70.word-search</a></p><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><h3 id="DFS解法"><a href="#DFS解法" class="headerlink" title="DFS解法"></a>DFS解法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exist</span><span class="params">(board [][]<span class="keyword">byte</span>, word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> row := <span class="number">0</span>; row &lt; <span class="built_in">len</span>(board); row ++&#123;</span><br><span class="line">        <span class="keyword">for</span> col := <span class="number">0</span>;col &lt; <span class="built_in">len</span>(board[row]); col ++&#123;</span><br><span class="line">            <span class="keyword">if</span> dfs(board, word, row, col, <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(board [][]<span class="keyword">byte</span>, word <span class="keyword">string</span>, i, j, idx <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">//越界或者字符不相等</span></span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span> || i &gt;= <span class="built_in">len</span>(board) || </span><br><span class="line">    j &lt; <span class="number">0</span> || j &gt;= <span class="built_in">len</span>(board[<span class="number">0</span>]) || </span><br><span class="line">    board[i][j] != word[idx] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> idx == <span class="built_in">len</span>(word) - <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标记已被访问</span></span><br><span class="line">    tmpCh := board[i][j]</span><br><span class="line">    board[i][j] = <span class="string">'/'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//上下左右检查一下</span></span><br><span class="line">    check := (dfs(board, word, i+<span class="number">1</span>, j, idx+<span class="number">1</span>) || dfs(board, word, i<span class="number">-1</span>, j, idx + <span class="number">1</span>) || </span><br><span class="line">    dfs(board, word, i, j+<span class="number">1</span>, idx+<span class="number">1</span>) || dfs(board, word, i, j<span class="number">-1</span>, idx+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复</span></span><br><span class="line">    board[i][j] = tmpCh</span><br><span class="line">    <span class="keyword">return</span> check</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="LeetCode-lcof-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-lcof-Solutions/"/>
    
    
      <category term="BFS" scheme="https://octopuslian.github.io/tags/BFS/"/>
    
      <category term="矩阵路径" scheme="https://octopuslian.github.io/tags/%E7%9F%A9%E9%98%B5%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 329.longest-increasing-path-in-a-matrix | 矩阵中的最长递增路径</title>
    <link href="https://octopuslian.github.io/2021/04/25/leetcode-329-longest-increasing-path-in-a-matrix/"/>
    <id>https://octopuslian.github.io/2021/04/25/leetcode-329-longest-increasing-path-in-a-matrix/</id>
    <published>2021-04-25T05:02:21.000Z</published>
    <updated>2021-04-27T09:54:34.238Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。</p><p><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">329. 矩阵中的最长递增路径</a></p><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rangeSumBST</span><span class="params">(root *TreeNode, low <span class="keyword">int</span>, high <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &gt; high &#123;</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(root.Left, low, high)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &lt; low &#123;</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(root.Right, low, high)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root.Val + rangeSumBST(root.Left, low, high) + rangeSumBST(root.Right, low, high)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="宽度优先搜索（待完善）"><a href="#宽度优先搜索（待完善）" class="headerlink" title="宽度优先搜索（待完善）"></a>宽度优先搜索（待完善）</h3><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
      <category term="BFS" scheme="https://octopuslian.github.io/tags/BFS/"/>
    
      <category term="DFS" scheme="https://octopuslian.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 179.largest-number | 最大数</title>
    <link href="https://octopuslian.github.io/2021/04/25/leetcode-179-largest-number/"/>
    <id>https://octopuslian.github.io/2021/04/25/leetcode-179-largest-number/</id>
    <published>2021-04-25T04:50:11.000Z</published>
    <updated>2021-04-26T07:00:34.645Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p><p>注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [10,2]</span><br><span class="line">输出：&quot;210&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [3,30,34,5,9]</span><br><span class="line">输出：&quot;9534330&quot;</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [1]</span><br><span class="line">输出：&quot;1&quot;</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：nums = [10]</span><br><span class="line">输出：&quot;10&quot;</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">1 &lt;= nums.length &lt;= 100</span><br><span class="line">0 &lt;= nums[i] &lt;= 109</span><br></pre></td></tr></table></figure><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 10- II. 青蛙跳台阶问题</title>
    <link href="https://octopuslian.github.io/2021/04/25/leetcode-lcof-10-ii-qing-wa-tiao-tai-jie-wen-ti/"/>
    <id>https://octopuslian.github.io/2021/04/25/leetcode-lcof-10-ii-qing-wa-tiao-tai-jie-wen-ti/</id>
    <published>2021-04-25T04:44:37.000Z</published>
    <updated>2021-04-25T04:49:34.550Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;= n &lt;= 100</span><br></pre></td></tr></table></figure><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><h3 id="循环求余法"><a href="#循环求余法" class="headerlink" title="循环求余法"></a>循环求余法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numWays</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    a := <span class="number">1</span></span><br><span class="line">    b := <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; n;i++ &#123;</span><br><span class="line">        sum = (a + b) % <span class="number">1000000007</span></span><br><span class="line">        a = b</span><br><span class="line">        b = sum</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="LeetCode-lcof-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-lcof-Solutions/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
      <category term="青蛙跳台阶" scheme="https://octopuslian.github.io/tags/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>九章算法基础-宽度优先搜索</title>
    <link href="https://octopuslian.github.io/2021/04/23/jiu-zhang-algo-elementary-bfs/"/>
    <id>https://octopuslian.github.io/2021/04/23/jiu-zhang-algo-elementary-bfs/</id>
    <published>2021-04-23T13:37:06.000Z</published>
    <updated>2021-04-26T07:00:34.643Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><h3 id="二叉树上的宽搜"><a href="#二叉树上的宽搜" class="headerlink" title="二叉树上的宽搜"></a>二叉树上的宽搜</h3><h3 id="图上的宽搜"><a href="#图上的宽搜" class="headerlink" title="图上的宽搜"></a>图上的宽搜</h3><p>拓扑排序</p><h3 id="棋盘上的宽搜"><a href="#棋盘上的宽搜" class="headerlink" title="棋盘上的宽搜"></a>棋盘上的宽搜</h3><h2 id="什么时候应该使用BFS"><a href="#什么时候应该使用BFS" class="headerlink" title="什么时候应该使用BFS"></a>什么时候应该使用BFS</h2><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><ul><li>层级遍历</li><li>由点及面</li><li>拓扑排序</li></ul><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><ul><li>仅限简单图求最短路径</li><li>图中每条边长度是1，没有方向</li></ul><h3 id="题目是最短路径，除了BFS还有什么算法"><a href="#题目是最短路径，除了BFS还有什么算法" class="headerlink" title="题目是最短路径，除了BFS还有什么算法"></a>题目是最短路径，除了BFS还有什么算法</h3><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;大纲&quot;&gt;&lt;a href=&quot;#大纲&quot; class=&quot;headerlink&quot; title=&quot;大纲&quot;&gt;&lt;/a&gt;大纲&lt;/h2&gt;&lt;h3 id=&quot;
      
    
    </summary>
    
    
      <category term="JZCourse" scheme="https://octopuslian.github.io/categories/JZCourse/"/>
    
    
      <category term="宽度优先搜索" scheme="https://octopuslian.github.io/tags/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="九章" scheme="https://octopuslian.github.io/tags/%E4%B9%9D%E7%AB%A0/"/>
    
      <category term="算法基础" scheme="https://octopuslian.github.io/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>四川省都江堰市青城后山一日游</title>
    <link href="https://octopuslian.github.io/2021/04/21/qing-cheng-hou-shan-one-day-trip/"/>
    <id>https://octopuslian.github.io/2021/04/21/qing-cheng-hou-shan-one-day-trip/</id>
    <published>2021-04-21T14:24:02.000Z</published>
    <updated>2021-04-21T14:25:30.609Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --><p>上周五去跟一位朋友约去爬山，地点选在都江堰市的青城山，本文将详细分享旅游攻略，以及旅行完的顿悟。</p><h2 id="出发前"><a href="#出发前" class="headerlink" title="出发前"></a>出发前</h2><p>出发之前，我和袁准备了一个背包，想着先爬到山上再去补给。</p><p>我和袁住在成都市，早上7点半约好见面，吃过早餐坐地铁到犀浦，然后转城际列车(10元/人)到青城山下车即可。建议如果去青城山最好直接上车前买直达，不然到车上补票还需要另外收费。</p><p>到了青城山车站出来，由于我们是要去的后山，自然景观丰富，空气清新，因此我们两人打了个车，一个人15（景区要16，还有等一会，小车直接走）。在此需要提醒：由于是上山的路且弯道众多，因此可能会晕车。</p><p>到了泰安古镇，也就是景区的入口处，我们吃了顿午饭（还是有些小贵），买了20元/人的门票，就开始爬山了。</p><h2 id="上山过程"><a href="#上山过程" class="headerlink" title="上山过程"></a>上山过程</h2><p>我们白天爬，感觉都还好，不是很热，沿途有各种卖饮料的，不过价格稍贵，水5元、饮料10元，棒棒糖3元一根。</p><p>爬到半山腰大概3个小时，然后有缆车可以往返，不过我们年轻小伙子想着多运动，于是就没有坐缆车（这是我最后悔的决定）。接着就开始体力不支，因为大多是上坡，很累，爬一会就得休息一下，不过还好在5点的时候（用了两个小时）爬到了白云寺，拜了拜佛，然后准备下山，这时候从卖饮料的大妈口中得知，5点半缆车停运！！！</p><h2 id="下山过程"><a href="#下山过程" class="headerlink" title="下山过程"></a>下山过程</h2><p>下山稍微轻松，但腿开始软了，感到走不动路，看着手机上还有几百米的距离到达缆车地点，我真想飞过去。结果我们5点20到那里后，人家告诉我缆车工作人员早就下班了，我不甘心，下去看了一眼，果然都停了，于是在想怎么办。有个姐姐告诉我下山大概一个小时可以坐船，坐上船后再走一个小时就下山了，我们一看时间，嗯，争取赶晚上8点下山，然后坐列车回成都。</p><p>结果坐船说过了运营时间，要涨价，5元/人（正常是2元/人）。行吧，就这样，结果坐完船就开始晕，恶心，头晕，心跳的贼快，于是朋友叫我先休息，最后休息到7点往下走，还是感到不舒服，没办法，直接叫救援。</p><h2 id="救援过程"><a href="#救援过程" class="headerlink" title="救援过程"></a>救援过程</h2><p>首先打完救援电话后，被告知救援费要1000元，我在犹豫间朋友已经替我答应了，挂了电话对我说，钱花了可以挣，但一定要保证你的安全。于是，我们在夜幕降临的过程中，用手机闪光灯照着周围环境，防止有蛇、虫子之类的靠近，同时我们也看到草丛里有一双泛着黄光的动物眼睛盯着我们。</p><p>等了大概一个小时，救援队上来，把我抬了下去，最后由120救护车把我送到医院做检查。</p><p>身体没有大碍，就心跳的太快了，于是开了一些降心率的药，叮嘱我回成都市了要好好检查。</p><p>就这样，在一天中结束了自己跌宕起伏的青城的后山爬山之旅。</p><h2 id="此次旅行感悟"><a href="#此次旅行感悟" class="headerlink" title="此次旅行感悟"></a>此次旅行感悟</h2><ul><li>有时候不能硬撑，实在走不动了，就用钱代替交通；</li><li>钱没了可以再挣，身体是最重要的；</li><li>出发前做好旅行规划很重要；</li><li>体检有不舒服的就赶紧去查，防止小病拖成大病；</li><li>不要把问题想的太严重，总会有解决之道。</li></ul><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;上周五去跟一位朋友约去爬山，地点选在都江堰市的青城山，本文将详细分享旅游攻略，以及旅行完的顿悟。&lt;/p&gt;&lt;h2 id=&quot;出发前&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="Travel-notes" scheme="https://octopuslian.github.io/categories/Travel-notes/"/>
    
    
      <category term="旅行" scheme="https://octopuslian.github.io/tags/%E6%97%85%E8%A1%8C/"/>
    
      <category term="青城山" scheme="https://octopuslian.github.io/tags/%E9%9D%92%E5%9F%8E%E5%B1%B1/"/>
    
      <category term="都江堰" scheme="https://octopuslian.github.io/tags/%E9%83%BD%E6%B1%9F%E5%A0%B0/"/>
    
  </entry>
  
  <entry>
    <title>玩转docker-核心知识概述</title>
    <link href="https://octopuslian.github.io/2021/04/08/fun-with-docker-1-core-knowledge/"/>
    <id>https://octopuslian.github.io/2021/04/08/fun-with-docker-1-core-knowledge/</id>
    <published>2021-04-08T02:14:24.000Z</published>
    <updated>2021-04-26T07:00:34.645Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --><h2 id="What——什么是容器"><a href="#What——什么是容器" class="headerlink" title="What——什么是容器"></a>What——什么是容器</h2><p>容器由两部分组成：（1）应用程序本身；（2）依赖：比如应用程序需要的库或其他软件容器在Host操作系统的用户空间中运行，与操作系统的其他进程隔离。这一点显著区别于的虚拟机。</p><p>传统的虚拟化技术，比如VMWare、KVM、Xen，目标是创建完整的虚拟机。为了运行应用，除了部署应用本身及其依赖（通常几十MB），还得安装整个操作系统（几十GB）。</p><h2 id="Why——为什么需要容器"><a href="#Why——为什么需要容器" class="headerlink" title="Why——为什么需要容器"></a>Why——为什么需要容器</h2><p>容器使软件具备了超强的可移植能力。</p><p>Docker将集装箱思想运用到软件打包上，为代码提供了一个基于容器的标准化运输系统。Docker可以将任何应用及其依赖打包成一个轻量级、可移植、自包含的容器。容器可以运行在几乎所有的操作系统上</p><h3 id="容器的优势"><a href="#容器的优势" class="headerlink" title="容器的优势"></a>容器的优势</h3><p>对于开发人员：Build Once、Run Anywhere。</p><p>对于运维人员：Configure Once、Run Anything。</p><h2 id="How——容器是如何工作的"><a href="#How——容器是如何工作的" class="headerlink" title="How——容器是如何工作的"></a>How——容器是如何工作的</h2><h3 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h3><p>Docker的核心组件包括：<br>● Docker客户端：Client<br>● Docker服务器：Docker daemon<br>● Docker镜像：Image● Registry<br>● Docker容器：Container</p><h3 id="Docker客户端"><a href="#Docker客户端" class="headerlink" title="Docker客户端"></a>Docker客户端</h3><p>最常用的Docker客户端是docker命令。通过docker我们可以方便地在Host上构建和运行容器。</p><h3 id="Docker服务器"><a href="#Docker服务器" class="headerlink" title="Docker服务器"></a>Docker服务器</h3><p>Docker daemon是服务器组件，以Linux后台服务的方式运行</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;What——什么是容器&quot;&gt;&lt;a href=&quot;#What——什么是容器&quot; class=&quot;headerlink&quot; title=&quot;What—
      
    
    </summary>
    
    
      <category term="Learn-Docker" scheme="https://octopuslian.github.io/categories/Learn-Docker/"/>
    
    
      <category term="docker" scheme="https://octopuslian.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>玩转Docker-鸟瞰容器生态系统</title>
    <link href="https://octopuslian.github.io/2021/04/08/fun-with-docker-0-container-ecosystem/"/>
    <id>https://octopuslian.github.io/2021/04/08/fun-with-docker-0-container-ecosystem/</id>
    <published>2021-04-08T02:13:26.000Z</published>
    <updated>2021-04-08T14:27:39.406Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --><p>这篇文章有一张思维导图足以</p><p><img src="/2021/04/08/fun-with-docker-0-container-ecosystem/container.jpg" alt></p><p>意外发现一本国人写的《玩转Docker容器技术》，好好学习一下Docker系列，就从开头为<code>fun with...</code>开始。</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;这篇文章有一张思维导图足以&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/2021/04/08/fun-with-docker-0-container-ec
      
    
    </summary>
    
    
      <category term="Learn-Docker" scheme="https://octopuslian.github.io/categories/Learn-Docker/"/>
    
    
  </entry>
  
  <entry>
    <title>今年终于要开始忙了</title>
    <link href="https://octopuslian.github.io/2021/04/07/first-entrepreneurship/"/>
    <id>https://octopuslian.github.io/2021/04/07/first-entrepreneurship/</id>
    <published>2021-04-07T02:08:18.000Z</published>
    <updated>2021-04-10T02:04:01.601Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --><p>昨天收到两条消息，我的副业&amp;创业终于要开始了。</p><p>聊天1：</p><p><img src="/2021/04/07/first-entrepreneurship/weixin1.png" alt></p><p>和川大计算机硕士毕业的学长一起做一款程序，预计9月初上线。</p><p>这位学长我是意外在工作中认识的，后来他毕业后，我俩有次在望江楼公园闲聊，他说他第一眼看到我就觉得我是个非常<code>nice</code>的人。我笑了笑说，一般对我没有攻击的我我都会真诚以待，不造谣，隐私除外。</p><p>技术和市场都做完调研，但对我来说是一块全新的领域。</p><p>聊天2：</p><p><img src="/2021/04/07/first-entrepreneurship/weixin2.png" alt></p><p>和清华在读博士的创业。</p><p>2月底他找到我时，问我有没有兴趣做这个，他目前拿到第一笔融资，想等9月中旬项目第一版上线后再去谈下一笔融资。我不懂融资，但我信过他这个人，从本科时接触他写的<a href="http://www.demongan.com/" target="_blank" rel="noopener">恶魔的世界</a>，到硕士出了一本黑客书籍，并创办了<a href="https://www.write-bug.com/" target="_blank" rel="noopener">WRITR-BUG技术共享平台</a>，在他身上我看到了许多将不可能转换为可能的事情。</p><p>2017年夏天我和他在北邮相遇，非常帅气的小伙子，带我逛了北邮，同时在他面前班门弄斧了一下汇编，哈哈</p><p>2月底他打电话说如果我要做的话，就会给我发工资，我说你即使不给我发工资我也愿意做。我嘛，总觉得按部就班的会缺少一些什么，你给我的这次机会，我要好好把握，我觉得我的一生，总要去尝试一些没有做过的事情。</p><p>半年时间，半年后，我会来这里还愿。</p><p>GOOD LUCK~</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;昨天收到两条消息，我的副业&amp;amp;创业终于要开始了。&lt;/p&gt;&lt;p&gt;聊天1：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/2021/04/07/first
      
    
    </summary>
    
    
      <category term="Try-to-Challenges" scheme="https://octopuslian.github.io/categories/Try-to-Challenges/"/>
    
    
      <category term="项目" scheme="https://octopuslian.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="创业" scheme="https://octopuslian.github.io/tags/%E5%88%9B%E4%B8%9A/"/>
    
      <category term="融资" scheme="https://octopuslian.github.io/tags/%E8%9E%8D%E8%B5%84/"/>
    
      <category term="技术" scheme="https://octopuslian.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>十年之约</title>
    <link href="https://octopuslian.github.io/2021/03/31/happy-25-birthday-ten-years-promise/"/>
    <id>https://octopuslian.github.io/2021/03/31/happy-25-birthday-ten-years-promise/</id>
    <published>2021-03-31T12:33:56.000Z</published>
    <updated>2021-03-31T14:21:24.249Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --><p>种一棵树最好的时间是十年前，其次是现在。</p><h2 id="过去十年"><a href="#过去十年" class="headerlink" title="过去十年"></a>过去十年</h2><h3 id="心中的童话镇"><a href="#心中的童话镇" class="headerlink" title="心中的童话镇"></a>心中的童话镇</h3><p>心中至今还记得， 大三暑假那会，每天早晨去公园散步，然后吃一碗粥，再加几个馒头，过几天换成可口的豆腐脑，上午看会《新概念英语》，睡个午觉，下午在卧室看一会小说，打一小会游戏，然后抱着冰镇的西瓜边啃边看剧的欢乐时光，偶尔想起几个好友，约着去体育公园打球，亦或是去是自助餐和看电影。</p><p>也许这就是我心中理想的幸福生活。</p><p>只是，我知道，我终将是要离开父母，独自去生活。</p><h3 id="高中三年"><a href="#高中三年" class="headerlink" title="高中三年"></a>高中三年</h3><p>收获最多的就是结识了几位良师益友，他们给予过我鼓励，安慰和期望，让我坚定自己的目标，不断向前。</p><h3 id="大学四年"><a href="#大学四年" class="headerlink" title="大学四年"></a>大学四年</h3><p>感触最多的是从大学同班同学何和唐身上学到的，也是我毕业后一直保持联系的人。</p><p>大一时我曾对何不以为然，觉得他只是个会考试会背题的机器罢了。直到大四机缘巧合搬进了何的宿舍，跟他做了一学期舍友，才发现我错了。</p><p>曾经我通过打算法竞赛和写博客结识了很多北京上海的竞赛大佬，直到我将他们和何对比了一下，才发现都有共通点，这一点我在唐的身上也看到了。</p><p>所以，我在大三的时候，抛弃了所有所谓的荣誉、职务，专心做自己觉得有价值的事情，因为那样我觉得才是踏实的。</p><h3 id="工作接近三年"><a href="#工作接近三年" class="headerlink" title="工作接近三年"></a>工作接近三年</h3><p>上班三年，实现了自己小时候想当工程师的梦想，从游戏服务端开发工程师到图形图像算法工程师，再到<code>Golang</code>后端研发工程师以及兼职的音视频工程师，虽然<code>title</code>在变，但一直不变的就是加班以及研发在国内卑微的地位。嗯，这和我小时候的设想的貌似不太一样呢。</p><h2 id="一些顿悟"><a href="#一些顿悟" class="headerlink" title="一些顿悟"></a>一些顿悟</h2><h3 id="对996以及加班的感悟"><a href="#对996以及加班的感悟" class="headerlink" title="对996以及加班的感悟"></a>对996以及加班的感悟</h3><ul><li>命是自己的，即使加班出事故了，企业也买了保险，大不了用废了再换一个，但自己的生命只有一次，这是大前提；</li><li>结合三年加班的经验，以及吸收消化那些加班场景，无非就是项目上线出事故或者是老板想看你好不好使唤（阶级思想），这是国内私企大部分加班的根本原因；</li><li>活是做不完的，即使做完了，老板也不会感慨你效率多高，而会开心的说自己花一个人的价钱省了三个人的成本。</li></ul><p>因此，结合以上三点，在保持不会没有存款的大前提之下，我会尽量边提升自己的技术，边找一些管理规范且<code>nice</code>的企业，小企业就不去浪费时间和精力了。</p><h3 id="关于离职"><a href="#关于离职" class="headerlink" title="关于离职"></a>关于离职</h3><p>感到是一种解脱，是从封闭的办公室，嘈杂的喧闹声和咳嗽声后带来的一份宁静。</p><h3 id="关于本科学历"><a href="#关于本科学历" class="headerlink" title="关于本科学历"></a>关于本科学历</h3><p>这是个沉重的话题，因为它会跟到你老。面试的时候会决定你和名校毕业生的起点，关系到升职加薪等等等。可能我刚毕业会担心，但经过这三年的洗礼，以及和一位南天信息的技术专家的沟通，我验证并得出了结论：<strong>只要你一直更新自己的知识储备，就永远不会被这个社会淘汰。</strong></p><h3 id="关于离别"><a href="#关于离别" class="headerlink" title="关于离别"></a>关于离别</h3><p>小学毕业时，我哭了，想着毕业后大家一定要常聚；初中毕业时，我悄悄地哭，想着以后还在一座城市，可以常聚；高中毕业时，我忍住没哭，即使高考结束后我依旧会突然从8点多惊醒，想着快迟到了；大学毕业时，我没有哭，平静的收拾好自己的行李，拿好毕业证学位证，定好火车票，就此离去；工作了，偶尔在机场碰到我的高中同班同学，惊喜、意外接踵而至，但这些过后呢，依旧平静，然后错过。</p><p>曾经我比喻两个人的关系就像平行线，如果相交后，错过可能就再也见不到了，是这样的。</p><p>在乌鲁木齐时失去了一个从幼儿园玩到大学的好朋友，那时我会失眠，会迷茫，像是生命中突然缺少了什么东西似的。直到大学毕业前，父母问起我和他还有联系没，我心中都会隐隐作痛后摇摇头，但我又无能为力。直到毕业后，我突然顿悟，有时候也许就是两个人缘分尽了就平静的看待吧，想想快乐的事情——两个人从小学相互打闹；初中因为没有手机就互传书信，就差买只鸽子做飞鸽传书了；相互请教理综和数学题；周末约着一起去打球或者看电影；老师看到我俩还以为是亲兄弟…哈哈。</p><p>如果要离别，我会微笑，会真诚的对你说一声：<strong>谢谢你，曾出现在我的回忆里，感谢相遇，离别保重。</strong>。然后继续走好我自己的路。</p><h2 id="未来十年"><a href="#未来十年" class="headerlink" title="未来十年"></a>未来十年</h2><ul><li>用一年时间沉淀自己的基础，深入后端开发；</li><li>用两年时间搭建自己的副业体系的雏形并开始运作；</li><li>用三年时间提升一下自己的核心竞争力，并尝试横向拓宽自己的技术面；</li><li>用四年时间丰富自己工作履历和项目经验，争取达到专家级别；</li><li>拥有自己的一套房；</li><li>注：以上流程可以交替并发运作。</li></ul><h2 id="十年的约定"><a href="#十年的约定" class="headerlink" title="十年的约定"></a>十年的约定</h2><p>回想起，我在大三时在北邮遇见了<code>DemonGan</code>，他给自己在一定时间内定了个目标，然后好长时间没发朋友圈，突然在研三之际发布保博清华；我也在大二时受到一位北大毕业的天使投资人的影响，他说<strong>优秀的人相互都是吸引的</strong>，于是我明白了——需要先让自己变强，才有和大佬共同合作的资本，所以，做一个可以创造价值的人，是我未来十年的要实现的理想。</p><p>因此，我也在25岁生日来临之际，给自己定个目标————十年之约。十年后，我35岁，即使不做技术，我也希望我的副业可以支撑着我的日常开销，我想到那时，我才是真正实现了财务自由以及真正在做着有意义的事情。</p><p>GOOD LUCK:)</p><p><img src="/2021/03/31/happy-25-birthday-ten-years-promise/dream.jpg" alt></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;种一棵树最好的时间是十年前，其次是现在。&lt;/p&gt;&lt;h2 id=&quot;过去十年&quot;&gt;&lt;a href=&quot;#过去十年&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="Happy-Birthday" scheme="https://octopuslian.github.io/categories/Happy-Birthday/"/>
    
    
      <category term="成长" scheme="https://octopuslian.github.io/tags/%E6%88%90%E9%95%BF/"/>
    
      <category term="生日祝福" scheme="https://octopuslian.github.io/tags/%E7%94%9F%E6%97%A5%E7%A5%9D%E7%A6%8F/"/>
    
      <category term="随笔" scheme="https://octopuslian.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="顿悟" scheme="https://octopuslian.github.io/tags/%E9%A1%BF%E6%82%9F/"/>
    
      <category term="约定" scheme="https://octopuslian.github.io/tags/%E7%BA%A6%E5%AE%9A/"/>
    
      <category term="承诺" scheme="https://octopuslian.github.io/tags/%E6%89%BF%E8%AF%BA/"/>
    
  </entry>
  
  <entry>
    <title>汇总LeetCode实现数据结构和算法的题目</title>
    <link href="https://octopuslian.github.io/2021/03/05/leetcode-all-achieve-data-structure-and-algo-problems/"/>
    <id>https://octopuslian.github.io/2021/03/05/leetcode-all-achieve-data-structure-and-algo-problems/</id>
    <published>2021-03-05T15:23:24.000Z</published>
    <updated>2021-03-13T14:09:03.379Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --><p>汇总各种实现数据结构和算法的<code>LeetCode</code>题目，等刷完《剑指offer》后将重点关注的题目，通过边刷题边梳理数据结构算法的知识。</p><h2 id="链表-跳表"><a href="#链表-跳表" class="headerlink" title="链表-跳表"></a>链表-跳表</h2><p><a href="https://leetcode-cn.com/problems/design-linked-list/" target="_blank" rel="noopener">707. 设计链表</a></p><p><a href="https://leetcode-cn.com/problems/design-skiplist/" target="_blank" rel="noopener">1206. 设计跳表</a></p><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><p><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 09. 用两个栈实现队列</a></p><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232. 用栈实现队列</a></p><p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/" target="_blank" rel="noopener">225. 用队列实现栈</a></p><p><a href="https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/" target="_blank" rel="noopener">1381. 设计一个支持增量操作的栈</a></p><p><a href="https://leetcode-cn.com/problems/design-circular-queue/" target="_blank" rel="noopener">622. 设计循环队列</a></p><p><a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">641. 设计循环双端队列</a></p><p><a href="https://leetcode-cn.com/problems/design-front-middle-back-queue/" target="_blank" rel="noopener">1670. 设计前中后队列</a></p><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p><a href="https://leetcode-cn.com/problems/design-hashset/" target="_blank" rel="noopener">705. 设计哈希集合</a></p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 07. 重建二叉树</a></p><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/" target="_blank" rel="noopener">剑指 Offer 27. 二叉树的镜像</a></p><p><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 28. 对称的二叉树</a></p><p><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 33. 二叉搜索树的后序遍历序列</a></p><p><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/" target="_blank" rel="noopener">剑指 Offer 37. 序列化二叉树</a></p><p><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. 平衡二叉树</a></p><p><a href="https://leetcode-cn.com/problems/minimum-height-trees/" target="_blank" rel="noopener">310. 最小高度树</a></p><p><a href="https://leetcode-cn.com/problems/design-circular-deque/" target="_blank" rel="noopener">641. 设计循环双端队列</a></p><p><a href="https://leetcode-cn.com/problems/design-front-middle-back-queue/" target="_blank" rel="noopener">1670. 设计前中后队列</a></p><p><a href="https://leetcode-cn.com/problems/er-cha-shu-ren-wu-diao-du/" target="_blank" rel="noopener">LCP 10. 二叉树任务调度</a></p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU 缓存机制</a></p><h2 id="场景设计"><a href="#场景设计" class="headerlink" title="场景设计"></a>场景设计</h2><p><a href="https://leetcode-cn.com/problems/design-twitter/" target="_blank" rel="noopener">355. 设计推特</a></p><p><a href="https://leetcode-cn.com/problems/design-hashset/" target="_blank" rel="noopener">705. 设计哈希集合</a></p><p><a href="https://leetcode-cn.com/problems/design-hashmap/" target="_blank" rel="noopener">706. 设计哈希映射</a></p><p><a href="https://leetcode-cn.com/problems/design-underground-system/" target="_blank" rel="noopener">1396. 设计地铁系统</a></p><p><a href="https://leetcode-cn.com/problems/design-browser-history/" target="_blank" rel="noopener">1472. 设计浏览器历史记录</a></p><p><a href="https://leetcode-cn.com/problems/design-parking-system/" target="_blank" rel="noopener">1603. 设计停车系统</a></p><p><a href="https://leetcode-cn.com/problems/design-an-ordered-stream/" target="_blank" rel="noopener">1656. 设计有序流</a></p><p><a href="https://leetcode-cn.com/problems/goal-parser-interpretation/" target="_blank" rel="noopener">1678. 设计 Goal 解析器</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;汇总各种实现数据结构和算法的&lt;code&gt;LeetCode&lt;/code&gt;题目，等刷完《剑指offer》后将重点关注的题目，通过边刷题边梳理数据结构
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
      <category term="算法" scheme="https://octopuslian.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://octopuslian.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 07. 重建二叉树</title>
    <link href="https://octopuslian.github.io/2021/03/05/leetcode-lcof-07-zhong-jian-er-cha-shu/"/>
    <id>https://octopuslian.github.io/2021/03/05/leetcode-lcof-07-zhong-jian-er-cha-shu/</id>
    <published>2021-03-05T10:42:24.000Z</published>
    <updated>2021-03-05T10:57:22.032Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">力扣-剑指 Offer 07. 重建二叉树</a></p><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">例如，给出</span><br><span class="line"></span><br><span class="line">前序遍历 preorder = [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line"></span><br><span class="line">0 &lt;= 节点个数 &lt;= 5000</span><br></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>二叉树的遍历顺序</li></ul><p>1，前序（Pre-order）：根-左-右<br>2，中序（In-order）：左-根-右<br>3，后序（Post-order）：左-右-根</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>难度为中等。</p><h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><p>按题目给的示例来划分：<br>前序遍历划分 [ 3 | 9 | 20 15 7 ]<br>中序遍历划分 [ 9 | 3 | 15 20 7 ]</p><p>根据以上性质，可得出以下推论：</p><ul><li>前序遍历的首元素 为 树的根节点 <code>node</code> 的值。</li><li>在中序遍历中搜索根节点 <code>node</code> 的索引 ，可将 中序遍历 划分为 [ 左子树 | 根节点 | 右子树 ] 。</li><li>根据中序遍历中的左 / 右子树的节点数量，可将 前序遍历 划分为 [ 根节点 | 左子树 | 右子树 ] 。</li></ul><p>考虑通过递归对所有子树进行划分：</p><ul><li><p>递推参数： 根节点在前序遍历的索引 root 、子树在中序遍历的左边界 left 、子树在中序遍历的右边界 right ；</p></li><li><p>终止条件： 当 left &gt; right ，代表已经越过叶节点，此时返回 null ；</p></li><li><p>递推工作：<br>建立根节点 node ： 节点值为 preorder[root] ；<br>划分左右子树： 查找根节点在中序遍历 inorder 中的索引 i ；</p></li></ul><p><img src="/2021/03/05/leetcode-lcof-07-zhong-jian-er-cha-shu/7-tijie.png" alt></p><p>网上摘的保姆式的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java借助Map版本 (Go的没写出来，等后面写出来了再更新)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//标记中序遍历</span></span><br><span class="line">    <span class="keyword">int</span>[] preorder;<span class="comment">//保留的先序遍历，方便递归时依据索引查看先序遍历的值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preorder = preorder;</span><br><span class="line">        <span class="comment">//将中序遍历的值及索引放在map中，方便递归时获取左子树与右子树的数量及其根的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//三个索引分别为</span></span><br><span class="line">        <span class="comment">//当前根的的索引</span></span><br><span class="line">        <span class="comment">//递归树的左边界，即数组左边界</span></span><br><span class="line">        <span class="comment">//递归树的右边界，即数组右边界</span></span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">recur</span><span class="params">(<span class="keyword">int</span> pre_root, <span class="keyword">int</span> in_left, <span class="keyword">int</span> in_right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(in_left &gt; in_right) <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">// 相等的话就是自己</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(preorder[pre_root]);<span class="comment">//获取root节点</span></span><br><span class="line">        <span class="keyword">int</span> idx = map.get(preorder[pre_root]);<span class="comment">//获取在中序遍历中根节点所在索引，以方便获取左子树的数量</span></span><br><span class="line">        <span class="comment">//左子树的根的索引为先序中的根节点+1 </span></span><br><span class="line">        <span class="comment">//递归左子树的左边界为原来的中序in_left</span></span><br><span class="line">        <span class="comment">//递归右子树的右边界为中序中的根节点索引-1</span></span><br><span class="line">        root.left = recur(pre_root+<span class="number">1</span>, in_left, idx-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//右子树的根的索引为先序中的 当前根位置 + 左子树的数量 + 1</span></span><br><span class="line">        <span class="comment">//递归右子树的左边界为中序中当前根节点+1</span></span><br><span class="line">        <span class="comment">//递归右子树的有边界为中序中原来右子树的边界</span></span><br><span class="line">        root.right = recur(pre_root + (idx - in_left) + <span class="number">1</span>, idx+<span class="number">1</span>, in_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode-cn执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">3 ms, 在所有 Java 提交中击败了55.11%的用户</span><br><span class="line">内存消耗：</span><br><span class="line">38.4 MB, 在所有 Java 提交中击败了80.00%的用户</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go，不借助Map版本</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="keyword">int</span>, inorder []<span class="keyword">int</span>)</span> *<span class="title">TreeNode</span></span> &#123;</span><br><span class="line">    root := <span class="built_in">new</span>(TreeNode)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    root_val := preorder[<span class="number">0</span>]</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> inorder[i] != root_val &#123;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    left_tree := buildTree(preorder[<span class="number">1</span>:i+<span class="number">1</span>],inorder[:i])</span><br><span class="line">    right_tree := buildTree(preorder[i+<span class="number">1</span>:],inorder[i+<span class="number">1</span>:])</span><br><span class="line">    root.Val = root_val</span><br><span class="line">    root.Left = left_tree</span><br><span class="line">    root.Right = right_tree</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode-cn执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">4 ms, 在所有 Go 提交中击败了95.75%的用户</span><br><span class="line">内存消耗：</span><br><span class="line">4.2 MB, 在所有 Go 提交中击败了25.36%的用户</span><br></pre></td></tr></table></figure><p>牛客网运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行时间：5ms</span><br><span class="line">超过39.31%用Go提交的代码</span><br><span class="line">占用内存：2344KB</span><br><span class="line">超过9.75%用Go提交的代码</span><br></pre></td></tr></table></figure><h2 id="思考：为什么二叉树的题目一般用递归来解？"><a href="#思考：为什么二叉树的题目一般用递归来解？" class="headerlink" title="思考：为什么二叉树的题目一般用递归来解？"></a>思考：为什么二叉树的题目一般用递归来解？</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/4chong-jie-fa-di-gui-zhan-dui-lie-by-sdwwld/" target="_blank" rel="noopener">4种解法（递归，栈，队列），最后一种击败了100%的用户</a><br><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-by-leetcode-s/" target="_blank" rel="noopener">力扣官方题解</a><br><a href="https://blog.csdn.net/Mr_SCX/article/details/106690412" target="_blank" rel="noopener">【面试题】重建二叉树（解题思路分析+Java、Python实现+代码详细注释）</a><br><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/mian-shi-ti-07-zhong-jian-er-cha-shu-di-gui-fa-qin/" target="_blank" rel="noopener">面试题07. 重建二叉树（递归法，清晰图解）</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed May 05 2021 21:54:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="LeetCode-lcof-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-lcof-Solutions/"/>
    
    
      <category term="二叉树" scheme="https://octopuslian.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://octopuslian.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
</feed>

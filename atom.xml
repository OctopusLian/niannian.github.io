<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>以写作调身心</title>
  
  <subtitle>熟能生巧，勤能补拙；念念不忘，必有回响。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://octopuslian.github.io/"/>
  <updated>2021-03-01T14:37:05.708Z</updated>
  <id>https://octopuslian.github.io/</id>
  
  <author>
    <name>Neo Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指 Offer 03. 数组中重复的数字</title>
    <link href="https://octopuslian.github.io/2021/03/01/leetcode-lcof-03-shu-zu-zhong-zhong-fu-de-shu-zi/"/>
    <id>https://octopuslian.github.io/2021/03/01/leetcode-lcof-03-shu-zu-zhong-zhong-fu-de-shu-zi/</id>
    <published>2021-03-01T14:35:30.000Z</published>
    <updated>2021-03-01T14:37:05.708Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --><p>今天开始争取每天更新至少一道<a href="https://leetcode-cn.com/problemset/lcof/" target="_blank" rel="noopener">《剑指offer》</a>的题解</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">力扣-剑指 Offer 03. 数组中重复的数字</a></p><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">2 &lt;= n &lt;= 100000</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>难度为简单。</p><h3 id="解法一：循环-Map"><a href="#解法一：循环-Map" class="headerlink" title="解法一：循环+Map"></a>解法一：循环+Map</h3><p>一次遍历，将扫描到数字做判断，如果可以在<code>map</code>中查到，就添加进去，否则返回这个数字，因为这个数字已经在<code>map</code>里存在了，属于重复数字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRepeatNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nummap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> _,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> !nummap[num] &#123;</span><br><span class="line">            nummap[num] = <span class="literal">true</span>  <span class="comment">//map中没有这个num</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> num  <span class="comment">//重复，直接返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>leetcode-cn</code>执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">56 ms, 在所有 Go 提交中击败了8.84%的用户</span><br><span class="line">内存消耗：8.9 MB, 在所有 Go 提交中击败了39.48%的用户</span><br></pre></td></tr></table></figure><p>牛客网执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">运行时间：3ms</span><br><span class="line">超过100.00%用Go提交的代码</span><br><span class="line">占用内存：832KB</span><br><span class="line">超过100.00%用Go提交的代码</span><br></pre></td></tr></table></figure><h3 id="解法二：原地交换"><a href="#解法二：原地交换" class="headerlink" title="解法二：原地交换"></a>解法二：原地交换</h3><p>遍历数组并通过交换操作，使元素的 索引 与 值 一一对应（即 nums[i] = inums[i]=i ）。因而，就能通过索引映射对应的值，起到与字典等价的作用。可以看这个<a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/solution/mian-shi-ti-03-shu-zu-zhong-zhong-fu-de-shu-zi-yua/" target="_blank" rel="noopener">题解</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRepeatNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] == i &#123;</span><br><span class="line">            i++</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> nums[nums[i]] == nums[i] &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        tmp := nums[i]</span><br><span class="line">        nums[i] = nums[tmp]</span><br><span class="line">        nums[tmp] = tmp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode-cn执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">执行用时：</span><br><span class="line">40 ms, 在所有 Go 提交中击败了86.59%的用户</span><br><span class="line">内存消耗：8.7 MB, 在所有 Go 提交中击败了89.50%的用户</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;今天开始争取每天更新至少一道&lt;a href=&quot;https://leetcode-cn.com/problemset/lcof
      
    
    </summary>
    
    
      <category term="LeetCode-lcof-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-lcof-Solutions/"/>
    
    
      <category term="Map" scheme="https://octopuslian.github.io/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营-AVL树和红黑树的实现和特性</title>
    <link href="https://octopuslian.github.io/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/"/>
    <id>https://octopuslian.github.io/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/</id>
    <published>2021-03-01T05:08:36.000Z</published>
    <updated>2021-03-01T14:34:20.326Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><ul><li>发明者：Adelson-Velsky and Landis Tree</li><li>Blance Factor(平衡因子)：是它的左子树的高度减去它的右子树的高度（有时相反）。balance factor= {-1,0,1}</li><li>通过旋转操作来进行平衡（四种）</li><li><a href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree" target="_blank" rel="noopener">Self-balancing binary search tree</a></li><li>不足：结点需要</li></ul><h3 id="记录左右子树高度"><a href="#记录左右子树高度" class="headerlink" title="记录左右子树高度"></a>记录左右子树高度</h3><p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/hight.png" alt></p><p>例如F点，右子树高度1 - 左子树高度2 = -1</p><h3 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a>旋转操作</h3><p>1，左旋</p><p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/zuoxuan.png" alt></p><p>2，右旋</p><p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/youxuan.png" alt></p><p>3，左右旋</p><p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/zuoyouxuan2.png" alt></p><p>4，右左旋</p><p><img src="/2021/03/01/geekbang-gatc-15-red-black-tree-and-avl-tree/youzuoxuan.png" alt></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zh.wikipedia.org/wiki/AVL%E6%A0%91" target="_blank" rel="noopener">wiki-AVL树</a><br><a href="https://zhuanlan.zhihu.com/p/63272157" target="_blank" rel="noopener">leetcode刷题(十）：树（红黑树，B树）</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;AVL树&quot;&gt;&lt;a href=&quot;#AVL树&quot; class=&quot;headerlink&quot; title=&quot;AVL树&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="Learn-algo" scheme="https://octopuslian.github.io/categories/Learn-algo/"/>
    
    
      <category term="红黑树" scheme="https://octopuslian.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
      <category term="AVL树" scheme="https://octopuslian.github.io/tags/AVL%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营-高级搜索</title>
    <link href="https://octopuslian.github.io/2021/03/01/geekbang-gatc-14-advanced-search/"/>
    <id>https://octopuslian.github.io/2021/03/01/geekbang-gatc-14-advanced-search/</id>
    <published>2021-03-01T05:08:16.000Z</published>
    <updated>2021-03-01T11:41:49.884Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --><h2 id="剪枝的实现和特性"><a href="#剪枝的实现和特性" class="headerlink" title="剪枝的实现和特性"></a>剪枝的实现和特性</h2><h3 id="初级搜索"><a href="#初级搜索" class="headerlink" title="初级搜索"></a>初级搜索</h3><ul><li>1，朴素搜索：暴力搜索；</li><li>2，优化方式：不重复(fibonacci)、剪枝(生成括号问题)；</li><li>3，搜索方向：深度优先搜索、广度优先搜索、双向搜索、启发式搜索。</li></ul><h2 id="双向BFS的实现、特性"><a href="#双向BFS的实现、特性" class="headerlink" title="双向BFS的实现、特性"></a>双向BFS的实现、特性</h2><p>单向BFS</p><p><img src="/2021/03/01/geekbang-gatc-14-advanced-search/bfs.png" alt></p><p>变形：</p><p><img src="/2021/03/01/geekbang-gatc-14-advanced-search/bfs2.png" alt></p><p>双向BFS</p><p><img src="/2021/03/01/geekbang-gatc-14-advanced-search/Tbfs.png" alt></p><h2 id="启发式搜索的实现、特性-Heuristc-Search-A"><a href="#启发式搜索的实现、特性-Heuristc-Search-A" class="headerlink" title="启发式搜索的实现、特性 - Heuristc Search(A*)"></a>启发式搜索的实现、特性 - Heuristc Search(A*)</h2><p>代码模板</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">AstarSearch</span><span class="params">(graph, start, end)</span>:</span></span><br><span class="line">    pq = collections.priority_queue() <span class="comment"># 优先级 —&gt; 估价函数</span></span><br><span class="line">    pq.append([start]) </span><br><span class="line">    visited.add(start)</span><br><span class="line">    <span class="keyword">while</span> pq: </span><br><span class="line">        node = pq.pop() <span class="comment"># can we add more intelligence here ?</span></span><br><span class="line">        visited.add(node)</span><br><span class="line">        process(node) </span><br><span class="line">        nodes = generate_related_nodes(node)    </span><br><span class="line">        unvisited = [node <span class="keyword">for</span> node <span class="keyword">in</span> nodes <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited]</span><br><span class="line">        pq.push(unvisited)</span><br></pre></td></tr></table></figure><h3 id="估价函数"><a href="#估价函数" class="headerlink" title="估价函数"></a>估价函数</h3><p>启发式搜索：h(n)，它用来评价哪些结点最有希望的是一个我们要找的结点，h(n)会返回一个非负实数，也可以认为是从结点<code>n</code>的目标结点路径的估计成本。<br>启发式搜索是一种告知搜索方向的方法。它提供了一种明智的方法来猜测哪个邻居结点会导向一个目标。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="双向BFS"><a href="#双向BFS" class="headerlink" title="双向BFS"></a>双向BFS</h3><ul><li><a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-ladder/</a></li><li><a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-genetic-mutation/</a></li></ul><h3 id="启发式搜索"><a href="#启发式搜索" class="headerlink" title="启发式搜索"></a>启发式搜索</h3><ul><li><a href="https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shortest-path-in-binary-matrix/</a></li><li><a href="https://leetcode-cn.com/problems/sliding-puzzle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sliding-puzzle/</a></li><li><a href="https://leetcode-cn.com/problems/sudoku-solver/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sudoku-solver/</a></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://nikcheerla.github.io/deeplearningschool/2018/01/01/AlphaZero-Explained/" target="_blank" rel="noopener">AlphaZero Explained</a><br><a href="https://en.wikipedia.org/wiki/Game_complexity" target="_blank" rel="noopener">棋类复杂度</a><br><a href="https://shimo.im/docs/CXvjHyWhpQcxXjcw/read" target="_blank" rel="noopener">A*代码模板</a><br><a href="https://dataaspirant.com/2015/04/11/five-most-popular-similarity-measures-implementation-in-python/" target="_blank" rel="noopener">相似度测量方法</a><br><a href="https://leetcode.com/problems/shortest-path-in-binary-matrix/discuss/313347/A*-search-in-Python" target="_blank" rel="noopener">二进制矩阵中的最短路径的 A* 解法</a><br><a href="https://zxi.mytechroad.com/blog/searching/8-puzzles-bidirectional-astar-vs-bidirectional-bfs/" target="_blank" rel="noopener">8 puzzles 解法比较</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;剪枝的实现和特性&quot;&gt;&lt;a href=&quot;#剪枝的实现和特性&quot; class=&quot;headerlink&quot; title=&quot;剪
      
    
    </summary>
    
    
      <category term="Learn-algo" scheme="https://octopuslian.github.io/categories/Learn-algo/"/>
    
    
      <category term="剪枝" scheme="https://octopuslian.github.io/tags/%E5%89%AA%E6%9E%9D/"/>
    
      <category term="双向BFS" scheme="https://octopuslian.github.io/tags/%E5%8F%8C%E5%90%91BFS/"/>
    
      <category term="双向DFS" scheme="https://octopuslian.github.io/tags/%E5%8F%8C%E5%90%91DFS/"/>
    
      <category term="启发式搜索" scheme="https://octopuslian.github.io/tags/%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营-字符串基础知识、高级字符串算法、字符串匹配算法</title>
    <link href="https://octopuslian.github.io/2021/02/24/geekbang-gatc-20-string-algo/"/>
    <id>https://octopuslian.github.io/2021/02/24/geekbang-gatc-20-string-algo/</id>
    <published>2021-02-24T13:11:04.000Z</published>
    <updated>2021-02-24T14:40:12.174Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --><h2 id="字符串匹配算法"><a href="#字符串匹配算法" class="headerlink" title="字符串匹配算法"></a>字符串匹配算法</h2><h2 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h2><h3 id="字符串基础问题"><a href="#字符串基础问题" class="headerlink" title="字符串基础问题"></a>字符串基础问题</h3><ul><li><a href="https://leetcode-cn.com/problems/to-lower-case/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/to-lower-case/</a></li><li><a href="https://leetcode-cn.com/problems/length-of-last-word/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/length-of-last-word/</a></li><li><a href="https://leetcode-cn.com/problems/jewels-and-stones/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jewels-and-stones/</a></li><li><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/first-unique-character-in-a-string/</a></li><li><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></li></ul><h3 id="字符串操作问题"><a href="#字符串操作问题" class="headerlink" title="字符串操作问题"></a>字符串操作问题</h3><ul><li><a href="https://leetcode-cn.com/problems/longest-common-prefix/description/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-prefix/description/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-string" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-string</a></li><li><a href="https://leetcode-cn.com/problems/reverse-string-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-string-ii/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-words-in-a-string/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-only-letters/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-only-letters/</a></li></ul><h3 id="异位词问题"><a href="#异位词问题" class="headerlink" title="异位词问题"></a>异位词问题</h3><ul><li><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-anagram/</a></li><li><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/group-anagrams/</a></li><li><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/</a></li></ul><h3 id="回文串问题"><a href="#回文串问题" class="headerlink" title="回文串问题"></a>回文串问题</h3><ul><li><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-palindrome/</a></li><li><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-palindrome-ii/</a></li><li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></li></ul><h3 id="最长子串、子序列问题"><a href="#最长子串、子序列问题" class="headerlink" title="最长子串、子序列问题"></a>最长子串、子序列问题</h3><ul><li><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-common-subsequence/</a></li><li><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/edit-distance/</a></li><li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></li></ul><h3 id="字符串-DP-问题"><a href="#字符串-DP-问题" class="headerlink" title="字符串 +DP 问题"></a>字符串 +DP 问题</h3><ul><li><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regular-expression-matching/</a></li><li><a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/</a></li><li><a href="https://leetcode-cn.com/problems/wildcard-matching/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/wildcard-matching/</a></li><li><a href="https://leetcode-cn.com/problems/distinct-subsequences/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/distinct-subsequences/</a></li></ul><h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><ul><li><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/first-unique-character-in-a-string/</a></li><li><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/string-to-integer-atoi/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-string-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-string-ii/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-words-in-a-string/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/</a></li><li><a href="https://leetcode-cn.com/problems/reverse-only-letters/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-only-letters/</a></li><li><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/</a></li><li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></li><li><a href="https://leetcode-cn.com/problems/isomorphic-strings/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/isomorphic-strings/</a></li><li><a href="https://leetcode-cn.com/problems/valid-palindrome-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/valid-palindrome-ii/</a></li><li><a href="https://leetcode-cn.com/problems/wildcard-matching" target="_blank" rel="noopener">https://leetcode-cn.com/problems/wildcard-matching</a></li><li><a href="https://leetcode-cn.com/problems/longest-valid-parentheses" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-valid-parentheses</a></li><li><a href="https://leetcode-cn.com/problems/distinct-subsequences/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/distinct-subsequences/</a></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://lemire.me/blog/2017/07/07/are-your-strings-immutable/" target="_blank" rel="noopener">不可变字符串</a><br><a href="https://shimo.im/docs/KkDKkpWxjjrJXdpY/read" target="_blank" rel="noopener">Atoi 代码示例</a><br><a href="http://xn--https-ni33a/www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html" target="_blank" rel="noopener">Boyer-Moore 算法</a><br><a href="https://blog.csdn.net/u012505432/article/details/52210975" target="_blank" rel="noopener">Sunday 算法</a><br><a href="https://shimo.im/docs/dQDxQW8yXPXxh3Hg/read" target="_blank" rel="noopener">字符串匹配暴力法代码示例</a><br><a href="https://shimo.im/docs/KXDdkT99TVtXvTXP/read" target="_blank" rel="noopener">Rabin-Karp 代码示例</a><br><a href="https://www.bilibili.com/video/av11866460?from=search&seid=17425875345653862171" target="_blank" rel="noopener">KMP 字符串匹配算法视频</a><br><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">字符串匹配的 KMP 算法</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;字符串匹配算法&quot;&gt;&lt;a href=&quot;#字符串匹配算法&quot; class=&quot;headerlink&quot; title=&quot;字符串
      
    
    </summary>
    
    
      <category term="Learn-algo" scheme="https://octopuslian.github.io/categories/Learn-algo/"/>
    
    
      <category term="字符串" scheme="https://octopuslian.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="高级字符串算法" scheme="https://octopuslian.github.io/tags/%E9%AB%98%E7%BA%A7%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串匹配算法" scheme="https://octopuslian.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营-初级排序和高级排序的实现和特性</title>
    <link href="https://octopuslian.github.io/2021/02/24/geekbang-gatc-18-sort-algo/"/>
    <id>https://octopuslian.github.io/2021/02/24/geekbang-gatc-18-sort-algo/</id>
    <published>2021-02-24T05:10:05.000Z</published>
    <updated>2021-02-26T01:15:48.212Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="1，比较类排序"><a href="#1，比较类排序" class="headerlink" title="1，比较类排序"></a>1，比较类排序</h3><p>通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</p><h3 id="2，非比较类排序"><a href="#2，非比较类排序" class="headerlink" title="2，非比较类排序"></a>2，非比较类排序</h3><p>不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</p><p><img src="/2021/02/24/geekbang-gatc-18-sort-algo/sort.png" alt></p><p><img src="/2021/02/24/geekbang-gatc-18-sort-algo/sort2.png" alt></p><p>(大厂一般回考时间复杂度为<code>nlogn</code>的排序算法——<strong>堆排序、快速排序、归并排序</strong>，比如快速排序和归并排序用到了分治思想)</p><h2 id="初级排序-O-n-2"><a href="#初级排序-O-n-2" class="headerlink" title="初级排序-O(n^2)"></a>初级排序-O(n^2)</h2><ul><li><p>1,选择排序<br>每次找最小值，然后放到待排序数组的起始位置。</p></li><li><p>2，插入排序<br>从前往后逐步构建有序序列；对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p></li><li><p>3，冒泡排序<br>嵌套循环，每次查看相邻的元素，如果逆序，则交换</p></li></ul><h2 id="高级排序-O-N-LogN"><a href="#高级排序-O-N-LogN" class="headerlink" title="高级排序-O(N*LogN)"></a>高级排序-O(N*LogN)</h2><ul><li>快速排序<br>数组取标杆<code>pivot</code>，将小元素放<code>pivot</code>左边，大元素放右侧，然后依次对右边和右边的子数组继续快排，以达到整个序列有序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Go</span></span><br><span class="line"><span class="function">func <span class="title">quickSort</span><span class="params">(array []<span class="keyword">int</span>, begin, end <span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> end &lt;= begin &#123;</span><br><span class="line">                 <span class="keyword">return</span>   </span><br><span class="line">                 &#125;   </span><br><span class="line">    pivot := partition(array, begin, end)   </span><br><span class="line">    quickSort(array, begin, pivot-<span class="number">1</span>)   </span><br><span class="line">    quickSort(array, pivot+<span class="number">1</span>, end)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">partition</span><span class="params">(array []<span class="keyword">int</span>, begin, end <span class="keyword">int</span>)</span> <span class="keyword">int</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pivot: 标杆位置，counter: 小于pivot的元素的个数   </span></span><br><span class="line">    pivot, counter := end, begin   </span><br><span class="line">    <span class="keyword">for</span> i := begin; i &lt; end; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> array[i] &lt; array[pivot] &#123;</span><br><span class="line">            array[i], array[counter] = array[counter], array[i]         </span><br><span class="line">            counter++      </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    array[pivot], array[counter] = array[counter], array[pivot]   </span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>归并排序——分治<br>1，把长度为<code>n</code>的输入序列分成两个长度为<code>n/2</code>的子序列；<br>2，把这两个子序列分别采用归并排序；<br>3，将两个排序好的子序列合并成一个最终的排序序列。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (right &lt;= left) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;  <span class="comment">//(left + right) / 2</span></span><br><span class="line"></span><br><span class="line">    mergeSort(array,left,mid);</span><br><span class="line">    mergeSort(array,mid + <span class="number">1</span>,right);</span><br><span class="line">    merge(array,left,mid,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> left,<span class="keyword">int</span> mid,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>]; <span class="comment">//中间数组</span></span><br><span class="line">    <span class="comment">//...未完</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>归并和快排具有相似性，但步骤顺序相反</strong></p><p>归并：先排序左右子数组，然后合并两个有序子数组；<br>快排：先调配出左右子数组，然后对于左右子数组进行排序。</p><ul><li>堆排序——堆插入O(logN)，取最大/小值O(1)<br>1，数组元素依次建立小顶堆；<br>2，依次取堆顶元素，并删除。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Cpp</span></span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">十大经典排序算法（动图演示）</a><br><a href="https://shimo.im/docs/98KjvGwwGpTpYGKy/read" target="_blank" rel="noopener">快速排序算法示例</a><br><a href="https://shimo.im/docs/YqgG6vtdKwkXJkWx/" target="_blank" rel="noopener">归并排序算法示例</a><br><a href="https://shimo.im/docs/6kRVHRphpgjHgCtx/" target="_blank" rel="noopener">堆排序代码示例</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="Learn-algo" scheme="https://octopuslian.github.io/categories/Learn-algo/"/>
    
    
      <category term="排序算法" scheme="https://octopuslian.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营-二分查找的实现、特性及实战题目解析</title>
    <link href="https://octopuslian.github.io/2021/02/23/geekbang-gatc-11-binary-search/"/>
    <id>https://octopuslian.github.io/2021/02/23/geekbang-gatc-11-binary-search/</id>
    <published>2021-02-23T10:06:14.000Z</published>
    <updated>2021-02-23T12:43:33.841Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --><h2 id="二分查找的前提"><a href="#二分查找的前提" class="headerlink" title="二分查找的前提"></a>二分查找的前提</h2><p>1，目标函数单调性（单调递增或者递减）——在有序的里面查找<br>2，存在上下界（bounded）<br>3，能够通过索引访问（index accessible）</p><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><p>(一定要写的非常熟练)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">left,right := <span class="number">0</span>,len(array) - <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt;= right:</span><br><span class="line">    mid := (left + right) / <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> array[mid] == target:</span><br><span class="line">        <span class="comment"># find the target</span></span><br><span class="line">        <span class="keyword">break</span> <span class="keyword">or</span> <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">elif</span> array[mid] &lt; target:</span><br><span class="line">        left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right = mid - <span class="number">1</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;二分查找的前提&quot;&gt;&lt;a href=&quot;#二分查找的前提&quot; class=&quot;headerlink&quot; title=&quot;二分查
      
    
    </summary>
    
    
      <category term="Learn-algo" scheme="https://octopuslian.github.io/categories/Learn-algo/"/>
    
    
      <category term="二分查找" scheme="https://octopuslian.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>算法训练营-贪心的实现、特性及实战题目解析</title>
    <link href="https://octopuslian.github.io/2021/02/23/geekbang-gatc-10-greedy-algo/"/>
    <id>https://octopuslian.github.io/2021/02/23/geekbang-gatc-10-greedy-algo/</id>
    <published>2021-02-23T09:40:38.000Z</published>
    <updated>2021-02-23T10:00:03.855Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --><h2 id="贪心算法-Greedy"><a href="#贪心算法-Greedy" class="headerlink" title="贪心算法-Greedy"></a>贪心算法-Greedy</h2><p>贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是全局最好或最优的算法。</p><p>贪心算法与动态规划的不同在于<strong>它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。</strong></p><ul><li>贪心：当下做局部最优判断</li><li>回溯：能够回退</li><li>动态规划：最优判断 + 回溯</li></ul><h3 id="可以解决的最优化问题"><a href="#可以解决的最优化问题" class="headerlink" title="可以解决的最优化问题"></a>可以解决的最优化问题</h3><ul><li>求图中的最小生成树</li><li>求哈夫曼编码等</li></ul><p><strong>由于贪心法的高效性以及所求得的答案比较接近最优结果，贪心算法可以用作辅助算法或直接解决一些要求结果不特别精确的问题。</strong></p><h2 id="适用贪心算法的场景"><a href="#适用贪心算法的场景" class="headerlink" title="适用贪心算法的场景"></a>适用贪心算法的场景</h2><p>简单来说：问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。这种子问题最优解称为最优子结构。</p><h2 id="实战题目"><a href="#实战题目" class="headerlink" title="实战题目"></a>实战题目</h2><p><a href>leetcode-322.Coin Change</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;贪心算法-Greedy&quot;&gt;&lt;a href=&quot;#贪心算法-Greedy&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Learn-algo" scheme="https://octopuslian.github.io/categories/Learn-algo/"/>
    
    
      <category term="贪心算法" scheme="https://octopuslian.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-38. Count and Say | 外观数列</title>
    <link href="https://octopuslian.github.io/2021/02/14/leetcode-38-count-and-say/"/>
    <id>https://octopuslian.github.io/2021/02/14/leetcode-38-count-and-say/</id>
    <published>2021-02-14T01:19:04.000Z</published>
    <updated>2021-02-26T02:51:21.799Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/count-and-say/" target="_blank" rel="noopener">LeetCode</a><br><a href="https://leetcode-cn.com/problems/count-and-say/" target="_blank" rel="noopener">LeetCode-cn</a></p><p>The count-and-say sequence is a sequence of digit strings defined by the recursive formula:</p><ul><li>countAndSay(1) = “1”</li><li>countAndSay(n) is the way you would “say” the digit string from countAndSay(n-1), which is then converted into a different digit string.</li></ul><p>To determine how you “say” a digit string, split it into the minimal number of groups so that each group is a contiguous section all of the same character. Then for each group, say the number of characters, then say the character. To convert the saying into a digit string, replace the counts with a number and concatenate every saying.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: n = 1</span><br><span class="line">Output: &quot;1&quot;</span><br><span class="line">Explanation: This is the base case.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: n = 4</span><br><span class="line">Output: &quot;1211&quot;</span><br><span class="line">Explanation:</span><br><span class="line">countAndSay(1) = &quot;1&quot;</span><br><span class="line">countAndSay(2) = say &quot;1&quot; = one 1 = &quot;11&quot;</span><br><span class="line">countAndSay(3) = say &quot;11&quot; = two 1&apos;s = &quot;21&quot;</span><br><span class="line">countAndSay(4) = say &quot;21&quot; = one 2 + one 1 = &quot;12&quot; + &quot;11&quot; = &quot;1211&quot;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line">1 &lt;= n &lt;= 30</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目为简单难度。<br>典型的递归题目。</p><h3 id="解法一：笨办法-打表"><a href="#解法一：笨办法-打表" class="headerlink" title="解法一：笨办法-打表"></a>解法一：笨办法-打表</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countAndSay</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> arr = []<span class="keyword">string</span>&#123;<span class="string">""</span>,<span class="string">"1"</span>,</span><br><span class="line"><span class="string">"11"</span>,</span><br><span class="line"><span class="string">"21"</span>,</span><br><span class="line"><span class="string">"1211"</span>,</span><br><span class="line"><span class="string">"111221"</span>,</span><br><span class="line"><span class="string">"312211"</span>,</span><br><span class="line"><span class="string">"13112221"</span>,</span><br><span class="line"><span class="string">"1113213211"</span>,</span><br><span class="line"><span class="string">"31131211131221"</span>,</span><br><span class="line"><span class="string">"13211311123113112211"</span>,</span><br><span class="line"><span class="string">"11131221133112132113212221"</span>,</span><br><span class="line"><span class="string">"3113112221232112111312211312113211"</span>,</span><br><span class="line"><span class="string">"1321132132111213122112311311222113111221131221"</span>,</span><br><span class="line"><span class="string">"11131221131211131231121113112221121321132132211331222113112211"</span>,</span><br><span class="line"><span class="string">"311311222113111231131112132112311321322112111312211312111322212311322113212221"</span>,</span><br><span class="line"><span class="string">"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211"</span>,</span><br><span class="line"><span class="string">"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221"</span>,</span><br><span class="line"><span class="string">"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211"</span>,</span><br><span class="line"><span class="string">"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221"</span>,</span><br><span class="line"><span class="string">"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211"</span>,</span><br><span class="line"><span class="string">"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221"</span>,</span><br><span class="line"><span class="string">"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211"</span>,</span><br><span class="line"><span class="string">"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221"</span>,</span><br><span class="line"><span class="string">"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211"</span>,</span><br><span class="line"><span class="string">"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221"</span>,</span><br><span class="line"><span class="string">"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211"</span>,</span><br><span class="line"><span class="string">"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221"</span>,</span><br><span class="line"><span class="string">"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211"</span>,</span><br><span class="line"><span class="string">"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221"</span>,</span><br><span class="line"><span class="string">"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211"</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> arr[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码时间复杂度为<code>O(1)</code></p><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leetcode-cn：</span><br><span class="line">执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：2.1 MB, 在所有 Go 提交中击败了99.11%的用户</span><br><span class="line"></span><br><span class="line">leetcode：</span><br><span class="line">Runtime: 0 ms, faster than 100.00% of Go online submissions for Count and Say.</span><br><span class="line">Memory Usage: 2.1 MB, less than 100.00% of Go online submissions for Count and Say.</span><br></pre></td></tr></table></figure><h3 id="解法二：递归"><a href="#解法二：递归" class="headerlink" title="解法二：递归"></a>解法二：递归</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strconv"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countAndSay</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n&lt;=<span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digui(<span class="string">"1"</span>,n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">digui</span><span class="params">(prestr <span class="keyword">string</span>,n <span class="keyword">int</span>)</span><span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> prestr</span><br><span class="line">    &#125;</span><br><span class="line">    temp:=<span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="built_in">len</span>(prestr);i&gt;<span class="number">0</span>;&#123;</span><br><span class="line">        j:=i</span><br><span class="line">        <span class="keyword">for</span> ;j&gt;<span class="number">0</span>&amp;&amp;prestr[j<span class="number">-1</span>:j] == prestr[i<span class="number">-1</span>:i];j--&#123;&#125;</span><br><span class="line">        temp=strconv.Itoa(i-j)+prestr[i<span class="number">-1</span>:i]+temp</span><br><span class="line">        i = i-(i-j)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> digui(temp,n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leetcode-cn：</span><br><span class="line">执行用时：12 ms, 在所有 Go 提交中击败了28.30%的用户</span><br><span class="line">内存消耗：7.3 MB, 在所有 Go 提交中击败了25.81%的用户</span><br><span class="line"></span><br><span class="line">leetcode：</span><br><span class="line">Runtime: 8 ms, faster than 46.85% of Go online submissions for Count and Say.</span><br><span class="line">Memory Usage: 6.6 MB, less than 32.43% of Go online submissions for Count and Say.</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="数组" scheme="https://octopuslian.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="递" scheme="https://octopuslian.github.io/tags/%E9%80%92/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-35. Search Insert Position | 搜索插入位置</title>
    <link href="https://octopuslian.github.io/2021/02/13/leetcode-35-search-insert-position/"/>
    <id>https://octopuslian.github.io/2021/02/13/leetcode-35-search-insert-position/</id>
    <published>2021-02-13T13:36:51.000Z</published>
    <updated>2021-02-13T13:37:33.910Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/search-insert-position/" target="_blank" rel="noopener">LeetCode</a><br><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">LeetCode-cn</a></p><p>Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: nums = [1,3,5,6], target = 5</span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: nums = [1,3,5,6], target = 2</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: nums = [1,3,5,6], target = 7</span><br><span class="line">Output: 4</span><br><span class="line"></span><br><span class="line">Example 4:</span><br><span class="line">Input: nums = [1,3,5,6], target = 0</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Example 5:</span><br><span class="line">Input: nums = [1], target = 0</span><br><span class="line">Output: 0</span><br><span class="line"> </span><br><span class="line">Constraints:</span><br><span class="line">1 &lt;= nums.length &lt;= 104</span><br><span class="line">-104 &lt;= nums[i] &lt;= 104</span><br><span class="line">nums contains distinct values sorted in ascending order.</span><br><span class="line">-104 &lt;= target &lt;= 104</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>题目为简单难度。</p><h3 id="解法一：暴力求解法"><a href="#解法一：暴力求解法" class="headerlink" title="解法一：暴力求解法"></a>解法一：暴力求解法</h3><p>使用<code>for</code>循环遍历<code>nums</code>数组，从下标<code>0</code>开始按个与目标值<code>target</code>进行对比，如果<code>nums[i]&gt;=target</code>，说明目标值在数组所有元素之前，直接返回<code>i</code>即可；另一种情况就是目标值在数组所有元素之后，这时返回<code>nums</code>数组长度<code>len(nums)</code>即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt;= target &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leetcode：</span><br><span class="line">Runtime: 4 ms, faster than 88.29% of Go online submissions for Search Insert Position.</span><br><span class="line">Memory Usage: 3.1 MB, less than 100.00% of Go online submissions for Search Insert Position.</span><br><span class="line"></span><br><span class="line">leetcode-cn：</span><br><span class="line">执行用时：4 ms, 在所有 Go 提交中击败了90.15%的用户</span><br><span class="line">内存消耗：2.9 MB, 在所有 Go 提交中击败了100.00%的用户</span><br></pre></td></tr></table></figure><h3 id="解法二：二分查找法"><a href="#解法二：二分查找法" class="headerlink" title="解法二：二分查找法"></a>解法二：二分查找法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    low := <span class="number">0</span></span><br><span class="line">    high := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> low &lt;= high &#123;</span><br><span class="line">        <span class="comment">// 下方写法为了防止数据溢出，如果先加在除以2 加完的值可能会大于INT_MAX，造成溢出 </span></span><br><span class="line">        mid := low + (high - low) / <span class="number">2</span></span><br><span class="line">        guess := nums[mid]</span><br><span class="line">        <span class="keyword">if</span> guess == target &#123;</span><br><span class="line">            <span class="keyword">return</span> mid <span class="comment">//找到了，返回下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> guess &gt; target &#123;</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid +<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> low <span class="comment">//没找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leetcode-cn：</span><br><span class="line">执行用时：4 ms, 在所有 Go 提交中击败了90.15%的用户</span><br><span class="line">内存消耗：3 MB, 在所有 Go 提交中击败了56.60%的用户</span><br><span class="line"></span><br><span class="line">leetcode：</span><br><span class="line">Runtime: 8 ms, faster than 8.78% of Go online submissions for Search Insert Position.</span><br><span class="line">Memory Usage: 3.3 MB, less than 6.08% of Go online submissions for Search Insert Position.</span><br></pre></td></tr></table></figure><h3 id="解法三：golang-sort-SearchInts包"><a href="#解法三：golang-sort-SearchInts包" class="headerlink" title="解法三：golang-sort.SearchInts包"></a>解法三：<a href="https://golang.org/pkg/sort/#SearchInts" target="_blank" rel="noopener">golang-sort.SearchInts</a>包</h3><p>解题时不推荐。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchInsert</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sort.SearchInts(nums, target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leetcode：</span><br><span class="line">Runtime: 4 ms, faster than 88.29% of Go online submissions for Search Insert Position.</span><br><span class="line">Memory Usage: 3.1 MB, less than 100.00% of Go online submissions for Search Insert Position.</span><br><span class="line"></span><br><span class="line">leetcode-cn：</span><br><span class="line">执行用时：4 ms, 在所有 Go 提交中击败了90.15%的用户</span><br><span class="line">内存消耗：3 MB, 在所有 Go 提交中击败了56.60%的用户</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="数组" scheme="https://octopuslian.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="暴力法" scheme="https://octopuslian.github.io/tags/%E6%9A%B4%E5%8A%9B%E6%B3%95/"/>
    
      <category term="排序" scheme="https://octopuslian.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="二分法" scheme="https://octopuslian.github.io/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-28-implement-strstr | 实现 strStr()</title>
    <link href="https://octopuslian.github.io/2021/02/12/leetcode-28-implement-strstr/"/>
    <id>https://octopuslian.github.io/2021/02/12/leetcode-28-implement-strstr/</id>
    <published>2021-02-12T13:53:52.000Z</published>
    <updated>2021-02-12T14:38:26.671Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/implement-strstr/" target="_blank" rel="noopener">LeetCode</a><br><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">LeetCode-cn</a></p><p>Implement strStr().</p><p>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p><p>Clarification:</p><p>What should we return when needle is an empty string? This is a great question to ask during an interview.</p><p>For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf().</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class="line">Output: -1</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: haystack = &quot;&quot;, needle = &quot;&quot;</span><br><span class="line">Output: 0</span><br><span class="line"> </span><br><span class="line">Constraints:</span><br><span class="line">0 &lt;= haystack.length, needle.length &lt;= 5 * 104</span><br><span class="line">haystack and needle consist of only lower-case English characters.</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>难度简单。<br>这道题就是说要找到<code>needle</code>在<code>haystack</code>第一个出现的位置，如果没有出现就返回<code>-1</code>。</p><h3 id="解法一：暴力法"><a href="#解法一：暴力法" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack <span class="keyword">string</span>, needle <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">//考虑特殊情况</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(haystack) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(needle) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(haystack) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(needle) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(haystack) &lt; <span class="built_in">len</span>(needle) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    len_h := <span class="built_in">len</span>(haystack)  <span class="comment">//获取haystack字符串的长度</span></span><br><span class="line">    len_n := <span class="built_in">len</span>(needle)  <span class="comment">//获取needle字符串的长度</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;len_h-len_n+<span class="number">1</span>;i++ &#123;</span><br><span class="line">        j := <span class="number">0</span>;  <span class="comment">//子串每次都要重头开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> ;j&lt;len_n;j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i+j] != needle[j]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == len_n) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leetcode-cn：</span><br><span class="line">执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：2.2 MB, 在所有 Go 提交中击败了64.54%的用户</span><br><span class="line"></span><br><span class="line">leetcode：</span><br><span class="line">Runtime: 0 ms, faster than 100.00% of Go online submissions for Implement strStr().</span><br><span class="line">Memory Usage: 2.3 MB, less than 100.00% of Go online submissions for Implement strStr().</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><code>Golang</code>中的内置函数<a href="https://golang.org/pkg/strings/#Index" target="_blank" rel="noopener">strings.Index</a>也可以实现，可以参考它的源码实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"strings"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strStr</span><span class="params">(haystack <span class="keyword">string</span>, needle <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> strings.Index(haystack,needle)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
      <category term="字符串" scheme="https://octopuslian.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="KMP" scheme="https://octopuslian.github.io/tags/KMP/"/>
    
      <category term="暴力法" scheme="https://octopuslian.github.io/tags/%E6%9A%B4%E5%8A%9B%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-27. Remove Element | 移除元素</title>
    <link href="https://octopuslian.github.io/2021/02/10/leetcode-27-remove-element/"/>
    <id>https://octopuslian.github.io/2021/02/10/leetcode-27-remove-element/</id>
    <published>2021-02-10T14:55:59.000Z</published>
    <updated>2021-02-12T15:02:16.313Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/remove-element/" target="_blank" rel="noopener">LeetCode</a><br><a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener">LeetCode-cn</a></p><p>Given an array nums and a value val, remove all instances of that value in-place and return the new length.</p><p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p><p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p><p>Clarification:</p><p>Confused why the returned value is an integer but your answer is an array?</p><p>Note that the input array is passed in by reference, which means a modification to the input array will be known to the caller as well.</p><p>Internally you can think of this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len = removeElement(nums, val);</span><br><span class="line"></span><br><span class="line">// any modification to nums in your function would be known by the caller.</span><br><span class="line">// using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [3,2,2,3], val = 3</span><br><span class="line">Output: 2, nums = [2,2]</span><br><span class="line">Explanation: Your function should return length = 2, with the first two elements of nums being 2.</span><br><span class="line">It doesn&apos;t matter what you leave beyond the returned length. For example if you return 2 with nums = [2,2,3,3] or nums = [2,2,0,0], your answer will be accepted.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">Output: 5, nums = [0,1,4,0,3]</span><br><span class="line">Explanation: Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4. Note that the order of those five elements can be arbitrary. It doesn&apos;t matter what values are set beyond the returned length.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line">0 &lt;= nums.length &lt;= 100</span><br><span class="line">0 &lt;= nums[i] &lt;= 50</span><br><span class="line">0 &lt;= val &lt;= 100</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>难度为简单。</p><p>特别注意<strong>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</strong></p><h3 id="解法一：双指针法"><a href="#解法一：双指针法" class="headerlink" title="解法一：双指针法"></a>解法一：双指针法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeElement</span><span class="params">(nums []<span class="keyword">int</span>, val <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">//双指针法</span></span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>;j &lt; <span class="built_in">len</span>(nums);j++ &#123;  <span class="comment">//遍历nums数组</span></span><br><span class="line">        <span class="keyword">if</span> nums[j] != val &#123;  <span class="comment">//如果nums下标 j 对应的元素不等于 val</span></span><br><span class="line">            nums[i] = nums[j]</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leetcode-cn：</span><br><span class="line">执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：2.1 MB, 在所有 Go 提交中击败了99.85%的用户</span><br><span class="line"></span><br><span class="line">leetcode：</span><br><span class="line">Runtime: 0 ms, faster than 100.00% of Go online submissions for Remove Element.</span><br><span class="line">Memory Usage: 2.1 MB, less than 17.08% of Go online submissions for Remove Element.</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="双指针法" scheme="https://octopuslian.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>geekbang-gatc-gain</title>
    <link href="https://octopuslian.github.io/2021/02/10/geekbang-gatc-gain/"/>
    <id>https://octopuslian.github.io/2021/02/10/geekbang-gatc-gain/</id>
    <published>2021-02-10T04:55:22.000Z</published>
    <updated>2021-01-22T05:00:34.572Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --&gt;&lt;!-- rebuild by neat --&gt;
&lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt;
&lt;scrip
      
    
    </summary>
    
    
      <category term="Learn-algo" scheme="https://octopuslian.github.io/categories/Learn-algo/"/>
    
    
  </entry>
  
  <entry>
    <title>LeetCode-26.Remove Duplicates from Sorted Array | 删除排序数组中的重复项</title>
    <link href="https://octopuslian.github.io/2021/02/09/leetcode-26-remove-duplicates-from-sorted-array/"/>
    <id>https://octopuslian.github.io/2021/02/09/leetcode-26-remove-duplicates-from-sorted-array/</id>
    <published>2021-02-09T14:24:56.000Z</published>
    <updated>2021-02-09T16:15:33.455Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">leetcode-cn</a></li><li><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">leetcode</a></li></ul><p>Given a sorted array nums, remove the duplicates in-place such that each element appears only once and returns the new length.</p><p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p><p>Clarification:</p><p>Confused why the returned value is an integer but your answer is an array?</p><p>Note that the input array is passed in by reference, which means a modification to the input array will be known to the caller as well.</p><p>Internally you can think of this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// any modification to nums in your function would be known by the caller.</span><br><span class="line">// using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [1,1,2]</span><br><span class="line">Output: 2, nums = [1,2]</span><br><span class="line">Explanation: Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn&apos;t matter what you leave beyond the returned length.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">Output: 5, nums = [0,1,2,3,4]</span><br><span class="line">Explanation: Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively. It doesn&apos;t matter what values are set beyond the returned length.</span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line">0 &lt;= nums.length &lt;= 3 * 104</span><br><span class="line">-104 &lt;= nums[i] &lt;= 104</span><br><span class="line">nums is sorted in ascending order.</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题就是希望让我返回一个没有重复数字的数组的大小，且不要使用额外的数组空间，必须在原地修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><h3 id="解法一：暴力"><a href="#解法一：暴力" class="headerlink" title="解法一：暴力"></a>解法一：暴力</h3><p>用<code>for</code>循环从数组<code>nums</code>末尾的最后一个数字开始遍历，让数组<code>nums</code>末尾最后一个数字与末尾最后倒数第二个数字做比较，如果后一个等于前一个，则从数组中删除后一个元素，直到遍历完成，返回新数组的长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="built_in">len</span>(nums)<span class="number">-1</span>;i&gt;<span class="number">0</span>;i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">            nums = <span class="built_in">append</span>(nums[:i],nums[i+<span class="number">1</span>:]...)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解法二：双指针法"><a href="#解法二：双指针法" class="headerlink" title="解法二：双指针法"></a>解法二：双指针法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;  <span class="comment">//考虑特殊情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    i := <span class="number">0</span>; <span class="comment">//慢指针</span></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>;j &lt; <span class="built_in">len</span>(nums);j++ &#123;  <span class="comment">//j是快指针</span></span><br><span class="line">        <span class="keyword">if</span> nums[j] != nums[i] &#123;</span><br><span class="line">            i++</span><br><span class="line">            nums[i] = nums[j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leetcode-cn：</span><br><span class="line">执行用时：8 ms, 在所有 Go 提交中击败了86.25%的用户</span><br><span class="line">内存消耗：4.6 MB, 在所有 Go 提交中击败了65.76%的用户</span><br><span class="line"></span><br><span class="line">leetcode：</span><br><span class="line">Runtime: 4 ms, faster than 99.38% of Go online submissions for Remove Duplicates from Sorted Array.</span><br><span class="line">Memory Usage: 4.6 MB, less than 100.00% of Go online submissions for Remove Duplicates from Sorted Array.</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
      <category term="数组" scheme="https://octopuslian.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="https://octopuslian.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-21.Merge Two Sorted Lists | 合并两个有序链表</title>
    <link href="https://octopuslian.github.io/2021/02/08/leetcode-21-merge-two-sorted-lists/"/>
    <id>https://octopuslian.github.io/2021/02/08/leetcode-21-merge-two-sorted-lists/</id>
    <published>2021-02-08T15:32:13.000Z</published>
    <updated>2021-02-08T15:33:09.345Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">LeetCode</a><br><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">LeetCode-cn</a></p><p>Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">Output: [1,1,2,3,4,4]</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: l1 = [], l2 = []</span><br><span class="line">Output: []</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: l1 = [], l2 = [0]</span><br><span class="line">Output: [0]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line">The number of nodes in both lists is in the range [0, 50].</span><br><span class="line">-100 &lt;= Node.val &lt;= 100</span><br><span class="line">Both l1 and l2 are sorted in non-decreasing order.</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题是经典的考察链表的题目。</p><h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><ul><li>终止条件：两条链表分别名为 <code>l1</code> 和 <code>l2</code>，当 <code>l1</code> 为空或 <code>l2</code> 为空时结束</li><li>返回值：每一层调用都返回排序好的链表头</li><li>本级递归内容：如果 <code>l1</code> 的 <code>val</code> 值更小，则将 <code>l1.next</code> 与排序好的链表头相接，<code>l2</code> 同理</li><li><code>O(m+n)O(m+n)</code>，<code>mm</code> 为 <code>l1</code>的长度，<code>nn</code> 为 <code>l2</code> 的长度</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (l1.Val &lt; l2.Val) &#123;</span><br><span class="line">        l1.Next = mergeTwoLists(l1.Next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        l2.Next = mergeTwoLists(l1, l2.Next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leetcode-cn：</span><br><span class="line">执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：2.6 MB, 在所有 Go 提交中击败了26.43%的用户</span><br><span class="line"></span><br><span class="line">leetcode：</span><br><span class="line">Runtime: 0 ms, faster than 100.00% of Go online submissions for Merge Two Sorted Lists.</span><br><span class="line">Memory Usage: 2.6 MB, less than 51.09% of Go online submissions for Merge Two Sorted Lists.</span><br></pre></td></tr></table></figure><p>可以看到，该解法执行用时为0ms，非常高效。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/hua-jie-suan-fa-21-he-bing-liang-ge-you-xu-lian-bi/" target="_blank" rel="noopener">力扣-画解算法：21. 合并两个有序链表</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
      <category term="链表" scheme="https://octopuslian.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="递归" scheme="https://octopuslian.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>你这么一棒子把人打死,难道不嫌太武断了吗?</title>
    <link href="https://octopuslian.github.io/2021/02/06/please-dont-discriminate-geographically/"/>
    <id>https://octopuslian.github.io/2021/02/06/please-dont-discriminate-geographically/</id>
    <published>2021-02-06T13:07:49.000Z</published>
    <updated>2021-02-06T13:12:03.651Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --><p><a href="https://book.douban.com/subject/3420392/" target="_blank" rel="noopener">《武林高手在校园》</a>这本穿越小说我高中&amp;大学时读了很多遍，也算是我读的第一本穿越小说，有一处印象比较深的情节，在此记录并抒发一下自己的感受。</p><p>内容应该在73-74节之间，当时油老鼠和林逸飞在街上走着，突然碰到一个人骑自行车钱包掉了出来，立马有人过来说见者有份，要平分赃款，而林逸飞早已识破骗局，于是油老鼠也跟着走了，并说了一句“可恶的河南人”，而林逸飞就说出了我印象最深的话： <em>林逸飞叹息道:“哪个地方都有好人,都会有骗子,你这么一棒子把人打死,难道不嫌太武断了吗?”</em></p><p>为什么我会对这句话印象极其深刻呢？——因为我见过太多的地域歧视。</p><p>上大学那会，我的本科舍友们偶尔会在宿舍关灯后还是唠嗑，这时候我就会闭嘴，因为话题真的很无语，比如——他们一直认为四川人的个子都很矮（我只想说如果都很矮那难道像CBA这种篮球比赛四川队都垫底吗？）；偷井盖子的都是河南人；广东人做的东西不要吃；….等等这种带着地域的偏见。</p><p>然而，当我毕业后，在成都拿了一家互联网公司的offer后，我发现四川当地人并不矮，地铁上、公交车上到处都是高个子；我在部门认识的河南同事都非常乐于助人，有时会停下手里的活帮我来看代码问题；广东的肠粉路边摊到处都是…所以，我学会了怀疑别人说的话，同时也建立了一个前提：哪个地方都有好人,都会有骗子，不能因为这地方出现了这件事情，就把这个地方的人一棍子打死。</p><p>而我也分析了为什么会出现这种现象呢？我罗列了以下原因：</p><ul><li>读书少，没有自己的思想，都是道听途说，别人说什么就信什么；</li><li>媒体作用，总是喜欢把一个地方发生的事件扩大影响，然后再举例子说前多少年也发生类似事件以及水军的无脑附和；</li><li>推荐算法的作用，你倾向于看到什么，算法就会帮你搜集你想看到的，久而久之内心就会产生一种潜意识；</li></ul><p>我很庆幸我生活在一个交通便利的时代，可以到处旅游，见识各地的饮食和风土人情以及方言，所以——写这篇文章也是项表达自己的心声：没事千万不要给不熟悉的地域打上标签，你这么一棒子把人打死,难道不嫌太武断了吗?</p><p>最后引用一下这句话的完整内容，我非常喜欢这段^_^</p><blockquote><p>“可恶的河南人。”油老鼠摇头晃脑的来了这么一句。<br>林逸飞一愣,“为什么这么说?”<br>“刚才那两个就是本地人,可不就是河南人,他们专找外地的旅客下手行骗的。”油老鼠恨恨的说道:“我对河南人向来没有什么好感,再说现在社会也有很多关于河南人的劣迹。” 林逸飞叹息道:“哪个地方都有好人,都会有骗子,你这么一棒子把人打死,难道不嫌太武断了吗?”<br>油老鼠本来想要反驳,突然看到林逸飞的脸色有些沉郁,终于还是嘴边的话咽了回去,点头装作同意道:“林老弟说的是。”<br>看着油老鼠言不由衷的样子,林逸飞苦笑一声,也不再说什么,油老鼠当然不知道,萧别离最尊敬的一个人就是岳元帅,而岳飞偏偏就是河南汤阴人! 从文化意义上来讲,河南实在是一块中国人无法忽视的地域,泱泱大国,千年的华夏文明,正是从这块黄土地发源流淌。<br>这里有着道家的先祖老庄,“外示会儒术,内尊黄道”八个字,为无数的统治者心照不暄的运用,有着墨家的创始人墨翟。提出了意义非凡的‘兼爱’,‘非攻’口号,可以算是最早地和平主义倡导者,有着:;风萧萧兮易水寒,壮士一去兮不复返‘伯侠士荆轲。差一点就凭借手中的宝剑改写了历史,更有着千古传诵,万人景仰的尽忠报国的岳武穆,凭借一腔热血扛起了那面风雨飘摇中地反金大旗! 以悲凉的歌声唱出‘新鬼烦冤旧鬼哭,天阴雨湿声啾啾’这等同情孤苦百姓诗词的杜甫是河南人,写出‘春心莫共花争发,一寸相思一寸灰!’这等华美语句的李商隐也是河南人,那个千百年来的造福苍生的医圣张仲景还是河南人! 而这些不过是河南数不胜数名人中的几个。河南,实在在中国的文明史上留下了不可磨灭地重重烙印,可是如今的人们记住了什么?! 河南人这个本来应该让人骄傲自豪的三个字。正在让人肆无忌惮地嘲笑,毫无顾忌的践踏。这实在是一种文化地悲哀,也是一种‘流言运动’的恶果,更是我们民族整体的悲哀! 在这里,新闻媒体,网络媒介无疑要深刻的反省一下,那些网络推波助澜的也应该停止这种可悲的附和的附和。当你在践踏嘲笑地时候,无疑那点仅存的文明也被你亲手摧毁。<br>“没有谁会比别人高出一等!”林逸飞突然叹息道:“<em>每个人都有尊严,当你认为高出别人一等的时候,我认为,那才是可悲的事情</em>。”<br>油老鼠咀嚼着林逸飞的话,一时竟然有些出神,这难道仅仅是个学生,他实在有着太多当代学生缺乏的东西。</p></blockquote><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/3420392/&quot; target=&quot;_bl
      
    
    </summary>
    
    
      <category term="Review-book" scheme="https://octopuslian.github.io/categories/Review-book/"/>
    
    
      <category term="歧视" scheme="https://octopuslian.github.io/tags/%E6%AD%A7%E8%A7%86/"/>
    
      <category term="地域" scheme="https://octopuslian.github.io/tags/%E5%9C%B0%E5%9F%9F/"/>
    
      <category term="武断" scheme="https://octopuslian.github.io/tags/%E6%AD%A6%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-14-longest-common-prefix | 最长公共前缀</title>
    <link href="https://octopuslian.github.io/2021/02/06/leetcode-14-longest-common-prefix/"/>
    <id>https://octopuslian.github.io/2021/02/06/leetcode-14-longest-common-prefix/</id>
    <published>2021-02-06T12:54:40.000Z</published>
    <updated>2021-02-06T12:55:41.783Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="noopener">LeetCode</a><br><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">LeetCode-cn</a></p><p>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string “”.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">Output: &quot;fl&quot;</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">Output: &quot;&quot;</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line">0 &lt;= strs.length &lt;= 200</span><br><span class="line">0 &lt;= strs[i].length &lt;= 200</span><br><span class="line">strs[i] consists of only lower-case English letters.</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题目的简单描述就是找一堆字符串的相同前缀，比如<code>flower</code>、<code>flow</code>、<code>flight</code>，发现每个字符串都有前缀<code>fl</code>，于是就将<code>fl</code>返回即可，本题就是要实现这样一个在字符串数组中找最长前缀的函数。</p><h3 id="解法一：暴力"><a href="#解法一：暴力" class="headerlink" title="解法一：暴力"></a>解法一：暴力</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="comment">//排除特殊情况</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(strs) == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> strs[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line">res := strs[<span class="number">0</span>]               <span class="comment">//获取字符串数组里的第一个元素</span></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> strs[<span class="number">1</span>:] &#123; <span class="comment">//从字符串数组第二个元素开始遍历</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> ; i &lt; <span class="built_in">len</span>(v) &amp;&amp; i &lt; <span class="built_in">len</span>(res); i++ &#123; <span class="comment">//遍历两数组里的元素</span></span><br><span class="line"><span class="keyword">if</span> res[i] != v[i] &#123; <span class="comment">//做判断，如果不相等</span></span><br><span class="line"><span class="keyword">break</span> <span class="comment">//直接结束循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res = res[:i]</span><br><span class="line"><span class="keyword">if</span> res == <span class="string">""</span> &#123;</span><br><span class="line"><span class="keyword">return</span> res <span class="comment">//返回空</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种相似解法，会用到<a href="https://golang.org/pkg/strings/#Index" target="_blank" rel="noopener">strings.Index</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestCommonPrefix</span><span class="params">(strs []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(strs) &lt; <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    prefix := strs[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> _,k := <span class="keyword">range</span> strs &#123;</span><br><span class="line">        <span class="keyword">for</span> strings.Index(k,prefix) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(prefix) == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">            prefix = prefix[:<span class="built_in">len</span>(prefix) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">力扣：</span><br><span class="line">执行用时：0 ms, 在所有 Go 提交中击败了100.00%的用户</span><br><span class="line">内存消耗：2.3 MB, 在所有 Go 提交中击败了55.76%的用户</span><br><span class="line"></span><br><span class="line">leetcode：</span><br><span class="line">Runtime: 0 ms, faster than 100.00% of Go online submissions for Longest Common Prefix.</span><br><span class="line">Memory Usage: 2.4 MB, less than 100.00% of Go online submissions for Longest Common Prefix.</span><br></pre></td></tr></table></figure><h2 id="参考题解"><a href="#参考题解" class="headerlink" title="参考题解"></a>参考题解</h2><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/solution/zui-chang-gong-gong-qian-zhui-by-leetcode-solution/" target="_blank" rel="noopener">力扣官方题解-5种解法</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="字符串" scheme="https://octopuslian.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="暴力" scheme="https://octopuslian.github.io/tags/%E6%9A%B4%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-13-roman-to-integer | 罗马数字转整数</title>
    <link href="https://octopuslian.github.io/2021/02/05/leetcode-13-roman-to-integer/"/>
    <id>https://octopuslian.github.io/2021/02/05/leetcode-13-roman-to-integer/</id>
    <published>2021-02-05T15:39:46.000Z</published>
    <updated>2021-02-06T12:58:32.597Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/roman-to-integer/" target="_blank" rel="noopener">LeetCode</a><br><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">力扣</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>先维护一个<code>map</code>，用于建立罗马数字和整数的关系，接着挨个破译即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">romanToInt</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> charToIntMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>, <span class="number">8</span>)</span><br><span class="line">    charToIntMap[<span class="string">'I'</span>] = <span class="number">1</span></span><br><span class="line">    charToIntMap[<span class="string">'V'</span>] = <span class="number">5</span></span><br><span class="line">    charToIntMap[<span class="string">'X'</span>] = <span class="number">10</span></span><br><span class="line">    charToIntMap[<span class="string">'L'</span>] = <span class="number">50</span></span><br><span class="line">    charToIntMap[<span class="string">'C'</span>] = <span class="number">100</span></span><br><span class="line">    charToIntMap[<span class="string">'D'</span>] = <span class="number">500</span></span><br><span class="line">    charToIntMap[<span class="string">'M'</span>] = <span class="number">1000</span></span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:= <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">switch</span> s[i] &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> &lt; <span class="built_in">len</span>(s) &amp;&amp; (s[i+<span class="number">1</span>] == <span class="string">'V'</span> || s[i+<span class="number">1</span>] == <span class="string">'X'</span>) &#123;</span><br><span class="line">                sum -= charToIntMap[s[i]]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += charToIntMap[s[i]]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'X'</span>:</span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> &lt; <span class="built_in">len</span>(s) &amp;&amp; (s[i+<span class="number">1</span>] == <span class="string">'L'</span> || s[i+<span class="number">1</span>] == <span class="string">'C'</span>) &#123;</span><br><span class="line">                sum -= charToIntMap[s[i]]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += charToIntMap[s[i]]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> &lt; <span class="built_in">len</span>(s) &amp;&amp; (s[i+<span class="number">1</span>] == <span class="string">'D'</span> || s[i+<span class="number">1</span>] == <span class="string">'M'</span>) &#123;</span><br><span class="line">                sum -= charToIntMap[s[i]]</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += charToIntMap[s[i]]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            sum += charToIntMap[s[i]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leetcode-cn执行：</span><br><span class="line">执行用时：16 ms, 在所有 Go 提交中击败了22.55%的用户</span><br><span class="line">内存消耗：3.1 MB, 在所有 Go 提交中击败了78.12%的用户</span><br><span class="line"></span><br><span class="line">leetcode执行：</span><br><span class="line">Runtime: 8 ms, faster than 64.36% of Go online submissions for Roman to Integer.</span><br><span class="line">Memory Usage: 3.1 MB, less than 100.00% of Go online submissions for Roman to Integer.</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
      <category term="数字转换" scheme="https://octopuslian.github.io/tags/%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>6次提交完善Github个人简介</title>
    <link href="https://octopuslian.github.io/2021/02/01/six-github-commits-update-my-github-readme/"/>
    <id>https://octopuslian.github.io/2021/02/01/six-github-commits-update-my-github-readme/</id>
    <published>2021-02-01T14:55:01.000Z</published>
    <updated>2021-02-01T15:03:57.621Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --><p>半年前意外看到了阿里巴巴半霜大佬的<code>Github</code>个人界面，甚是喜欢，今天晚上我利用了一个半小时的时间查资料分析代码，，地址点<a href="https://github.com/OctopusLian" target="_blank" rel="noopener">这里</a></p><p>个人觉得一个好的<code>Github</code>页面应该包含以下内容：</p><ul><li>简短的个人介绍</li><li>最近的学习情况和期待完成的事</li><li>社交&amp;其他技术网站链接</li><li>常用的软件和编程语言</li><li><code>Github</code>信息，包括star数、commit次数、PRs等</li><li>项目列表</li></ul><p>以上，是我完成这次个人<code>README</code>的动力。</p><p>最后我想说，前端还是很有趣的，有空一定要系统学习一下^_^</p><p><a href="https://www.cnblogs.com/xueweihan/p/13441511.html" target="_blank" rel="noopener">【译】10 款国外实用、有趣的 GitHub 简介 README</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --&gt;&lt;p&gt;半年前意外看到了阿里巴巴半霜大佬的&lt;code&gt;Github&lt;/code&gt;个人界面，甚是喜欢，今天晚上我利用了一个半小时的时间
      
    
    </summary>
    
    
      <category term="Essay" scheme="https://octopuslian.github.io/categories/Essay/"/>
    
    
      <category term="github" scheme="https://octopuslian.github.io/tags/github/"/>
    
      <category term="简介" scheme="https://octopuslian.github.io/tags/%E7%AE%80%E4%BB%8B/"/>
    
      <category term="README" scheme="https://octopuslian.github.io/tags/README/"/>
    
  </entry>
  
  <entry>
    <title>开课吧直播_C/C++开发实战3天训练营</title>
    <link href="https://octopuslian.github.io/2021/01/29/kaikeba-live-cpp-dev-3days-act-tc/"/>
    <id>https://octopuslian.github.io/2021/01/29/kaikeba-live-cpp-dev-3days-act-tc/</id>
    <published>2021-01-29T11:37:53.000Z</published>
    <updated>2021-02-01T15:10:02.850Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --><h2 id="直播老师"><a href="#直播老师" class="headerlink" title="直播老师"></a>直播老师</h2><p>胡光，船长。</p><p>(由于这个课程就是讲解一个<code>Google</code>的测试框架，在此不做详细描述，主要是对直播课的一些有用的问题做记录)</p><h2 id="面试题1-一个数变为二进制后有多少个1？"><a href="#面试题1-一个数变为二进制后有多少个1？" class="headerlink" title="面试题1-一个数变为二进制后有多少个1？"></a>面试题1-一个数变为二进制后有多少个1？</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法一：位运算  </span></span><br><span class="line"><span class="comment">//运算次数32次</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_cnt_v1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">32</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &amp; (<span class="number">1</span> &lt;&lt; i)) cnt += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解法二：while循环，借位</span></span><br><span class="line"><span class="comment">//运算次数16次</span></span><br><span class="line"><span class="keyword">int</span> count_cnt_v2(<span class="keyword">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        x = x &amp; (x - <span class="number">1</span>);</span><br><span class="line">        cnt += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解法三：分组统计法</span></span><br><span class="line"><span class="comment">//运算次数8次</span></span><br><span class="line"><span class="keyword">int</span> arr_cnt[<span class="number">16</span>] = &#123;</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">    <span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,</span><br><span class="line">    <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,</span><br><span class="line">    <span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> count_cnt_v3(<span class="keyword">int</span> x)&#123;</span><br><span class="line">     <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++) &#123;</span><br><span class="line">         cnt += arr_cnt[(x &gt;&gt; (i * <span class="number">4</span>)) &amp; <span class="number">0xf</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解法四：字符串取位</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_cnt_v4</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">8</span>;i++) &#123;</span><br><span class="line">         cnt += <span class="string">"0\1\1\2\1\2\2\3\1\2\3\3\2\3\3\4"</span>[(x &gt;&gt; (i * <span class="number">4</span>)) &amp; <span class="number">0xf</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解法五：分统计法</span></span><br><span class="line"><span class="comment">//运算次数5次</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_cnt_v5</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    x = (x &amp; <span class="number">0</span>x)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="百度面试要求"><a href="#百度面试要求" class="headerlink" title="百度面试要求"></a>百度面试要求</h2><p><img src="/2021/01/29/kaikeba-live-cpp-dev-3days-act-tc/baidu1.png" alt></p><h2 id="撸代码-快速排序"><a href="#撸代码-快速排序" class="headerlink" title="撸代码-快速排序"></a>撸代码-快速排序</h2><ul><li>第一步：选择基准值；</li><li>第二步：partition</li><li>第三步：递归调度</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="comment">//2404ms</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort_v1</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> x = l,y = z,z = arr[l];</span><br><span class="line">    <span class="keyword">while</span>(x &lt; y) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x &lt; y &amp;&amp; arr[y] &gt;= z) --y;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; y) arr[x++] = arr[y];</span><br><span class="line">        <span class="keyword">while</span> (x &lt; y &amp;&amp; arr[x] &lt;= z) ++x;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//版本二：单边递归法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//版本三：无监督的算法优化思想</span></span><br></pre></td></tr></table></figure><h2 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h2><h3 id="为什么C-难学？"><a href="#为什么C-难学？" class="headerlink" title="为什么C++难学？"></a>为什么C++难学？</h3><p>C++支持四种编程范式：</p><ul><li>面向过程的编程范式</li><li>面向对象的编程范式</li><li>泛型编程，模板</li><li>函数式编程</li></ul><p>C++是一门极其考验技术想象力的编程语言。所以一定要学好C语言、算法、操作系统、网络。</p><h3 id="推荐的考试和竞赛"><a href="#推荐的考试和竞赛" class="headerlink" title="推荐的考试和竞赛"></a>推荐的考试和竞赛</h3><ul><li>PAT</li><li>CSP / 蓝桥杯</li><li>ACM</li></ul><h3 id="IDE包含了哪些"><a href="#IDE包含了哪些" class="headerlink" title="IDE包含了哪些"></a>IDE包含了哪些</h3><p>集成环境，集成了很多东西，比如：</p><ul><li>编辑器(vim)</li><li>编译器(g++)</li><li>调试器(gdb)</li></ul><h3 id="什么叫函数的定义？"><a href="#什么叫函数的定义？" class="headerlink" title="什么叫函数的定义？"></a>什么叫函数的定义？</h3><p>能看到函数的实现过程。</p><h3 id="什么叫函数的声明？"><a href="#什么叫函数的声明？" class="headerlink" title="什么叫函数的声明？"></a>什么叫函数的声明？</h3><p>告诉程序有这样一个函数。</p><h3 id="什么是条件式编译？"><a href="#什么是条件式编译？" class="headerlink" title="什么是条件式编译？"></a>什么是条件式编译？</h3><h3 id="什么叫无监督的算法优化思想？"><a href="#什么叫无监督的算法优化思想？" class="headerlink" title="什么叫无监督的算法优化思想？"></a>什么叫无监督的算法优化思想？</h3><p>用插入排序来举例：</p><p>最简单的排序算法，类似插队，一直向前插队</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a,b) &#123; \</span></span><br><span class="line">    __typeof(a) __c = a; \</span><br><span class="line">    a = b, b = _c; \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="keyword">int</span> *arr,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l + <span class="number">1</span>;i &lt;= r;i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; l &amp;&amp; arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;  <span class="comment">//重点 j &gt; l 是监督项，防止下标越界</span></span><br><span class="line">            swap(arr[j],arr[j<span class="number">-1</span>]);</span><br><span class="line">            j -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> un</span><br></pre></td></tr></table></figure><h3 id="为什么插入排序要一个一个的往前调整？"><a href="#为什么插入排序要一个一个的往前调整？" class="headerlink" title="为什么插入排序要一个一个的往前调整？"></a>为什么插入排序要一个一个的往前调整？</h3><p>答：为了不破坏稳定性。</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;直播老师&quot;&gt;&lt;a href=&quot;#直播老师&quot; class=&quot;headerlink&quot; title=&quot;直播老师&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="Share-live" scheme="https://octopuslian.github.io/categories/Share-live/"/>
    
    
      <category term="C++" scheme="https://octopuslian.github.io/tags/C/"/>
    
      <category term="模块编译" scheme="https://octopuslian.github.io/tags/%E6%A8%A1%E5%9D%97%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>《工作细胞Black》第3集——或许是我见过的最好的性教育动画片</title>
    <link href="https://octopuslian.github.io/2021/01/25/work-cell-black-3-erection/"/>
    <id>https://octopuslian.github.io/2021/01/25/work-cell-black-3-erection/</id>
    <published>2021-01-25T12:43:12.000Z</published>
    <updated>2021-01-27T05:32:40.189Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --><h2 id="第3集剧情简介"><a href="#第3集剧情简介" class="headerlink" title="第3集剧情简介"></a>第3集剧情简介</h2><p>周末跟完了《工作细胞 BLACK》的最新剧集，第三集的剧情给我留下了非常深刻的印象，因为它触碰到了我上小学和中学的知识禁区——性行为。</p><p>第3集的大致剧情是一群红细胞收到了比运输氧气更重要的任务，就是这具身体因生殖行为而进行兴奋状态，需要红细胞使阴茎中的海绵组织（海绵体）勃起，完成射精！</p><p><img src="/2021/01/25/work-cell-black-3-erection/wcell.png" alt></p><p>但结果非常不顺：刚开始红细胞排成一队进入海绵体，把螺旋动脉张开，血液进去，进入勃起状态，看似一切顺利</p><p><img src="/2021/01/25/work-cell-black-3-erection/tianchong.png" alt></p><p>紧接着<strong>海绵体的环磷酸鸟苷值正在急剧下降，平滑肌的松弛状态已经解除了，原因是环磷酸鸟苷产量不足，似乎是性兴奋无法顺利通过神经传达到阴茎</strong>——感觉好多陌生名词哦，其实简单来说就是“还没有射精，勃起就停止了，这就是ED（勃起功能障碍）”，这样下去人体没办法勃起-&gt;没办法射精-&gt;精细胞和卵细胞就无法相遇形成受精卵-&gt;生命就无法延续下去。感觉情况很糟糕，就在系统都宣布这次勃起任务失败了，局势逆转了：</p><p><strong>海绵体的环磷酸鸟苷值正在急剧上升，原因是外部投入了伟哥，使PDE5（能够分解环磷酸鸟苷的酶）遭到抑制。</strong></p><p><img src="/2021/01/25/work-cell-black-3-erection/weige.png" alt></p><p>最终，血液填充率达到100%-&gt;静脉出口关闭-&gt;阴茎完全勃起了-&gt;收到射精中枢传来的信号，精子们做好射精准备-&gt;射精准备完毕-&gt;收缩尿道括约肌（尿液和精液就不会同时射出，精液进入前列腺后，尿道的出入口就会关闭，然后只打开出口，精液就会因猛烈的压力而射出）-&gt;收缩完毕-&gt;发射-&gt;射精完毕。</p><p><img src="/2021/01/25/work-cell-black-3-erection/jz1.png" alt><br><img src="/2021/01/25/work-cell-black-3-erection/jz2.png" alt></p><h2 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h2><p>我依稀记得，我第一次接触性知识是初二的生物课上，课本上画了一幅男性性生殖器官构造图，女性的也有，但当时很害羞就直接盖上了，上课的时候老是讲到这也只是简单说男性的生殖器官是阴茎和睾丸，女性的是子宫，它们分别产生精细胞和暖细胞，好了记到这吧，考试不会超出这范围。</p><p>我当时对生物非常感兴趣，总是好奇生命是如何产生的。</p><p>直到有节健康课，老师放了一段受精卵形成的过程，好多精子奔向卵子，我才对理解了一些，高中对这块的知识会在受精后的变化加大考查和分值，而对于为什么有些人性行为的时候要用伟哥，射精前身体要做哪些准备，我都不知道，当然考试也不会考。</p><p>非常感谢这部动漫，让我更形象的看到生命延续的全部过程，也让我更加爱惜自己的身体，拒绝修996福报！！！</p><p>最后我想说，性不应该是洪水猛兽，如果对性这块懵懂的朋友，我非常推荐看这部剧，就从第3集来说，是我目前看到的非常棒的性教育动画片！</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 01 2021 22:51:10 GMT+0800 (China Standard Time) --&gt;&lt;h2 id=&quot;第3集剧情简介&quot;&gt;&lt;a href=&quot;#第3集剧情简介&quot; class=&quot;headerlink&quot; title=&quot;第3集
      
    
    </summary>
    
    
      <category term="Review-film" scheme="https://octopuslian.github.io/categories/Review-film/"/>
    
    
      <category term="工作细胞" scheme="https://octopuslian.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%BB%86%E8%83%9E/"/>
    
      <category term="勃起" scheme="https://octopuslian.github.io/tags/%E5%8B%83%E8%B5%B7/"/>
    
      <category term="性教育" scheme="https://octopuslian.github.io/tags/%E6%80%A7%E6%95%99%E8%82%B2/"/>
    
  </entry>
  
</feed>

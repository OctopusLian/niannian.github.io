<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>以写作调身心</title>
  
  <subtitle>熟能生巧，勤能补拙；念念不忘，必有回响。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://octopuslian.github.io/"/>
  <updated>2021-07-14T16:22:12.747Z</updated>
  <id>https://octopuslian.github.io/</id>
  
  <author>
    <name>Neo Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>突发情况，一定要有B计划</title>
    <link href="https://octopuslian.github.io/2021/07/14/always-to-have-plan-B/"/>
    <id>https://octopuslian.github.io/2021/07/14/always-to-have-plan-B/</id>
    <published>2021-07-13T16:13:17.000Z</published>
    <updated>2021-07-14T16:22:12.747Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --><p>记得最开始看到这句话，是在《小时代1》中那个帅气的混血儿，因为拿错演讲稿，但依旧有条不紊的说了自己准备的<code>planB</code>开场白。</p><p>当时觉得不以为然，心想秘书都帮你安排好了，何必多此一举，现在想想，我真是天真啊…</p><p>感谢社会大学在这一周给我上了精彩的一课，为了等这一刻，你们这些小人也已经蓄谋很久了吧，没关系的，我心态很好，我有家人，有朋友，有一定的资源人脉，而你们也只能在这里继续啃食下一个天真的灵魂。</p><p>再一次，对这块天府之国上的企业感到失望，我不会哭，因为我要假装坚强，我不会气馁，因为打不死的会让我变的更强，我也不会随意的发牢骚，而是要在黑夜里坚持不懈的练拳头。</p><p>再见了，天真的自己。</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;记得最开始看到这句话，是在《小时代1》中那个帅气的混血儿，因为拿错演讲稿，但依旧有条不紊的说了自己准备的&lt;code&gt;planB&lt;/code&gt;开场
      
    
    </summary>
    
    
      <category term="Essay" scheme="https://octopuslian.github.io/categories/Essay/"/>
    
    
      <category term="职场" scheme="https://octopuslian.github.io/tags/%E8%81%8C%E5%9C%BA/"/>
    
      <category term="危机意识" scheme="https://octopuslian.github.io/tags/%E5%8D%B1%E6%9C%BA%E6%84%8F%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Django的MTV架构</title>
    <link href="https://octopuslian.github.io/2021/06/24/django-mtv/"/>
    <id>https://octopuslian.github.io/2021/06/24/django-mtv/</id>
    <published>2021-06-23T16:00:34.000Z</published>
    <updated>2021-06-23T16:08:39.467Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --><h2 id="MTV架构"><a href="#MTV架构" class="headerlink" title="MTV架构"></a>MTV架构</h2><p><img src="/2021/06/24/django-mtv/1.png" alt></p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><ul><li>不重复造轮子</li><li>MVT</li><li>快速开发</li><li>灵活易于扩展</li><li>松耦合</li><li>显式优于隐式</li></ul><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>Python实现，代码干净整洁</li><li>提供管理后台，能快速开发</li><li>复用度高</li><li>易于扩展</li><li>内置的安全框架</li><li>丰富的第三方类库</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>单体应用，不易并行开发</li><li>不适合非常小的几行代码的项目</li><li>不适合高并发面向C端的互联网项目</li></ul><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;MTV架构&quot;&gt;&lt;a href=&quot;#MTV架构&quot; class=&quot;headerlink&quot; title=&quot;MTV架构&quot;&gt;&lt;/a&gt;MTV架构&lt;
      
    
    </summary>
    
    
      <category term="Learn-Django" scheme="https://octopuslian.github.io/categories/Learn-Django/"/>
    
    
      <category term="Django" scheme="https://octopuslian.github.io/tags/Django/"/>
    
      <category term="MTV" scheme="https://octopuslian.github.io/tags/MTV/"/>
    
  </entry>
  
  <entry>
    <title>T项目合作第一次感到不爽</title>
    <link href="https://octopuslian.github.io/2021/06/16/trs-career-first-feel-not-well/"/>
    <id>https://octopuslian.github.io/2021/06/16/trs-career-first-feel-not-well/</id>
    <published>2021-06-16T15:47:59.000Z</published>
    <updated>2021-06-16T16:02:21.239Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --><p>今天是和<code>T</code>项目合伙人的第4or5次开线上腾讯会议，为了一个数据库表的问题争论了10几分钟，才发现问题原来出在我这里，我把问题想复杂了，导致<code>Th</code>童鞋进度慢了两周，额，好吧，在此说声抱歉….</p><p>目前产品原型图、人员都固定了，就照着做就行。然而没想到还是会出现这样那样的问题，<code>Lzd</code>都感到无语了。</p><p>但是，我想，也许这就是一个磨合的过程吧，如果不是这次项目合伙，我也不会频繁的和你沟通、从而了解你的野心、你的执行力，甚至不知道川大南门那附近的一家好吃的小笼包店，嘻嘻…</p><p>后面的路，我想我得抓紧赶业务流程了，感谢目前公司带我的<code>leader</code>，耐心指导我的编码风格，让我一点一点的走上正轨，让我慢慢掌握了<code>gorm</code>和<code>gin</code>这两个主流后端框架。</p><p>加油，办法总比困难多，迎难而上解决掉，让自己不断成长！</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;今天是和&lt;code&gt;T&lt;/code&gt;项目合伙人的第4or5次开线上腾讯会议，为了一个数据库表的问题争论了10几分钟，才发现问题原来出在我这里，我
      
    
    </summary>
    
    
      <category term="Career-notes" scheme="https://octopuslian.github.io/categories/Career-notes/"/>
    
    
      <category term="合伙" scheme="https://octopuslian.github.io/tags/%E5%90%88%E4%BC%99/"/>
    
      <category term="事业" scheme="https://octopuslian.github.io/tags/%E4%BA%8B%E4%B8%9A/"/>
    
      <category term="挫败" scheme="https://octopuslian.github.io/tags/%E6%8C%AB%E8%B4%A5/"/>
    
  </entry>
  
  <entry>
    <title>七年前的高考</title>
    <link href="https://octopuslian.github.io/2021/06/07/seven-years-ago-china-gao-kao/"/>
    <id>https://octopuslian.github.io/2021/06/07/seven-years-ago-china-gao-kao/</id>
    <published>2021-06-07T14:46:15.000Z</published>
    <updated>2021-06-07T16:43:47.426Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --><p><strong>本以为自己离开了地狱走向天堂，却不知离开的才是天堂，走向的才是地狱。</strong></p><h2 id="什么是地狱、什么是天堂？"><a href="#什么是地狱、什么是天堂？" class="headerlink" title="什么是地狱、什么是天堂？"></a>什么是地狱、什么是天堂？</h2><p>在我看来，只要是愿意将时光定格在某个时刻，并且保持身心愉悦，它就是天堂，反之即是地狱。</p><p>曾经的我非常怀念高三那段时光，虽然有成堆的试卷要做，但老班说做不完就别做了，睡眠要紧，每一章前几道题一眼就看出答案的就别做了…哈哈哈，这句话至今印象深刻。</p><p>那时候的我，单纯且乐观，对待一切事物都是尽力就好，不留遗憾。心情不好的时候，约上一个朋友操场散心，亦或是放学留下来打球释放压力，大家开开心心的数着高考的倒计时日历…</p><p>然后，高考结束，从此各奔东西。</p><h2 id="散"><a href="#散" class="headerlink" title="散"></a>散</h2><p>曾经我以为，只要心在，无论身处何方，我们一定还会再见的。</p><p>然而，我忽视了物理学中对原子的质量和动量的描述，即使我一直按照自己的轨迹往前走，但还是无法预测同伴们的轨迹，以至于感到渐行渐远的无奈。</p><h2 id="关于死亡与疾病"><a href="#关于死亡与疾病" class="headerlink" title="关于死亡与疾病"></a>关于死亡与疾病</h2><p>曾经我以为，死亡跟我们这些20岁左右的没关系，直到大三那年回去，一位朋友说有个和我们一届毕业的去年得癌症去世了，我哦了一下，刚毕业一年，我的高中好牛油<code>S</code>因为肺结核，各种吃药化疗瘦了好几圈，我的大学好朋友<code>Y</code>得了甲状腺癌，甲状腺切掉了一半，今年和我一起入职的新同事，去医院检查出早期肺癌，庆幸于自己捡了一条命回来，我的高中物理老师告诉我，曾经带我的英语李老师得了癌症去世…</p><p>原来，死亡一直围绕在我身边，随时找到身体防御系统的漏洞准备入侵，只是我并不知情。</p><h2 id="关于我的高考"><a href="#关于我的高考" class="headerlink" title="关于我的高考"></a>关于我的高考</h2><p>我是2014年参加的高考，犹记得高考前一天晚上，父亲开车带我去爬山，让我把心里的气大声吼出来，妹妹在旁边送给我美好的祝福，我看着夕阳西下，微风吹拂过脸庞，带着阵阵凉意，我在山上站了一会，然后对父亲说，走吧，明天考试。</p><p>第一天的考试，感觉发挥还行，语文作文字写飘了；第二天考完数学，去上卫生间的时候听旁边人说“有个人太紧张，复读了一年来考试，竟然考完忘记把选择题答案涂上去”，吓的我赶紧回忆了一下，哦还好，我涂了；下午考完理综，没有想象中如脱缰野马飞奔而出，而是静静的走出校园，坐上公交回学校拿答案，然后再看一眼自己的母校，再见了，我的中学时光。</p><h2 id="录取通知到了"><a href="#录取通知到了" class="headerlink" title="录取通知到了"></a>录取通知到了</h2><p><strong>潜伏在波涛下寂静无声，跃升于惊涛上乘风化龙。</strong></p><p>录取通知到的那天，我记得很清楚，家里人很开心，我也感到幸运，被喜欢的专业录取。</p><p>四年后，我毕业了，参加工作，入职、成长、离职，跳槽，认识了各个阶级的人，看到曾经的一个个目标在逐步实现，小时候对大人世界的困惑和迷茫也慢慢散去。</p><p>回想起这七年来，让我明白了两件事：</p><ul><li>永远不要做一个被一眼就看透的人；</li><li>韩信的胯下之辱确实让人难以忍受，但当一个人的心中有着更高的山峰想去攀登时，他就不会在意脚下的泥沼。</li></ul><p>曾经的我如同一个无知且单纯的少年，害怕考试，害怕身边的人离我远去。感谢这七年的成长，当我回首自己的中学时光，我确实虚度了它，没有把精力全部放在做题上，但如果时光倒流，我想我依旧会去选择逃课、看小说，选择去追喜欢的女生，选择去做一些刺激的事情…如今那个少年已经不在。</p><h2 id="梦醒、破茧"><a href="#梦醒、破茧" class="headerlink" title="梦醒、破茧"></a>梦醒、破茧</h2><p>前几天做梦，梦见高中好基友凡儿在高考前终于肾结石好了，排出了一个拳头大的石头，然后明天是高考，结果我的准考证还没有打印，路过车站时看到了她那扎着马尾的侧颜，我心中默念高考加油，结果准备打印准考证时手机都碎了，这是铁了心不让我高考啊，凡儿还问我该怎么办，考场座位号都晓得不，但我随即淡定的笑了笑，说道没事，以后还有的是机会…</p><p><img src="/2021/06/07/seven-years-ago-china-gao-kao/gao.jpg" alt></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;本以为自己离开了地狱走向天堂，却不知离开的才是天堂，走向的才是地狱。&lt;/strong&gt;&lt;/p&gt;&lt;h2 id=&quot;什么是地狱、什么是
      
    
    </summary>
    
    
      <category term="Essay" scheme="https://octopuslian.github.io/categories/Essay/"/>
    
    
      <category term="高考" scheme="https://octopuslian.github.io/tags/%E9%AB%98%E8%80%83/"/>
    
      <category term="回忆" scheme="https://octopuslian.github.io/tags/%E5%9B%9E%E5%BF%86/"/>
    
      <category term="初心" scheme="https://octopuslian.github.io/tags/%E5%88%9D%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-日志&amp;指标&amp;链路追踪</title>
    <link href="https://octopuslian.github.io/2021/05/10/goatc-10-log-metrics-and-link-tracking/"/>
    <id>https://octopuslian.github.io/2021/05/10/goatc-10-log-metrics-and-link-tracking/</id>
    <published>2021-05-10T09:12:07.000Z</published>
    <updated>2021-06-09T15:24:28.073Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><p><a href="https://github.com/golang/glog" target="_blank" rel="noopener">https://github.com/golang/glog</a> 是 google 提供的一个不维护的日志库，glog 有其他语言的一些版本，对我当时使用 log 库有很大的影响。它包含如下日志级别：</p><ul><li>Info</li><li>Warning</li><li>Error</li><li>Fatal(会中断程序执行)</li></ul><p>还有类似 log4go，loggo，zap 等其他第三方日志库，他们还提供了设置日志级别的可见行，一般提供日志级别：</p><ul><li>Trace</li><li>Debug</li><li>Info</li><li>Warning</li><li>Error</li><li>Critical</li></ul><h4 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h4><p>没人看警告，因为从定义上讲，没有什么出错。也许将来会出问题，但这听起来像是别人的问题。我们尽可能的消除警告级别，它要么是一条信息性消息，要么是一个错误。我们参考 Go 语言设计额哲学，所有警告都是错误，其他语言的 warning 都可以忽略，除非 IDE 或者在 CICD 流程中强制他们为 error，然后逼着程序员们尽可能去消除。同样的，如果想要最终消除 warning 可以记录为 error，让代码作者重视起来。</p><h4 id="Fatal"><a href="#Fatal" class="headerlink" title="Fatal"></a>Fatal</h4><p>记录消息后，直接调用 os.Exit(1)，这意味着：</p><ul><li>在其他 goroutine defer 语句不会被执行；</li><li>各种 buffers 不会被 flush，包括日志的；</li><li>临时文件或者目录不会被移除；</li></ul><p>不要使用 fatal 记录日志，而是向调用者返回错误。如果错误一直持续到 main.main。main.main 那就是在退出之前做处理任何清理操作的正确位置。</p><h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h4><p>也有很多人，在错误发生的地方要立马记录日志，尤其要使用 error 级别记录。</p><ul><li>处理 error；</li><li>把 error 抛给调用者，在顶部打印日志；</li></ul><p>如果您选择通过日志记录来处理错误，那么根据定义，它不再是一个错误 — 您已经处理了它。记录错误的行为会处理错误，因此不再适合将其记录为错误。</p><h4 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h4><p>相信只有两件事你应该记录：</p><ul><li>开发人员在开发或调试软件时关心的事情。</li><li>用户在使用软件时关心的事情。</li></ul><p>显然，它们分别是调试和信息级别。<br>log.Info 只需将该行写入日志输出。不应该有关闭它的选项，因为用户只应该被告知对他们有用的事情。如果发生了一个无法处理的错误，它就会抛出到 main.main。main.main 程序终止的地方。在最后的日志消息前面插入 fatal 前缀，或者直接写入 os.Stderr。<br>log.Debug，是完全不同的事情。它由开发人员或支持工程师控制。在开发过程中，调试语句应该是丰富的，而不必求助于 trace 或 debug2（您知道自己是谁）级别。日志包应该支持细粒度控制，以启用或禁用调试，并且只在包或更精细的范围内启用或禁用调试语句。</p><p>我们如何设计和思考的：<a href="https://github.com/go-kratos/kratos/tree/v2.0.x/log" target="_blank" rel="noopener">https://github.com/go-kratos/kratos/tree/v2.0.x/log</a></p><h3 id="日志选型"><a href="#日志选型" class="headerlink" title="日志选型"></a>日志选型</h3><p>一个完整的集中式日志系统，需要包含以下几个主要特点：</p><ul><li>收集－能够采集多种来源的日志数据；</li><li>传输－能够稳定的把日志数据传输到中央系统；</li><li>存储－如何存储日志数据；</li><li>分析－可以支持 UI 分析；</li><li>警告－能够提供错误报告，监控机制；</li></ul><p>开源界鼎鼎大名 ELK stack，分别表示：Elasticsearch , Logstash, Kibana , 它们都是开源软件。新增了一个 FileBeat，它是一个轻量级的日志收集处理工具(Agent)，Filebeat 占用资源少，适合于在各个服务器上搜集日志后传输给 Logstash，官方也推荐此工具。</p><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/elk.png" alt></p><p>此架构由 Logstash 分布于各个节点上搜集相关日志、数据，并经过分析、过滤后发送给远端服务器上的 Elasticsearch 进行存储。</p><p>Elasticsearch 将数据以分片的形式压缩存储并提供多种 API 供用户查询，操作。用户亦可以更直观的通过配置 Kibana Web方便的对日志查询，并根据数据生成报表。</p><p>因为 logstash 属于 server 角色，必然出现流量集中式的热点问题，因此我们不建议使用这种部署方式，同时因为 还需要做大量 match 操作（格式化日志），消耗的 CPU 也很多，不利于 scale out。</p><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/2.png" alt></p><p>此种架构引入了消息队列机制，位于各个节点上的 Logstash Agent 先将数据/日志传递给 Kafka，并将队列中消息或数据间接传递给 Logstash，Logstash 过滤、分析后将数据传递给Elasticsearch 存储。最后由 Kibana 将日志和数据呈现给用户。因为引入了 Kafka，所以即使远端 Logstash server 因故障停止运行，数据将会先被存储下来，从而避免数据丢失。</p><p>更进一步的：将收集端 logstash 替换为 beats，更灵活，消耗资源更少，扩展性更强。</p><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/3.png" alt><br><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/4.png" alt></p><h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><ul><li>接入方式收敛；</li><li>日志格式规范；</li><li>日志解析对日志系统透明；</li><li>系统高吞吐、低延迟；</li><li>系统高可用、容量可扩展、高可运维性；</li></ul><h3 id="格式规范"><a href="#格式规范" class="headerlink" title="格式规范"></a>格式规范</h3><p>JSON作为日志的输出格式：</p><ul><li>time: 日志产生时间，ISO8601格式；</li><li>level: 日志等级，ERROR、WARN、 INFO、DEBUG；</li><li>app_id: 应用id，用于标示日志来源；</li><li>instance_id: 实例 id，用于区分同一应用不同实例，即 hostname；</li></ul><h3 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h3><p>日志从产生到可检索，经历几个阶段：</p><ul><li>生产 &amp; 采集</li><li>传输 &amp; 切分</li><li>存储 &amp; 检索</li></ul><h4 id="采集"><a href="#采集" class="headerlink" title="采集"></a>采集</h4><p>logstash：</p><ul><li>监听 tcp/udp</li><li>适用于通过网络上报日志的方式</li></ul><p>filebeat：</p><ul><li>直接采集本地生成的日志文件</li><li>适用于日志无法定制化输出的应用</li></ul><p>logagent：</p><ul><li>物理机部署，监听 unixsocket</li><li>日志系统提供各种语言 SDK</li><li>直接读取本地日志文件</li></ul><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/5.png" alt></p><h4 id="logagent设计"><a href="#logagent设计" class="headerlink" title="logagent设计"></a>logagent设计</h4><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/6.png" alt></p><h4 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h4><p>基于 flume + Kafka 统一传输平台<br>基于 LogID 做日志分流：</p><ul><li>一般级别</li><li>低级别</li><li>高级别（ERROR）</li></ul><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/7.png" alt></p><h4 id="切分"><a href="#切分" class="headerlink" title="切分"></a>切分</h4><p>从kafka消费日志，解析日志，写入elasticsearch<br>bili-index: 自研，golang 开发，逻辑简单，性能 高, 可定制化方便。</p><ul><li>日志规范产生的日志(log agent 收集)<br>logstash: es 官方组件，基于 jruby 开发，功能强大， 资源消耗高，性能低。</li><li>处理未按照日志规范产生的日志(filebeat、logstash 收集)，需配置各种日志解析规则。</li></ul><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/8.png" alt></p><h4 id="存储和检索"><a href="#存储和检索" class="headerlink" title="存储和检索"></a>存储和检索</h4><p>elasticsearch多集群架构：日志分级、高可用<br>单数据集群内: master node + data node(hot/stale) + client node</p><ul><li>每日固定时间进行热-&gt;冷迁移</li><li>Index 提前一天创建，基于 template 进行mapping 管理</li><li>检索基于 kibana</li></ul><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/9.png" alt></p><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>使用自定义协议，对 SDK 质量、版本升级都有比较高的要求，因此我们长期会使用“本地文件”的方案实现：<br>采集本地日志文件：位置不限，容器内 or 物理机<br>配置自描述：不做中心化配置，配置由 app/paas 自身提供，agent 读取配置并生效<br>日志不重不丢：多级队列，能够稳定地处理日志收集过程中各种异常<br>可监控：实时监控运行状态<br>完善的自我保护机制：限制自身对于宿主机资源的消耗，限制发送速度</p><h4 id="容器日志采集"><a href="#容器日志采集" class="headerlink" title="容器日志采集"></a>容器日志采集</h4><p>容器内应用日志采集：基于 overlay2，直接从物理机上查找对应日志文件。</p><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/10.png" alt></p><h2 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h2><h3 id="设计目标-1"><a href="#设计目标-1" class="headerlink" title="设计目标"></a>设计目标</h3><ul><li>无处不在的部署</li><li>持续的监控</li><li>低消耗</li><li>应用级的透明</li><li>延展性</li><li>低延迟</li></ul><h3 id="Dapper"><a href="#Dapper" class="headerlink" title="Dapper"></a>Dapper</h3><p>参考 Google Dapper 论文实现，为每个请求都生成一个全局唯一的 traceid，端到端透传到上下游所有节点，每一层生成一个 spanid，通过traceid 将不同系统孤立的调用日志和异常信息串联一起，通过 spanid 和 level 表达节点的父子关系。</p><p>核心概念：</p><ul><li>Tree</li><li>Span</li><li>Annotation</li></ul><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/11.png" alt></p><h3 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h3><p>在跟踪树结构中，树节点是整个架构的基本单元，而每一个节点又是对 span 的引用。虽然 span 在日志文件中只是简单的代表 span 的开始和结束时间，他们在整个树形结构中却是相对独立的。</p><p>核心概念：</p><ul><li>TraceID</li><li>SpanID</li><li>ParentID</li><li>Family &amp; Title</li></ul><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/12.png" alt></p><h3 id="植入点"><a href="#植入点" class="headerlink" title="植入点"></a>植入点</h3><p>Dapper 可以以对应用开发者近乎零浸入的成本对分布式控制路径进行跟踪，几乎完全依赖于基于少量通用组件库的改造。如下：<br>当一个线程在处理跟踪控制路径的过程中，Dapper 把这次跟踪的上下文的在 ThreadLocal中进行存储，在 Go 语言中，约定每个方法首参数为 context（上下文）<br>覆盖通用的中间件&amp;通讯框架、不限于：redis、memcache、rpc、http、database、queue。</p><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/13.png" alt></p><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/14.png" alt></p><h3 id="跟踪消耗"><a href="#跟踪消耗" class="headerlink" title="跟踪消耗"></a>跟踪消耗</h3><p>处理跟踪消耗：</p><ul><li>正在被监控的系统在生成追踪和收集追踪数据的消耗导致系统性能下降，</li><li>需要使用一部分资源来存储和分析跟踪数据，是Dapper性能影响中最关键的部分：<blockquote><p>因为收集和分析可以更容易在紧急情况下被关闭，ID生成耗时、创建Span等；<br>修改agent nice值，以防在一台高负载的服务器上发生cpu竞争；</p></blockquote></li></ul><p>采样：</p><ul><li>如果一个显着的操作在系统中出现一次，他就会出现上千次，基于这个事情我们不全量收集数据。</li></ul><p>有意思的论文：Uncertainty in Aggregate Estimates from Sampled Distributed Traces</p><h3 id="跟踪采样"><a href="#跟踪采样" class="headerlink" title="跟踪采样"></a>跟踪采样</h3><p>固定采样，1/1024：<br>这个简单的方案是对我们的高吞吐量的线上服务来说是非常有用，因为那些感兴趣的事件(在大吞吐量的情况下)仍然很有可能经常出现，并且通常足以被捕捉到。然而，在较低的采样率和较低的传输负载下可能会导致错过重要事件，而想用较高的采样率就需要能接受的性能损耗。对于这样的系统的解决方案就是覆盖默认的采样率，这需要手动干预的，这种情况是我们试图避免在 Dapper 中出现的。</p><p>应对积极采样：<br>我们理解为单位时间期望采集样本的条目，在高 QPS 下，采样率自然下降，在低 QPS 下，采样率自然增加；比如1s内某个接口采集1条。</p><p>二级采样：<br>容器节点数量多，即使使用积极采样仍然会导致采样样本非常多，所以需要控制写入中央仓库的数据的总规模，利用所有 span 都来自一个特定的跟踪并分享同一个 traceid 这个事实，虽然这些 span 有可能横跨了数千个主机。</p><p>对于在收集系统中的每一个 span，我们用hash算法把 traceid 转成一个标量Z ，这里0&lt;=Z&lt;=1，我们选择了运行期采样率，这样就可以优雅的去掉我们无法写入到仓库中的多余数据，我们还可以通过调节收集系统中的二级采样率系数来调整这个运行期采样率，最终我们通过后端存储压力把策略下发给 agent采集系统，实现精准的二级采样。</p><p>下游采样：<br>越被依赖多的服务，网关层使用积极采样以后，对于 downstream 的服务采样率仍然很高。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>搜索：按照 Family（服务名）、Title（接口）、时间、调用者等维度进行搜索<br>详情：根据单个 traceid，查看整体链路信息，包含 span、level 统计，span 详情，依赖的服务、组件信息等；<br>全局依赖图：由于服务之间的依赖是动态改变的，所以不可能仅从配置信息上推断出所有这些服务之间的依赖关系，能够推算出任务各自之间的依赖，以及任务和其他软件组件之间的依赖。<br>依赖搜索：搜索单个服务的依赖情况，方便我们做“异地多活”时候来全局考虑资源的部署情况，以及区分服务是否属于多活范畴，也可以方便我们经常性的梳理依赖服务和层级来优化我们的整体架构可用性。<br>推断环依赖：一个复杂的业务架构，很难避免全部是层级关系的调用，但是我们要尽可能保证一点：调用栈永远向下，即：不产生环依赖。</p><h3 id="经验-amp-优化"><a href="#经验-amp-优化" class="headerlink" title="经验&amp;优化"></a>经验&amp;优化</h3><p>性能优化：<br>1、不必要的串行调用；2、缓存读放大；3、数据库写放大；4、服务接口聚合调用；</p><p>异常日志系统集成：<br>如果这些异常发生在 Dapper 跟踪采样的上下文中，那么相应的 traceid 和 spanid 也会作为元数据记录在异常日志中。异常监测服务的前端会提供一个链接，从特定的异常信息的报告直接导向到他们各自的分布式跟踪；</p><p>用户日志集成：<br>在请求的头中返回 traceid，当用户遇到故障或者上报客服我们可以根据 traceid 作为整个请求链路的关键字，再根据接口级的服务依赖接口所涉及的服务并行搜索 ES Index，聚合排序数据，就比较直观的诊断问题了；</p><p>容量预估：<br>根据入口网关服务，推断整体下游服务的调用扇出来精确预估流量再各个系统的占比；</p><p>网络热点&amp;易故障点：<br>我们内部 RPC 框架还不够统一，以及基础库的组件部分还没解决拿到应用层协议大小，如果我们收集起来，可以很简单的实现流量热点、机房热点、异常流量等情况。同理容易失败的 span，很容易统计出来，方便我们辨识服务的易故障点；</p><p>opentraceing：<br>标准化的推广，上面几个特性，都依赖 span TAG 来进行计算，因此我们会逐步完成标准化协议，也更方便我们开源，而不是一个内部“特殊系统”；</p><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>Monitoring：</p><ul><li>延迟、流量、错误、饱和度</li><li>长尾问题</li><li>依赖资源 (Client/Server ‘s view)</li></ul><p>opentracing (Google Dapper)：</p><ul><li>jaeger</li><li>zipkin</li></ul><p>Logging：</p><ul><li>traceid关联</li></ul><p>Metric：</p><ul><li>Prometheus + Granfana</li></ul><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/15.png" alt></p><p>涉及到 net、cache、db、rpc 等资源类型的基础库，首先监控维度4个黄金指标：</p><ul><li>延迟（耗时，需要区分正常还是异常）</li><li>流量（需要覆盖来源，即：caller）</li><li>错误（覆盖错误码或者 HTTP Status Code）</li><li>饱和度（服务容量有多“满”）</li></ul><p>系统层面：</p><ul><li>CPU，Memory，IO，Network，TCP/IP 状态等，FD（等其他），Kernel：Context Switch</li><li>Runtime：各类 GC、Mem 内部状态等</li></ul><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/16.png" alt></p><ul><li>线上打开 Profiling 的端口；</li><li>使用服务发现找到节点信息，以及提供快捷的方式快速可以 WEB 化查看进程的 Profiling 信息（火焰图等）；</li><li>watchdog，使用内存、CPU 等信号量触发自动采集；</li></ul><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/17-1.png" alt><br><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/17-2.png" alt></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://dave.cheney.net/2015/11/05/lets-talk-about-logging" target="_blank" rel="noopener">https://dave.cheney.net/2015/11/05/lets-talk-about-logging</a><br><a href="https://www.ardanlabs.com/blog/2013/11/using-log-package-in-go.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2013/11/using-log-package-in-go.html</a><br><a href="https://www.ardanlabs.com/blog/2017/05/design-philosophy-on-logging.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2017/05/design-philosophy-on-logging.html</a><br><a href="https://dave.cheney.net/2017/01/23/the-package-level-logger-anti-pattern" target="_blank" rel="noopener">https://dave.cheney.net/2017/01/23/the-package-level-logger-anti-pattern</a><br><a href="https://help.aliyun.com/document_detail/28979.html?spm=a2c4g.11186623.2.10.3b0a729amtsBZe" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/28979.html?spm=a2c4g.11186623.2.10.3b0a729amtsBZe</a><br><a href="https://developer.aliyun.com/article/703229" target="_blank" rel="noopener">https://developer.aliyun.com/article/703229</a><br><a href="https://developer.aliyun.com/article/204554" target="_blank" rel="noopener">https://developer.aliyun.com/article/204554</a><br><a href="https://developer.aliyun.com/article/251629" target="_blank" rel="noopener">https://developer.aliyun.com/article/251629</a><br><a href="https://www.elastic.co/cn/what-is/elk-stack" target="_blank" rel="noopener">https://www.elastic.co/cn/what-is/elk-stack</a><br><a href="https://my.oschina.net/itblog/blog/547250" target="_blank" rel="noopener">https://my.oschina.net/itblog/blog/547250</a><br><a href="https://www.cnblogs.com/aresxin/p/8035137.html" target="_blank" rel="noopener">https://www.cnblogs.com/aresxin/p/8035137.html</a><br><a href="https://www.elastic.co/cn/products/beats/filebeat" target="_blank" rel="noopener">https://www.elastic.co/cn/products/beats/filebeat</a><br><a href="https://www.elastic.co/guide/en/beats/filebeat/5.6/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/filebeat/5.6/index.html</a><br><a href="https://www.elastic.co/cn/products/logstash" target="_blank" rel="noopener">https://www.elastic.co/cn/products/logstash</a><br><a href="https://www.elastic.co/guide/en/logstash/5.6/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/5.6/index.html</a><br><a href="https://www.elastic.co/cn/products/kibana" target="_blank" rel="noopener">https://www.elastic.co/cn/products/kibana</a><br><a href="https://www.elastic.co/guide/en/kibana/5.5/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/kibana/5.5/index.html</a><br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/5.6/index.html</a><br><a href="https://elasticsearch.cn/" target="_blank" rel="noopener">https://elasticsearch.cn/</a><br><a href="https://blog.aliasmee.com/post/graylog-log-system-architecture/" target="_blank" rel="noopener">https://blog.aliasmee.com/post/graylog-log-system-architecture/</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;日志&quot;&gt;&lt;a href=&quot;#日志&quot; class=&quot;headerlink&quot; title=&quot;日志&quot;&gt;&lt;/a&gt;日志&lt;/h2&gt;&lt;h3 id=&quot;
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="golang" scheme="https://octopuslian.github.io/tags/golang/"/>
    
      <category term="日志" scheme="https://octopuslian.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-分布式缓存和分布式事务</title>
    <link href="https://octopuslian.github.io/2021/05/06/goatc-8-distributed-cache-and-affair/"/>
    <id>https://octopuslian.github.io/2021/05/06/goatc-8-distributed-cache-and-affair/</id>
    <published>2021-05-06T13:43:07.000Z</published>
    <updated>2021-06-09T14:56:56.299Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --><h2 id="缓存选型"><a href="#缓存选型" class="headerlink" title="缓存选型"></a>缓存选型</h2><h3 id="memcache"><a href="#memcache" class="headerlink" title="memcache"></a>memcache</h3><p>memcache 提供简单的 kv cache 存储，value 大小不超过1mb。</p><p>我使用 memcache 作为大文本或者简单的 kv结构使用。</p><p>memcache 使用了slab 方式做内存管理，存在一定的浪费，如果大量接近的 item，建议调整 memcache 参数来优化每一个 slab 增长的 ratio、可以通过设置 slab_automove &amp; slab_reassign 开启memcache 的动态/手动 move slab，防止某些 slab 热点导致内存足够的情况下引发 LRU。</p><p>大部分情况下，简单 KV 推荐使用 Memcache，吞吐和相应都足够好。</p><p>每个 slab 包含若干大小为1M的内存页，这些内存又被分割成多个 chunk，每个 chunk存储一个 item；<br>在 memcache 启动初始化时，每个 slab 都预分配一个 1M 的内存页，由slabs_preallocate 完成(也可将相应代码注释掉关闭预分配功能)。</p><p>chunk 的增长因子由 -f 指定，默认1.25，起始大小为48字节。<br>内存池有很多种设计，可以参考下: nginx ngx_pool_t，tcmalloc 的设计等等。</p><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><p>redis 有丰富的数据类型，支持增量方式的修改部分数据，比如排行榜，集合，数组等。</p><p>比较常用的方式是使用 redis 作为数据索引，比如评论的列表 ID，播放历史的列表 ID 集合，我们的关系链列表 ID。</p><p>redis 因为没有使用内存池，所以是存在一定的内存碎片的，一般会使用 jemalloc 来优化内存分配，需要编译时候使用 jemalloc 库代替 glib 的 malloc 使用。</p><h3 id="redis-vs-memcache"><a href="#redis-vs-memcache" class="headerlink" title="redis vs memcache"></a>redis vs memcache</h3><p>Redis 和 Memcache 最大的区别其实是 redis 单线程(新版本双线程)，memcache 多线程，所以 QPS 可能两者差异不大，但是吞吐会有很大的差别，比如大数据 value 返回的时候，redis qps 会抖动下降的的很厉害，因为单线程工作，其他查询进不来(新版本有不少的改善)。</p><p>所以建议纯 kv 都走 memcache，比如我们的关系链服务中用了 hashs 存储双向关系，但是我们也会使用 memcache 档一层来避免hgetall 导致的吞吐下降问题。</p><p>我们系统中多次使用 memcache + redis 双缓存设计。</p><p><img src="/2021/05/06/goatc-8-distributed-cache-and-affair/memcache-vs-redis.png" alt></p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>早期使用 twemproxy 作为缓存代理，但是在使用上有如下一些痛点：</p><ul><li>单进程单线程模型和 redis 类似，在处理一些大 key 的时候可能出现 io 瓶颈；</li><li>二次开发成本难度高，难以于公司运维平台进行深度集成；</li><li>不支持自动伸缩，不支持 autorebalance 增删节点需要重启才能生效；</li><li>运维不友好，没有控制面板；</li></ul><p>业界开源的的其他代理工具：</p><ul><li>codis: 只支持 redis 协议，且需要使用 patch版本的 redis；</li><li>mcrouter: 只支持 memcache 协议，C 开发，与运维集成开发难度高；</li></ul><p>从集中式访问缓存到 Sidecar 访问缓存：</p><ul><li>微服务强调去中心化；</li><li>LVS 运维困难，容易流量热点，随下游扩容而扩容，连接不均衡等问题；</li><li>Sidecar 伴生容器随 App 容器启动而启动，配置简化；</li></ul><h3 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h3><p>一致性 hash 是将数据按照特征值映射到一个首尾相接的 hash 环上，同时也将节点（按照 IP 地址或者机器名 hash）映射到这个环上。</p><p>对于数据，从数据在环上的位置开始，顺时针找到的第一个节点即为数据的存储节点。</p><p>余数分布式算法由于保存键的服务器会发生巨大变化而影响缓存的命中率，但Consistent Hashing 中，只有在园（continuum）上增加服务器的地点逆时针方向的第一台服务器上的键会受到影响。</p><ul><li>平衡性(Balance)：尽可能分布到所有的缓冲中去</li><li>单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲区加入到系统中，那么哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲区中去，而不会被映射到旧的缓冲集合中的其他缓冲区。</li><li>分散性(Spread)：相同内容被存储到不同缓冲中去，降低了系统存储的效率，需要尽量降低分散性。</li><li>负载(Load)：哈希算法应能够尽量降低缓冲的负荷。</li><li>平滑性(Smoothness)：缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的。</li></ul><p>一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。</p><p>此时必然造成大量数据集中到 Node A 上，而只有极少量会定位到 Node B 上。为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。</p><p>具体做法可以在服务器 ip 或主机名的后面增加编号来实现。</p><p><img src="/2021/05/06/goatc-8-distributed-cache-and-affair/yi-zhi-hash.png" alt></p><p>例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算<br>“Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点。<br>同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到<br>“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到 Node A 上。这样就解决了服务节点少时数据倾斜的问题。</p><p>参考微信红包的写合并优化：<br><a href="https://www.cnblogs.com/chinanetwind/articles/9460820.html" target="_blank" rel="noopener">https://www.cnblogs.com/chinanetwind/articles/9460820.html</a></p><p>在网关层，使用一致性 hash，对红包 id 进行分片，命中到某一个逻辑服务器处理，在进程内做写操作的合并，减少存储层的单行锁争用。<br>我认为更好的做法是 有界负载一致性 hash。</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>数据分片的 hash 方式也是这个思想，即按照数据的某一特征（key）来计算哈希值，并将哈希值与系统中的节点建立映射关系,从而将哈希值不同的数据分布到不同的节点上。</p><p>按照 hash 方式做数据分片，映射关系非常简单；需要管理的元数据也非常之少，只需要记录节点的数目以及 hash 方式就行了。</p><p>当加入或者删除一个节点的时候，大量的数据需要移动。比如在这里增加一个节点 N3，因此 hash 方式变为了 mod 4。</p><p>均衡问题：原始数据的特征值分布不均匀，导致大量的数据集中到一个物理节点上；第二，对于可修改的记录数据，单条记录的数据变大。<br>高级玩法是抽象 slot，基于 Hash 的 Slot Sharding，例如 Redis-Cluster。</p><h3 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h3><p>redis-cluster 把16384 槽按照节点数量进行平均分配，由节点进行管理。</p><p>对每个 key 按照 CRC16 规则进行 hash 运算，把 hash 结果对16383进行取余，把余数发送给 Redis 节点。</p><p>需要注意的是：Redis Cluster 的节点之间会共享消息，每个节点都会知道是哪个节点负责哪个范围内的数据槽</p><h2 id="缓存模式"><a href="#缓存模式" class="headerlink" title="缓存模式"></a>缓存模式</h2><h3 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h3><p>Storage 和 Cache 同步更新容易出现数据不一致。</p><p>模拟 MySQL Slave 做数据复制，再把消息投递到 Kafka，保证至少一次消费：</p><ul><li>同步操作DB；</li><li>同步操作Cache；</li><li>利用Job消费消息，重新补偿一次缓存操作</li></ul><p>保证时效性和一致性。</p><p>读/写同时操作：<br>读操作，读缓存，缓存 MISS<br>读操作，读 DB，读取到数据<br>写操作，更新 DB 数据<br>写操作 SET/DELETE Cache（可 Job 异步操作）<br>读操作，SET操作数据回写缓存（可 Job 异步操作）</p><p>这种交互下，由于4和5操作步骤都是设置缓存，导致写入的值互相覆盖；并且操作的顺序性不确定，从而导致 cache 存在脏缓存的情况。</p><p><img src="/2021/05/06/goatc-8-distributed-cache-and-affair/shu-ju-yi-zhi.png" alt></p><h3 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h3><p>微服务拆分细粒度原子业务下的整合服务（聚合服务），用于提供粗粒度的接口，以及二级缓存加速，减少扇出的 rpc 网络请求，减少延迟。<br>最重要是保证多级缓存的一致性：</p><ul><li>清理的优先级是有要求的，先优先清理下游再上游；</li><li>下游的缓存expire要大于上游，里面穿透回源；</li></ul><p>天下大势分久必合，适当的微服务合并也是不错的做法，再使用 DDD 思路以及我们介绍的目录结构组织方式，区分不同的 Usecase。</p><h3 id="热点缓存"><a href="#热点缓存" class="headerlink" title="热点缓存"></a>热点缓存</h3><p>对于热点缓存 Key，按照如下思路解决：</p><ul><li>小表广播，从 RemoteCache 提升为LocalCache，App 定时更新，甚至可以让运营平台支持广播刷新 LocalCache；</li><li>主动监控防御预热，比如直播房间页高在线情况下直接外挂服务主动防御；</li><li>基础库框架支持热点发现，自动短时的 short-live cache；</li><li>多 Cluster 支持；<br>多 Key 设计: 使用多副本，减小节点热点的问题<br>使用多副本 ms_1,ms_2,ms_3 每个节点保存一份数据，使得请求分散到多个节点，避免单点热点问题。</li></ul><h3 id="穿透缓存"><a href="#穿透缓存" class="headerlink" title="穿透缓存"></a>穿透缓存</h3><ul><li><p>singlefly<br>对关键字进行一致性 hash，使其某一个维度的 key 一定命中某个节点，然后在节点内使用互斥锁，保证归并回源，但是对于批量查询无解；</p></li><li><p>分布式锁<br>设置一个 lock key，有且只有一个人成功，并且返回，交由这个人来执行回源操作，其他候选者轮训 cache 这个 lock key，如果不存在去读数据缓存，hit 就返回，miss 继续抢锁；</p></li><li><p>队列<br>如果 cache miss，交由队列聚合一个key，来 load 数据回写缓存，对于 miss 当前请求可以使用 singlefly 保证回源，如评论架构实现。适合回源加载数据重的任务，比如评论 miss 只返回第一页，但是需要构建完成评论数据索引。</p></li><li><p>lease<br>通过加入 lease 机制，可以很好避免这两个问题，lease 是 64-bit 的 token，与客户端请求的 key 绑定，对于过时设置，在写入时验证 lease，可以解决这个问题；对于 thundering herd，每个key 10s 分配一次，当 client 在没有获取到 lease 时，可以稍微等一下再访问 cache，这时往往cache 中已有数据。（基础库支持 &amp; 修改 cache 源码）；</p></li></ul><h2 id="缓存技巧"><a href="#缓存技巧" class="headerlink" title="缓存技巧"></a>缓存技巧</h2><h3 id="Incast-Congestion"><a href="#Incast-Congestion" class="headerlink" title="Incast Congestion"></a>Incast Congestion</h3><p>如果在网路中的包太多，就会发生 Incast Congestion 的问题（可以理解为，network 有很多switch，router 啥的，一旦一次性发一堆包，这些包同时到达 switch，这些 switch 就会忙不过来）。</p><p>应对这个问题就是不要让大量包在同一时间发送出去，在客户端限制每次发出去的包的数量（具体实现就是客户端弄个队列）。</p><p>每次发送的包的数量称为“Window size”。这个值太小的话，发送太慢，自然延迟会变高；这个值太大，发送的包太多把 network switch 搞崩溃了，就可能发生比如丢包之类的情况，可能被当作 cache miss，这样延迟也会变高。所以这个值需要调，一般会在 proxy 层面实现。</p><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><ul><li>易读性的前提下，key 设置尽可能小，减少资源的占用，redis value 可以用 int 就不要用string，对于小于 N 的 value，redis 内部有 shared_object 缓存。</li><li>拆分 key。主要是用在 redis 使用 hashes 情况下。同一个 hashes key 会落到同一个 redis 节点，hashes 过大的情况下会导致内存及请求分布的不均匀。考虑对 hash 进行拆分为小的hash，使得节点内存均匀及避免单节点请求热点。</li><li>空缓存设置。对于部分数据，可能数据库始终为空，这时应该设置空缓存，避免每次请求都缓存 miss 直接打到 DB。</li><li>空缓存保护策略。</li><li>读失败后的写缓存策略（降级后一般读失败不触发回写缓存）。</li><li>序列化使用 protobuf，尽可能减少 size。</li><li>工具化浇水代码</li></ul><h3 id="memcache-小技巧"><a href="#memcache-小技巧" class="headerlink" title="memcache 小技巧"></a>memcache 小技巧</h3><ul><li>flag 使用：标识 compress、encoding、large value 等；</li><li>memcache 支持 gets，尽量读取，尽可能的 pipeline，减少网络往返；</li><li>使用二进制协议，支持 pipeline delete，UDP 读取、TCP 更新；</li></ul><h3 id="redis-小技巧"><a href="#redis-小技巧" class="headerlink" title="redis 小技巧"></a>redis 小技巧</h3><ul><li>增量更新一致性：EXPIRE、ZADD/HSET 等，保证索引结构体务必存在的情况下去操作新增数据；</li><li>BITSET: 存储每日登陆用户，单个标记位置（boolean），为了避免单个 BITSET 过大或者热点，需要使用 region sharding，比如按照mid求余 %和/ 10000，商为 KEY、余数作为offset；</li><li>List:抽奖的奖池、顶弹幕，用于类似 Stack PUSH/POP操作；</li><li>Sortedset: 翻页、排序、有序的集合，杜绝 zrange 或者 zrevrange 返回的集合过大；</li><li>Hashs: 过小的时候会使用压缩列表、过大的情况容易导致 rehash 内存浪费，也杜绝返回hgetall，对于小结构体，建议直接使用 memcache KV；</li><li>String: SET 的 EX/NX 等 KV 扩展指令，SETNX 可以用于分布式锁、SETEX 聚合了SET + EXPIRE；</li><li>Sets: 类似 Hashs，无 Value，去重等；</li><li>尽可能的 PIPELINE 指令，但是避免集合过大；</li><li>避免超大 Value；</li></ul><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>讲到事务，又得搬出经典的转账问题了：<br>支付宝账户表：A (id, user_id, amount)<br>余额宝账户表：B (id, user_id, amount)<br>用户的 user_id = 1，从支付宝转帐1万快到余额宝分为两个步骤：<br>支付宝表扣除1万：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> A <span class="keyword">SET</span> amount = amount - <span class="number">10000</span> <span class="keyword">WHERE</span> user_id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>余额宝表增加1万：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> B <span class="keyword">SET</span> amount = amount + <span class="number">10000</span> <span class="keyword">WHERE</span> user_id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如何保证数据一致性呢？<br>单个数据库，我们保证 ACID 使用 数据库事务。</p><h3 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h3><p>如何可靠的保存消息凭证？<br>要解决消息可靠存储，我们实际上需要解决的问题是，本地的 mysql 存储和 message 存储的一致性问题。</p><ul><li>Transactional outbox</li><li>Polling publisher</li><li>Transaction log tailing</li><li>2PC Message Queue</li></ul><p>事务消息一旦被可靠的持久化，我们整个分布式事务，变为了最终一致性，消息的消费才能保障最终业务数据的完整性，所以我们要尽最大努力，把消息送达到下游的业务消费方，称为：Best Effort。只有消息被消费，整个交易才能算是完整完结。</p><h3 id="Best-Effort"><a href="#Best-Effort" class="headerlink" title="Best Effort"></a>Best Effort</h3><p>即尽最大努力交付，主要用于在这样一种场景：不同的服务平台之间的事务性保证。<br>比如我们在电商购物，使用支付宝支付；又比如玩网游的时候，通过 App Store 充值。<br>拿购物为例，电商平台与支付平台是相互独立的，隶属于不同的公司，即使是同一个公司也很可能是独立的部门。<br>“ 做过支付宝交易接口的同学都知道，我们一般会在支付宝的回调页面和接口里，解密参数，然后调用系统中更新交易状态相关的服务，将订单更新为付款成功。<br>同时，只有当我们回调页面中输出了success 字样或者标识业务处理成功相应状态码时，支付宝才会停止回调请求。否则，支付宝会每间隔一段时间后，再向客户方发起回调请求，直到输出成功标识为止。”</p><h3 id="Transactional-outbox"><a href="#Transactional-outbox" class="headerlink" title="Transactional outbox"></a>Transactional outbox</h3><p>Transactional outbox，支付宝在完成扣款的同时，同时记录消息数据，这个消息数据与业务数据保存在同一数据库实例里（消息记录表表名为 msg）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EGIN TRANSACTION</span><br><span class="line">    <span class="keyword">UPDATE</span> A <span class="keyword">SET</span> amount = amount - <span class="number">10000</span> <span class="keyword">WHERE</span> user_id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> msg(user_id, amount, <span class="keyword">status</span>) <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">10000</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">TRANSACTION</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>上述事务能保证只要支付宝账户里被扣了钱，消息一定能保存下来。当上述事务提交成功后，我们想办法将此消息通知余额宝，余额宝处理成功后发送回复成功消息，支付宝收到回复后删除该条消息数据。</p><h3 id="Polling-publisher"><a href="#Polling-publisher" class="headerlink" title="Polling publisher"></a>Polling publisher</h3><p>Polling publisher，我们定时的轮训 msg 表，把 status = 1 的消息统统拿出来消费，可以按照自增 id 排序，保证顺序消费。在这里我们独立了一个 pay_task 服务，把拖出来的消息 publish 给我们消息队列，balance 服务自己来消费队列，或者直接 rpc 发送给 balance 服务。</p><p>实际我们第一个版本的 archive-service 在使用 CQRS 时，就用的这个模型，Pull 的模型，从延迟来说不够好，Pull 太猛对 Database 有一定压力，Pull 频次低了，延迟比较高。</p><h3 id="Transaction-log-tailing"><a href="#Transaction-log-tailing" class="headerlink" title="Transaction log tailing"></a>Transaction log tailing</h3><p>Transaction log tailing，上述保存消息的方式使得消息数据和业务数据紧耦合在一起，从架构上看不够优雅，而且容易诱发其他问题。<br>有一些业务场景，可以直接使用主表被 canal 订阅使用，有一些业务场景自带这类 message 表，比如订单或者交易流水，可以直接使用这类流水表作为 message 表使用。</p><p>使用 canal 订阅以后，是实时流式消费数据，在消费者 balance 或者 balance-job 必须努力送达到。</p><p>我们发现，所有努力送达的模型，必须是先预扣（预占资源）的做法。</p><h3 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h3><p>还有一个很严重的问题就是消息重复投递，如果相同的消息被重复投递两次，那么我们余额宝账户将会增加2万而不是1万了。</p><p>为什么相同的消息会被重复投递？比如余额宝处理完消息 msg 后，发送了处理成功的消息给支付宝，正常情况下支付宝应该要删除消息msg，但如果支付宝这时候悲剧的挂了，重启后一看消息 msg 还在，就会继续发送消息 msg。</p><ul><li><p>全局唯一 ID+ 去重表<br>在余额宝这边增加消息应用状态表 msg_apply，通俗来说就是个账本，用于记录消息的消费情况，每次来一个消息，在真正执行之前，先去消息应用状态表中查询一遍，如果找到说明是重复消息，丢弃即可，如果没找到才执行，同时插入到消息应用状态表（同一事务）。</p></li><li><p>版本号</p></li></ul><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p>两阶段提交协议(Two Phase Commitment Protocol)中，涉及到两种角色</p><ul><li>一个事务协调者（coordinator）：负责协调多个参与者进行事务投票及提交(回滚)</li><li>多个事务参与者（participants）：即本地事务执行者</li></ul><p>总共处理步骤有两个<br>（1）投票阶段（voting phase）：协调者将通知事务参与者准备提交或取消事务，然后进入表决过程。参与者将告知协调者自己的决策：同意（事务参与者本地事务执行成功，但未提交）或取消（本地事务执行故障）；<br>（2）提交阶段（commit phase）：收到参与者的通知后，协调者再向参与者发出通知，根据反馈情况决定各参与者是否要提交还是回滚；</p><h3 id="2PC-Message-Queue"><a href="#2PC-Message-Queue" class="headerlink" title="2PC Message Queue"></a>2PC Message Queue</h3><p><img src="/2021/05/06/goatc-8-distributed-cache-and-affair/affair.png" alt></p><h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><p>TCC 是 Try、Conﬁrm、Cancel 三个词语的缩写，TCC 要求每个分支事务实现三个操作：预处理 Try、确认 Conﬁrm、撤销 Cancel。<br>Try 操作做业务检查及资源预留，Conﬁrm 做业务确认操作，Cancel 实现一个与 Try 相反的操作即回滚操作。<br>TM 首先发起所有的分支事务的 Try 操作，任何一个分支事务的 Try 操作执行失败，TM 将会发起所有分支事务的 Cancel 操作，若 Try 操作全部成功，TM 将会发起所有分支事务的 Conﬁrm 操作，其中 Conﬁrm/Cancel 操作若执行失败，TM 会进行重试。</p><p>需要注意：</p><ul><li>空回滚</li><li>防悬挂</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://blog.csdn.net/chen_kkw/article/details/82724330" target="_blank" rel="noopener">https://blog.csdn.net/chen_kkw/article/details/82724330</a><br><a href="https://zhuanlan.zhihu.com/p/328728595" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/328728595</a><br><a href="https://www.cnblogs.com/chinanetwind/articles/9460820.html" target="_blank" rel="noopener">https://www.cnblogs.com/chinanetwind/articles/9460820.html</a><br><a href="https://medium.com/vimeo-engineering-blog/" target="_blank" rel="noopener">https://medium.com/vimeo-engineering-blog/</a> improving-load-balancing-with-a-new-consistent-hashing-algorithm-9f1bd75709ed<br><a href="https://www.jianshu.com/p/5fa447c60327" target="_blank" rel="noopener">https://www.jianshu.com/p/5fa447c60327</a><br><a href="https://writings.sh/post/consistent-hashing-algorithms-part-1-the-problem-and-the-concept" target="_blank" rel="noopener">https://writings.sh/post/consistent-hashing-algorithms-part-1-the-problem-and-the-concept</a><br><a href="https://www.cnblogs.com/williamjie/p/11132211.html" target="_blank" rel="noopener">https://www.cnblogs.com/williamjie/p/11132211.html</a></p><p><a href="https://blog.csdn.net/hosaos/article/details/89136666" target="_blank" rel="noopener">https://blog.csdn.net/hosaos/article/details/89136666</a><br><a href="https://zhuanlan.zhihu.com/p/183753774" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/183753774</a><br><a href="https://www.cnblogs.com/dyzcs/p/13780668.html" target="_blank" rel="noopener">https://www.cnblogs.com/dyzcs/p/13780668.html</a><br><a href="https://blog.csdn.net/bjweimengshu/article/details/79607522" target="_blank" rel="noopener">https://blog.csdn.net/bjweimengshu/article/details/79607522</a><br><a href="https://microservices.io/patterns/data/event-sourcing.html" target="_blank" rel="noopener">https://microservices.io/patterns/data/event-sourcing.html</a><br><a href="https://microservices.io/patterns/data/saga.html" target="_blank" rel="noopener">https://microservices.io/patterns/data/saga.html</a><br><a href="https://microservices.io/patterns/data/polling-publisher.html" target="_blank" rel="noopener">https://microservices.io/patterns/data/polling-publisher.html</a><br><a href="https://microservices.io/patterns/data/polling-publisher.html" target="_blank" rel="noopener">https://microservices.io/patterns/data/polling-publisher.html</a><br><a href="https://microservices.io/patterns/data/transaction-log-tailing.html" target="_blank" rel="noopener">https://microservices.io/patterns/data/transaction-log-tailing.html</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;缓存选型&quot;&gt;&lt;a href=&quot;#缓存选型&quot; class=&quot;headerlink&quot; title=&quot;缓存选型&quot;&gt;&lt;/a&gt;缓存选型&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="golang" scheme="https://octopuslian.github.io/tags/golang/"/>
    
      <category term="分布式" scheme="https://octopuslian.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="缓存" scheme="https://octopuslian.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="事务" scheme="https://octopuslian.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="redis" scheme="https://octopuslian.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-网络编程</title>
    <link href="https://octopuslian.github.io/2021/05/05/goatc-9-network-programming-practice/"/>
    <id>https://octopuslian.github.io/2021/05/05/goatc-9-network-programming-practice/</id>
    <published>2021-05-05T14:00:45.000Z</published>
    <updated>2021-06-09T14:56:57.377Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --><h2 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h2><p>互联网的核心是一系列协议，总称为”互联网协议”（Internet Protocol Suite），正是这一些协议规定了电脑如何连接和组网。</p><p>主要协议分为：</p><ul><li>Socket：接口抽象层</li><li>TCP / UDP：面向连接(可靠) / 无连接(不可靠)</li><li>HTTP1.1 / HTTP2 / QUIC（HTTP3）：超文本传输协议</li></ul><h3 id="Socket-抽象层"><a href="#Socket-抽象层" class="headerlink" title="Socket 抽象层"></a>Socket 抽象层</h3><p>应用程序通常通过“套接字”向网络发出请求或者应答网络请求。</p><p>一种通用的面向流的网络接口</p><p>主要操作：</p><ul><li>建立、接受连接</li><li>读写、关闭、超时</li><li>获取地址、端口</li></ul><h3 id="TCP-可靠连接，面向连接的协议"><a href="#TCP-可靠连接，面向连接的协议" class="headerlink" title="TCP 可靠连接，面向连接的协议"></a>TCP 可靠连接，面向连接的协议</h3><p>TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一种面向连接（连接导向）的、可靠的、基于字节流的传输层（Transport layer）通信协议，因为是面向连接的协议。</p><p>服务端流程：</p><ul><li>监听端口</li><li>接收客户端请求建立连接</li><li>创建 goroutine 处理连接</li></ul><p>客户端流程：</p><ul><li>建立与服务端的连接</li><li>进行数据收发</li><li>关闭连接</li></ul><h3 id="UDP-不可靠连接，允许广播或多播"><a href="#UDP-不可靠连接，允许广播或多播" class="headerlink" title="UDP 不可靠连接，允许广播或多播"></a>UDP 不可靠连接，允许广播或多播</h3><p>UDP 协议（User Datagram Protocol）中文名称是用户数据报协议，是 OSI（Open System Interconnection，开放式系统互联）参考模型中一种无连接的传输层协议。</p><p>一个简单的传输层协议：</p><ul><li>不需要建立连接</li><li>不可靠的、没有时序的通信</li><li>数据报是有长度（65535-20=65515）</li><li>支持多播和广播</li><li>低延迟，实时性比较好</li><li>应用于用于视频直播、游戏同步</li></ul><h3 id="HTTP-超文本传输协议"><a href="#HTTP-超文本传输协议" class="headerlink" title="HTTP 超文本传输协议"></a>HTTP 超文本传输协议</h3><p>HTTP(HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议，它详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。</p><p>请求报文：</p><ul><li>Method: HEAD/GET/POST/PUT/DELETE</li><li>Accept：text/html、application/json</li><li>Content-Type:</li><li>application/json</li><li>application/x-www-form-urlencoded</li><li>请求正文</li></ul><p>响应报文：</p><ul><li>状态行(200/400/500)</li><li>响应头(Response Header)</li><li>响应正文</li></ul><h3 id="HTTP-超文本传输协议-演进"><a href="#HTTP-超文本传输协议-演进" class="headerlink" title="HTTP 超文本传输协议-演进"></a>HTTP 超文本传输协议-演进</h3><p>HTTP 发展史：</p><ul><li>1991 年发布初代 HTTP/0.9 版</li><li>1996 年发布 HTTP/1.0 版</li><li>1997 年是 HTTP/1.1 版，是到今天为止传输最广泛的版本</li><li>2015 年发布了 HTTP/2.0 版，优化了 HTTP/1.1 的性能和安全性</li><li>2018 年发布的 HTTP/3.0 版，使用 UDP 取代 TCP 协议</li></ul><p>HTTP2：<br>二进制分帧，按帧方式传输<br>多路复用，代替原来的序列和阻塞机制<br>头部压缩，通过 HPACK 压缩格式<br>服务器推送，服务端可以主动推送资源</p><p>HTTP3：<br>连接建立延时低，一次往返可建立HTTPS连接<br>改进的拥塞控制，高效的重传确认机制<br>切换网络保持连接，从4G切换到WIFI不用重建连接</p><h2 id="Go-网络编程基础"><a href="#Go-网络编程基础" class="headerlink" title="Go 网络编程基础"></a>Go 网络编程基础</h2><p>基础概念：</p><ul><li>Socket：数据传输</li><li>Encoding：内容编码</li><li>Session：连接会话状态</li><li>C/S模式：通过客户端实现双端通信</li><li>B/S模式：通过浏览器即可完成数据的传输</li></ul><p>简单例子<br>• 通过TCP/UDP实现网络通信</p><p>网络轮询器</p><ul><li>多路复用模型</li><li>多路复用模块</li><li>文件描述符</li><li>Goroutine 唤醒</li></ul><h3 id="TCP简单例子"><a href="#TCP简单例子" class="headerlink" title="TCP简单例子"></a>TCP简单例子</h3><h3 id="UDP简单例子"><a href="#UDP简单例子" class="headerlink" title="UDP简单例子"></a>UDP简单例子</h3><h3 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h3><p>Linux下主要的IO模型分为:</p><ul><li>Blocking IO - 阻塞IO</li><li>Nonblocking IO - 非阻塞IO</li><li>IO multiplexing - IO 多路复用</li><li>Signal-driven IO - 信号驱动式IO（异步阻塞）</li><li>Asynchronous IO - 异步IO</li></ul><p>同步：调用端会一直等待服务端响应，直到返回结果<br>异步：调用端发起调用之后不会立刻返回，不会等待服务端响应<br>阻塞：服务端返回结果之前，客户端线程会被挂起，此时线程不可被 CPU 调度，线程暂停运行<br>非阻塞：在服务端返回前，函数不会阻塞调用端线程，而会立刻返回</p><p><img src="/2021/05/05/goatc-9-network-programming-practice/io.png" alt></p><h3 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h3><p>Go 语言在采用 I/O 多路复用 模型处理 I/O 操作，但是他没有选择最常见的系统调用 select。虽然 select 也可以提供 I/O 多路复用的能力，但是使用它有比较多的限制：</p><ul><li>监听能力有限 — 最多只能监听 1024 个文件描述符；</li><li>内存拷贝开销大 — 需要维护一个较大的数据结构存储文件描述符，该结构需要拷贝到内核中；</li><li>时间复杂度 𝑂(𝑛) — 返回准备就绪的事件个数后，需要遍历所有的文件描述符；</li></ul><p>I/O多路复用：进程阻塞于 select，等待多个 IO 中的任一个变为可读，select调 用返回，通知相应 IO 可以读。 它可以支持单线程响应多个请求这种模式。</p><p><img src="/2021/05/05/goatc-9-network-programming-practice/iomm.png" alt></p><h3 id="多路复用模块"><a href="#多路复用模块" class="headerlink" title="多路复用模块"></a>多路复用模块</h3><p>为了提高 I/O 多路复用的性能<br>不同的操作系统也都实现了自己的 I/O 多路复用函数，例如：epoll、kqueue 和 evport 等<br>Go 语言为了提高在不同操作系统上的 I/O 操作性能，使用平台特定的函数实现了多个版本的网络轮询模块：</p><p>src/runtime/netpoll_epoll.go<br>src/runtime/netpoll_kqueue.go<br>src/runtime/netpoll_solaris.go<br>src/runtime/netpoll_windows.go<br>src/runtime/netpoll_aix.go<br>src/runtime/netpoll_fake.go</p><h2 id="Goim-长连接-TCP-编程"><a href="#Goim-长连接-TCP-编程" class="headerlink" title="Goim 长连接 TCP 编程"></a>Goim 长连接 TCP 编程</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul><li><p>Comet<br>长连接管理层，主要是监控外网 TCP/Websocket端口，并且通过设备 ID 进行绑定 Channel实 现，以及实现了 Room 合适直播等大房间消息广播。</p></li><li><p>Logic<br>逻辑层，监控连接 Connect、Disconnect 事件，可自定义鉴权，进行记录 Session 信息（设备 ID、ServerID、用户 ID），业务可通过设备 ID、用户 ID、RoomID、全局广播进行消息推送。</p></li><li><p>Job<br>通过消息队列的进行推送消峰处理，并把消息推送到对应 Comet 节点。</p></li></ul><p><strong>各个模块之间通过 gRPC 进行通信。</strong></p><p><img src="/2021/05/05/goatc-9-network-programming-practice/long-tcp-gai-lan.png" alt></p><h3 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h3><p>主要以包/针方式：<br>Package Length，包长度<br>Header Length，头长度<br>Protocol Version，协议版本<br>Operation，操作码<br>Sequence 请求序号 ID<br>Body，包内容</p><p>Operation:</p><ul><li>Auth</li><li>Heartbeat</li><li>Message</li></ul><p>Sequence</p><ul><li>按请求、响应对应递增 ID</li></ul><h3 id="边缘节点"><a href="#边缘节点" class="headerlink" title="边缘节点"></a>边缘节点</h3><p>Comet 长连接连续节点，通常部署在距离用户比较近，通过 TCP 或者 Websocket 建立连接，并且通过应用层 Heartbeat 进行保活检测，保证连接可用性。</p><p>节点之间通过云 VPC 专线通信，按地区部署分布。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>长连接负载均衡比较特殊，需要按一定的负载算法进行分配节点，可以通过 HTTPDNS 方式，请求获致到对应的节点 IP 列表，例如，返回固定数量 IP，按一定的权重或者最少连接数进行排序，客户端通过 IP 逐个重试连接；</p><ul><li>Comet 注册 IP 地址，以及节点权重，定时 Renew当前节点连接数量；</li><li>Balancer 按地区经纬度计算，按最近地区（经纬度）提供 Comet 节点 IP 列表，以及权重计算排序；</li><li>BFF 返回对应的长连接节点 IP，客户端可以通过 IP直接连；</li><li>客户端 按返回IP列表顺序，逐个连接尝试建立长连接</li></ul><h3 id="心跳保活机制"><a href="#心跳保活机制" class="headerlink" title="心跳保活机制"></a>心跳保活机制</h3><p>长连接断开的原因：<br>长连接所在进程被杀死<br>NAT 超时<br>网络状态发生变化，如移动网络 &amp; Wifi 切换、断开、重连<br>其他不可抗因素（网络状态差、DHCP 的租期等等 ）</p><p>高效维持长连接方案：<br>进程保活（防止进程被杀死）<br>心跳保活（阻止 NAT 超时）<br>断线重连（断网以后重新连接网络）</p><p>自适应心跳时间：<br>心跳可选区间，[min=60s，max=300s]<br>心跳增加步长，step=30s<br>心跳周期探测，success=current + step、fail=current - step</p><h3 id="用户鉴权和-Session-信息"><a href="#用户鉴权和-Session-信息" class="headerlink" title="用户鉴权和 Session 信息"></a>用户鉴权和 Session 信息</h3><p>用户鉴权，在长连接建立成功后，需要先进行连接鉴权，并且绑定对应的会话信息；</p><p>Connect，建立连接进行鉴权，保存Session信息：</p><ul><li>DeviceID，设备唯一 ID</li><li>Token，用户鉴权 Token，认证得到用户 ID</li><li>CometID，连接所在 comet 节点</li></ul><p>Disconnect，断开连接，删除对应Session信息：</p><ul><li>DeviceID，设备唯一 ID</li><li>CometID，连接所在 Comet 节点</li><li>UserID，用户 ID</li></ul><p>Session，会话信息通过Redis保存连接路由信息：</p><ul><li>连接维度，通过 设备 ID 找到所在 Comet 节点</li><li>用户维度，通过 用户 ID 找到对应的连接和 Comet所在节点</li></ul><h3 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h3><p>Comet 长连接层，实现连接管理和消息推送：</p><p>Protocol，TCP/Websocket 协议监听；</p><ul><li>Packet，长连接消息包，每个包都有固定长度；</li><li>Channel，消息管道相当于每个连接抽象，最终TCP/Websocket 中的封装，进行消息包的读写分发；</li><li>Bucket，连接通过 DeviceID 进行管理，用于读写锁拆散，并且实现房间消息推送，类似 Nginx Worker；</li><li>Room，房间管理通过 RoomID 进行管理，通过链表进行Channel遍历推送消息；</li></ul><p>每个 Bucket 都有独立的 Goroutine 和读写锁优化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Buckets &#123;  channels <span class="keyword">map</span>[<span class="keyword">string</span>]*Channel</span><br><span class="line">  rooms <span class="keyword">map</span>[<span class="keyword">string</span>]*Room&#125;</span><br></pre></td></tr></table></figure><h3 id="Logic"><a href="#Logic" class="headerlink" title="Logic"></a>Logic</h3><p>Logic 业务逻辑层，处理连接鉴权、消息路由，用户会话管理；</p><p>主要分为三层：</p><ul><li>sdk，通过 TCP/Websocket 建立长连接，进行重连、心跳保活；</li><li>goim，主要负责连接管理，提供消息长连能力；</li><li>backend，处理业务逻辑，对推送消息过虑，以及持久化相关等；</li></ul><h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>业务通过对应的推送方式，可以对连接设备、房间、用户ID进行推送，通过Session信息定位到所在的Comet连接节点，并通过Job推送消息；</p><p>通过Kafka进行推送消峰，保证消息逐步推送成功；</p><p>支持的多种推送方式：</p><ul><li>Push(DeviceID, Message)</li><li>Push(UserID, Message)</li><li>Push(RoomID, Message)</li><li>Push(Message)</li></ul><h3 id="推拉结合"><a href="#推拉结合" class="headerlink" title="推拉结合"></a>推拉结合</h3><p>在长连接中，如果想把消息通知所有人，主要有两种模式：一种是自己拿广播通知所有人，这叫“推”模式；一种是有人主动来找你要，这叫“拉”模式。；</p><p>在业务系统中，通常会有三种可能的做法：</p><ul><li>推模式，有新消息时服务器主动推给客户端；</li><li>拉模式，由前端主动发起拉取消息的请求；</li><li>推拉结合模式，有新消息实时通知，客户端再进行新的消息摘取；</li></ul><h3 id="读写扩散"><a href="#读写扩散" class="headerlink" title="读写扩散"></a>读写扩散</h3><p>一般消息系统中，通常会比较关注消息存储；<br>主要进行考虑“读”、“写”扩散，也就是性能问题；<br>在不同场景，可能选择不同的方式：</p><p>读扩散，在IM系统里的读扩散通常是每两个相关联的人就有一个信箱，或者每个群一个信箱。<br>优点：写操作（发消息）很轻量，只用写自己信箱<br>缺点：读操作（读消息）很重，需要读所有人信箱<br>写扩散，每个人都只从自己的信箱里读取消息，但写（发消息）的时候需要所有人写一份<br>优点：读操作很轻量<br>缺点：写操作很重，尤其是对于群聊来说</p><h3 id="唯一-ID-设计"><a href="#唯一-ID-设计" class="headerlink" title="唯一 ID 设计"></a>唯一 ID 设计</h3><p>唯一 ID，需要保证全局唯一，绝对不会出现重复的 ID，且 ID 整体趋势递增。<br>通常情况下，ID 的设计主要有以下几大类：</p><ul><li>UUID</li><li>基于 Snowflake 的 ID 生成方式</li><li>基于申请 DB 步长的生成方式</li><li>基于 Redis 或者 DB 的自增 ID生成方式</li><li>特殊的规则生成唯一 ID</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/" target="_blank" rel="noopener">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/</a><br><a href="https://www.liwenzhou.com/posts/Go/15_socket/" target="_blank" rel="noopener">https://www.liwenzhou.com/posts/Go/15_socket/</a><br><a href="https://hit-alibaba.github.io/interview/basic/network/HTTP.html" target="_blank" rel="noopener">https://hit-alibaba.github.io/interview/basic/network/HTTP.html</a><br><a href="https://cloud.tencent.com/developer/article/1030660" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1030660</a><br><a href="https://juejin.cn/post/6844903827536117774" target="_blank" rel="noopener">https://juejin.cn/post/6844903827536117774</a><br><a href="https://xie.infoq.cn/article/19e95a78e2f5389588debfb1c" target="_blank" rel="noopener">https://xie.infoq.cn/article/19e95a78e2f5389588debfb1c</a><br><a href="https://tech.meituan.com/2019/03/07/open-source-project-leaf.html" target="_blank" rel="noopener">https://tech.meituan.com/2019/03/07/open-source-project-leaf.html</a><br><a href="https://mp.weixin.qq.com/s/8WmASie_DjDDMQRdQi1FDg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/8WmASie_DjDDMQRdQi1FDg</a><br><a href="https://www.imooc.com/article/265871" target="_blank" rel="noopener">https://www.imooc.com/article/265871</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;网络通信协议&quot;&gt;&lt;a href=&quot;#网络通信协议&quot; class=&quot;headerlink&quot; title=&quot;网络通信协议&quot;&gt;&lt;/a&gt;网络通
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="golang" scheme="https://octopuslian.github.io/tags/golang/"/>
    
      <category term="网络编程" scheme="https://octopuslian.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-播放历史架构设计</title>
    <link href="https://octopuslian.github.io/2021/05/05/goatc-7-play-history-architecture-design/"/>
    <id>https://octopuslian.github.io/2021/05/05/goatc-7-play-history-architecture-design/</id>
    <published>2021-05-05T13:05:21.000Z</published>
    <updated>2021-06-09T14:56:54.896Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --><h2 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h2><p>为了大部分用户的基本功能体验，满足用户需求，例如播放历史查看、播放进度同步等。离线型用户，app 本地保留历史记录数据。<br>同样的，也要考虑平台化，视频、文章、漫画等业务扩展接入。</p><ul><li>变更功能：添加记录、删除记录、清空历史。</li><li>读取功能：按照 timeline 返回 top N，点查获取进度信息。</li><li>其他功能：暂停/恢复记录，首次观察增加经验等。</li></ul><p><strong>历史记录类型的业务，是一个极高 tps 写入，高 qps 读取的业务服务。分析清楚系统的 hot path，投入优化，而不是哪哪都去优化。</strong></p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul><li><p>BFF: app-interface、history<br>历史 BFF 层接受来自外部用户的读请求，依赖其他例如稿件、漫画服务来组装完整的面向历史业务（页面）需要的数据的组合。同时接受来自内部其他业务线的写请求，通常都是业务方自己进行业务 ID 的判定，然后投递到历史服务的 BFF 写接口中。最终 BFF 是打包在 app-interface 大杂烩 BFF 中，考虑到隔离性，读写流量很大，独立成 history BFF 服务。</p></li><li><p>Service: history-service<br>服务层，去平台业务的逻辑，专注在历史数据的持久化上(因为对于播放类业务，BFF 专注平台业务数据组织，service 负责数据的读、写、删、清理等操作。播放进度是非常高频同步的，需要考虑性能优化)。</p></li></ul><p><strong>使用 write-back 的思路，把状态数据先入分布式缓存，再回写数据库。</strong></p><ul><li><p>Job: history-job<br>job 消费上游 kafka 的数据，利用消息队列的堆积能力，对于存储层的差速(消费能力跟不上生产速度时)，可以进行一定的数据反压。配合上游 service 批量打包过来的数据持久化。</p></li><li><p>Upstream: some-app，some-api<br>整个历史服务还会被一些外部 gRPC 服务所依赖，所以 history 还充当了内网的 gRPC Provider，这些上游服务，使用历史服务的写接口，把自己业务的数据进行持久化。</p></li></ul><p><strong>历史服务最重要的设计，就是批量打包(pipeline)聚合数据。将高频、密集的写请求先入缓存(write-back)，批量消费减少对存储的直接压力，类似的设计随处可见。</strong></p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/gai-lan.png" alt></p><h3 id="history-service"><a href="#history-service" class="headerlink" title="history service"></a>history service</h3><p>专注在历史数据处理。</p><p>写的核心逻辑:<br>用户观看的稿件、漫画等，带有进度信息的数据，同一个 id 最后一次的数据即可，即 last-write win，高频的用户端同步逻辑，只需要最后一次数据持久化即可。我们可以在 in-process 内存中，定时定量来聚合不同用户的“同一个对象的最后一次进度”，使用 kafka 消息队列来消除写入峰值。但同时我们需要保证用户数据可以实时被观察到，不能出现上报进度后，需要一阵子才能体现进度变化。所以我们即在内存中打包数据，同时实时写入到 redis 中，这样即保证了实时，又避免海量写入冲击存储。</p><p>kafka 是为高吞吐设计，超高频的写入并不是最优，所以内存聚合和分片算法比较重要，按照 uid 来sharding 数据，写放大仍然很大，这里我们使用 region sharding，打包一组数据当作一个 kafka message(比如 uid % 100数据打包)。</p><p>写逻辑的数据流向: 实时写 redis -&gt; 内存维护用户数据 -&gt; 定时/定量写入到 kafka。</p><p>读的核心逻辑:<br>历史数据，实时写入 redis 后，不会无限制的存储，会按量截断，所以分布式缓存中数据不是完整数据，历史数据从 redis sortedset 中读取后，如果发现尾部数据不足，会触发 cache-aside 模式，从存储中回捞数据，但是不会重新回填缓存，因为拉取过去更久远的数据，属于用户纬度的低频度行为。历史数据通常是按照 timeline 来组织，游标的 key 可以使用时间戳进行翻页或者下拉。</p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/history-service.png" alt></p><h3 id="history-job"><a href="#history-job" class="headerlink" title="history job"></a>history job</h3><p>获取打包好的用户数据，进行批量持久化。</p><p>上游 history-service 按照 uid region sharding 聚合好的数据，在 job 中消费取出，为了节约传输过程，以及 history-service 的 in-process cache 的内存使用，我们只维护了用户的 uid 以及 id 列表，最小化存储和传输。因为数据是不完整的，我们额外需要从 redis 中按照 id 对应的数据内容，再持久化。从原来的 N 条记录变为一个用户一条记录。</p><p>对于存储的选型，我们认为 HBase 非常合适高密度写入。后续我们会单独讨论我们经历过的几次存储迭代和选型。</p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/history-job.png" alt></p><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>history 作为 BFF，对用户端提供统一的用户记录记录入口接口，同时也对内提供 gRPC 写入历史接口。如果业务场景中不存在统一的用户入口访问历史记录，可以去掉 BFF 层，直接使用 history-service 提供读接口，这样需要每个业务方自己实现自己的数据组装。</p><p>我们也有类似用户首次播放、观看等加经验或者奖励积分类似的操作，所以我们这里依赖 redis，进行判定用户当天是否是首次访问，我们比较容易想到使用 bitmap 或者 bloom filter 来进行判断，然后往下游 kafka 投递消息，而不直接依赖业务的某个服务。</p><p>Q：因为我们有关闭历史记录的功能，这样每次写入操作都需要前置读取一次，是否打开了开关，同样的每次首次发送奖励也是一样，你有更好的办法吗？</p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/history.png" alt></p><h2 id="存储设计"><a href="#存储设计" class="headerlink" title="存储设计"></a>存储设计</h2><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p>我们最早的主力存储选型是: HBase。</p><p>数据写入: PUT mid, values，只需要写入到 column_family 的 info 列簇，rowkey 使用用户 id md5 以后的头两位 + 用户，避免 rowkey 热点密集到一个 region 中，导致写/读热点。 对于 column_family: info，存储一个列 obj_id + obj_type，例如 稿件业务:1、稿件ID: 100，100_1 作为列名，对于 value 使用 protobuf 序列化一个结构体接入。所以只需要单次更新 kv store。另外我们使用 HBase TTL 的能力，只需要保存90天的用户数据即可。(删除同理)</p><p>数据读取: 列表获取为 GET mid，直接获取1000条，在内存中排序和翻页。点查 GET mid columns，在茫茫多视频查看当前视频的阅读进度，cache miss 会非常严重，虽然支持点查，但是对于上层 cache miss 后，不再回源请求 HBase。</p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/database-design.png" alt></p><h3 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h3><p>数据写入: 每次产生的历史数据，需要立马更新 redis，使用 sorted set 基于时间排序的列表，member 为业务 ID。同时存储一份数据到 redis string 中，使用 protobuf 序列化完整的数据内容。为了避免 redis 中单个用户数据无限增长，需要超过一定量后对数据进行截断。<br>数据读取: 分为两个场景，一个是历史页面，这时候使用 sorted set，排序查找即可，拿到列表后，mget 批量获取history_content 内容。<br>另外一个是点查进度，比如我们点击进入一个视频详情页，这时候直接查找 history_content 进行点查，不再回源 HBase，因为命中率太低。</p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/cache-design.png" alt></p><p>首次触发某行为，增加经验的，我们在缓存设计中，经常使用 bitmap(roaring bitmap)、bloom filter 缓存加速访问，但是在使用缓存时，需要注意规避热点问题，某个key sharding 命中 node 是固定的，因此我们可以利用构建多组 bitmap 或 bloom filter，来进行打散。</p><p>prefix_key = hash(mid) % 1000</p><p>根据 prefix_key 找到对应的 cache 再进行操作，这样 1000 个 key 尽可能均匀的分布到更小集合的 node，而不会产生数据热点。</p><p>Q：但是仍然每次触发行为，都为前置判定，有更好的优化方案吗？</p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/cache-design2.png" alt></p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/cache-design3.png" alt></p><h2 id="可用性设计"><a href="#可用性设计" class="headerlink" title="可用性设计"></a>可用性设计</h2><h3 id="Write-Back"><a href="#Write-Back" class="headerlink" title="Write Back"></a>Write Back</h3><p>在 history-service 中实时写入 redis 数据，因此只需要重点优化缓存架构中，扛住峰值的流量写入。之后在服务内存中，使用 map[int]map[int]struct{} 聚合数据，之后利用 chan 在内部发送每个小消息，再聚合成一个大map，在 sendproc 中，使用 timer 和 定量判定逻辑，发送到下游 kafka 中。</p><p>在 history-job 中，获取消息后，重新去 redis 中回捞数据即: history-content，然后构建完整的数据批量写入到 HBase 中。</p><p>这里存在两个风险:<br>1、history-service 重启过程中，预聚合的消息丢失；<br>2、history-job 读取 redis 构建数据，但 redis 丢失；</p><p><strong>我们在这里进行了 trade-off，高收敛比的设计，意味着存在数据丢失的风险，对于历史场景，非 L0 的业务服务/数据，我们认为极端情况下可接受。</strong></p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/wb.png" alt></p><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>经过 BFF history 的流量 per-request 都会发送给 history-service，我们最容易想到的优化就是聚合上移来减少发送给下游的 rpc。但是按照 mid region sharding 的思路非常具有业务的耦合性，所以不应该把逻辑上移，而只是数据上移，所以可以考虑简单 batch put 请求，做一个无逻辑的数据聚合再发送给 history-service，这样可以大大的减少内网的流量，节约资源。</p><p>我们发现经过 API Gateway 的流量都会触发高频的 per-rpc auth，给内网的 identify-service 带来了不少压力。我们认为大部分历史行为通过心跳的方式同步进度，为何不连接一个长连接，长连接服务再握手后先进行用户级的身份验证，之后维持身份信息，而不是每次发送 request 都进行验证，这样可以大大减少内网的 identify-service 的流量。</p><p>我们内网使用 boardcast(goim) 服务维护长连接，长连接一次验证，不断使用。</p><h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>用户首次触发的行为，需要发送消息给下游系统进行触发其他奖励等。如何减少这类一天只用一次的标记位缓存请求？</p><p>使用 in-process localcache，只有高频的用户访问，带来的收益就越大，我们很容易想到使用 LRU 维护这个集合，但用户分布很广，很难覆盖，命中率很低。</p><p>越源头解决架构问题，通常越简单，效率越高。</p><p>我们在写操作(高频请求)中，把当前的 flag 返回到 API 协议中，作为一个日期值，客户端保存到本地，下次请求的时候带上，如果发现该值在，获取以后直接使用不再请求缓存，例如: 2021-1-1，发现当前时间还是2021-1-1，直接不再请求 redis，如果发现当前时间是2021-1-2，需要触发一次 redis 访问，返回新的 flag 到客户端，这样把状态广播同步到任何其他设备，可以大大减少判定缓存。</p><p>实现成本在于，你认为的代价高低。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://en.wikipedia.org/wiki/Cache#Writing_Policies" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Cache#Writing_Policies</a><br><a href="https://blog.csdn.net/jiaomeng/article/details/1495500" target="_blank" rel="noopener">https://blog.csdn.net/jiaomeng/article/details/1495500</a><br><a href="https://blog.csdn.net/yizishou/article/details/78342499" target="_blank" rel="noopener">https://blog.csdn.net/yizishou/article/details/78342499</a><br><a href="https://blog.csdn.net/caoshangpa/article/details/78783749" target="_blank" rel="noopener">https://blog.csdn.net/caoshangpa/article/details/78783749</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;功能模块&quot;&gt;&lt;a href=&quot;#功能模块&quot; class=&quot;headerlink&quot; title=&quot;功能模块&quot;&gt;&lt;/a&gt;功能模块&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="架构设计" scheme="https://octopuslian.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="golang" scheme="https://octopuslian.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-微服务可用性设计</title>
    <link href="https://octopuslian.github.io/2021/05/05/goatc-5-microservice-availability-design/"/>
    <id>https://octopuslian.github.io/2021/05/05/goatc-5-microservice-availability-design/</id>
    <published>2021-05-05T04:43:20.000Z</published>
    <updated>2021-06-09T14:56:50.187Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --><h2 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h2><p>隔离，本质上是对系统或资源进行分割，从而实现当系统发生故障时能限定传播范围和影响范围，即发生故障后只有出问题的服务不可用，保证其他服务仍然可用。</p><p>服务隔离：动静分离、读写分离<br>轻重隔离：核心、快慢、热点<br>物理隔离:线程、进程、集群、机房</p><h3 id="服务隔离"><a href="#服务隔离" class="headerlink" title="服务隔离"></a>服务隔离</h3><h4 id="动静隔离"><a href="#动静隔离" class="headerlink" title="动静隔离:"></a>动静隔离:</h4><p>小到 CPU 的 cacheline false sharing、数据库 mysql 表设计中避免 bufferpool 频繁过期，隔离动静表，大到架构设计中的图片、静态资源等缓存加速。本质上都体现的一样的思路，即加速/缓存访问变换频次小的。比如 CDN 场景中，将静态资源和动态 API 分离，也是体现了隔离的思路:</p><ul><li>降低应用服务器负载，静态文件访问负载全部通过CDN。</li><li>对象存储存储费用最低。</li><li>海量存储空间，无需考虑存储架构升级。</li><li>静态CDN带宽加速，延迟低。</li></ul><h4 id="读写分离：主从、Replicaset、CQRS。"><a href="#读写分离：主从、Replicaset、CQRS。" class="headerlink" title="读写分离：主从、Replicaset、CQRS。"></a>读写分离：主从、Replicaset、CQRS。</h4><h3 id="轻重隔离"><a href="#轻重隔离" class="headerlink" title="轻重隔离"></a>轻重隔离</h3><h4 id="核心隔离"><a href="#核心隔离" class="headerlink" title="核心隔离"></a>核心隔离</h4><p>业务按照 Level 进行资源池划分(L0/L1/L2)。</p><ul><li>核心/非核心的故障域的差异隔离(机器资源、依赖资源)。</li><li>多集群，通过冗余资源来提升吞吐和容灾能力。</li></ul><h4 id="快慢隔离"><a href="#快慢隔离" class="headerlink" title="快慢隔离"></a>快慢隔离</h4><p>我们可以把服务的吞吐想象为一个池，当突然洪流进来时，池子需要一定时间才能排放完，这时候其他支流在池子里待的时间取决于前面的排放能力，耗时就会增高，对小请求产生影响。</p><p>日志传输体系的架构设计中，整个流都会投放到一个 kafka topic 中(早期设计目的: 更好的顺序IO)，流内会区分不同的 logid，logid 会有不同的 sink 端，它们之前会出现差速，比如 HDFS 抖动吞吐下降，ES 正常水位，全局数据就会整体反压。</p><ul><li>按照各种纬度隔离：sink、部门、业务、logid、重要性(S/A/B/C)。</li></ul><p>业务日志也属于某个 logid，日志等级就可以作为隔离通道。</p><h4 id="热点隔离"><a href="#热点隔离" class="headerlink" title="热点隔离"></a>热点隔离</h4><p>何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行缓存。比如：</p><ul><li>小表广播: 从 remotecache 提升为 localcache，app 定时更新，甚至可以让运营平台支持广播刷新 localcache。</li><li>主动预热: 比如直播房间页高在线情况下bypass 监控主动防御。</li></ul><h3 id="物理隔离"><a href="#物理隔离" class="headerlink" title="物理隔离"></a>物理隔离</h3><h4 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h4><p>主要通过线程池进行隔离，也是实现服务隔离的基础。把业务进行分类并交给不同的线程池进行处理，当某个线程池处理一种业务请求发生问题时，不会讲故障扩散和影响到其他线程池，保证服务可用。</p><p>对于 Go 来说，所有 IO 都是 Nonblocking，且托管给了 Runtime，只会阻塞Goroutine，不阻塞 M，我们只需要考虑 Goroutine 总量的控制，不需要线程模型语言的线程隔离。</p><h4 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h4><p>容器化(docker)，容器编排引擎(k8s)。</p><h4 id="集群隔离"><a href="#集群隔离" class="headerlink" title="集群隔离"></a>集群隔离</h4><p>逻辑上是一个应用，物理上部署多套应用，通过 cluster 区分。</p><h3 id="Case-Stduy"><a href="#Case-Stduy" class="headerlink" title="Case Stduy"></a>Case Stduy</h3><ul><li>早期转码集群被超大视频攻击，导致转码大量延迟。</li><li>入口Nginx(SLB)故障，影响全机房流量入口故障。</li><li>缩略图服务，被大图实时缩略吃完所有 CPU，导致正常的小图缩略被丢弃，大量503。</li><li>数据库实例 cgroup 未隔离，导致大 SQL 引起的集体故障。</li><li>INFO 日志量过大，导致异常 ERROR 日志采集延迟。</li></ul><h2 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h2><p>超时控制，我们的组件能够快速失效(fail fast)，因为我们不希望等到断开的实例直到超时。没有什么比挂起的请求和无响应的界面更令人失望。这不仅浪费资源，而且还会让用户体验变得更差。我们的服务是互相调用的，所以在这些延迟叠加前，应该特别注意防止那些超时的操作。</p><ul><li>网路传递具有不确定性。</li><li>客户端和服务端不一致的超时策略导致资源浪费。</li><li>“默认值”策略。</li><li>高延迟服务导致 client 浪费资源等待，使用超时传递: 进程间传递 + 跨进程传递。</li></ul><h3 id="Case-Stduy-1"><a href="#Case-Stduy-1" class="headerlink" title="Case Stduy"></a>Case Stduy</h3><ul><li>SLB 入口 Nginx 没配置超时导致连锁故障。</li><li>服务依赖的 DB 连接池漏配超时，导致请求阻塞，最终服务集体 OOM。</li><li>下游服务发版耗时增加，而上游服务配置超时过短，导致上游请求失败。</li></ul><h2 id="过载保护"><a href="#过载保护" class="headerlink" title="过载保护"></a>过载保护</h2><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。令牌桶算法的描述如下：</p><ul><li>假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌。</li><li>桶中最多存放 b 个令牌，当桶满时，新添加的令牌被丢弃或拒绝。</li><li>当一个 n 个字节大小的数据包到达，将从桶中删除n 个令牌，接着数据包被发送到网络上。</li><li>如果桶中的令牌不足 n 个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。</li></ul><h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>作为计量工具(The Leaky Bucket Algorithm as a Meter)时，可以用于流量整形(Traffic Shaping)和流量控制(TrafficPolicing)，漏桶算法的描述如下：</p><ul><li>一个固定容量的漏桶，按照常量固定速率流出水滴。</li><li>如果桶是空的，则不需流出水滴。</li><li>可以以任意速率流入水滴到漏桶。</li><li>如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的。</li></ul><h3 id="如何计算接近峰值时的系统吞吐？"><a href="#如何计算接近峰值时的系统吞吐？" class="headerlink" title="如何计算接近峰值时的系统吞吐？"></a>如何计算接近峰值时的系统吞吐？</h3><ul><li>CPU: 使用一个独立的线程采样，每隔 250ms 触发一次。在计算均值时，使用了简单滑动平均去除峰值的影响。</li><li>Inflight: 当前服务中正在进行的请求的数量。</li><li>Pass&amp;RT: 最近5s，pass 为每100ms采样窗口内成功请求的数量，rt 为单个采样窗口中平均响应时间。</li></ul><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>限流是指在一段时间内，定义某个客户或应用可以接收或处理多少个请求的技术。例如，通过限流，你可以过滤掉产生流量峰值的客户和微服务，或者可以确保你的应用程序在自动扩展(Auto Scaling)失效前都不会出现过载的情况。</p><ul><li>令牌桶、漏桶 针对单个节点，无法分布式限流。</li><li>QPS 限流</li><li>不同的请求可能需要数量迥异的资源来处理。</li><li>某种静态 QPS 限流不是特别准。</li></ul><p>给每个用户设置限制</p><ul><li>全局过载发生时候，针对某些“异常”进行控制。</li><li>一定程度的“超卖”配额。</li><li>按照优先级丢弃。</li><li>拒绝请求也需要成本。</li></ul><h3 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h3><p>分布式限流，是为了控制某个应用全局的流量，而非真对单个节点纬度。</p><ul><li>单个大流量的接口，使用 redis 容易产生热点。</li><li>pre-request 模式对性能有一定影响，高频的网络往返。</li></ul><p>Q：如何来分配资源？<br>A：“最大最小公平分享”(Max-Min Fairness)。</p><p>最大最小公平分配算法的形式化定义如下：</p><ul><li>资源按照需求递增的顺序进行分配。</li><li>不存在用户得到的资源超过自己的需求。</li><li>未得到满足的用户等价的分享资源。</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><a href="./goatc-5-microservice-availability-design/fen-bu-shi-xian-liu.png"></a></p><h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>每个接口配置阈值，运营工作繁重，最简单的我们配置服务级别 quota，更细粒度的，我们可以根据不同重要性设定 quota，我们引入了重要性(criticality):</p><ul><li>最重要 CRITICAL_PLUS，为最终的要求预留的类型，拒绝这些请求会造成非常严重的用户可见的问题。</li><li>重要 CRITICAL，生产任务发出的默认请求类型。拒绝这些请求也会造成用户可见的问题。但是可能没那么严重。</li><li>可丢弃的 SHEDDABLE_PLUS 这些流量可以容忍某种程度的不可用性。这是批量任务发出的请求的默认值。这些请求通常可以过几分钟、几小时后重试。</li><li>可丢弃的 SHEDDABLE 这些流量可能会经常遇到部分不可用情况，偶尔会完全不可用。</li></ul><p>gRPC 系统之间，需要自动传递重要性信息。如果后端接受到请求 A，在处理过程中发出了请求 B 和 C 给其他后端，请求 B 和 C 会使用与 A 相同的重要性属性。</p><ul><li>全局配额不足时，优先拒绝低优先级的。</li><li>全局配额，可以按照重要性分别设置。</li><li>过载保护时，低优先级的请求先被拒绝。</li></ul><h3 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h3><p>断路器(Circuit Breakers): 为了限制操作的持续时间，我们可以使用超时，超时可以防止挂起操作并保证系统可以响应。因为我们处于高度动态的环境中，几乎不可能确定在每种情况下都能正常工作的准确的时间限制。断路器以现实世界的电子元件命名，因为它们的行为是都是相同的。断路器在分布式系统中非常有用，因为重复的故障可能会导致雪球效应，并使整个系统崩溃。</p><ul><li>服务依赖的资源出现大量错误。</li><li>某个用户超过资源配额时，后端任务会快速拒绝请求，返回“配额不足”的错误，但是拒绝回复仍然会消耗一定资源。有可能后端忙着不停发送拒绝请求，导致过载。</li></ul><h3 id="Gutter"><a href="#Gutter" class="headerlink" title="Gutter"></a>Gutter</h3><p>基于熔断的 gutter kafka ，用于接管自动修复系统运行过程中的负载，这样只需要付出10%的资源就能解决部分系统可用性问题。</p><p>我们经常使用 failover 的思路，但是完整的 failover 需要翻倍的机器资源，平常不接受流量时，资源浪费。高负载情况下接管流量又不一定完整能接住。所以这里核心利用熔断的思路，是把抛弃的流量转移到 gutter 集群，如果 gutter 也接受不住的流量，重新回抛到主集群，最大力度来接受。</p><h3 id="客户端流控"><a href="#客户端流控" class="headerlink" title="客户端流控"></a>客户端流控</h3><p>positive feedback: 用户总是积极重试，访问一个不可达的服务。</p><ul><li>客户端需要限制请求频次，retry backoff 做一定的请求退让。</li><li>可以通过接口级别的error_details，挂载到每个 API 返回的响应里。</li></ul><h3 id="Case-Study"><a href="#Case-Study" class="headerlink" title="Case Study"></a>Case Study</h3><ul><li><p>二层缓存穿透、大量回源导致的核心服务故障。</p></li><li><p>异常客户端引起的服务故障(query of death)<br>(1)请求放大。<br>(2)资源数放大。</p></li><li><p>用户重试导致的大面积故障。</p></li></ul><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>通过降级回复来减少工作量，或者丢弃不重要的请求。而且需要了解哪些流量可以降级，并且有能力区分不同的请求。我们通常提供降低回复的质量来答复减少所需的计算量或者时间。我们自动降级通常需要考虑几个点：</p><ul><li>确定具体采用哪个指标作为流量评估和优雅降级的决定性指标(如，CPU、延迟、队列长度、线程数量、错误等)。</li><li>当服务进入降级模式时，需要执行什么动作？</li><li>流量抛弃或者优雅降级应该在服务的哪一层实现？是否需要在整个服务的每一层都实现，还是可以选择某个高层面的关键节点来实现？</li></ul><p>同时我们要考虑一下几点：</p><ul><li>优雅降级不应该被经常触发 - 通常触发条件现实了容量规划的失误，或者是意外的负载。</li><li>演练，代码平时不会触发和使用，需要定期针对一小部分的流量进行演练，保证模式的正常。</li><li>应该足够简单。</li></ul><p>降级本质为: <strong>提供有损服务。</strong></p><ul><li><p>UI 模块化，非核心模块降级。<br>BFF 层聚合 API，模块降级。</p></li><li><p>页面上一次缓存副本。</p></li><li><p>默认值、热门推荐等。</p></li><li><p>流量拦截 + 定期数据缓存(过期副本策略)。</p></li><li><p>处理策略<br>页面降级、延迟服务、写/读降级、缓存降级<br>抛异常、返回约定协议、Mock 数据、Fallback 处理</p></li></ul><h3 id="Case-Study-1"><a href="#Case-Study-1" class="headerlink" title="Case Study"></a>Case Study</h3><ul><li>客户端解析协议失败，app 奔溃。</li><li>客户端部分协议不兼容，导致页面失败。</li><li>local cache 数据源缓存，发版失效 + 依赖接口故障，引起的白屏。</li><li>没有 playbook，导致的 MTTR 上升。</li></ul><h2 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h2><p>当请求返回错误(例: 配额不足、超时、内部错误等)，对于 backend 部分节点过载的情况下，倾向于立刻重试，但是需要留意重试带来的流量放大:</p><ul><li>限制重试次数和基于重试分布的策略(重试比率: 10%)。</li><li>随机化、指数型递增的重试周期: exponential ackoff + jitter。</li><li>client 测记录重试次数直方图，传递到 server，进行分布判定，交由 server 判定拒绝。</li><li>只应该在失败的这层进行重试，当重试仍然失败，全局约定错误码“过载，无须重试”，避免级联重试。</li></ul><h3 id="Case-Study-2"><a href="#Case-Study-2" class="headerlink" title="Case Study"></a>Case Study</h3><ul><li><p>Nginx upstream retry 过大，导致服务雪崩。</p></li><li><p>业务不幂等，导致的重试，数据重复。<br>(1)全局唯一 ID: 根据业务生成一个全局唯一 ID，在调用接口时会传入该 ID，接口提供方会从相应的存储系统比如 redis 中去检索这个全局 ID 是否存在，如果存在则说明该操作已经执行过了，将拒绝本次服务请求；否则将相应该服务请求并将全局 ID 存入存储系统中,之后包含相同业务 ID 参数的请求将被拒绝。<br>(2)去重表: 这种方法适用于在业务中有唯一标识的插入场景。比如在支付场景中，一个订单只会支付一次，可以建立一张去重表,将订单 ID 作为唯一索引。把支付并且写入支付单据到去重表放入一个事务中了，这样当出现重复支付时，数据库就会抛出唯一约束异常,操作就会回滚。这样保证了订单只会被支付一次。<br>(3)多版本并发控制: 适合对更新请求作幂等性控制,比如要更新商品的名字，这是就可以在更新的接口中增加一个版本号来做幂等性控制。</p></li><li><p>多层级重试传递，放大流量引起雪崩。</p></li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>数据中心内部的负载均衡</p><p>在理想情况下，某个服务的负载会完全均匀地分发给所有的后端任务。在任何时刻，最忙和最不忙的节点永远消耗同样数量的CPU。</p><p>目标：</p><ul><li>均衡的流量分发。</li><li>可靠的识别异常节点。</li><li>scale-out，增加同质节点扩容。</li><li>减少错误，提高可用性。</li></ul><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul><li>变更管理:<br>70％的问题是由变更引起的，恢复可用代码并不总是坏事。</li><li>避免过载:<br>过载保护、流量调度等。</li><li>依赖管理:<br>任何依赖都可能故障，做 chaos monkey testing，注入故障测试。</li><li>优雅降级:<br>有损服务，避免核心链路依赖故障。</li><li>重试退避:<br>退让算法，冻结时间，API retry detail 控制策略。</li><li>超时控制:<br>进程内 + 服务间 超时控制。</li><li>极限压测 + 故障演练。</li><li>扩容 + 重启 + 消除有害流量。</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="http://www.360doc.com/content/16/1124/21/31263000_609259745.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/16/1124/21/31263000_609259745.shtml</a><br><a href="http://www.infoq.com/cn/articles/basis-frameworkto-implement-micro-service/" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/basis-frameworkto-implement-micro-service/</a><br><a href="http://www.infoq.com/cn/news/2017/04/linkerd-celebrates-one-year" target="_blank" rel="noopener">http://www.infoq.com/cn/news/2017/04/linkerd-celebrates-one-year</a><br><a href="https://medium.com/netflix-techblog/netflix-edge-load-balancing-695308b5548c" target="_blank" rel="noopener">https://medium.com/netflix-techblog/netflix-edge-load-balancing-695308b5548c</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAwNjQwNzU2NQ==&amp;mid=402841629&amp;idx=1&amp;sn=f598fec9b370b8a6f2062233b31122e0&amp;mpshare=1&amp;scene=23&amp;srcid=0404qP0fH8zRiIiFzQBiuzuU#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAwNjQwNzU2NQ==&amp;mid=402841629&amp;idx=1&amp;sn=f598fec9b370b8a6f2062233b31122e0&amp;mpshare=1&amp;scene=23&amp;srcid=0404qP0fH8zRiIiFzQBiuzuU#rd</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzIzMzk2NDQyMw==&amp;mid=2247486641&amp;idx=1&amp;sn=1660fb41b0c5b8d8d6eacdfc1b26b6a6&amp;source=41#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzIzMzk2NDQyMw==&amp;mid=2247486641&amp;idx=1&amp;sn=1660fb41b0c5b8d8d6eacdfc1b26b6a6&amp;source=41#wechat_redirect</a><br><a href="https://blog.acolyer.org/2018/11/16/overload-control-for-scaling-wechat-microservices/" target="_blank" rel="noopener">https://blog.acolyer.org/2018/11/16/overload-control-for-scaling-wechat-microservices/</a><br><a href="https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf" target="_blank" rel="noopener">https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf</a><br><a href="https://github.com/alibaba/Sentinel/wiki/系统负载保护" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel/wiki/系统负载保护</a><br><a href="https://blog.csdn.net/okiwilldoit/article/details/81738782" target="_blank" rel="noopener">https://blog.csdn.net/okiwilldoit/article/details/81738782</a><br><a href="http://alex-ii.github.io/notes/2019/02/13/predictive_load_balancing.html" target="_blank" rel="noopener">http://alex-ii.github.io/notes/2019/02/13/predictive_load_balancing.html</a><br><a href="https://blog.csdn.net/m0_38106113/article/details/81542863" target="_blank" rel="noopener">https://blog.csdn.net/m0_38106113/article/details/81542863</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;隔离&quot;&gt;&lt;a href=&quot;#隔离&quot; class=&quot;headerlink&quot; title=&quot;隔离&quot;&gt;&lt;/a&gt;隔离&lt;/h2&gt;&lt;p&gt;隔离，本质
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="架构设计" scheme="https://octopuslian.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="微服务" scheme="https://octopuslian.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="golang" scheme="https://octopuslian.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-评论系统架构设计</title>
    <link href="https://octopuslian.github.io/2021/05/04/goatc-6-comment-system-architecture-design/"/>
    <id>https://octopuslian.github.io/2021/05/04/goatc-6-comment-system-architecture-design/</id>
    <published>2021-05-04T14:41:57.000Z</published>
    <updated>2021-06-09T14:56:53.082Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --><p><strong>架构设计最重要的就是理解整个产品体系在系统中的定位。搞清楚系统背后的背景，才能做出最佳的设计和抽象。不要做需求的翻译机，先理解业务背后的本质，事情的初衷。</strong></p><h2 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h2><p>评论系统，我们往小里做就是视频评论系统，往大里做就是评论平台，可以接入各种业务形态。</p><ul><li>发布评论: 支持回复楼层、楼中楼。</li><li>读取评论: 按照时间、热度排序。</li><li>删除评论: 用户删除、作者删除。</li><li>管理评论: 作者置顶、后台运营管理(搜索、删除、审核等)。</li></ul><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul><li><p>BFF: comment<br>复杂评论业务的服务编排，比如访问账号服务进行等级判定，同时需要在 BFF 面向移动端/WEB场景来设计 API，这一层抽象把评论的本身的内容列表处理(加载、分页、排序等)进行了隔离，关注在业务平台化逻辑上。</p></li><li><p>Service: comment-service<br>服务层，去平台业务的逻辑，专注在评论功能的 API 实现上，比如发布、读取、删除等，关注在稳定性、可用性上，这样让上游可以灵活组织逻辑把基础能力和业务能力剥离。</p></li><li><p>Job: comment-job<br>消息队列的最大用途是消峰处理。</p></li></ul><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/gai-lan.png" alt></p><h3 id="comment-service"><a href="#comment-service" class="headerlink" title="comment service"></a>comment service</h3><p>专注在评论数据处理。</p><p>读的核心逻辑:<br>Cache-Aside 模式，先读取缓存，再读取存储。早期 cache rebuild 是做到服务里的，对于重建逻辑，一般会使用 read ahead 的思路，即预读，用户访问了第一页，很有可能访问第二页，所以缓存会超前加载，避免频繁 cache miss。当缓存抖动是否，特别容易引起集群 hundering herd 现象，大量的请求会触发 cache rebuild，因为使用了预加载，容易导致服务 OOM。所以我们开到回源的逻辑里，我们使用了消息队列来进行逻辑异步化，对于当前请求只返回 mysql 中部分数据即止。</p><p>写的核心逻辑:<br>我们担心类似“明星出轨”等热点事件的发生，而且写和读相比较，写可以认为是透穿到存储层的，系统的瓶颈往往就来自于存储层，或者有状态层。对于写的设计上，我们认为刚发布的评论有极短的延迟(通常小于几 ms)对用户可见是可接受的，把对存储的直接冲击下放到消息队列，按照消息反压的思路，即如果存储 latency 升高，消费能力就下降，自然消息容易堆积，系统始终以最大化方式消费。</p><p>Kafka 是存在 partition 概念的，可以认为是物理上的一个小队列，一个 topic 是由一组 partition 组成的，所以 Kafka 的吞吐模型理解为: 全局并行，局部串行的生产消费方式。对于入队的消息，可以按照 hash(comment_subject) % N(partitions) 的方式进行分发。那么某个 partition 中的 评论主题的数据一定都在一起，这样方便我们串行消费。<br>同样的，我们处理回源消息也是类似的思路。</p><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/comment-service.png" alt></p><h3 id="comment-admin"><a href="#comment-admin" class="headerlink" title="comment admin"></a>comment admin</h3><p>mysql binlog 中的数据被 canal 中间件流式消费，获取到业务的原始 CRUD 操作，需要回放录入到 es 中，但是 es 中的数据最终是面向运营体系提供服务能力，需要检索的数据维度比较多，在入 es 前需要做一个异构的 joiner，把单表变宽预处理好 join 逻辑，然后倒入到 es 中。<br>一般来说，运营后台的检索条件都是组合的，使用 es 的好处是避免依赖 mysql 来做多条件组合检索，同时 mysql 毕竟是 oltp 面向线上联机事务处理的。通过冗余数据的方式，使用其他引擎来实现。<br>es 一般会存储检索、展示、primary key 等数据，当我们操作编辑的时候，找到记录的 primary key，最后交由 comment-admin 进行运营测的 CRUD 操作。</p><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/comment-admin.png" alt></p><h3 id="comment"><a href="#comment" class="headerlink" title="comment"></a>comment</h3><p>comment 作为 BFF，是面向端，面向平台，面向业务组合的服务。所以平台扩展的能力，我们都在 comment 服务来实现，方便统一和准入平台，以统一的接口形式提供平台化的能力。</p><ul><li>依赖其他 gRPC 服务，整合统一平台测的逻辑(比如发布评论用户等级限定)。</li><li>直接向端上提供接口，提供数据的读写接口，甚至可以整合端上，提供统一的端上 SDK。</li><li>需要对非核心依赖的 gRPC 服务进行降级，当这些服务不稳定时。</li></ul><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/comment.png" alt></p><h2 id="存储设计"><a href="#存储设计" class="headerlink" title="存储设计"></a>存储设计</h2><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p>数据写入: 事务更新 comment_subject，comment_index，comment_content 三张表，其中 content 属于非强制需要一致性考虑的。可以先写入 content，之后事务更新其他表。即便 content 先成功，后续失败仅仅存在一条 ghost 数据。</p><p>数据读取: 基于 obj_id + obj_type 在 comment_index 表找到评论列表，WHERE root = 0 ORDER BY floor。之后根据 comment_index 的 id 字段捞出 comment_content 的评论内容。对于二级的子楼层，WHERE parent/root IN (id…)。</p><p>因为产品形态上只存在二级列表，因此只需要迭代查询两次即可。对于嵌套层次多的，产品上，可以通过二次点击支持。</p><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/database-design.png" alt></p><h3 id="索引内容分离"><a href="#索引内容分离" class="headerlink" title="索引内容分离"></a>索引内容分离</h3><p>comment_index: 评论楼层的索引组织表，实际并不包含内容。comment_content: 评论内容的表，包含评论的具体内容。其中 comment_index 的 id 字段和 comment_content 是1对1的关系，这里面包含几种设计思想。</p><ul><li>表都有主键，即 cluster index，是物理组织形式存放的，comment_content 没有 id，是为了减少一次 二级索引查找，直接基于主键检索，同时 comment_id 在写入要尽可能的顺序自增。</li><li>索引、内容分离，方便 mysql datapage 缓存更多的 row，如果和 context 耦合，会导致更大的 IO。长远来看 content 信息可以直接使用 KV storage 存储。</li></ul><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/suo-yin-nei-rong-fen-li.png" alt></p><h3 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h3><p>comment_subject_cache: 对应主题的缓存，value 使用 protobuf 序列化的方式存入。我们早期使用 memcache 来进行缓存，因为 redis 早期单线程模型，吞吐能力不高。</p><p>comment_index_cache: 使用 redis sortedset 进行索引的缓存，索引即数据的组织顺序，而非数据内容。参考过百度的贴吧，他们使用自己研发的拉链存储来组织索引，我认为 mysql 作为主力存储，利用 redis 来做加速完全足够，因为 cache miss 的构建，我们前面讲过使用 kafka 的消费者中处理，预加载少量数据，通过增量加载的方式逐渐预热填充缓存，而 redis sortedset skiplist 的实现，可以做到 O(logN) + O(M) 的时间复杂度，效率很高。</p><p>sorted set 是要增量追加的，因此必须判定 key 存在，才能 zdd。</p><p>comment_content_cache: 对应评论内容数据，使用 protobuf 序列化的方式存入。类似的我们早期使用 memcache 进行缓存。</p><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/cache-design.png" alt></p><h2 id="可用性设计"><a href="#可用性设计" class="headerlink" title="可用性设计"></a>可用性设计</h2><h3 id="Singleflight"><a href="#Singleflight" class="headerlink" title="Singleflight"></a>Singleflight</h3><p>对于热门的主题，如果存在缓存穿透的情况，会导致大量的同进程、跨进程的数据回源到存储层，可能会引起存储过载的情况，如何只交给同进程内，一个人去做加载存储?</p><p>使用归并回源的思路:<br><a href="https://pkg.go.dev/golang.org/x/sync/singleflight" target="_blank" rel="noopener">https://pkg.go.dev/golang.org/x/sync/singleflight</a></p><p>同进程只交给一个人去获取 mysql 数据，然后批量返回。同时这个 lease owner 投递一个 kafka 消息，做 index cache 的 recovery 操作。这样可以大大减少 mysql 的压力，以及大量透穿导致的密集写 kafka 的问题。</p><p>更进一步的，后续连续的请求，仍然可能会短时 cache miss，我们可以在进程内设置一个 short-lived flag，标记最近有一个人投递了 cache rebuild 的消息，直接 drop。</p><p>Q：为什么我们不用分布式锁之类的思路？</p><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/singleflight.png" alt></p><h3 id="热点"><a href="#热点" class="headerlink" title="热点"></a>热点</h3><p>流量热点是因为突然热门的主题，被高频次的访问，因为底层的 cache 设计，一般是按照主题 key 进行一致性 hash 来进行分片，但是热点 key 一定命中某一个节点，这时候 remote cache 可能会变为瓶颈，因此做 cache 的升级 local cache 是有必要的，我们一般使用单进程自适应发现热点的思路，附加一个短时的 ttl local cache，可以在进程内吞掉大量的读请求。<br>在内存中使用 hashmap 统计每个 key 的访问频次，这里可以使用滑动窗口统计，即每个窗口中，维护一个 hashmap，之后统计所有未过去的 bucket，汇总所有 key 的数据。<br>之后使用小堆计算 TopK 的数据，自动进行热点识别。</p><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/hot.png" alt></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;架构设计最重要的就是理解整个产品体系在系统中的定位。搞清楚系统背后的背景，才能做出最佳的设计和抽象。不要做需求的翻译机，先理解业
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="架构设计" scheme="https://octopuslian.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="golang" scheme="https://octopuslian.github.io/tags/golang/"/>
    
      <category term="评论系统" scheme="https://octopuslian.github.io/tags/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-工程化实践</title>
    <link href="https://octopuslian.github.io/2021/05/04/goatc-4-go-engineering-practice/"/>
    <id>https://octopuslian.github.io/2021/05/04/goatc-4-go-engineering-practice/</id>
    <published>2021-05-04T08:26:13.000Z</published>
    <updated>2021-06-09T14:56:48.906Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --><h1 id="工程项目结构"><a href="#工程项目结构" class="headerlink" title="工程项目结构"></a>工程项目结构</h1><h2 id="Standard-Go-Project-Layout"><a href="#Standard-Go-Project-Layout" class="headerlink" title="Standard Go Project Layout"></a>Standard Go Project Layout</h2><h3 id="cmd"><a href="#cmd" class="headerlink" title="/cmd"></a>/cmd</h3><p>本项目的主干。<br>每个应用程序的目录名应该与你想要的可执行文件的名称相匹配(例如，/cmd/myapp)。<br>不要在这个目录中放置太多代码。如果你认为代码可以导入并在其他项目中使用，那么它应该位于 /pkg 目录中。如果代码不是可重用的，或者你不希望其他人重用它，请将该代码放到 /internal 目录中。</p><h3 id="internal"><a href="#internal" class="headerlink" title="/internal"></a>/internal</h3><p>私有应用程序和库代码。这是你不希望其他人在其应用程序或库中导入代码。请注意，这个布局模式是由 Go 编译器本身执行的。有关更多细节，请参阅Go 1.4 release notes。</p><p>注意，你并不局限于顶级 internal 目录。在项目树的任何级别上都可以有多个内部目录。</p><p>你可以选择向 internal 包中添加一些额外的结构，以分隔共享和非共享的内部代码。这不是必需的(特别是对于较小的项目)，但是最好有有可视化的线索来显示预期的包的用途。你的实际应用程序代码可以放在 /internal/app 目录下(例如 /internal/app/myapp)，这些应用程序共享的代码可以放在 /internal/pkg 目录下(例如 /internal/pkg/myprivlib)。</p><h3 id="pkg"><a href="#pkg" class="headerlink" title="/pkg"></a>/pkg</h3><p>外部应用程序可以使用的库代码(例如 /pkg/mypubliclib)。其他项目会导入这些库，所以在这里放东西之前要三思:-)注意，internal 目录是确保私有包不可导入的更好方法，因为它是由 Go 强制执行的。/pkg 目录仍然是一种很好的方式，可以显式地表示该目录中的代码对于其他人来说是安全使用的好方法。</p><p>/pkg 目录内，可以参考 go 标准库的组织方式，按照功能分类。/internla/pkg 一般用于项目内的 跨多个应用的公共共享代码，但其作用域仅在单个项目工程内。</p><p><strong>当根目录包含大量非 Go 组件和目录时，这也是一种将 Go 代码分组到一个位置的方法，这使得运行各种 Go 工具变得更加容易组织。</strong></p><h2 id="Kit-Project-Layout"><a href="#Kit-Project-Layout" class="headerlink" title="Kit Project Layout"></a>Kit Project Layout</h2><p>基础库 kit 为独立项目，公司级建议只有一个，按照功能目录来拆分会带来不少的管理工作，因此建议合并整合。</p><p>by [Package Oriented Design]</p><blockquote><p>“To this end, the Kit project is not allowed to have a vendor folder. If any of packages are dependent on 3rd party packages, they must always build against the latest version of those dependences.”</p></blockquote><p>kit 项目必须具备的特点:</p><ul><li>统一</li><li>标准库方式布局</li><li>高度抽象</li><li>支持插件</li></ul><h2 id="Service-Application-Project-Layout"><a href="#Service-Application-Project-Layout" class="headerlink" title="Service Application Project Layout"></a>Service Application Project Layout</h2><h3 id="api"><a href="#api" class="headerlink" title="/api"></a>/api</h3><p>API 协议定义目录，xxapi.proto protobuf 文件，以及生成的 go 文件。我们通常把 api 文档直接在 proto 文件中描述。</p><h3 id="configs"><a href="#configs" class="headerlink" title="/configs"></a>/configs</h3><p>配置文件模板或默认配置。</p><h3 id="test"><a href="#test" class="headerlink" title="/test"></a>/test</h3><p>额外的外部测试应用程序和测试数据。你可以随时根据需求构造 /test 目录。对于较大的项目，有一个数据子目录是有意义的。例如，你可以使用 /test/data 或 /test/testdata (如果你需要忽略目录中的内容)。请注意，Go 还会忽略以“.”或“_”开头的目录或文件，因此在如何命名测试数据目录方面有更大的灵活性。<br>不应该包含：/src</p><p>有些 Go 项目确实有一个 src 文件夹，但这通常发生在开发人员有 Java 背景，在那里它是一种常见的模式。不要将项目级别 src 目录与 Go 用于其工作空间的 src 目录。</p><p>一个 gitlab 的 project 里可以放置多个微服务的app(类似 monorepo)。也可以按照 gitlab 的 group 里建立多个 project，每个 project 对应一个 app。<br>多 app 的方式，app 目录内的每个微服务按照自己的全局唯一名称，比如 “account.service.vip” 来建立目录，如: account/vip/*。<br>和 app 平级的目录 pkg 存放业务有关的公共库（非基础框架库）。如果应用不希望导出这些目录，可以放置到 myapp/internal/pkg 中。</p><h1 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h1><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p>“A high-performance, open-source universal RPC framework”</p><ul><li>多语言：语言中立，支持多种语言。</li><li>轻量级、高性能：序列化支持 PB(Protocol Buffer)和 JSON，PB 是一种语言无关的高性能序列化框架。<br>可插拔</li><li>IDL：基于文件定义服务，通过 proto3 工具生成指定语言的数据结构、服务端接口以及客户端 Stub。</li></ul><p>设计理念</p><ul><li><p>移动端：基于标准的 HTTP2 设计，支持双向流、消息头压缩、单 TCP 的多路复用、服务端推送等特性，这-些特性使得 gRPC 在移动端设备上更加省电和节省网络流量。</p></li><li><p>服务而非对象、消息而非引用：促进微服务的系统间粗粒度消息交互设计理念。</p></li><li><p>负载无关的：不同的服务需要使用不同的消息类型和编码，例如 protocol buffers、JSON、XML和Thrift。</p></li><li><p>流: Streaming API。</p></li><li><p>阻塞式和非阻塞式：支持异步和同步处理在客户端和服务端间交互的消息序列。</p></li><li><p>元数据交换：常见的横切关注点，如认证或跟踪，依赖数据交换。</p></li><li><p>标准化状态码：客户端通常以有限的方式响应 API 调用返回的错误。</p></li></ul><p><strong>不要过早关注性能问题，先标准化。</strong></p><p>为了统一检索和规范 API，我们内部建立了一个统一的 bapis 仓库，整合所有对内对外 API。</p><p>API 仓库，方便跨部门协作。<br>版本管理，基于 git 控制。<br>规范化检查，API lint。<br>API design review，变更 diff。<br>权限管理，目录 OWNERS。</p><h2 id="API-Compatibility"><a href="#API-Compatibility" class="headerlink" title="API Compatibility"></a>API Compatibility</h2><p>向后兼容(非破坏性)的修改<br>给 API 服务定义添加 API 接口<br>从协议的角度来看，这始终是安全的。</p><p>给请求消息添加字段<br>只要客户端在新版和旧版中对该字段的处理不保持一致，添加请求字段就是兼容的。</p><p>给响应消息添加字段<br>在不改变其他响应字段的行为的前提下，非资源（例如，ListBooksResponse）的响应消息可以扩展而不必破坏客户端的兼容性。即使会引入冗余，先前在响应中填充的任何字段应继续使用相同的语义填充。</p><p>向后不兼容(破坏性)的修改<br>删除或重命名服务，字段，方法或枚举值<br>从根本上说，如果客户端代码可以引用某些东西，那么删除或重命名它都是不兼容的变化，这时必须修改major 版本号。<br>修改字段的类型<br>即使新类型是传输格式兼容的，这也可能会导致客户端库生成的代码发生变化，因此必须增加major版本号。 对于编译型静态语言来说，会容易引入编译错误。<br>修改现有请求的可见行为<br>客户端通常依赖于 API 行为和语义，即使这样的行为没有被明确支持或记录。 因此，在大多数情况下，修改 API 数据的行为或语义将被消费者视为是破坏性的。如果行为没有加密隐藏，您应该假设用户已经发现它，并将依赖于它。<br>给资源消息添加 读取/写入 字段</p><h2 id="API-Naming-Conventions"><a href="#API-Naming-Conventions" class="headerlink" title="API Naming Conventions"></a>API Naming Conventions</h2><p>包名为应用的标识(APP_ID)，用于生成 gRPC 请求路径，或者 proto 之间进行引用 Message。文件中声明的包名称应该与产品和服务名称保持一致。带有版本的 API 的软件包名称必须以此版本结尾。<br>my.package.v1，为 API 目录，定义service相关接口，用于提供业务使用。</p><p>// RequestURL: /<package_name>.<version>.<service_name>/{method}<br>package<package_name>.<version>;</version></package_name></service_name></version></package_name></p><h2 id="API-Primitive-Fields"><a href="#API-Primitive-Fields" class="headerlink" title="API Primitive Fields"></a>API Primitive Fields</h2><p>gRPC 默认使用 Protobuf v3 格式，因为去除了 required 和 optional 关键字，默认全部都是 optional 字段。如果没有赋值的字段，默认会基础类型字段的默认值，比如 0 或者 “”。<br>Protobuf v3 中，建议使用：<a href="https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wrappers.proto" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wrappers.proto</a><br>Warpper 类型的字段，即包装一个 message，使用时变为指针。</p><p>Protobuf 作为强 schema 的描述文件，也可以方便扩展，是不是用于配置文件定义也可？</p><h2 id="API-Errors"><a href="#API-Errors" class="headerlink" title="API Errors"></a>API Errors</h2><p>使用一小组标准错误配合大量资源<br>例如，服务器没有定义不同类型的“找不到”错误，而是使用一个标准 google.rpc.Code.NOT_FOUND 错误代码并告诉客户端找不到哪个特定资源。状态空间变小降低了文档的复杂性，在客户端库中提供了更好的惯用映射，并降低了客户端的逻辑复杂性，同时不限制是否包含可操作信息(/google/rpc/error_details)。<br>错误传播<br>如果您的 API 服务依赖于其他服务，则不应盲目地将这些服务的错误传播到您的客户端。在翻译错误时，我们建议执行以下操作：<br>隐藏实现详细信息和机密信息。<br>调整负责该错误的一方。例如，从另一个服务接收 INVALID_ARGUMENT 错误的服务器应该将 INTERNAL 传播给它自己的调用者。</p><p>全局错误码<br>全局错误码，是松散、易被破坏契约的，基于我们上述讨论的，在每个服务传播错误的时候，做一次翻译，这样保证每个服务 + 错误枚举，应该是唯一的，而且在 proto 定义中是可以写出来文档的。</p><h2 id="API-Design"><a href="#API-Design" class="headerlink" title="API Design"></a>API Design</h2><h1 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h1><h2 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/gomods/athens</span><br><span class="line">https://goproxy.cn</span><br><span class="line"></span><br><span class="line">https://blog.golang.org/modules2019</span><br><span class="line">https://blog.golang.org/using-go-modules</span><br><span class="line">https://blog.golang.org/migrating-to-go-modules</span><br><span class="line">https://blog.golang.org/module-mirror-launch</span><br><span class="line">https://blog.golang.org/publishing-go-modules</span><br><span class="line">https://blog.golang.org/v2-go-modules</span><br><span class="line">https://blog.golang.org/module-compatibility</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="Unittest"><a href="#Unittest" class="headerlink" title="Unittest"></a>Unittest</h2><p>小型测试带来优秀的代码质量、良好的异常处理、优雅的错误报告；大中型测试会带来整体产品质量和数据验证。<br>不同类型的项目，对测试的需求不同，总体上有一个经验法则，即70/20/10原则：70%是小型测试，20%是中型测试，10%是大型测试。<br>如果一个项目是面向用户的，拥有较高的集成度，或者用户接口比较复杂，他们就应该有更多的中型和大型测试；如果是基础平台或者面向数据的项目，例如索引或网络爬虫，则最好有大量的小型测试，中型测试和大型测试的数量要求会少很多。</p><p>“自动化实现的，用于验证一个单独函数或独立功能模块的代码是否按照预期工作，着重于典型功能性问题、数据损坏、错误条件和大小差一错误（译注：大小差一(off-by-one)错误是一类常见的程序设计错误）等方面的验证”<br>- 《Google软件测试之道》</p><p>单元测试的基本要求：<br>快速<br>环境一致<br>任意顺序<br>并行</p><p>基于 docker-compose 实现跨平台跨语言环境的容器依赖管理方案，以解决运行 unittest 场景下的(mysql, redis, mc)容器依赖问题:<br>本地安装 Docker。<br>无侵入式的环境初始化。<br>快速重置环境。<br>随时随地运行(不依赖外部服务)。<br>语义式 API 声明资源。</p><p>真实外部依赖，而非 in-process 模拟。<br>正确的对容器内服务进行健康检测，避免unittest 启动时候资源还未 ready。<br>应该交由 app 自己来初始化数据，比如 db 的scheme，初始的 sql 数据等，为了满足测试的一致性，在每次结束后，都会销毁容器。<br>在单元测试开始前，导入封装好的 testing 库，方便启动和销毁容器。<br>对于 service 的单元测试，使用 gomock 等库把 dao mock 掉，所以在设计包的时候，应该面向抽象编程。<br>在本地执行依赖 Docker，在 CI 环境里执行Unittest，需要考虑在物理机里的 Docker 网络，或者在 Docker 里再次启动一个 Docker。</p><p>利用 go 官方提供的: Subtests + Gomock 完成整个单元测试。<br>/api<br>比较适合进行集成测试，直接测试 API，使用 API 测试框架(例如: yapi)，维护大量业务测试 case。<br>/data<br>docker compose 把底层基础设施真实模拟，因此可以去掉 infra 的抽象层。<br>/biz<br>依赖 repo、rpc client，利用 gomock 模拟 interface 的实现，来进行业务单元测试。<br>/service<br>依赖 biz 的实现，构建 biz 的实现类传入，进行单元测试。<br>基于 git branch 进行 feature 开发，本地进行 unittest，之后提交 gitlab merge request 进行 CI 的单元测试，基于 feature branch 进行构建，完成功能测试，之后合并 master，进行集成测试，上线后进行回归测试。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html</a><br><a href="https://www.ardanlabs.com/blog/2017/02/design-philosophy-on-packaging.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2017/02/design-philosophy-on-packaging.html</a><br><a href="https://github.com/golang-standards/project-layout" target="_blank" rel="noopener">https://github.com/golang-standards/project-layout</a><br><a href="https://github.com/golang-standards/project-layout/blob/master/README_zh.md" target="_blank" rel="noopener">https://github.com/golang-standards/project-layout/blob/master/README_zh.md</a><br><a href="https://www.cnblogs.com/zxf330301/p/6534643.html" target="_blank" rel="noopener">https://www.cnblogs.com/zxf330301/p/6534643.html</a><br><a href="https://blog.csdn.net/k6T9Q8XKs6iIkZPPIFq/article/details/109192475?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160561008419724839224387%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=160561008419724839224387&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-6-109192475.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=阿里技术专家详解DDD系列&amp;spm=1018.2118.3001.4449" target="_blank" rel="noopener">https://blog.csdn.net/k6T9Q8XKs6iIkZPPIFq/article/details/109192475?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160561008419724839224387%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=160561008419724839224387&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-6-109192475.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=阿里技术专家详解DDD系列&amp;spm=1018.2118.3001.4449</a><br><a href="https://blog.csdn.net/chikuai9995/article/details/100723540?biz_id=102&amp;utm_term=阿里技术专家详解DDD系列&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-100723540&amp;spm=1018.2118.3001.4449" target="_blank" rel="noopener">https://blog.csdn.net/chikuai9995/article/details/100723540?biz_id=102&amp;utm_term=阿里技术专家详解DDD系列&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-100723540&amp;spm=1018.2118.3001.4449</a><br><a href="https://blog.csdn.net/Taobaojishu/article/details/101444324?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160561008419724838528569%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160561008419724838528569&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-101444324.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=阿里技术专家详解DDD系列&amp;spm=1018.2118.3001.4449" target="_blank" rel="noopener">https://blog.csdn.net/Taobaojishu/article/details/101444324?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160561008419724838528569%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160561008419724838528569&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-101444324.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=阿里技术专家详解DDD系列&amp;spm=1018.2118.3001.4449</a><br><a href="https://blog.csdn.net/taobaojishu/article/details/106152641" target="_blank" rel="noopener">https://blog.csdn.net/taobaojishu/article/details/106152641</a><br><a href="https://cloud.google.com/apis/design/errors" target="_blank" rel="noopener">https://cloud.google.com/apis/design/errors</a><br><a href="https://kb.cnblogs.com/page/520743/" target="_blank" rel="noopener">https://kb.cnblogs.com/page/520743/</a><br><a href="https://zhuanlan.zhihu.com/p/105466656" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/105466656</a><br><a href="https://zhuanlan.zhihu.com/p/105648986" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/105648986</a><br><a href="https://zhuanlan.zhihu.com/p/106634373" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/106634373</a><br><a href="https://zhuanlan.zhihu.com/p/107347593" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/107347593</a><br><a href="https://zhuanlan.zhihu.com/p/109048532" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/109048532</a><br><a href="https://zhuanlan.zhihu.com/p/110252394" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/110252394</a><br><a href="https://www.jianshu.com/p/dfa427762975" target="_blank" rel="noopener">https://www.jianshu.com/p/dfa427762975</a><br><a href="https://www.citerus.se/go-ddd/" target="_blank" rel="noopener">https://www.citerus.se/go-ddd/</a><br><a href="https://www.citerus.se/part-2-domain-driven-design-in-go/" target="_blank" rel="noopener">https://www.citerus.se/part-2-domain-driven-design-in-go/</a><br><a href="https://www.citerus.se/part-3-domain-driven-design-in-go/" target="_blank" rel="noopener">https://www.citerus.se/part-3-domain-driven-design-in-go/</a><br><a href="https://www.jianshu.com/p/dfa427762975" target="_blank" rel="noopener">https://www.jianshu.com/p/dfa427762975</a><br><a href="https://www.jianshu.com/p/5732b69bd1a1" target="_blank" rel="noopener">https://www.jianshu.com/p/5732b69bd1a1</a></p><p><a href="https://www.cnblogs.com/qixuejia/p/10789612.html" target="_blank" rel="noopener">https://www.cnblogs.com/qixuejia/p/10789612.html</a><br><a href="https://www.cnblogs.com/qixuejia/p/4390086.html" target="_blank" rel="noopener">https://www.cnblogs.com/qixuejia/p/4390086.html</a><br><a href="https://www.cnblogs.com/qixuejia/p/10789621.html" target="_blank" rel="noopener">https://www.cnblogs.com/qixuejia/p/10789621.html</a><br><a href="https://zhuanlan.zhihu.com/p/46603988" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46603988</a><br><a href="https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wrappers.proto" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wrappers.proto</a><br><a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis" target="_blank" rel="noopener">https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis</a><br><a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html" target="_blank" rel="noopener">https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html</a><br><a href="https://blog.csdn.net/taobaojishu/article/details/106152641" target="_blank" rel="noopener">https://blog.csdn.net/taobaojishu/article/details/106152641</a></p><p><a href="https://apisyouwonthate.com/blog/creating-good-api-errors-in-rest-graphql-and-grpc" target="_blank" rel="noopener">https://apisyouwonthate.com/blog/creating-good-api-errors-in-rest-graphql-and-grpc</a><br><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="noopener">https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html</a><br><a href="https://www.youtube.com/watch?v=oL6JBUk6tj0" target="_blank" rel="noopener">https://www.youtube.com/watch?v=oL6JBUk6tj0</a><br><a href="https://github.com/zitryss/go-sample" target="_blank" rel="noopener">https://github.com/zitryss/go-sample</a><br><a href="https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md" target="_blank" rel="noopener">https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md</a><br><a href="https://medium.com/@eminetto/clean-architecture-using-golang-b63587aa5e3f" target="_blank" rel="noopener">https://medium.com/@eminetto/clean-architecture-using-golang-b63587aa5e3f</a><br><a href="https://hackernoon.com/golang-clean-archithecture-efd6d7c43047" target="_blank" rel="noopener">https://hackernoon.com/golang-clean-archithecture-efd6d7c43047</a><br><a href="https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1" target="_blank" rel="noopener">https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1</a><br><a href="https://medium.com/wtf-dial/wtf-dial-domain-model-9655cd523182" target="_blank" rel="noopener">https://medium.com/wtf-dial/wtf-dial-domain-model-9655cd523182</a><br><a href="https://hackernoon.com/golang-clean-archithecture-efd6d7c43047" target="_blank" rel="noopener">https://hackernoon.com/golang-clean-archithecture-efd6d7c43047</a><br><a href="https://hackernoon.com/trying-clean-architecture-on-golang-2-44d615bf8fdf" target="_blank" rel="noopener">https://hackernoon.com/trying-clean-architecture-on-golang-2-44d615bf8fdf</a><br><a href="https://manuel.kiessling.net/2012/09/28/applying-the-clean-architecture-to-go-applications/" target="_blank" rel="noopener">https://manuel.kiessling.net/2012/09/28/applying-the-clean-architecture-to-go-applications/</a><br><a href="https://github.com/katzien/go-structure-examples" target="_blank" rel="noopener">https://github.com/katzien/go-structure-examples</a><br><a href="https://www.youtube.com/watch?v=MzTcsI6tn-0" target="_blank" rel="noopener">https://www.youtube.com/watch?v=MzTcsI6tn-0</a><br><a href="https://www.appsdeveloperblog.com/dto-to-entity-and-entity-to-dto-conversion/" target="_blank" rel="noopener">https://www.appsdeveloperblog.com/dto-to-entity-and-entity-to-dto-conversion/</a><br><a href="https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/" target="_blank" rel="noopener">https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/</a><br><a href="https://github.com/google/wire/blob/master/docs/best-practices.md" target="_blank" rel="noopener">https://github.com/google/wire/blob/master/docs/best-practices.md</a><br><a href="https://github.com/google/wire/blob/master/docs/guide.md" target="_blank" rel="noopener">https://github.com/google/wire/blob/master/docs/guide.md</a><br><a href="https://blog.golang.org/wire" target="_blank" rel="noopener">https://blog.golang.org/wire</a><br><a href="https://github.com/google/wire" target="_blank" rel="noopener">https://github.com/google/wire</a><br><a href="https://www.ardanlabs.com/blog/2019/03/integration-testing-in-go-executing-tests-with-docker.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2019/03/integration-testing-in-go-executing-tests-with-docker.html</a><br><a href="https://www.ardanlabs.com/blog/2019/10/integration-testing-in-go-set-up-and-writing-tests.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2019/10/integration-testing-in-go-set-up-and-writing-tests.html</a><br><a href="https://blog.golang.org/examples" target="_blank" rel="noopener">https://blog.golang.org/examples</a><br><a href="https://blog.golang.org/subtests" target="_blank" rel="noopener">https://blog.golang.org/subtests</a><br><a href="https://blog.golang.org/cover" target="_blank" rel="noopener">https://blog.golang.org/cover</a><br><a href="https://blog.golang.org/module-compatibility" target="_blank" rel="noopener">https://blog.golang.org/module-compatibility</a><br><a href="https://blog.golang.org/v2-go-modules" target="_blank" rel="noopener">https://blog.golang.org/v2-go-modules</a><br><a href="https://blog.golang.org/publishing-go-modules" target="_blank" rel="noopener">https://blog.golang.org/publishing-go-modules</a><br><a href="https://blog.golang.org/module-mirror-launch" target="_blank" rel="noopener">https://blog.golang.org/module-mirror-launch</a><br><a href="https://blog.golang.org/migrating-to-go-modules" target="_blank" rel="noopener">https://blog.golang.org/migrating-to-go-modules</a><br><a href="https://blog.golang.org/using-go-modules" target="_blank" rel="noopener">https://blog.golang.org/using-go-modules</a><br><a href="https://blog.golang.org/modules2019" target="_blank" rel="noopener">https://blog.golang.org/modules2019</a><br><a href="https://blog.codecentric.de/en/2017/08/gomock-tutorial/" target="_blank" rel="noopener">https://blog.codecentric.de/en/2017/08/gomock-tutorial/</a><br><a href="https://pkg.go.dev/github.com/golang/mock/gomock" target="_blank" rel="noopener">https://pkg.go.dev/github.com/golang/mock/gomock</a><br><a href="https://medium.com/better-programming/a-gomock-quick-start-guide-71bee4b3a6f1" target="_blank" rel="noopener">https://medium.com/better-programming/a-gomock-quick-start-guide-71bee4b3a6f1</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;工程项目结构&quot;&gt;&lt;a href=&quot;#工程项目结构&quot; class=&quot;headerlink&quot; title=&quot;工程项目结构&quot;&gt;&lt;/a&gt;工程项
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="项目" scheme="https://octopuslian.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="golang" scheme="https://octopuslian.github.io/tags/golang/"/>
    
      <category term="工程" scheme="https://octopuslian.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-并行编程</title>
    <link href="https://octopuslian.github.io/2021/05/02/goatc-3-concurrency/"/>
    <id>https://octopuslian.github.io/2021/05/02/goatc-3-concurrency/</id>
    <published>2021-05-02T13:32:19.000Z</published>
    <updated>2021-06-23T14:58:44.560Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --><h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><h3 id="Processes-and-Threads"><a href="#Processes-and-Threads" class="headerlink" title="Processes and Threads"></a>Processes and Threads</h3><p>操作系统会为该应用程序创建一个进程。作为一个应用程序，它像一个为所有资源而运行的容器。这些资源包括内存地址空间、文件句柄、设备和线程。<br>线程是操作系统调度的一种执行路径，用于在处理器执行我们在函数中编写的代码。一个进程从一个线程开始，即主线程，当该线程终止时，进程终止。这是因为主线程是应用程序的原点。然后，主线程可以依次启动更多的线程，而这些线程可以启动更多的线程。</p><p>无论线程属于哪个进程，操作系统都会安排线程在可用处理器上运行。每个操作系统都有自己的算法来做出这些决定。</p><h2 id="Goroutines-and-Parallelism"><a href="#Goroutines-and-Parallelism" class="headerlink" title="Goroutines and Parallelism"></a>Goroutines and Parallelism</h2><p>Go 语言层面支持的 go 关键字，可以快速的让一个函数创建为 goroutine，我们可以认为 main 函数就是作为 goroutine 执行的。操作系统调度线程在可用处理器上运行，Go运行时调度 goroutines 在绑定到单个操作系统线程的逻辑处理器中运行(P)。即使使用这个单一的逻辑处理器和操作系统线程，也可以调度数十万 goroutine 以惊人的效率和性能并发运行。</p><p><strong>Concurrency is not Parallelism.（并行不意味着并发）</strong></p><p>并发(可以同时做)不是并行(不同的执行单元)。</p><p>并行是指两个或多个线程同时在不同的处理器执行代码。如果将运行时配置为使用多个逻辑处理器，则调度程序将在这些逻辑处理器之间分配 goroutine，这将导致 goroutine 在不同的操作系统线程上运行。但是，要获得真正的并行性，您需要在具有多个物理处理器的计算机上运行程序。否则，goroutines 将针对单个物理处理器并发运行，即使 Go 运行时使用多个逻辑处理器。</p><h3 id="Keep-your-busy-or-do-the-work-yourself"><a href="#Keep-your-busy-or-do-the-work-yourself" class="headerlink" title="Keep your busy or do the work yourself"></a>Keep your busy or do the work yourself</h3><p>空的select语句将永远堵塞：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Sprintln(w, <span class="string">"Hello，GopherCon SG"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":8000"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Incomplete-Work"><a href="#Incomplete-Work" class="headerlink" title="Incomplete Work"></a>Incomplete Work</h3><h2 id="Memory-model"><a href="#Memory-model" class="headerlink" title="Memory model"></a>Memory model</h2><p><a href="https://golang.org/ref/mem" target="_blank" rel="noopener">https://golang.org/ref/mem</a></p><p>如何保证在一个 goroutine 中看到在另一个 goroutine 修改的变量的值，如果程序中修改数据时有其他 goroutine 同时读取，那么必须将读取串行化。为了串行化访问，请使用 channel 或其他同步原语，例如 sync 和 sync/atomic 来保护数据。</p><h3 id="Happen-Before"><a href="#Happen-Before" class="headerlink" title="Happen-Before"></a>Happen-Before</h3><p>在一个 goroutine 中，读和写一定是按照程序中的顺序执行的。即编译器和处理器只有在不会改变这个 goroutine 的行为时才可能修改读和写的执行顺序。由于重排，不同的goroutine 可能会看到不同的执行顺序。例如，一个goroutine 执行 a = 1;b = 2;，另一个 goroutine 可能看到 b 在 a 之前更新。</p><h3 id="Memory-Reordering"><a href="#Memory-Reordering" class="headerlink" title="Memory Reordering"></a>Memory Reordering</h3><p>用户写下的代码，先要编译成汇编代码，也就是各种指令，包括读写内存的指令。CPU 的设计者们，为了榨干 CPU 的性能，无所不用其极，各种手段都用上了，你可能听过不少，像流水线、分支预测等等。其中，为了提高读写内存的效率，会对读写指令进行重新排列，这就是所谓的 内存重排，英文为 MemoryReordering。</p><h2 id="Package-sync"><a href="#Package-sync" class="headerlink" title="Package sync"></a>Package sync</h2><p>传统的线程模型(通常在编写 Java、C++ 和Python 程序时使用)程序员在线程之间通信需要使用共享内存。通常，共享数据结构由锁保护，线程将争用这些锁来访问数据。在某些情况下，通过使用线程安全的数据结构(如Python的Queue)，这会变得更容易。</p><p>Go 的并发原语 goroutines 和 channels 为构造并发软件提供了一种优雅而独特的方法。Go 没有显式地使用锁来协调对共享数据的访问，而是鼓励使用 chan 在 goroutine 之间传递对数据的引用。这种方法确保在给定的时间只有一个goroutine 可以访问数据。</p><p>Do not communicate by sharing memory; instead, share memory by communicating.</p><h3 id="Detecting-Race-Conditions-With-Go"><a href="#Detecting-Race-Conditions-With-Go" class="headerlink" title="Detecting Race Conditions With Go"></a>Detecting Race Conditions With Go</h3><p>data race 是两个或多个 goroutine 访问同一个资源(如变量或数据结构)，并尝试对该资源进行读写而不考虑其他 goroutine。这种类型的代码可以创建您见过的最疯狂和最随机的 bug。通常需要大量的日志记录和运气才能找到这些类型的bug。</p><p>早在6月份的Go 1.1中，Go 工具引入了一个 race detector。竞争检测器是在构建过程中内置到程序中的代码。然后，一旦你的程序运行，它就能够检测并报告它发现的任何竞争条件。它非常酷，并且在识别罪魁祸首的代码方面做了令人难以置信的工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3/8.go</span><br><span class="line">go build -race</span><br><span class="line">go test -race</span><br></pre></td></tr></table></figure><h3 id="sync-atomic"><a href="#sync-atomic" class="headerlink" title="sync.atomic"></a>sync.atomic</h3><h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><h3 id="errgroup"><a href="#errgroup" class="headerlink" title="errgroup"></a>errgroup</h3><h3 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a>sync.Pool</h3><h2 id="chan"><a href="#chan" class="headerlink" title="chan"></a>chan</h2><h3 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h3><p>channels 是一种类型安全的消息队列，充当两个 goroutine 之间的管道，将通过它同步的进行任意资源的交换。chan 控制 goroutines 交互的能力从而创建了 Go 同步机制。当创建的 chan 没有容量时，称为无缓冲通道。反过来，使用容量创建的 chan 称为缓冲通道。</p><h3 id="Unbuffered-Channels"><a href="#Unbuffered-Channels" class="headerlink" title="Unbuffered Channels"></a>Unbuffered Channels</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>无缓冲 chan 没有容量，因此进行任何交换前需要两个 goroutine 同时准备好。当 goroutine 试图将一个资源发送到一个无缓冲的通道并且没有goroutine 等待接收该资源时，该通道将锁住发送 goroutine 并使其等待。当 goroutine 尝试从无缓冲通道接收，并且没有 goroutine 等待发送资源时，该通道将锁住接收 goroutine 并使其等待。</p><p>无缓冲信道的本质是保证同步。</p><h3 id="Buffered-Channels"><a href="#Buffered-Channels" class="headerlink" title="Buffered Channels"></a>Buffered Channels</h3><p>buffered channel 具有容量，因此其行为可能有点不同。当 goroutine 试图将资源发送到缓冲通道，而该通道已满时，该通道将锁住 goroutine并使其等待缓冲区可用。如果通道中有空间，发送可以立即进行，goroutine 可以继续。当goroutine 试图从缓冲通道接收数据，而缓冲通道为空时，该通道将锁住 goroutine 并使其等待资源被发送。</p><h3 id="Latencies-due-to-under-sized-buffer"><a href="#Latencies-due-to-under-sized-buffer" class="headerlink" title="Latencies due to under-sized buffer"></a>Latencies due to under-sized buffer</h3><p>我们在 chan 创建过程中定义的缓冲区大小可能会极大地影响性能。我将使用密集使用 chan 的扇出模式来查看不同缓冲区大小的影响。在我们的基准测试中，一个 producer 将在通道中注入百万个整数元素，而5个 worker 将读取并将它们追加到一个名为 total 的结果变量中。</p><h3 id="Go-Concurrency-Patterns"><a href="#Go-Concurrency-Patterns" class="headerlink" title="Go Concurrency Patterns"></a>Go Concurrency Patterns</h3><ul><li><p>Timing out</p></li><li><p>Moving on</p></li><li><p>Pipeline</p></li><li><p>Fan-out, Fan-in</p></li><li><p>Cancellation<br>Close 先于 Receive 发生(类似 Buffered)。<br>不需要传递数据，或者传递 nil。<br>非常适合去掉和超时控制。</p></li><li><p>Contex<br><a href="https://blog.golang.org/concurrency-timeouts" target="_blank" rel="noopener">https://blog.golang.org/concurrency-timeouts</a><br><a href="https://blog.golang.org/pipelines" target="_blank" rel="noopener">https://blog.golang.org/pipelines</a><br><a href="https://talks.golang.org/2013/advconc.slide#1" target="_blank" rel="noopener">https://talks.golang.org/2013/advconc.slide#1</a><br><a href="https://github.com/go-kratos/kratos/tree/master/pkg/sync" target="_blank" rel="noopener">https://github.com/go-kratos/kratos/tree/master/pkg/sync</a></p></li></ul><h2 id="Package-context"><a href="#Package-context" class="headerlink" title="Package context"></a>Package context</h2><h3 id="Request-scoped-context"><a href="#Request-scoped-context" class="headerlink" title="Request-scoped context"></a>Request-scoped context</h3><p>在 Go 服务中，每个传入的请求都在其自己的goroutine 中处理。请求处理程序通常启动额外的 goroutine 来访问其他后端，如数据库和 RPC服务。处理请求的 goroutine 通常需要访问特定于请求(request-specific context)的值，例如最终用户的身份、授权令牌和请求的截止日期(deadline)。当一个请求被取消或超时时，处理该请求的所有 goroutine 都应该快速退出(fail fast)，这样系统就可以回收它们正在使用的任何资源。</p><p>Go 1.7 引入一个 context 包，它使得跨 API 边界的请求范围元数据、取消信号和截止日期很容易传递给处理请求所涉及的所有 goroutine(显示传递)。</p><h3 id="Do-not-store-Contexts-inside-a-struct-type"><a href="#Do-not-store-Contexts-inside-a-struct-type" class="headerlink" title="Do not store Contexts inside a struct type"></a>Do not store Contexts inside a struct type</h3><h3 id="context-WithValue"><a href="#context-WithValue" class="headerlink" title="context.WithValue"></a>context.WithValue</h3><h3 id="Debugging-or-tracing-data-is-safe-to-pass-in-a-Context"><a href="#Debugging-or-tracing-data-is-safe-to-pass-in-a-Context" class="headerlink" title="Debugging or tracing data is safe to pass in a Context"></a>Debugging or tracing data is safe to pass in a Context</h3><h3 id="When-a-Context-is-canceled-all-Contexts-derived-from-it-are-also-canceled"><a href="#When-a-Context-is-canceled-all-Contexts-derived-from-it-are-also-canceled" class="headerlink" title="When a Context is canceled, all Contexts derived from it are also canceled"></a>When a Context is canceled, all Contexts derived from it are also canceled</h3><h3 id="All-blocking-long-operations-should-be-cancelable"><a href="#All-blocking-long-operations-should-be-cancelable" class="headerlink" title="All blocking/long operations should be cancelable"></a>All blocking/long operations should be cancelable</h3><h2 id="Final-Notes"><a href="#Final-Notes" class="headerlink" title="Final Notes"></a>Final Notes</h2><ul><li>Incoming requests to a server should create a Context.</li><li>Outgoing calls to servers should accept a Context.</li><li>Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it.</li><li>The chain of function calls between them must propagate the Context.</li><li>Replace a Context using WithCancel, WithDeadline, WithTimeout, or WithValue.</li><li>When a Context is canceled, all Contexts derived from it are also canceled.</li><li>The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines.</li><li>Do not pass a nil Context, even if a function permits it. Pass a TODO context if you are unsure about which Context to use.</li><li>Use context values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html</a><br><a href="https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html</a><br><a href="https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html</a><br><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_concurrency" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html#_concurrency</a><br><a href="https://golang.org/ref/mem" target="_blank" rel="noopener">https://golang.org/ref/mem</a><br><a href="https://blog.csdn.net/caoshangpa/article/details/78853919" target="_blank" rel="noopener">https://blog.csdn.net/caoshangpa/article/details/78853919</a><br><a href="https://blog.csdn.net/qcrao/article/details/92759907" target="_blank" rel="noopener">https://blog.csdn.net/qcrao/article/details/92759907</a><br><a href="https://cch123.github.io/ooo/" target="_blank" rel="noopener">https://cch123.github.io/ooo/</a><br><a href="https://blog.golang.org/codelab-share" target="_blank" rel="noopener">https://blog.golang.org/codelab-share</a><br><a href="https://dave.cheney.net/2018/01/06/" target="_blank" rel="noopener">https://dave.cheney.net/2018/01/06/</a></p><p><code>if-aligned-memory-writes-are-atomic-why-do-we-need-the-sync-atomic-package</code></p><p><a href="http://blog.golang.org/race-detector" target="_blank" rel="noopener">http://blog.golang.org/race-detector</a><br><a href="https://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races" target="_blank" rel="noopener">https://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races</a><br><a href="https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html</a><br><a href="https://medium.com/a-journey-with-go/" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/</a></p><p><code>go-how-to-reduce-lock-contention-with-the-atomic-package-ba3b2664b549</code></p><p><a href="https://medium.com/a-journey-with-go/go-discovery-of-the-trace-package-e5a821743c3c" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-discovery-of-the-trace-package-e5a821743c3c</a><br><a href="https://medium.com/a-journey-with-go/go-mutex-and-starvation-3f4f4e75ad50" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-mutex-and-starvation-3f4f4e75ad50</a><br><a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html</a><br><a href="https://medium.com/a-journey-with-go/go-buffered-and-unbuffered-channels-29a107c00268" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-buffered-and-unbuffered-channels-29a107c00268</a><br><a href="https://medium.com/a-journey-with-go/go-ordering-in-select-statements-fd0ff80fd8d6" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-ordering-in-select-statements-fd0ff80fd8d6</a><br><a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html</a><br><a href="https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html</a><br><a href="https://www.ardanlabs.com/blog/2013/10/my-channel-select-bug.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2013/10/my-channel-select-bug.html</a><br><a href="https://blog.golang.org/io2013-talk-concurrency" target="_blank" rel="noopener">https://blog.golang.org/io2013-talk-concurrency</a><br><a href="https://blog.golang.org/waza-talk" target="_blank" rel="noopener">https://blog.golang.org/waza-talk</a><br><a href="https://blog.golang.org/io2012-videos" target="_blank" rel="noopener">https://blog.golang.org/io2012-videos</a><br><a href="https://blog.golang.org/concurrency-timeouts" target="_blank" rel="noopener">https://blog.golang.org/concurrency-timeouts</a><br><a href="https://blog.golang.org/pipelines" target="_blank" rel="noopener">https://blog.golang.org/pipelines</a><br><a href="https://www.ardanlabs.com/blog/2014/02/running-queries-concurrently-against.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/02/running-queries-concurrently-against.html</a><br><a href="https://blogtitle.github.io/go-advanced-concurrency-patterns-part-3-channels/" target="_blank" rel="noopener">https://blogtitle.github.io/go-advanced-concurrency-patterns-part-3-channels/</a><br><a href="https://www.ardanlabs.com/blog/2013/05/thread-pooling-in-go-programming.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2013/05/thread-pooling-in-go-programming.html</a><br><a href="https://www.ardanlabs.com/blog/2013/09/pool-go-routines-to-process-task.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2013/09/pool-go-routines-to-process-task.html</a><br><a href="https://blogtitle.github.io/categories/concurrency/" target="_blank" rel="noopener">https://blogtitle.github.io/categories/concurrency/</a><br><a href="https://medium.com/@cep21/how-to-correctly-use-context-context-in-go-1-7-8f2c0fafdf39" target="_blank" rel="noopener">https://medium.com/@cep21/how-to-correctly-use-context-context-in-go-1-7-8f2c0fafdf39</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Goroutine&quot;&gt;&lt;a href=&quot;#Goroutine&quot; class=&quot;headerlink&quot; title=&quot;Goroutine
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="Golang" scheme="https://octopuslian.github.io/tags/Golang/"/>
    
      <category term="并行" scheme="https://octopuslian.github.io/tags/%E5%B9%B6%E8%A1%8C/"/>
    
      <category term="并发" scheme="https://octopuslian.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="goroutine" scheme="https://octopuslian.github.io/tags/goroutine/"/>
    
      <category term="channel" scheme="https://octopuslian.github.io/tags/channel/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-异常处理</title>
    <link href="https://octopuslian.github.io/2021/05/02/goatc-2-error/"/>
    <id>https://octopuslian.github.io/2021/05/02/goatc-2-error/</id>
    <published>2021-05-02T13:12:25.000Z</published>
    <updated>2021-06-23T14:58:44.560Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --><h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>Golang的<code>error</code>就是普通的一个接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span>&#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Error-vs-Exception"><a href="#Error-vs-Exception" class="headerlink" title="Error vs Exception"></a>Error vs Exception</h2><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>单返回值，一般通过传递指针作为入参，返回值为 int 表示成功还是失败。</p><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><p>引入了 exception，但是无法知道被调用方会抛出什么异常。</p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>引入了 checked exception，方法的所有者必须申明，调用者必须处理。在启动时抛出大量的异常是司空见惯的事情，并在它们的调用堆栈中尽职地记录下来。Java 异常不再是异常，而是变得司空见惯了。它们从良性到灾难性都有使用，异常的严重性由函数的调用者来区分。</p><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p>Go 的处理异常逻辑是不引入 exception，支持多参数返回，所以你很容易的在函数签名中带上实现了 error interface 的对象，交由调用者来判定。</p><p>如果一个函数返回了 value, error，你不能对这个 value 做任何假设，必须先判定 error。唯一可以忽略 error 的是，如果你连 value 也不关心。</p><p>Go 中有 panic 的机制，如果你认为和其他语言的 exception 一样，那你就错了。当我们抛出异常的时候，相当于你把 exception 扔给了调用者来处理。</p><p>比如，你在 C++ 中，把 string 转为 int，如果转换失败，会抛出异常。或者在 java 中转换 string 为 date 失败时，会抛出异常。</p><p>Go panic 意味着 fatal error(就是挂了)。不能假设调用者来解决 panic，意味着代码不能继续运行。<br>使用多个返回值和一个简单的约定，Go 解决了让程序员知道什么时候出了问题，并为真正的异常情况保留了 panic。</p><p>对于真正意外的情况，那些表示不可恢复的程序错误，例如索引越界、不可恢复的环境问题、栈溢出，我们才使用 panic。对于其他的错误情况，我们应该是期望使用 error 来进行判定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">you only need to check the error value if you care about the result.  -- Dave  </span><br><span class="line">This blog post from Microsoft’s engineering blog in 2005 still holds true today, namely:  </span><br><span class="line">My point isn’t that exceptions are bad. My point is that exceptions are too hard and I’m not smart enough to handle them.</span><br></pre></td></tr></table></figure><ul><li>简单。</li><li>考虑失败，而不是成功(Plan for failure, not success)。</li><li>没有隐藏的控制流。</li><li>完全交给你来控制 error。</li><li>Error are values。</li></ul><h2 id="Error-Type"><a href="#Error-Type" class="headerlink" title="Error Type"></a>Error Type</h2><h3 id="Sentinel-Error"><a href="#Sentinel-Error" class="headerlink" title="Sentinel Error"></a>Sentinel Error</h3><p>预定义的特定错误，我们叫为 sentinel error，这个名字来源于计算机编程中使用一个特定值来表示不可能进行进一步处理的做法。所以对于 Go，我们使用特定的值来表示错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err == ErrSomething &#123; … &#125;</span><br></pre></td></tr></table></figure><p>类似的 io.EOF，更底层的 syscall.ENOENT。</p><p>使用 sentinel 值是最不灵活的错误处理策略，因为调用方必须使用 == 将结果与预先声明的值进行比较。当您想要提供更多的上下文时，这就出现了一个问题，因为返回一个不同的错误将破坏相等性检查。</p><p>甚至是一些有意义的 fmt.Errorf 携带一些上下文，也会破坏调用者的 == ，调用者将被迫查看 error.Error() 方法的输出，以查看它是否与特定的字符串匹配。</p><ul><li><p>不依赖检查 error.Error 的输出。<br>不应该依赖检测 error.Error 的输出，Error 方法存在于 error 接口主要用于方便程序员使用，但不是程序(编写测试可能会依赖这个返回)。这个输出的字符串用于记录日志、输出到 stdout 等。</p></li><li><p>Sentinel errors 成为你 API 公共部分<br>如果您的公共函数或方法返回一个特定值的错误，那么该值必须是公共的，当然要有文档记录，这会增加 API 的表面积。<br>如果 API 定义了一个返回特定错误的 interface，则该接口的所有实现都将被限制为仅返回该错误，即使它们可以提供更具描述性的错误。<br>比如 io.Reader。像 io.Copy 这类函数需要 reader 的实现者比如返回 io.EOF 来告诉调用者没有更多数据了，但这又不是错误。</p></li><li><p>Sentinel errors 在两个包之间创建了依赖<br>sentinel errors 最糟糕的问题是它们在两个包之间创建了源代码依赖关系。例如，检查错误是否等于 io.EOF，您的代码必须导入 io 包。这个特定的例子听起来并不那么糟糕，因为它非常常见，但是想象一下，当项目中的许多包导出错误值时，存在耦合，项目中的其他包必须导入这些错误值才能检查特定的错误条件(in the form of an import loop)。</p></li><li><p>结论: 尽可能避免 sentinel errors<br>我的建议是避免在编写的代码中使用 sentinel errors。在标准库中有一些使用它们的情况，但这不是一个您应该模仿的模式。</p></li></ul><p><strong>Error type 是实现了 error 接口的自定义类型。</strong></p><h3 id="Opaque-errors"><a href="#Opaque-errors" class="headerlink" title="Opaque errors"></a>Opaque errors</h3><p>在我看来，这是最灵活的错误处理策略，因为它要求代码和调用者之间的耦合最少。<br>我将这种风格称为不透明错误处理，因为虽然您知道发生了错误，但您没有能力看到错误的内部。作为调用者，关于操作的结果，您所知道的就是它起作用了，或者没有起作用(成功还是失败)。<br>这就是不透明错误处理的全部功能–只需返回错误而不假设其内容。</p><ul><li>Assert errors for behaviour, not type<br>在少数情况下，这种二分错误处理方法是不够的。例如，与进程外的世界进行交互(如网络活动)，需要调用方调查错误的性质，以确定重试该操作是否合理。在这种情况下，我们可以断言错误实现了特定的行为，而不是断言错误是特定的类型或值。</li></ul><h2 id="Handling-Error"><a href="#Handling-Error" class="headerlink" title="Handling Error"></a>Handling Error</h2><h3 id="Indented-flow-is-for-errors"><a href="#Indented-flow-is-for-errors" class="headerlink" title="Indented flow is for errors"></a>Indented flow is for errors</h3><p>无错误的正常流程代码，将成为一条直线，而不是缩进的代码。</p><h3 id="Eliminate-error-handling-by-eliminating-errors"><a href="#Eliminate-error-handling-by-eliminating-errors" class="headerlink" title="Eliminate error handling by eliminating errors"></a>Eliminate error handling by eliminating errors</h3><p>(后面再细说)</p><h3 id="Wrap-erros"><a href="#Wrap-erros" class="headerlink" title="Wrap erros"></a>Wrap erros</h3><p>在程序的顶部，程序的主体将把错误打印到屏幕或日志文件中，打印出来的只是：没有这样的文件或目录。</p><p>没有生成错误的 file:line 信息。没有导致错误的调用堆栈的堆栈跟踪。这段代码的作者将被迫进行长时间的代码分割，以发现是哪个代码路径触发了文件未找到错误。</p><p>这种模式与 sentinel errors 或 type assertions 的使用不兼容，因为将错误值转换为字符串，将其与另一个字符串合并，然后将其转换回 fmt.Errorf 破坏了原始错误，导致等值判定失败。</p><p>Go 中的错误处理契约规定，在出现错误的情况下，不能对其他返回值的内容做出任何假设。由于 JSON 序列化失败，buf 的内容是未知的，可能它不包含任何内容，但更糟糕的是，它可能包含一个半写的 JSON 片段。</p><p>由于程序员在检查并记录错误后忘记 return，损坏的缓冲区将被传递给 WriteAll，这可能会成功，因此配置文件将被错误地写入。但是，该函数返回的结果是正确的。</p><p>日志记录与错误无关且对调试没有帮助的信息应被视为噪音，应予以质疑。记录的原因是因为某些东西失败了，而日志包含了答案。</p><ul><li>错误要被日志记录。</li><li>应用程序处理错误，保证100%完整性。</li><li>之后不再报告当前错误。</li></ul><h2 id="Go-1-13-errors"><a href="#Go-1-13-errors" class="headerlink" title="Go 1.13 errors"></a>Go 1.13 errors</h2><p>最简单的错误检查：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">//something went wrong</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><p>我们在数据库操作的时候，比如 dao 层中当遇到一个 sql.ErrNoRows 的时候，是否应该 Wrap 这个 error，抛给上层。为什么，应该怎么做请写出代码？</p><h2 id="Go-2-Error-Inspection"><a href="#Go-2-Error-Inspection" class="headerlink" title="Go 2 Error Inspection"></a>Go 2 Error Inspection</h2><p><a href="https://go.googlesource.com/proposal/+/master/design/29934-error-values.md" target="_blank" rel="noopener">https://go.googlesource.com/proposal/+/master/design/29934-error-values.md</a></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://dave.cheney.net/2012/01/18/why-go-gets-exceptions-right" target="_blank" rel="noopener">https://dave.cheney.net/2012/01/18/why-go-gets-exceptions-right</a><br><a href="https://dave.cheney.net/2015/01/26/errors-and-exceptions-redux" target="_blank" rel="noopener">https://dave.cheney.net/2015/01/26/errors-and-exceptions-redux</a><br><a href="https://dave.cheney.net/2014/11/04/error-handling-vs-exceptions-redux" target="_blank" rel="noopener">https://dave.cheney.net/2014/11/04/error-handling-vs-exceptions-redux</a><br><a href="https://rauljordan.com/2020/07/06/why-go-error-handling-is-awesome.html" target="_blank" rel="noopener">https://rauljordan.com/2020/07/06/why-go-error-handling-is-awesome.html</a><br><a href="https://morsmachine.dk/error-handling" target="_blank" rel="noopener">https://morsmachine.dk/error-handling</a><br><a href="https://blog.golang.org/error-handling-and-go" target="_blank" rel="noopener">https://blog.golang.org/error-handling-and-go</a><br><a href="https://www.ardanlabs.com/blog/2014/10/error-handling-in-go-part-i.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/10/error-handling-in-go-part-i.html</a><br><a href="https://www.ardanlabs.com/blog/2014/11/error-handling-in-go-part-ii.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/11/error-handling-in-go-part-ii.html</a><br><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully</a><br><a href="https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html" target="_blank" rel="noopener">https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html</a><br><a href="https://blog.golang.org/errors-are-values" target="_blank" rel="noopener">https://blog.golang.org/errors-are-values</a><br><a href="https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package" target="_blank" rel="noopener">https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package</a><br><a href="https://www.ardanlabs.com/blog/2017/05/design-philosophy-on-logging.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2017/05/design-philosophy-on-logging.html</a><br><a href="https://crawshaw.io/blog/xerrors" target="_blank" rel="noopener">https://crawshaw.io/blog/xerrors</a><br><a href="https://blog.golang.org/go1.13-errors" target="_blank" rel="noopener">https://blog.golang.org/go1.13-errors</a><br><a href="https://medium.com/gett-engineering/error-handling-in-go-53b8a7112d04" target="_blank" rel="noopener">https://medium.com/gett-engineering/error-handling-in-go-53b8a7112d04</a><br><a href="https://medium.com/gett-engineering/error-handling-in-go-1-13-5ee6d1e0a55c" target="_blank" rel="noopener">https://medium.com/gett-engineering/error-handling-in-go-1-13-5ee6d1e0a55c</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Error&quot;&gt;&lt;a href=&quot;#Error&quot; class=&quot;headerlink&quot; title=&quot;Error&quot;&gt;&lt;/a&gt;Error&lt;
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="Golang" scheme="https://octopuslian.github.io/tags/Golang/"/>
    
      <category term="error" scheme="https://octopuslian.github.io/tags/error/"/>
    
      <category term="异常" scheme="https://octopuslian.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 42.trapping-rain-water | 接雨水</title>
    <link href="https://octopuslian.github.io/2021/04/25/leetcode-42-trapping-rain-water/"/>
    <id>https://octopuslian.github.io/2021/04/25/leetcode-42-trapping-rain-water/</id>
    <published>2021-04-25T05:57:53.000Z</published>
    <updated>2021-04-25T05:59:55.292Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left, right, leftMax, rightMax, res <span class="keyword">int</span></span><br><span class="line">right = <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line"><span class="keyword">if</span> height[left] &lt; height[right] &#123;</span><br><span class="line"><span class="keyword">if</span> height[left] &gt;= leftMax &#123;</span><br><span class="line"><span class="comment">//设置左边最高柱子</span></span><br><span class="line">leftMax = height[left]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//右边必定有柱子挡水，所以，遇到所有值小于等于leftMax的，全部加入水池</span></span><br><span class="line">res += leftMax - height[left]</span><br><span class="line">&#125;</span><br><span class="line">left++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> height[right] &gt; rightMax &#123; </span><br><span class="line"><span class="comment">//设置右边最高柱子</span></span><br><span class="line">rightMax = height[right] </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//左边必定有柱子挡水，所以，遇到所有值小于等于rightMax的，全部加入水池</span></span><br><span class="line">res += rightMax - height[right] </span><br><span class="line">&#125;</span><br><span class="line">right--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 12. 矩阵中的路径</title>
    <link href="https://octopuslian.github.io/2021/04/25/leetcode-lcof-12-ju-zhen-zhong-de-lu-jing/"/>
    <id>https://octopuslian.github.io/2021/04/25/leetcode-lcof-12-ju-zhen-zhong-de-lu-jing/</id>
    <published>2021-04-25T05:52:34.000Z</published>
    <updated>2021-04-27T09:50:44.097Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p>题目同<a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">leetcode 70.word-search</a></p><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><h3 id="DFS解法"><a href="#DFS解法" class="headerlink" title="DFS解法"></a>DFS解法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exist</span><span class="params">(board [][]<span class="keyword">byte</span>, word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> row := <span class="number">0</span>; row &lt; <span class="built_in">len</span>(board); row ++&#123;</span><br><span class="line">        <span class="keyword">for</span> col := <span class="number">0</span>;col &lt; <span class="built_in">len</span>(board[row]); col ++&#123;</span><br><span class="line">            <span class="keyword">if</span> dfs(board, word, row, col, <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(board [][]<span class="keyword">byte</span>, word <span class="keyword">string</span>, i, j, idx <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="comment">//越界或者字符不相等</span></span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span> || i &gt;= <span class="built_in">len</span>(board) || </span><br><span class="line">    j &lt; <span class="number">0</span> || j &gt;= <span class="built_in">len</span>(board[<span class="number">0</span>]) || </span><br><span class="line">    board[i][j] != word[idx] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> idx == <span class="built_in">len</span>(word) - <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标记已被访问</span></span><br><span class="line">    tmpCh := board[i][j]</span><br><span class="line">    board[i][j] = <span class="string">'/'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//上下左右检查一下</span></span><br><span class="line">    check := (dfs(board, word, i+<span class="number">1</span>, j, idx+<span class="number">1</span>) || dfs(board, word, i<span class="number">-1</span>, j, idx + <span class="number">1</span>) || </span><br><span class="line">    dfs(board, word, i, j+<span class="number">1</span>, idx+<span class="number">1</span>) || dfs(board, word, i, j<span class="number">-1</span>, idx+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复</span></span><br><span class="line">    board[i][j] = tmpCh</span><br><span class="line">    <span class="keyword">return</span> check</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="LeetCode-lcof-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-lcof-Solutions/"/>
    
    
      <category term="BFS" scheme="https://octopuslian.github.io/tags/BFS/"/>
    
      <category term="矩阵路径" scheme="https://octopuslian.github.io/tags/%E7%9F%A9%E9%98%B5%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 329.longest-increasing-path-in-a-matrix | 矩阵中的最长递增路径</title>
    <link href="https://octopuslian.github.io/2021/04/25/leetcode-329-longest-increasing-path-in-a-matrix/"/>
    <id>https://octopuslian.github.io/2021/04/25/leetcode-329-longest-increasing-path-in-a-matrix/</id>
    <published>2021-04-25T05:02:21.000Z</published>
    <updated>2021-04-27T09:54:34.238Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。</p><p><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">329. 矩阵中的最长递增路径</a></p><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rangeSumBST</span><span class="params">(root *TreeNode, low <span class="keyword">int</span>, high <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &gt; high &#123;</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(root.Left, low, high)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> root.Val &lt; low &#123;</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(root.Right, low, high)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root.Val + rangeSumBST(root.Left, low, high) + rangeSumBST(root.Right, low, high)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="宽度优先搜索（待完善）"><a href="#宽度优先搜索（待完善）" class="headerlink" title="宽度优先搜索（待完善）"></a>宽度优先搜索（待完善）</h3><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
      <category term="BFS" scheme="https://octopuslian.github.io/tags/BFS/"/>
    
      <category term="DFS" scheme="https://octopuslian.github.io/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 179.largest-number | 最大数</title>
    <link href="https://octopuslian.github.io/2021/04/25/leetcode-179-largest-number/"/>
    <id>https://octopuslian.github.io/2021/04/25/leetcode-179-largest-number/</id>
    <published>2021-04-25T04:50:11.000Z</published>
    <updated>2021-04-26T07:00:34.645Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一组非负整数 nums，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p><p>注意：输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [10,2]</span><br><span class="line">输出：&quot;210&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [3,30,34,5,9]</span><br><span class="line">输出：&quot;9534330&quot;</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [1]</span><br><span class="line">输出：&quot;1&quot;</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：nums = [10]</span><br><span class="line">输出：&quot;10&quot;</span><br><span class="line"> </span><br><span class="line">提示：</span><br><span class="line">1 &lt;= nums.length &lt;= 100</span><br><span class="line">0 &lt;= nums[i] &lt;= 109</span><br></pre></td></tr></table></figure><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 10- II. 青蛙跳台阶问题</title>
    <link href="https://octopuslian.github.io/2021/04/25/leetcode-lcof-10-ii-qing-wa-tiao-tai-jie-wen-ti/"/>
    <id>https://octopuslian.github.io/2021/04/25/leetcode-lcof-10-ii-qing-wa-tiao-tai-jie-wen-ti/</id>
    <published>2021-04-25T04:44:37.000Z</published>
    <updated>2021-04-25T04:49:34.550Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：n = 7</span><br><span class="line">输出：21</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：n = 0</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;= n &lt;= 100</span><br></pre></td></tr></table></figure><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><h3 id="循环求余法"><a href="#循环求余法" class="headerlink" title="循环求余法"></a>循环求余法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numWays</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    a := <span class="number">1</span></span><br><span class="line">    b := <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; n;i++ &#123;</span><br><span class="line">        sum = (a + b) % <span class="number">1000000007</span></span><br><span class="line">        a = b</span><br><span class="line">        b = sum</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="LeetCode-lcof-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-lcof-Solutions/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
      <category term="青蛙跳台阶" scheme="https://octopuslian.github.io/tags/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>九章算法基础-宽度优先搜索</title>
    <link href="https://octopuslian.github.io/2021/04/23/jiu-zhang-algo-elementary-bfs/"/>
    <id>https://octopuslian.github.io/2021/04/23/jiu-zhang-algo-elementary-bfs/</id>
    <published>2021-04-23T13:37:06.000Z</published>
    <updated>2021-04-26T07:00:34.643Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><h3 id="二叉树上的宽搜"><a href="#二叉树上的宽搜" class="headerlink" title="二叉树上的宽搜"></a>二叉树上的宽搜</h3><h3 id="图上的宽搜"><a href="#图上的宽搜" class="headerlink" title="图上的宽搜"></a>图上的宽搜</h3><p>拓扑排序</p><h3 id="棋盘上的宽搜"><a href="#棋盘上的宽搜" class="headerlink" title="棋盘上的宽搜"></a>棋盘上的宽搜</h3><h2 id="什么时候应该使用BFS"><a href="#什么时候应该使用BFS" class="headerlink" title="什么时候应该使用BFS"></a>什么时候应该使用BFS</h2><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><ul><li>层级遍历</li><li>由点及面</li><li>拓扑排序</li></ul><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><ul><li>仅限简单图求最短路径</li><li>图中每条边长度是1，没有方向</li></ul><h3 id="题目是最短路径，除了BFS还有什么算法"><a href="#题目是最短路径，除了BFS还有什么算法" class="headerlink" title="题目是最短路径，除了BFS还有什么算法"></a>题目是最短路径，除了BFS还有什么算法</h3><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;大纲&quot;&gt;&lt;a href=&quot;#大纲&quot; class=&quot;headerlink&quot; title=&quot;大纲&quot;&gt;&lt;/a&gt;大纲&lt;/h2&gt;&lt;h3 id=&quot;
      
    
    </summary>
    
    
      <category term="JZCourse" scheme="https://octopuslian.github.io/categories/JZCourse/"/>
    
    
      <category term="宽度优先搜索" scheme="https://octopuslian.github.io/tags/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="九章" scheme="https://octopuslian.github.io/tags/%E4%B9%9D%E7%AB%A0/"/>
    
      <category term="算法基础" scheme="https://octopuslian.github.io/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>四川省都江堰市青城后山一日游</title>
    <link href="https://octopuslian.github.io/2021/04/21/qing-cheng-hou-shan-one-day-trip/"/>
    <id>https://octopuslian.github.io/2021/04/21/qing-cheng-hou-shan-one-day-trip/</id>
    <published>2021-04-21T14:24:02.000Z</published>
    <updated>2021-04-21T14:25:30.609Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --><p>上周五去跟一位朋友约去爬山，地点选在都江堰市的青城山，本文将详细分享旅游攻略，以及旅行完的顿悟。</p><h2 id="出发前"><a href="#出发前" class="headerlink" title="出发前"></a>出发前</h2><p>出发之前，我和袁准备了一个背包，想着先爬到山上再去补给。</p><p>我和袁住在成都市，早上7点半约好见面，吃过早餐坐地铁到犀浦，然后转城际列车(10元/人)到青城山下车即可。建议如果去青城山最好直接上车前买直达，不然到车上补票还需要另外收费。</p><p>到了青城山车站出来，由于我们是要去的后山，自然景观丰富，空气清新，因此我们两人打了个车，一个人15（景区要16，还有等一会，小车直接走）。在此需要提醒：由于是上山的路且弯道众多，因此可能会晕车。</p><p>到了泰安古镇，也就是景区的入口处，我们吃了顿午饭（还是有些小贵），买了20元/人的门票，就开始爬山了。</p><h2 id="上山过程"><a href="#上山过程" class="headerlink" title="上山过程"></a>上山过程</h2><p>我们白天爬，感觉都还好，不是很热，沿途有各种卖饮料的，不过价格稍贵，水5元、饮料10元，棒棒糖3元一根。</p><p>爬到半山腰大概3个小时，然后有缆车可以往返，不过我们年轻小伙子想着多运动，于是就没有坐缆车（这是我最后悔的决定）。接着就开始体力不支，因为大多是上坡，很累，爬一会就得休息一下，不过还好在5点的时候（用了两个小时）爬到了白云寺，拜了拜佛，然后准备下山，这时候从卖饮料的大妈口中得知，5点半缆车停运！！！</p><h2 id="下山过程"><a href="#下山过程" class="headerlink" title="下山过程"></a>下山过程</h2><p>下山稍微轻松，但腿开始软了，感到走不动路，看着手机上还有几百米的距离到达缆车地点，我真想飞过去。结果我们5点20到那里后，人家告诉我缆车工作人员早就下班了，我不甘心，下去看了一眼，果然都停了，于是在想怎么办。有个姐姐告诉我下山大概一个小时可以坐船，坐上船后再走一个小时就下山了，我们一看时间，嗯，争取赶晚上8点下山，然后坐列车回成都。</p><p>结果坐船说过了运营时间，要涨价，5元/人（正常是2元/人）。行吧，就这样，结果坐完船就开始晕，恶心，头晕，心跳的贼快，于是朋友叫我先休息，最后休息到7点往下走，还是感到不舒服，没办法，直接叫救援。</p><h2 id="救援过程"><a href="#救援过程" class="headerlink" title="救援过程"></a>救援过程</h2><p>首先打完救援电话后，被告知救援费要1000元，我在犹豫间朋友已经替我答应了，挂了电话对我说，钱花了可以挣，但一定要保证你的安全。于是，我们在夜幕降临的过程中，用手机闪光灯照着周围环境，防止有蛇、虫子之类的靠近，同时我们也看到草丛里有一双泛着黄光的动物眼睛盯着我们。</p><p>等了大概一个小时，救援队上来，把我抬了下去，最后由120救护车把我送到医院做检查。</p><p>身体没有大碍，就心跳的太快了，于是开了一些降心率的药，叮嘱我回成都市了要好好检查。</p><p>就这样，在一天中结束了自己跌宕起伏的青城的后山爬山之旅。</p><h2 id="此次旅行感悟"><a href="#此次旅行感悟" class="headerlink" title="此次旅行感悟"></a>此次旅行感悟</h2><ul><li>有时候不能硬撑，实在走不动了，就用钱代替交通；</li><li>钱没了可以再挣，身体是最重要的；</li><li>出发前做好旅行规划很重要；</li><li>体检有不舒服的就赶紧去查，防止小病拖成大病；</li><li>不要把问题想的太严重，总会有解决之道。</li></ul><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Jul 15 2021 00:24:58 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;上周五去跟一位朋友约去爬山，地点选在都江堰市的青城山，本文将详细分享旅游攻略，以及旅行完的顿悟。&lt;/p&gt;&lt;h2 id=&quot;出发前&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="Travel-notes" scheme="https://octopuslian.github.io/categories/Travel-notes/"/>
    
    
      <category term="旅行" scheme="https://octopuslian.github.io/tags/%E6%97%85%E8%A1%8C/"/>
    
      <category term="青城山" scheme="https://octopuslian.github.io/tags/%E9%9D%92%E5%9F%8E%E5%B1%B1/"/>
    
      <category term="都江堰" scheme="https://octopuslian.github.io/tags/%E9%83%BD%E6%B1%9F%E5%A0%B0/"/>
    
  </entry>
  
</feed>

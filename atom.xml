<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>以写作调身心</title>
  
  <subtitle>熟能生巧，勤能补拙；念念不忘，必有回响。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://octopuslian.github.io/"/>
  <updated>2020-12-18T15:25:30.375Z</updated>
  <id>https://octopuslian.github.io/</id>
  
  <author>
    <name>Neo Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sad Workers</title>
    <link href="https://octopuslian.github.io/2020/12/18/how-sad-workers/"/>
    <id>https://octopuslian.github.io/2020/12/18/how-sad-workers/</id>
    <published>2020-12-18T15:28:03.000Z</published>
    <updated>2020-12-18T15:25:30.375Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --><p>打工人，越来越难了。</p><p>曾以为打工只是出卖自己的劳动力换取报酬，然而没想到行业内卷的这么严重，停止等于倒退；没有今天的996，哪有明天的669；优化不能加班的员工；35岁被裁…现在要成立HR联盟，垄断员工肆意跳槽。</p><p>我不知道未来将会怎样，今天意外刷到一部冷门电影<a href="https://movie.douban.com/subject/4116481/" target="_blank" rel="noopener">《极乐空间》</a>，放佛看到了打工人的未来。</p><p>社会缺什么，就会赞美什么————缺爱国情怀，就去拍各种抗日神剧；缺真善美，就去拍各种脑残傻白甜的电视剧…我一直很喜欢<a href="https://movie.douban.com/subject/5350027/" target="_blank" rel="noopener">《妖猫转》</a>里的一段话：<strong>人心这么黑暗，我想找到一种不再痛苦的秘密。</strong>而最后杨玉环给了我一个答案：生活是不完美的，但我依然可以选择去拥抱生活的美好。</p><p>什么是美好呢？也许是一次温暖的鼓励，也许是临行前父母的嘱托，也许是高考前妹妹大声喊着“哥哥高考必胜”，也许是大雪纷飞中公交车司机多等了我一分钟…可是，当我步入职场后，我却发现自己越来越难以坚守本心。</p><p>最近忙着申请了成都市的失业补助金，也为极客时间又当了一回审稿人，看着这些忙忙碌碌我生活奔波的打工人，是的，也许我就是一滴水，多我少我都算不了什么，因为我迟早要融入这浩浩荡荡的打工人海中去随波逐流，为着这居高不下的房价当做我奋斗的目标，衡量工作的成功而是以工作作为评级。</p><p>只是，如果允许我再任性一回，我想再回归本心，去找寻真正的出路。</p><p>（最近备考压力有些大，看着杭州市成立了HR联盟，难免心里有些膈应，写一此文吐槽一番…）</p><p><a href="https://www.zhihu.com/question/357459810/answer/908791884" target="_blank" rel="noopener">如何看待网传网易裁员，让保安把身患绝症的 5 年老员工赶出公司一事？</a><br><a href="https://www.zhihu.com/question/434158902" target="_blank" rel="noopener">如何评价杭州阿里、海康、网易等组成 HR 联盟？</a><br><a href="https://www.zhihu.com/question/359047845/answer/921118877" target="_blank" rel="noopener">「华为前员工李洪元被羁押 251 天」 事发过程是怎样的？还有哪些值得注意的疑点和信息？</a><br><a href="https://www.zhihu.com/question/308375308/answer/654108580" target="_blank" rel="noopener">如何看待华为工程师 22 月无休后猝死的传闻，事件真相如何？</a><br><a href="https://www.zhihu.com/question/407009249" target="_blank" rel="noopener">如何看待腾讯高级工程师因「每天在岗不足8小时」被辞退，反诉加班费等 500 余万两度败诉？</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --&gt;&lt;p&gt;打工人，越来越难了。&lt;/p&gt;&lt;p&gt;曾以为打工只是出卖自己的劳动力换取报酬，然而没想到行业内卷的这么严重，停止等于倒退；没有今天的996，哪有明天的669；优
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://octopuslian.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="打工人" scheme="https://octopuslian.github.io/tags/%E6%89%93%E5%B7%A5%E4%BA%BA/"/>
    
      <category term="悲哀" scheme="https://octopuslian.github.io/tags/%E6%82%B2%E5%93%80/"/>
    
      <category term="出路" scheme="https://octopuslian.github.io/tags/%E5%87%BA%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>Leave——成都华栖云</title>
    <link href="https://octopuslian.github.io/2020/12/10/leave-china-sichuan-chengdu-chinamcloud/"/>
    <id>https://octopuslian.github.io/2020/12/10/leave-china-sichuan-chengdu-chinamcloud/</id>
    <published>2020-12-10T14:21:30.000Z</published>
    <updated>2020-12-11T03:02:49.488Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --><p><strong>很多事情我无法改变，但可以选择离开。 ————题记</strong></p><p>成都华栖云是我从成都飞鱼离职后入职的一家传统互联网型公司，主要面向的客户是国企和学校。</p><p>从大学毕业到现在的两年内，我在这家公司不断积累社会经验，也解开了我大学时曾有过的困惑。</p><h2 id="困惑一-为什么产品经常会和研发打架？"><a href="#困惑一-为什么产品经常会和研发打架？" class="headerlink" title="困惑一_为什么产品经常会和研发打架？"></a>困惑一_为什么产品经常会和研发打架？</h2><p>这个困惑最先来自于大学看到的段子，直到毕业后我才真实体会到这里面的心酸和无奈。</p><p>2019年夏天，我记得非常清楚，已经数不清多少次，想骂我部门的W姓产品经理，但不好听的话到嘴边就变成了“好的，我先去实现一下。”</p><p>每次对需求，不说个具体时间，等火烧眉毛了才知道着急，最后矛头全指在我这里；对需求的时候，只要稍微涉及点和技术相关的话题，立马怼我一句“不要给我讲技术，我听不懂。”——我TM又没有叫你写程序，只是我觉得这样不好实现的原因给你说一下，你就不耐烦了？那我还懒得讲了呢。</p><p>有一次我在钉钉上写了200多字的话想发过去给她，但还是忍住了，算了，忍忍就过去了。</p><h2 id="困惑二-为什么要加班？"><a href="#困惑二-为什么要加班？" class="headerlink" title="困惑二_为什么要加班？"></a>困惑二_为什么要加班？</h2><p>一个词——<strong>内卷</strong>。</p><p>现在的行业，讲究的就是快，先不看质量如何，你能立马回复，立马拿出个样品，你就比别人领先一步，以至于明明需要一个月做完的东西，也许加加班3天就搞定，我不知道这是我国程序员的福报还是悲哀呢？</p><p>记得呼兰在脱口秀中曾说过这样一件事：当他刚回国做管理的时候，有个需求他评估了以下觉得至少需要2周才能做完，于是问底下的人多久做完，他们说3天就可以做出来，呼兰啊了一声，底下的人以为时间太长了，于是咬咬牙说加班两天内可以搞定。</p><p>而从公司内部竞争来看，我发现加班多的部门，越容易得到领导层的重视。</p><h2 id="困惑三-为什么职场上很少像上学那会能遇到可以喝酒吃肉的朋友？"><a href="#困惑三-为什么职场上很少像上学那会能遇到可以喝酒吃肉的朋友？" class="headerlink" title="困惑三_为什么职场上很少像上学那会能遇到可以喝酒吃肉的朋友？"></a>困惑三_为什么职场上很少像上学那会能遇到可以喝酒吃肉的朋友？</h2><p>步入社会前，我在象牙塔里听到最多的提醒就是<strong>千万不要把同事当朋友。</strong></p><p>为什么这么说呢，我通过以下一个例子来说明。</p><p>部门内原先有个硕士毕业做C++的同事S，与一位本科毕业的同事H同毕业于一所大学，本来我以为是校友沟通会多一些吧，看他们平时也有说有笑的，然而在同事S离职后，同事H没事就在我跟前抱怨同事S的代码烂的一批，我说至于吗，这项目代码又不是他S一个人写的，同事H摇摇头，还是一直在贬低和骂同事S，还咒骂同事S说就他这水平，即时跳槽去了大厂照样混不好。</p><p>我心想呵呵，也许这就是所谓的酸，见不得别人的好，首先别人混的好不好和你没关系吧，其次人家跳槽去了大厂，薪资比你高出至少一个级别，接触的人脉和技术与你这井底之蛙般的人也不同。</p><p>另外，对于同事H这种人，我只想说<strong>说人是非者，必是是非人</strong>。因为同事H不光在我跟前骂过同事S，还骂过2019年一位已经离职的老实同事J，不停的骂不停的损，有意思吗？而通过观察同事H吐槽人的逻辑，我也预测到在我离职的时候他也会这样说我，果不其然，我在同事Y那得到的验证。</p><p>所以说，在职场上，就只管做好自己的事，不传谣，不信谣，能遇到一个可以当做朋友的同事，那是我的运气，如果没有遇到，那我也没有损失，并将继续坚持走我的职场路。</p><h4 id="很多事情我无法改变，但可以选择离开"><a href="#很多事情我无法改变，但可以选择离开" class="headerlink" title="很多事情我无法改变，但可以选择离开"></a>很多事情我无法改变，但可以选择离开</h4><p>这句话最先实在<a href="https://github.com/623637646/996.Leave" target="_blank" rel="noopener">gitub-996.Leave</a>上看到的，当时全国爆发了996icu，于是一位在新加坡工作的程序员写下了这些话，讲真，我是羡慕了，你呢？</p><h2 id="无法改变之国人加班的魔咒"><a href="#无法改变之国人加班的魔咒" class="headerlink" title="无法改变之国人加班的魔咒"></a>无法改变之国人加班的魔咒</h2><p>以前也许996加班是互联网程序员的福报，而现在996几乎是各行各业的福报。</p><p>我仍记得，我刚毕业的时候，来成都求职，我去面试一家游戏小公司的C#客户端岗，然后HR就说我们这公司目前在业务上升期，你进来可能要9107工作制，薪资给你2k，你看能接受吗？我当时还不清楚9107是什么概念，于是我说考虑下，结果那家公司就没下文了。</p><p>为什么我要说这件事，因为我真的发现，<strong>我们的时间根本不值钱！！！</strong></p><p>你想找一个朝九晚五的工作，对不起，没有，996爱干不干，外面还有好多待业的；</p><p>你想找一个996但工资开的和华为一样高的工作，对不起，没有，5k爱干不干；</p><p>你想找一个996工资没有华为高但有加班费的工作，对不起，没有，我有让你加班吗，是你自愿的；</p><p>你想找一个996工资没有华为高没有加班费但压力不是很大的，对不起，没有，算了你的问题太多了我还是找个实习生来吧…</p><p>社会上的现状，让我的世界观一点点的崩塌，我开始迷茫，既然无法改变，我只能选择离开，找个地方静静思考未来合适的出路。</p><h2 id="无法改变之同事的白眼和乱糟糟的管理"><a href="#无法改变之同事的白眼和乱糟糟的管理" class="headerlink" title="无法改变之同事的白眼和乱糟糟的管理"></a>无法改变之同事的白眼和乱糟糟的管理</h2><p>刚入公司的导师Y曾对我说过两遍一模一样的话：有些人的尊重不是发自内心。</p><p>是的，就像我对某些同事的尊重就不是发自内心的，只是因为我接你的项目时暂时表现出耐心和虚心求教的面孔，可是，当你删我微信，删我gitlab账号权限的时候，这层窗户纸就彻底被捅破了。</p><p>接受同事D写的代码，我不得不说，我看不下去，但不得不看，因为维护这份代码是我可以继续在这家公司待下去的充分必要条件。可是，既然是交接，为什么交接的时候你写的bug叫我来改，我TM怎么晓得整个流程是什么样的…好，领导说叫我改，那我改好又出bug了，最后交还给同事D，结果第二天就把我gitlab权限删了，微信上问他怎么回事，好家伙，发的消息被拒收了，因为我不是他好友，呵呵，好吧，于是我舔着脸问同事Y如何联系到同事D，我当时心想，如果同事D敢当面承认删我号是因为项目的原因，我敬你是条汉子，敢作敢当，可是同事D最后说是他删错了，搞不搞笑哦，所以从此，同事D在我眼里和小人没什么两样，我唯一能做的就是远离，离的越远越好，最好从此不再有交集。</p><h2 id="无法改变之领导眼中的标签"><a href="#无法改变之领导眼中的标签" class="headerlink" title="无法改变之领导眼中的标签"></a>无法改变之领导眼中的标签</h2><p>我在这个部门的领导其实是个很务实的人，从来不给我画大饼，一向都是实事求是，具体问题具体分析，曾经有次还拍拍我的肩部，说了句小伙子好好干，不需要有太大压力，我当时真的很感动，因为从毕业到现在，在职场上还从没有人给过我这样的鼓励。</p><p>然而，人的观念就像二维坐标系上的y一样，随着小道消息x的不断变多，这条曲线的斜率不断变大，所以当我被打上负面的标签时，就是这家公司做到头的时候了。</p><p>比如在接手同事D的项目后，bug变得很多，一时解决不过来，而这时候同事D还在冷嘲热讽，一会说我能力不行，一会说我眼睛有问题，我当时真想一个嘴巴子扇过去，再补上一个回旋踢，将同事D的嘴巴打歪，但我还是忍住了。也许这就是社会职场给我上的第一课。</p><p>就这样，经历的各种bug和背后小报告，领导对我的看法变成了负面，而我也在今年为部门做了巨大的牺牲，没有了年终奖，而这给我造成的直接后果就是，我对这个部门的彻底失望和死心，后面的规划，就不再以部门利益为第一位，而是自己寻找新的出路和转机。</p><h2 id="无法改变之研发卑微的地位"><a href="#无法改变之研发卑微的地位" class="headerlink" title="无法改变之研发卑微的地位"></a>无法改变之研发卑微的地位</h2><p>有次在电梯里听到公司的销售聊起方案书，只要采纳就能奖励18w以上，我心动了，突然想想我在这干研发，虽然表面上看着很光鲜，搞技术，但讲真地位还不如销售那些人。没加班费没福利没节日礼物，有时一个美好的周末就因为一句随口的加班被毁了，不好意思，这样卑微的研发，我不稀罕。</p><p>是的，我有段时间开始琢磨，写代码真的是我所热爱的吗？？？</p><p>我仍记得，我高一第一次接触写程序，那种难以描述的喜悦之情，大二的时候和队友在机房里AC一道道算法题的快感…可是全被现在这该死的制度给磨没了。</p><p>不过如果回到最初的原点，我发现变的不是我，是这个环境，曾经的我想法很纯粹，喜欢挑战逻辑性强的题目，如果解答不出来，我就会上论坛讨论，上博客吸收别人的想法，寻找一系列和这种题相关的蛛丝马迹，直到把它搞定，并在此过程中意外结识了很多竞赛大佬和读硕士读博士的学长。</p><p>我想，这也许就是作为技术人简单又纯粹的快乐吧，所以，既然不喜欢且无法改变，那就只能默默选择离开。</p><h2 id="一些需要澄清的真相"><a href="#一些需要澄清的真相" class="headerlink" title="一些需要澄清的真相"></a>一些需要澄清的真相</h2><p>两年中多多少少发生了一些让领导或同事不解的事情，虽然已经没有澄清的必要，但我还是要借此机会说明以下，未来也许有某个熟悉的人访问进来，突然大悟。</p><h3 id="真相一-2019年农历七夕让加班但我关手机的真实原因"><a href="#真相一-2019年农历七夕让加班但我关手机的真实原因" class="headerlink" title="真相一_2019年农历七夕让加班但我关手机的真实原因"></a>真相一_2019年农历七夕让加班但我关手机的真实原因</h3><p>2019年七夕这一天晚上，本来应该在公司加班，因为明天要演示，但我提前到家，然后手机关机，因此Dong总和XY姐对我很不满，其实真实情况是这样：2019年七夕，我早晨在元祖食品订好蛋糕，准备在七夕下班给女友一个小惊喜，结果我骑共享单车刚到家就接到产品经理W的电话，告知我要过去加班，因为这个人经常说话不算数，且小题大做，所以我理所应当的挂了电话就把她拉黑，也就没有去加班的意愿，然而如果其他人打完电话我会立马过去，也算是我感情用事吧，哈哈。</p><h3 id="真相二-2019年端午节三天没有去公司加班的真实原因"><a href="#真相二-2019年端午节三天没有去公司加班的真实原因" class="headerlink" title="真相二_2019年端午节三天没有去公司加班的真实原因"></a>真相二_2019年端午节三天没有去公司加班的真实原因</h3><p>2019年端午节前一天，同事D说有个紧急需求，给产品W说明情况，推迟到下周发版，同事D叫我周末来公司，我心里呵呵一笑，你有什么权力叫我去加班，但心里这么想，表面上还得装作言听计从的样子，而正好端午节那天我女朋友从新疆乌鲁木齐飞到成都来了，所以我就把我周末的时间全用在和女朋友相处和逛街了，对于工作和爱情，我果断选择后者。</p><h3 id="真相三-2020年清明节三天叫加班赶需求但我没动的真实原因"><a href="#真相三-2020年清明节三天叫加班赶需求但我没动的真实原因" class="headerlink" title="真相三_2020年清明节三天叫加班赶需求但我没动的真实原因"></a>真相三_2020年清明节三天叫加班赶需求但我没动的真实原因</h3><p>2020年清明节，又TM叫我加班，而之前我已经连续加班半个月了，所以这次我果断选择反抗，况且2019年年终奖都没得，我凭什么这么卖命干活？？？于是我等要放假的那个下午，背上包赶紧打卡离开公司，当时本想着清明来了就提离职，但这时候我女朋友告诉我它不想工作了，准备裸辞，中间辞职的原因忽略，所以我当时考虑到开销，决定我先不辞职，等她找到新工作了，我再辞职。就这样，从3月耗到了11月，她终于转正了，而我也受够领导的指指点点了，终于，一切尘埃落定。</p><h3 id="真相四-为什么你会觉得我的逻辑性思维差"><a href="#真相四-为什么你会觉得我的逻辑性思维差" class="headerlink" title="真相四_为什么你会觉得我的逻辑性思维差"></a>真相四_为什么你会觉得我的逻辑性思维差</h3><p>很直接的原因，因为我不想动脑了，有些东西既然已经习惯了复制粘贴，那何必动脑呢。其次，我在想一个问题的时候，最讨厌最讨厌最讨厌旁边的人对我指手画脚，有什么急事不能等我想完理清脉络了再问？？？就算我写的程序再糟糕，是不是得先把问题解决了，你TM一直在我耳边唠叨说架构设计不对，优化度不高，拜托，你的工作经验是我的几十倍，我要是有你的三分之一，我还会在这里呆？</p><p>之前离职的同事S也跟我说过，最烦别人在我旁边一直说，如果你这么能，那这些东西都交给你来做岂不是省心多了？？？</p><h2 id="讨厌的同事"><a href="#讨厌的同事" class="headerlink" title="讨厌的同事"></a>讨厌的同事</h2><p>在此记录我在这个企业遇到的一些讨厌的人，以此也当做标记，看看十年后我是否会变成这样的人。</p><h3 id="一位天天吐痰的死鱼眼"><a href="#一位天天吐痰的死鱼眼" class="headerlink" title="一位天天吐痰的死鱼眼"></a>一位天天吐痰的死鱼眼</h3><p>不知道为何，我总是会和他在茶水间遇到，他瞪着一双死鱼眼，像做贼似的矗立在洗手池那，等我打完开水后，他就开始各种咳嗽，各种打喷嚏，各种吐痰吐进洗手池内。麻烦你多挪几步路跑厕所去吐可以吗，这边好多人都在这洗手洗饭盒，你万一吐在外面….额，画面好恶心。</p><h3 id="大声吼叫的驼背男"><a href="#大声吼叫的驼背男" class="headerlink" title="大声吼叫的驼背男"></a>大声吼叫的驼背男</h3><p>总是拖着背，而这是次要的，我非常讨厌他是因为在午休的时候，嗓门故意提高，1-2次也就算了，经常这样，仿佛生怕我们不知道你在谈几个亿的大单子似的。</p><h3 id="奋斗逼们"><a href="#奋斗逼们" class="headerlink" title="奋斗逼们"></a>奋斗逼们</h3><p>这个公司有个很神奇的部门，经常加班，带头的领导常在群里打鸡血，仿佛每个人的手上都握着这个公司的命脉。但不得不说，因为加班，它一跃变成公司最赚钱的部门，但它准备对全公司实行995工作制，那我就不愿意了。</p><p>记得有个成信大的学弟说，他有好几个朋友被分到这个部门，以至于经常开会开到9-10点，好吧，既然无法改变这现状，那我果断选择离开。</p><h2 id="在这家企业的收获"><a href="#在这家企业的收获" class="headerlink" title="在这家企业的收获"></a>在这家企业的收获</h2><ul><li>最大的收获就是项目经验和工作经验得到了积累，知道什么是自己不想要的；</li><li>心态上的变化，对bug不再感到害怕，而是抽丝剥茧顺藤摸瓜找到出现bug的原因，举一反三，做好总结；</li><li>沟通上的变化，不再做老好人，不合适的需求必须砍掉，态度强硬；</li><li>结识了几位不错的同事&amp;朋友，后期会继续保持联系；</li><li>住了快23个月的公司提供的廉价青年公寓，给我省了很大的一笔租房开销；</li><li>存款突破了六位数，在未来至少一年内就算待业中也不会为生活费发愁；</li><li>潜力激发，曾经一学期都没有学懂的<code>shell</code>脚本，我在精神力高度集中的情况下，边吸收边实践边总结的循环过程中最多6h掌握；</li><li>遇到的第一位技术上的引路人Y，传授于我技术和生活上的宝贵经验。</li></ul><h2 id="结束，也是新的开始"><a href="#结束，也是新的开始" class="headerlink" title="结束，也是新的开始"></a>结束，也是新的开始</h2><p>离开华栖云，我并不后悔，因为我给自己定的毕业第一阶段的职场目标，已经提前一年实现了，后面的路，我想做一些自己喜欢的事情，去看一些一直渴望的风景，早点回家和父母聊聊天，未来，我还是希望能去一些有核心竞争力和完善管理制度的企业发展。</p><p>GOOD LUCK!</p><p><img src="/2020/12/10/leave-china-sichuan-chengdu-chinamcloud/lian.jpg" alt></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --&gt;&lt;p&gt;&lt;strong&gt;很多事情我无法改变，但可以选择离开。 ————题记&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;成都华栖云是我从成都飞鱼离职后入职的一家传统互联网型公司，
      
    
    </summary>
    
    
      <category term="离职感悟" scheme="https://octopuslian.github.io/categories/%E7%A6%BB%E8%81%8C%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="离职" scheme="https://octopuslian.github.io/tags/%E7%A6%BB%E8%81%8C/"/>
    
      <category term="离开" scheme="https://octopuslian.github.io/tags/%E7%A6%BB%E5%BC%80/"/>
    
      <category term="chinamcloud" scheme="https://octopuslian.github.io/tags/chinamcloud/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 1137-n-th-tribonacci-number | 第 N 个泰波那契数</title>
    <link href="https://octopuslian.github.io/2020/12/05/leetcode-1137-n-th-tribonacci-number/"/>
    <id>https://octopuslian.github.io/2020/12/05/leetcode-1137-n-th-tribonacci-number/</id>
    <published>2020-12-05T13:36:40.000Z</published>
    <updated>2020-12-05T13:48:45.054Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/n-th-tribonacci-number/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/n-th-tribonacci-number/</a></p><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tribonacci</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp,x,y,z := <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">3</span>;i &lt;= n;i++ &#123;</span><br><span class="line">        tmp = x + y + z</span><br><span class="line">        x = y</span><br><span class="line">        y = z</span><br><span class="line">        z = tmp</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h2&gt;&lt;p&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="LeetCode题解" scheme="https://octopuslian.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
      <category term="递归" scheme="https://octopuslian.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="斐波那契" scheme="https://octopuslian.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 111-minimum-depth-of-binary-tree | 二叉树的最小深度</title>
    <link href="https://octopuslian.github.io/2020/12/05/leetcode-111-minimum-depth-of-binary-tree/"/>
    <id>https://octopuslian.github.io/2020/12/05/leetcode-111-minimum-depth-of-binary-tree/</id>
    <published>2020-12-05T13:27:04.000Z</published>
    <updated>2020-12-05T13:34:15.992Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a></p><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    leftDepth := minDepth(root.Left)</span><br><span class="line">    rightDepth := minDepth(root.Right)</span><br><span class="line">    <span class="keyword">if</span> root.Left == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + rightDepth</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + leftDepth</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + min(leftDepth,rightDepth)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a,b <span class="keyword">int</span>)</span><span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h2&gt;&lt;p&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="LeetCode题解" scheme="https://octopuslian.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
      <category term="二叉树" scheme="https://octopuslian.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 141-linked-list-cycle | 环形链表</title>
    <link href="https://octopuslian.github.io/2020/12/04/leetcode-141-linked-list-cycle/"/>
    <id>https://octopuslian.github.io/2020/12/04/leetcode-141-linked-list-cycle/</id>
    <published>2020-12-04T10:47:07.000Z</published>
    <updated>2020-12-04T11:03:15.287Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle/</a></p><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><p>该题是面试常考题型，以前好友面字节游戏引擎岗的时候专门考过。</p><h3 id="快慢指针Golang"><a href="#快慢指针Golang" class="headerlink" title="快慢指针Golang"></a>快慢指针Golang</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">(head *ListNode)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    slow := head  <span class="comment">//慢指针</span></span><br><span class="line">    fast := head.Next  <span class="comment">//快指针</span></span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        <span class="keyword">if</span> slow == fast &#123;</span><br><span class="line">            <span class="comment">//一块一慢，如果两个指针指向同一个值，说明链表有环</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h2&gt;&lt;p&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="LeetCode题解" scheme="https://octopuslian.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
      <category term="链表" scheme="https://octopuslian.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>极客时间_7天算法体验营_Day5-算法体验营-结课考试题</title>
    <link href="https://octopuslian.github.io/2020/12/03/geekbang-live-a-week-algo-training-camp-5-test/"/>
    <id>https://octopuslian.github.io/2020/12/03/geekbang-live-a-week-algo-training-camp-5-test/</id>
    <published>2020-12-03T03:12:05.000Z</published>
    <updated>2020-12-03T09:28:52.606Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --><h2 id="数组相关"><a href="#数组相关" class="headerlink" title="数组相关"></a>数组相关</h2><ul><li>1,数组作为函数参数传递的是（A）</li></ul><p>A. 数组的首地址</p><p>B. 数组元素个数</p><p>C. 数组中各元素值</p><p>D. 数组的大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">【答案解析】：考察的是数组传递给函数作为参数的原理。</span><br><span class="line"></span><br><span class="line">传递方式如下三种：每种方式都会告诉编译器要接收一个指针，及数组的地址（首元素地址）</span><br><span class="line">void myFunction(int *param)</span><br><span class="line">&#123;</span><br><span class="line">    //形式参数是一个指针</span><br><span class="line">&#125;</span><br><span class="line">void myFunction(int param[10])</span><br><span class="line">&#123;</span><br><span class="line">    //形式参数是一个已定义大小的数组</span><br><span class="line">&#125;</span><br><span class="line">void myFunction(int param[])</span><br><span class="line">&#123;</span><br><span class="line">    //形式参数是一个未定义大小的数组</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2,在一个长度为n的顺序表中删除第i个元素，要移动<strong>___</strong>个元素。如果要在第i个元素前插入一个元素，要后移<strong>_____</strong>个元素。 （A）</li></ul><p>A. n-i，n-i+1</p><p>B. n-i+1，n-i</p><p>C. n-i，n-i</p><p>D. n-i+1，n-i+1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【答案解析】：删除第i个元素，要移动后面n-i个元素</span><br><span class="line"></span><br><span class="line">在第i个元素之前插入，要移动包括i在内的n-i+1个元素</span><br></pre></td></tr></table></figure><h2 id="链表相关"><a href="#链表相关" class="headerlink" title="链表相关"></a>链表相关</h2><p>3,带头结点head的单向循环链表L为空的判断条件是？（C）</p><p>A. head==NULL</p><p>B. head-&gt;next==NULL</p><p>C. head-&gt;next==head</p><p>D. head!=NULL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【答案解析】：基础概念，单向循环链表且带有头节点，判断为空，即循环链表只有头节点，自己指向自己，head-&gt;next = head，因此选C。</span><br></pre></td></tr></table></figure><h2 id="栈、队列相关"><a href="#栈、队列相关" class="headerlink" title="栈、队列相关"></a>栈、队列相关</h2><p>4,队列和栈有什么区别？(A)</p><p>A. 队列先进先出，栈后进先出</p><p>B. 队列和栈都是先进先出</p><p>C. 队列和栈都是后进先出</p><p>D. 栈先进先出，队列后进先出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">答案解析】：相同点：从&quot;数据结构&quot;的角度看，它们都是线性结构，即数据元素之间的关系相同。</span><br><span class="line"></span><br><span class="line">不同点：栈（Stack）是限定只能在表的一端进行插入和删除操作的线性表。 队列（Queue）是限定只能在表的一端进行插入和在另一端进行删除操作的线性表。它们是完全不同的数据类型。除了它们各自的基本操作集不同外，主要区别是对插入和删除操作的&quot;限定&quot;。</span><br><span class="line"></span><br><span class="line">栈必须按&quot;后进先出&quot;的规则进行操作：比如说，小学老师批改学生的作业，如果不打乱作业本的顺序的话，那么老师批改的第一份作业一定是最后那名同学交的那份作业，如果把所有作业本看作是一个栈中的元素，那么最后一个同学交的作业本就是栈顶元素，而第一个同学交的，也就是最低端的作业本，就是栈底元素，这就是对栈的读取规则。</span><br><span class="line"></span><br><span class="line">而队列必须按&quot;先进先出&quot;的规则进行操作：打个比方，一些人去银行办理业务，一定是先去排队的最先得到服务，当然他也是第一个走出银行的（假设这些人都在一个窗口排队）。如果把所有这些等候服务的人看作是队的元素，第一个人就是对头元素，相应的，最后一个人就是队尾元素。这是队的读取规则。</span><br></pre></td></tr></table></figure><h2 id="二叉树相关"><a href="#二叉树相关" class="headerlink" title="二叉树相关"></a>二叉树相关</h2><p>5,已知某二叉树的前序为（1-2-3-4-5-6-7-8-9），中序为（2-3-1-6-7-8-5-9-4），则它的后续为？ （A）</p><p>A. 3-2-8-7-6-9-5-4-1</p><p>B. 1-2-6-5-4-3-8-7-9</p><p>C. 5-4-2-1-3-7-6-9-8</p><p>D. 2-3-5-4-6-7-9-1-8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【答案解析】：根据前序遍历可以确定根节点为1，再根据中序遍历可以确定A的左侧为左子树23，其余为右子树，再根据前序遍历得到左子树的根节点为2，右子树的根节点为4，然后递归下去就能恢复二叉树，然后后续遍历得到结果328769541。</span><br></pre></td></tr></table></figure><p>6,在任意一棵二叉树的前序序列和后序序列中，各叶子之间的相对次序关系（ B ）</p><p>A. 不一定相同</p><p>B. 都相同</p><p>C. 都不相同</p><p>D. 互为逆序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【答案解析】：</span><br><span class="line"></span><br><span class="line">前序序列：根结点 --&gt; 左子树 --&gt; 右子树    </span><br><span class="line"></span><br><span class="line">后序序列：左子树 --&gt; 右子树 --&gt; 根结点   </span><br><span class="line"></span><br><span class="line">根据题目结合前序、后续的遍历顺序规则，如下图：</span><br></pre></td></tr></table></figure><p><img src="/2020/12/03/geekbang-live-a-week-algo-training-camp-5-test/tree.png" alt></p><ul><li><p>第一个二叉树叶子节点D、C 先序和后序顺序均为先D后C</p></li><li><p>第二个二叉树叶子节点B、D 先序和后序属性均为先B后D</p></li></ul><p><strong>结论</strong>：叶子节点位于左右两个分支上，先序和后序的遍历属性均是左子树在右子树之前（相对次序一定相同），和二叉树的样式无关。</p><h2 id="递归相关"><a href="#递归相关" class="headerlink" title="递归相关"></a>递归相关</h2><ul><li>7,采用递归方式对顺序表进行快速排序，下列关于递归次数的叙述中，正确的是（D）</li></ul><p>A. 递归次数与初始数据的排列次序无关</p><p>B. 每次划分后，先处理较长的分区可以减少递归次数</p><p>C. 每次划分后，先处理较短的分区可以减少递归次数</p><p>D. 递归次数与每次划分后得到的分区处理顺序无关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【答案解析】递归次数，取决于递归树，而递归树取决于轴枢的选择。树越平衡，递归次数越少。</span><br><span class="line"></span><br><span class="line">而对分区的长短处理顺序，影响的是递归时对栈的使用内存，而不是递归次数</span><br></pre></td></tr></table></figure><ul><li>8,对递归程序的优化的一般的手段是？（A）</li></ul><p>A. 尾递归优化</p><p>B. 循环优化</p><p>C. 堆栈优化</p><p>D. 停止值优化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">【答案解析】：尾递归是指，在函数返回的时候，调用自身本身，并且return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。 尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。</span><br><span class="line"></span><br><span class="line">以斐波那契数列为例子，普通的递归版本如下：</span><br><span class="line"></span><br><span class="line">int fab(int n)&#123; </span><br><span class="line">    if(n&lt;3) </span><br><span class="line">        return 1; </span><br><span class="line">    else </span><br><span class="line">        return fab(n-1)+fab(n-2);   </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">具有&quot;线性迭代过程&quot;特性的递归---尾递归过程</span><br><span class="line"></span><br><span class="line">int fab(int n,int b1=1,int b2=1,int c=3)&#123; </span><br><span class="line">    if(n&lt;3) </span><br><span class="line">        return 1; </span><br><span class="line">    else &#123; </span><br><span class="line">        if(n==c) </span><br><span class="line">             return b1+b2; </span><br><span class="line">        else </span><br><span class="line">             return fab1(n,b2,b1+b2,c+1); </span><br><span class="line">    &#125; 以fab(4)为例子 </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">普通递归fab(4)=fab(3)+fab(2)=fab(2)+fab(1)+fab(2)=3  6次调用 </span><br><span class="line"></span><br><span class="line">尾递归fab(4,1,1,3)=fab(4,1,2,4)=1+2=3                2次调用</span><br></pre></td></tr></table></figure><h2 id="分治相关"><a href="#分治相关" class="headerlink" title="分治相关"></a>分治相关</h2><p>9,在快速排序，归并排序，插入排序，选择排序，冒泡排序中，使用到分治思想的算法个数有几个（B）</p><p>A. 1</p><p>B. 2</p><p>C. 3</p><p>D. 4</p><p>【答案解析】：分治思想是很多高效算法的基础，如归并排序、快速排序、傅立叶变换（快速傅立叶变换）。</p><h2 id="DFS相关"><a href="#DFS相关" class="headerlink" title="DFS相关"></a>DFS相关</h2><ul><li>10,图的Depth-First Search(DFS)遍历思想实际上是二叉树（A）遍历方法的推广。</li></ul><p>A. 先序</p><p>B. 中序</p><p>C. 后序</p><p>D. 层序</p><p>【答案解析】：深度先序，广度层次。</p><h2 id="BFS相关"><a href="#BFS相关" class="headerlink" title="BFS相关"></a>BFS相关</h2><ul><li>11,图的BFS生成树的树高比DFS生成树的树高(A)</li></ul><p>A. 小或相等</p><p>B. 小</p><p>C. 大或相等</p><p>D. 大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【答案解析】：BFS是广度优先遍历，DFS是深度优先遍历。</span><br><span class="line"></span><br><span class="line">对于一些特殊的图，比如只有一个顶点的图，其BFS生成树的树高和DFS生成树的树高相等。 一般的图，根据图的BFS生成树和DFS树的算法思想，BFS生成树的树高比DFS生成树的树高小</span><br></pre></td></tr></table></figure><h2 id="排序相关"><a href="#排序相关" class="headerlink" title="排序相关"></a>排序相关</h2><ul><li>12,假设你只有100M的内存，需要对1G的数据进行排序，最合适的算法是？（A）</li></ul><p>A. 归并排序</p><p>B. 插入排序</p><p>C. 快速排序</p><p>D. 冒泡排序</p><p>【答案解析】：归并排序的典型例子，很简单的题目，应该做对。</p><ul><li>13,一个数据表有51233个元素，如果仅要求找出其中最大的12个元素，你觉得采用下列哪种算法比较节省时间？（A）</li></ul><p>A. 堆排序</p><p>B. 希尔排序</p><p>C. 快速排序</p><p>D. 直接选择排序</p><p>【答案解析】：本题比较常见排序算法，TopK问题，堆排序，因此选A</p><h2 id="堆、时间复杂度相关"><a href="#堆、时间复杂度相关" class="headerlink" title="堆、时间复杂度相关"></a>堆、时间复杂度相关</h2><ul><li>14,从n个数里面找最大的两个数理论上最少需要比较多少次？（C）</li></ul><p>A. 2logn</p><p>B. 2logn -1</p><p>C. n+ logn -2</p><p>D. 2n-3</p><p>【答案解析】：在n个数中找到最大的两个数的最少比较次数，可以考虑堆排序，首先建堆是时间复杂度为O(n)或比较n-1次，找到最大的一个，然后调整堆，找到次大元素，比较logn-1，因此选C。</p><h2 id="哈希相关"><a href="#哈希相关" class="headerlink" title="哈希相关"></a>哈希相关</h2><ul><li>15,下面关于哈希查找的说法正确的是？（C）</li></ul><p>A. 哈希函数构造的越复杂越好，因为这样随机性好，冲突小</p><p>B. 除留余数法是所有哈希函数中最好的</p><p>C. 不存在特别好与坏的哈希函数，要视情况而定</p><p>D. 若需在哈希表中删去一个元素，不管用任何方法解决冲突都只要简单地将该元素删去即可</p><p>【答案解析】：考察哈希，关于哈希有xxx的构造方法，具体哈希算法的好坏需要看情况而定，没有绝对的好与坏。A. 对于数据结构中的哈希函数有两个特点：简单，均匀性。所谓简单就是可以很快的产生一个较好的hash值，均匀性是指所有的数据可以均匀的映射到各个hash值上，避免产生大部分数据映射到少数的hash值上。B.不同的hash函数有不同的适应场景，各有优缺点。主要的方法有，直接定址法，数字分析法，平方取中法，折叠法，随机数法，除留余数法。D.对于空域法，还需要把冲突记录去掉。</p><h2 id="二分查找相关"><a href="#二分查找相关" class="headerlink" title="二分查找相关"></a>二分查找相关</h2><ul><li>16,若有序表的关键字序列为（b,c,d,e,f,g,q,r,s,t)，则在二分查找关键字b的过程中，先后进行比较的关键字依次是？（A）</li></ul><p>A. f,c,b</p><p>B. f,d,b</p><p>C. g,c,d</p><p>D. g,d,b</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【答案解析】：考察二分查找，对于(b,c,d,e,f,g,q,r,s,t)</span><br><span class="line"></span><br><span class="line">第一次查找，left = 0, right = 9, mid = 4, 关键字是f, f != b &amp;&amp; f &gt; b</span><br><span class="line"></span><br><span class="line">第二次查找，left = 0, right = 3, mid = 1, 关键字是c, c != b &amp;&amp; c &gt; b</span><br><span class="line"></span><br><span class="line">第三次查找，left = 0, right = 0, mid = 0, 关键字是b, b == b 查找到</span><br><span class="line"></span><br><span class="line">因此是关键字依次是(f,c,b)</span><br></pre></td></tr></table></figure><h2 id="时间复杂度、排序相关"><a href="#时间复杂度、排序相关" class="headerlink" title="时间复杂度、排序相关"></a>时间复杂度、排序相关</h2><ul><li>17,在最坏的情况下，下列排序方法中时间复杂度最小的是？（D）</li></ul><p>A. 冒泡排序</p><p>B. 快速排序</p><p>C. 插入排序</p><p>D. 堆排序</p><p>【答案解析】：常见排序算法最坏时间复杂度比较，其中冒泡排序和插入排序O(n^2)，快速排序最坏情况为O(n^2)，只有堆排序比较稳定复杂度为O(nlogn)。</p><h2 id="线性表，二叉平衡树，哈希，高级算法相关"><a href="#线性表，二叉平衡树，哈希，高级算法相关" class="headerlink" title="线性表，二叉平衡树，哈希，高级算法相关"></a>线性表，二叉平衡树，哈希，高级算法相关</h2><ul><li>18,下列关于线性表，二叉平衡树，哈希表存储数据的优劣描述错误的是？ （D）</li></ul><p>A. 哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；</p><p>B. 线性表实现相对比较简单</p><p>C. 平衡二叉树的各项操作的时间复杂度为O（logn）</p><p>D. 平衡二叉树的插入节点比较快</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【答案解析】：哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。 </span><br><span class="line"></span><br><span class="line">在平衡二叉树中插入结点要随时保证插入后整棵二叉树是平衡的，所以可能需要通过一次或多次树旋转来重新平衡这个树</span><br></pre></td></tr></table></figure><h2 id="动态规划相关"><a href="#动态规划相关" class="headerlink" title="动态规划相关"></a>动态规划相关</h2><ul><li>19,下面关于动态规划说法正确的是 （A）</li></ul><p>A. 他是利用子结构，进行自底而上的算法设计</p><p>B. 他需要后来多次计算的问题进行缓存，减少重复子问题的计算</p><p>C. 他所求问题的整体最优解可以通过一系列局部最优的选择</p><p>D. 他将分解后的子问题看成相互独立的.</p><p>【答案解析】：</p><ul><li><p>动态规划利用最优子结构，自底向上从子问题的最优解逐步构成整个问题的最优解</p></li><li><p>用空间换时间只是一种技巧，不是动态规划的本质</p></li><li><p>贪心选择是指所求问题的整体最优解可以通过一系列局部最优的选择,即贪心选择来达到。</p></li><li><p>与分治法不同的是，适合于用动态规划法求解的问题，经分解得到的子问题往往不是互相独立的，它们可能共享更小的子问题，被称为重叠子问题。</p></li></ul><h2 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h2><ul><li>20,字符串 <a href="http://www.qq.com" target="_blank" rel="noopener">www.qq.com</a> 所有非空子串（两个子串如果内容相同则只算一个）个数是（D）</li></ul><p>A. 1024</p><p>B. 1018</p><p>C. 55</p><p>D. 50</p><p>【答案解析】：非空子串的个数共有n(n+1)/2个，n=10即55个，由于相同子串算一个，其中w(两次）, ww, q, ., 有重复。故 55 - 5 = 50。</p><h2 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h2><ul><li>基础还是有些薄弱，后期准备再系统学习以下数据结构和算法；</li><li>不懂的一定要尽快搞清楚；</li><li>多刷题，多总结。</li></ul><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;数组相关&quot;&gt;&lt;a href=&quot;#数组相关&quot; class=&quot;headerlink&quot; title=&quot;数组相关&quot;&gt;&lt;/a&gt;数组相关&lt;/h2&gt;&lt;ul&gt;&lt;l
      
    
    </summary>
    
    
      <category term="算法学习" scheme="https://octopuslian.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="测试" scheme="https://octopuslian.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="极客时间" scheme="https://octopuslian.github.io/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>极客时间_7天算法体验营_Day4-递归的实现、特性以及思维要点</title>
    <link href="https://octopuslian.github.io/2020/12/02/geekbang-live-a-week-algo-training-camp-4-recursive/"/>
    <id>https://octopuslian.github.io/2020/12/02/geekbang-live-a-week-algo-training-camp-4-recursive/</id>
    <published>2020-12-02T15:20:58.000Z</published>
    <updated>2020-12-02T13:01:38.666Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --><h2 id="递归-Recursion"><a href="#递归-Recursion" class="headerlink" title="递归-Recursion"></a>递归-Recursion</h2><p>通过函数体来循环调用自己。</p><h3 id="Python代码模板"><a href="#Python代码模板" class="headerlink" title="Python代码模板"></a>Python代码模板</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Recursion</span><span class="params">(level,param1,param2,...)</span>:</span></span><br><span class="line">    <span class="comment">#递归终结条件</span></span><br><span class="line">    <span class="keyword">if</span> level &gt; MAX_LEVEL:</span><br><span class="line">        process_result</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#处理当前层逻辑</span></span><br><span class="line">    process(level,data...)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#下探到下一层</span></span><br><span class="line">    self.Recursion(level+<span class="number">1</span>,p1,...)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#清理当前层</span></span><br></pre></td></tr></table></figure><h3 id="Java代码模板"><a href="#Java代码模板" class="headerlink" title="Java代码模板"></a>Java代码模板</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(<span class="keyword">int</span> level,<span class="keyword">int</span> param)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//terminator</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; MAX_LEVEL) &#123;</span><br><span class="line">        <span class="comment">//process result</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//process current logic</span></span><br><span class="line">    process(level,param);</span><br><span class="line">    <span class="comment">//drill down</span></span><br><span class="line">    recur(level:level+<span class="number">1</span>,newParam);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//restore current status</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思维要点"><a href="#思维要点" class="headerlink" title="思维要点"></a>思维要点</h3><ul><li>不要人肉递归（最大误区）</li><li>找到最近最简方法，将其拆解成可重复解决的问题（重复子问题）</li><li>数学归纳法思维</li></ul><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;递归-Recursion&quot;&gt;&lt;a href=&quot;#递归-Recursion&quot; class=&quot;headerlink&quot; title=&quot;递归-Recurs
      
    
    </summary>
    
    
      <category term="算法学习" scheme="https://octopuslian.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="递归" scheme="https://octopuslian.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
      <category term="极客时间" scheme="https://octopuslian.github.io/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 104-maximum-depth-of-binary-tree | 二叉树的最大深度</title>
    <link href="https://octopuslian.github.io/2020/12/02/leetcode-104-maximum-depth-of-binary-tree/"/>
    <id>https://octopuslian.github.io/2020/12/02/leetcode-104-maximum-depth-of-binary-tree/</id>
    <published>2020-12-02T12:56:31.000Z</published>
    <updated>2020-12-02T13:01:51.814Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p><h2 id="题目解法"><a href="#题目解法" class="headerlink" title="题目解法"></a>题目解法</h2><p>此题可以用递归来解：</p><h3 id="递归Golang"><a href="#递归Golang" class="headerlink" title="递归Golang"></a>递归Golang</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        left := maxDepth(root.Left) <span class="comment">// 左子树的最大深度</span></span><br><span class="line">        right := maxDepth(root.Right) <span class="comment">// 右子树的最大深度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int</span>(math.Max(<span class="keyword">float64</span>(left), <span class="keyword">float64</span>(right)) + <span class="number">1</span>) <span class="comment">// 深度加上根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;题目链接&lt;/h2&gt;&lt;p&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="LeetCode题解" scheme="https://octopuslian.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
      <category term="二叉树" scheme="https://octopuslian.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="递归" scheme="https://octopuslian.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>极客时间_7天算法体验营_Day3-树、二叉树、二叉搜索树的实现和特性</title>
    <link href="https://octopuslian.github.io/2020/12/01/geekbang-live-a-week-algo-training-camp-3-tree-binary-tree-and-binary-search-tree/"/>
    <id>https://octopuslian.github.io/2020/12/01/geekbang-live-a-week-algo-training-camp-3-tree-binary-tree-and-binary-search-tree/</id>
    <published>2020-12-01T15:19:42.000Z</published>
    <updated>2020-12-01T13:03:03.482Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><img src="/2020/12/01/geekbang-live-a-week-algo-training-camp-3-tree-binary-tree-and-binary-search-tree/tree.png" alt></p><ul><li>Linked List就是特殊化的Tree</li><li>Tree是特殊化的Graph（因为多了个环）</li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p><img src="/2020/12/01/geekbang-live-a-week-algo-training-camp-3-tree-binary-tree-and-binary-search-tree/btree.png" alt></p><p>节点只有两个。</p><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul><li>1，前序（Pre-order）：根-左-右</li><li>2，中序（In-order）：左-根-右</li><li>3，后序（Post-order）：左-右-根</li></ul><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p><img src="/2020/12/01/geekbang-live-a-week-algo-training-camp-3-tree-binary-tree-and-binary-search-tree/bstree1.png" alt></p><p><img src="/2020/12/01/geekbang-live-a-week-algo-training-camp-3-tree-binary-tree-and-binary-search-tree/bstree2.png" alt></p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p><img src="/2020/12/01/geekbang-live-a-week-algo-training-camp-3-tree-binary-tree-and-binary-search-tree/complex.png" alt></p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ul><li>树的面试题解法一般都是递归，为什么？</li></ul><h2 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h2><p>树这个数据结构在项目中经常被使用，面试也经常被问到二叉树相关的题目，所以要熟悉它的流程，多刷题，争取掌握它！</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; title=&quot;树&quot;&gt;&lt;/a&gt;树&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2020
      
    
    </summary>
    
    
      <category term="算法学习" scheme="https://octopuslian.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="二叉树" scheme="https://octopuslian.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="极客时间" scheme="https://octopuslian.github.io/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"/>
    
      <category term="树" scheme="https://octopuslian.github.io/tags/%E6%A0%91/"/>
    
      <category term="二叉搜索树" scheme="https://octopuslian.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>leetcode binary-tree-inorder-traversal | 二叉树的中序遍历</title>
    <link href="https://octopuslian.github.io/2020/12/01/leetcode-94-binary-tree-inorder-traversal/"/>
    <id>https://octopuslian.github.io/2020/12/01/leetcode-94-binary-tree-inorder-traversal/</id>
    <published>2020-12-01T10:41:35.000Z</published>
    <updated>2020-12-01T12:44:40.850Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</a></p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        helper(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List&lt;Integer&gt; ret)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            helper(root.left, ret);</span><br><span class="line">            ret.add(root.val);</span><br><span class="line">            helper(root.right, ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;ht
      
    
    </summary>
    
    
      <category term="LeetCode题解" scheme="https://octopuslian.github.io/categories/LeetCode%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
      <category term="二叉树" scheme="https://octopuslian.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>为什么要学习算法</title>
    <link href="https://octopuslian.github.io/2020/11/30/why-learn-algorithm/"/>
    <id>https://octopuslian.github.io/2020/11/30/why-learn-algorithm/</id>
    <published>2020-11-30T15:57:53.000Z</published>
    <updated>2020-11-30T13:46:30.777Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --><p>开始这篇文章之前，我特别查了<code>learn</code>和<code>study</code>的区别，虽然两者都表示学习，但当我查了<a href="https://zhidao.baidu.com/question/176752757.html" target="_blank" rel="noopener">learn 和study有什么区别？</a>的结果后，决定用<code>learn</code>，因为我们学习算法肯定是要学有所得，而不是重视学算法的过程！</p><h2 id="引用一些大佬的话（持续更新）"><a href="#引用一些大佬的话（持续更新）" class="headerlink" title="引用一些大佬的话（持续更新）"></a>引用一些大佬的话（持续更新）</h2><h3 id="覃超"><a href="#覃超" class="headerlink" title="覃超"></a>覃超</h3><p><img src="/2020/11/30/why-learn-algorithm/qinchao.png" alt></p><h3 id="亮老师"><a href="#亮老师" class="headerlink" title="亮老师"></a>亮老师</h3><p>大家好，我是陪伴大家7天学习的算法训练营助教，大家可以叫我亮老师，我学习算法多年，在大学阶段多次代表学校参加ACM竞赛，并取得铜奖，也曾获得过蓝桥杯个人赛国二，平常喜欢研究算法知识。7天的学习过程中有问题可以随时提问。</p><p>在开始学习之前，我想结合我自身学习算法和参加竞赛的经验，以及作为助教期间的心得体会，和你一起聊一聊算法的重要性和如何高效学习算法，希望能对你的学习有所帮助。 算法为什么重要呢？</p><p>我想一千个程序员有一千种理解，首先它是面试的敲门砖，每期训练营都有很多同学通过算法训练营的学习成功的进入了大厂，在座的各位我相信不少人也是基于此考虑报名参加。其次我想用以下几点说明算法的重要性:</p><p>如果不熟悉复杂度分析，如何做容量规划？</p><p>如果不清楚B+树, 又如何能够真正理解innodb的索引，并对查询过程了如指掌？</p><p>如果不能理解hash算法帮助我们如何在O(N)时间复杂度解决两数和的问题，又怎么能有信心去理解redis的hash结构在短链接生成等各种场景下实践？</p><p>等等</p><p>其实比如mysql、redis、es等等这些开源项目中的很多核心细节，都能从leetcode算法题目中找到影子，如果我们有足够的理论知识，可以帮助我们比较快的理解，否则，将寸步难行甚至根本找不到重点。所以，我认为, 算法不仅仅是面试的敲门砖，更是理解优秀中间件，甚至有一天自己造轮子的，不可缺少的工具。</p><p>反过来讲，学习好算法知识，才能帮助更快的真正理解优秀的开源实现，才有机会将这些宝贵的资源为我所用，而不是任其牵引，即使它也许并不是一个好的实现，我们仍然没有一个评价和拒绝的能力。相反可能会在写bug，解决bug的循环中悲壮前行。</p><p>同时，这也提示我们如果觉得自己掌握了某个算法，可以回溯到相关的开源工程实践中，看看大牛们如何优化我们朴素的算法实现, 另外业界大牛又是如何做到物尽其用，有了这个过程我相信你再也不会怀疑算法的作用。所以，从今天起我们一起来学习算法，也是给自己一个向大牛们学习的机会，给自己一个真正掌控各种业务和技术要点的机会。</p><p>说完为什么学算法，接下来我们聊聊怎样学习算法。条条道路通山顶，雄鹰可以直接飞过去，但是蜗牛也可以爬过去。我自认为是蜗牛，结合我见过的几届学员学习方法给大家分享以下几点：</p><ul><li><p>第一，摆正态度，正视问题。目前我们接触到的算法虽然基本上都能在二三十行解决，这意味着它不难被跟踪甚至以为理解，当然我们可以在战略上藐视它，但是也因为如此，也更容易轻视它，觉得自己懂了，其实自己想的并不全面甚至是错误的，所以需要我们重视它，通过交流、通过集体的力量、通过反复回忆、通过挖掘相关题型、通过总结等等，最终，想全了、记深了、也理解透了;</p></li><li><p>第二，理论和实践要两条腿走路。理论部分就是老师的视频，要反复听，每个知识点要十分熟悉，不明白的地方在群里提出来；实践部分就是老师讲过的经典习题和布置的作业要落地到实践，亲自做一做，同时千万不要忘了过遍数，另外平时经常回过头看看自己的代码，也很有效；</p></li><li><p>第三，高质量的完成。开课之后，你会发现习题的数量很多，但是希望大家采用五毒神掌方法练习题目，题不在多，有精则灵，另外千万别死磕，给自己一个时间限制，好多学员“一副我最牛逼，这题目一定能拿下”从而花费大量时间，但如果你认真听老师的课程就知道这样是没有必要的；</p></li><li><p>第四，多讨论多交流多提问。这个是融会贯通的机会，可以是组员，也可以是老师或者助教，有任何问题都不放过，一定要抓好班级群，小组群这个平台，跟大家一起交流相互学习提升，每期班主任都会组织学员做社群分享，也欢迎大家到时在群里分享你的学习经验、面试经验、工作心得等等；</p></li><li><p>第五，蓦然回首那题却在 灯火阑珊处。曾经的你众里寻它千百度，所以来到这里。我坚信通过以上付出，通过7天的努力，养成刷题习惯不畏惧刷题，等到毕业以后，再来复盘这段时间的收获，一定不同往日。</p></li></ul><h2 id="我的各阶段学习算法的目的"><a href="#我的各阶段学习算法的目的" class="headerlink" title="我的各阶段学习算法的目的"></a>我的各阶段学习算法的目的</h2><ul><li>高中：没啥感觉，就是觉得有趣；</li><li>大学：赚钱，因为学院非常鼓励那些参加竞赛的学生，省一会给4000元的奖金，所以我当时参加一次算法竞赛，把我一学年的学费+住宿费+伙食费全部付清了；</li><li>职场（大学毕业五年内）：接触更牛逼的大佬&amp;更高的薪资。</li></ul><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --&gt;&lt;p&gt;开始这篇文章之前，我特别查了&lt;code&gt;learn&lt;/code&gt;和&lt;code&gt;study&lt;/code&gt;的区别，虽然两者都表示学习，但当我查了&lt;a href=
      
    
    </summary>
    
    
      <category term="算法学习" scheme="https://octopuslian.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="https://octopuslian.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>极客时间_7天算法体验营_Day2-数组、链表、跳表的基本实现和特性</title>
    <link href="https://octopuslian.github.io/2020/11/30/geekbang-live-a-week-algo-training-camp-2-array-linked-list-skip-list/"/>
    <id>https://octopuslian.github.io/2020/11/30/geekbang-live-a-week-algo-training-camp-2-array-linked-list-skip-list/</id>
    <published>2020-11-30T10:17:27.000Z</published>
    <updated>2020-11-30T13:46:53.285Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --><h2 id="数组、链表、跳表的基本实现和特性"><a href="#数组、链表、跳表的基本实现和特性" class="headerlink" title="数组、链表、跳表的基本实现和特性"></a>数组、链表、跳表的基本实现和特性</h2><h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组-Array"></a>数组-Array</h3><p>时间复杂度</p><ul><li>prepend O(1)</li><li>append O(n)</li><li>lookup O(1)</li><li>insert O(n)</li><li>delete O(n)</li></ul><h3 id="链表-Link-List"><a href="#链表-Link-List" class="headerlink" title="链表-Link-List"></a>链表-Link-List</h3><p>时间复杂度</p><ul><li>prepend O(1)</li><li>append O(1)</li><li>lookup O(n)</li><li>insert O(1)</li><li>delete O(1)</li></ul><h3 id="跳表-skip-list"><a href="#跳表-skip-list" class="headerlink" title="跳表-skip-list"></a>跳表-skip-list</h3><p><img src="/2020/11/30/geekbang-live-a-week-algo-training-camp-2-array-linked-list-skip-list/sktedian.png" alt></p><h3 id="如何给有序的链表加速"><a href="#如何给有序的链表加速" class="headerlink" title="如何给有序的链表加速"></a>如何给有序的链表加速</h3><p><strong>一维数据的加速方式——升级为二维。</strong></p><p><img src="/2020/11/30/geekbang-live-a-week-algo-training-camp-2-array-linked-list-skip-list/sk1.png" alt></p><p><img src="/2020/11/30/geekbang-live-a-week-algo-training-camp-2-array-linked-list-skip-list/sk2.png" alt></p><h3 id="跳表查询的时间复杂度分析"><a href="#跳表查询的时间复杂度分析" class="headerlink" title="跳表查询的时间复杂度分析"></a>跳表查询的时间复杂度分析</h3><p><img src="/2020/11/30/geekbang-live-a-week-algo-training-camp-2-array-linked-list-skip-list/sktime.png" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>数组、链表、跳表的原理和实现</li><li>三者的时间复杂度、空间复杂度</li><li>跳表：升维思想 + 空间换时间</li></ul><h2 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h2><p>学习了数组、链表、跳表三种数据结构的特点和时间复杂度分析，虽然项目中用的最多的还是数组，但后期如果优化的还是可以借鉴链表和跳表的设计思想。</p><h2 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h2><ul><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">26. 删除排序数组中的重复项</a></li><li><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a></li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.jianshu.com/p/b1ab4a170c3c" target="_blank" rel="noopener">简书_LRU缓存算法</a><br><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">leetcode-146. LRU 缓存机制</a><br><a href="https://www.zhihu.com/question/20202931/answer/30983057" target="_blank" rel="noopener">为啥 redis 使用跳表(skiplist)而不是使用 red-black？</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;数组、链表、跳表的基本实现和特性&quot;&gt;&lt;a href=&quot;#数组、链表、跳表的基本实现和特性&quot; class=&quot;headerlink&quot; title=&quot;数
      
    
    </summary>
    
    
      <category term="算法学习" scheme="https://octopuslian.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="数组" scheme="https://octopuslian.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="链表" scheme="https://octopuslian.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="跳表" scheme="https://octopuslian.github.io/tags/%E8%B7%B3%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>极客时间_7天算法体验营_Day1-时间复杂度和空间复杂度分析</title>
    <link href="https://octopuslian.github.io/2020/11/29/geekbang-live-a-week-algo-training-camp-1-time-space-complex-analyze/"/>
    <id>https://octopuslian.github.io/2020/11/29/geekbang-live-a-week-algo-training-camp-1-time-space-complex-analyze/</id>
    <published>2020-11-29T15:16:06.000Z</published>
    <updated>2020-11-29T11:03:12.704Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --><h2 id="常见的7种时间复杂度"><a href="#常见的7种时间复杂度" class="headerlink" title="常见的7种时间复杂度"></a>常见的7种时间复杂度</h2><ul><li>O(1)：常数复杂度；</li><li>O(log n)：对数复杂度；</li><li>O(n)：线性时间复杂度；</li><li>O(n^2)：平方；</li><li>O(n^3)：立方；</li><li>O(2^n)：指数；</li><li>O(n!)：阶乘法。</li></ul><h2 id="通过代码来分析时间复杂度-Golang"><a href="#通过代码来分析时间复杂度-Golang" class="headerlink" title="通过代码来分析时间复杂度(Golang)"></a>通过代码来分析时间复杂度(Golang)</h2><h3 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n := <span class="number">100</span></span><br><span class="line">fmt.Print(n)</span><br></pre></td></tr></table></figure><p>程序只执行1次。</p><h3 id="O-N"><a href="#O-N" class="headerlink" title="O(N)"></a>O(N)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=n;i++ &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello:"</span>,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序将<code>fmt.Println(&quot;hello&quot;)</code>执行了n次。</p><h3 id="O-N-2"><a href="#O-N-2" class="headerlink" title="O(N^2)"></a>O(N^2)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=n;i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j:=<span class="number">1</span>;j&lt;=n;j++ &#123;</span><br><span class="line">        fmt.Println(<span class="string">"hello:"</span>,i,j)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序将<code>fmt.Println(&quot;hello&quot;)</code>执行力n*n=n^2次。</p><p>拓展：如果是以下代码，时间复杂度是多少？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=n;i++ &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello:"</span>,i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">1</span>;j&lt;=n;j++ &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello:"</span>,j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为两个循环是并列关系，所以<code>fmt.Println(&quot;hello&quot;)</code>被执行了2*n次，我们忽略常数系数，所以时间复杂度是O(N)。</p><p><strong>总结：如果循环是N层嵌套关系，则时间复杂度是O(N^N)，如果循环是并列关系，则时间复杂度是O(N)。</strong></p><h3 id="O-log-n"><a href="#O-log-n" class="headerlink" title="O(log(n))"></a>O(log(n))</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;n;i=i*<span class="number">2</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hello:,"</span>i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="O-k-n"><a href="#O-k-n" class="headerlink" title="O(k^n)"></a>O(k^n)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span><span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个递归程序。</p><h2 id="时间复杂度曲线图"><a href="#时间复杂度曲线图" class="headerlink" title="时间复杂度曲线图"></a>时间复杂度曲线图</h2><p><img src="/2020/11/29/geekbang-live-a-week-algo-training-camp-1-time-space-complex-analyze/time.png" alt></p><ul><li>一定要在写程序的时候时刻考虑时间复杂度；</li><li>能够用最简单的时间复杂度和空间复杂度完成这段程序的话基本是一个顶尖职业选手的必备素养。</li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="计算1-2-3-…-n"><a href="#计算1-2-3-…-n" class="headerlink" title="计算1+2+3+…+n"></a>计算1+2+3+…+n</h3><h4 id="方法一：循环"><a href="#方法一：循环" class="headerlink" title="方法一：循环"></a>方法一：循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y = 0</span><br><span class="line">for i = 1 to n:</span><br><span class="line">    y += i</span><br></pre></td></tr></table></figure><p>时间复杂度O(n)</p><h4 id="方法二：求和公式"><a href="#方法二：求和公式" class="headerlink" title="方法二：求和公式"></a>方法二：求和公式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = n * (n + 1) / 2</span><br></pre></td></tr></table></figure><p>时间复杂度O(1)</p><h3 id="求斐波那契数列第n项和"><a href="#求斐波那契数列第n项和" class="headerlink" title="求斐波那契数列第n项和"></a>求斐波那契数列第n项和</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span><span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画出递归树分析时间复杂度：</p><p><img src="/2020/11/29/geekbang-live-a-week-algo-training-camp-1-time-space-complex-analyze/tree.png" alt></p><h2 id="主定理（重要）"><a href="#主定理（重要）" class="headerlink" title="主定理（重要）"></a>主定理（重要）</h2><p><img src="/2020/11/29/geekbang-live-a-week-algo-training-camp-1-time-space-complex-analyze/master.png" alt></p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ul><li><p>二叉树遍历-前序、中序、后序：时间复杂度是多少？</p></li><li><p>图的遍历：时间复杂度是多少？</p></li><li><p>搜索算法：DFS、BFS时间复杂度是多少？</p></li><li><p>二分查找：时间复杂度是多少？</p></li></ul><h2 id="面试四件套"><a href="#面试四件套" class="headerlink" title="面试四件套"></a>面试四件套</h2><ul><li>１，和面试官沟通清楚问题，扫清问题的盲点；</li><li>２，想所有可能的解决方案；</li><li>３，比较时间和空间复杂度，找出最优解；</li><li>４，写程序实现；</li><li>５，测试结果。</li></ul><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>通过亮点来分析：</p><ul><li><p>数组的长度</p></li><li><p>递归的深度（特殊说明）</p></li></ul><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p><a href="https://leetcode-cn.com/problems/climbing-stairs/solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/climbing-stairs/solution/</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>常用工具配置</li><li>基本功和编程功法</li><li>常见的时间、空间复杂度</li></ul><h2 id="个人感受"><a href="#个人感受" class="headerlink" title="个人感受"></a>个人感受</h2><p>我最开始体会到时间复杂度的优势是在大二参加算法竞赛前夕，犹记得在搜索某一个算法题目的题解的时候，眼睁睁看着作者将一段复杂的程序通过微积分优化成一行简易的代码，AC一遍直接通过，这使我留下了时刻的印象。<br>工作后虽然我主要做的是开发，但有些优化时间复杂度的思想有时也会用在业务逻辑中，希望我后期可以<strong>最简单的时间复杂度和空间复杂度完成一段程序，达到职业选手的素养！</strong></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.zhihu.com/question/21387264/answer/422323594" target="_blank" rel="noopener">知乎_如何理解算法时间复杂度的表示法，例如 O(n²)、O(n)、O(1)、O(nlogn) 等？</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;常见的7种时间复杂度&quot;&gt;&lt;a href=&quot;#常见的7种时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;常见的7种时间复杂度&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="算法学习" scheme="https://octopuslian.github.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="https://octopuslian.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="体验营" scheme="https://octopuslian.github.io/tags/%E4%BD%93%E9%AA%8C%E8%90%A5/"/>
    
      <category term="极客时间" scheme="https://octopuslian.github.io/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>极客时间_直播 畅聊技术人学习&amp;晋升法则</title>
    <link href="https://octopuslian.github.io/2020/11/25/geektime-live-thanksgiving-share-work-experience/"/>
    <id>https://octopuslian.github.io/2020/11/25/geektime-live-thanksgiving-share-work-experience/</id>
    <published>2020-11-25T11:58:24.000Z</published>
    <updated>2020-11-25T14:34:14.183Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --><h2 id="李运华-聊聊晋升背后的“潜规则”"><a href="#李运华-聊聊晋升背后的“潜规则”" class="headerlink" title="李运华_聊聊晋升背后的“潜规则”"></a>李运华_聊聊晋升背后的“潜规则”</h2><h3 id="明面上的晋升规则"><a href="#明面上的晋升规则" class="headerlink" title="明面上的晋升规则"></a>明面上的晋升规则</h3><p>绩效+年限+红线+附件条件</p><h3 id="价值原则"><a href="#价值原则" class="headerlink" title="价值原则"></a>价值原则</h3><p><strong>员工为企业创造了价值，且能力提升了，才有机会晋升。</strong></p><ul><li><p>不能只埋头干活，要考虑通过做事和自我学习来提升能力</p></li><li><p>能力提升要能为企业带来价值，不要“自嗨式”提升</p></li><li><p>企业会有一套流程机制来防止“拉关系”晋升</p></li></ul><h3 id="成长原则"><a href="#成长原则" class="headerlink" title="成长原则"></a>成长原则</h3><p><strong>能力提升到下一级别，才有机会晋升。</strong></p><ul><li><p>不要沉迷已有的熟练技能带来的满足感，要主动“打破舒适区”</p></li><li><p>不管业务结果好坏，你都可以成长，关键在于“总结提炼”</p></li><li><p>一年经验重复五年是不能满足晋升要求的</p></li></ul><h3 id="主动原则"><a href="#主动原则" class="headerlink" title="主动原则"></a>主动原则</h3><p><strong>主动寻找晋升机会，才有机会晋升。</strong></p><ul><li><p>明确自己的晋升规划，找主管沟通达成一致；</p></li><li><p>主动挖掘成长点，包括专业能力、业务能力、管理能力；</p></li><li><p>主动争取更大的任务和挑战，不要被动等待别人安排任务<br>（建议一年聊一次）</p></li></ul><h2 id="李佳-从100多位老师身上得到的5点启发"><a href="#李佳-从100多位老师身上得到的5点启发" class="headerlink" title="李佳_从100多位老师身上得到的5点启发"></a>李佳_从100多位老师身上得到的5点启发</h2><h3 id="工作那么忙，哪来时间学习？"><a href="#工作那么忙，哪来时间学习？" class="headerlink" title="工作那么忙，哪来时间学习？"></a>工作那么忙，哪来时间学习？</h3><ul><li>减少精力消耗，脑子决策时间，要程序化工作；</li><li>管理自己的理念，10分钟也能学很多东西；</li></ul><h3 id="不擅长的事如何快速解决？"><a href="#不擅长的事如何快速解决？" class="headerlink" title="不擅长的事如何快速解决？"></a>不擅长的事如何快速解决？</h3><ul><li>找个好老师且自己值得被帮助</li><li>20个小时速成一个技能</li></ul><h3 id="学好英语的程序员有多爽？"><a href="#学好英语的程序员有多爽？" class="headerlink" title="学好英语的程序员有多爽？"></a>学好英语的程序员有多爽？</h3><ul><li>微习惯，知行合一</li><li>推荐《老友记》</li><li>每天看一段《This is water》</li></ul><h3 id="事事较真好不好？"><a href="#事事较真好不好？" class="headerlink" title="事事较真好不好？"></a>事事较真好不好？</h3><ul><li>较真，是因为执念</li><li>不较真，是因为开放</li><li>讲究而不将就</li></ul><h3 id="35岁焦虑吗？"><a href="#35岁焦虑吗？" class="headerlink" title="35岁焦虑吗？"></a>35岁焦虑吗？</h3><ul><li>踏踏实实，认真做事，没有心思去焦虑</li><li>首先要认可自己的焦虑</li><li>克服焦虑从行动开始，而行动从习惯中养成</li><li>花上10-30分钟吐槽焦虑，然后投入工作</li></ul><h2 id="池建强-写作是职场人最重要的通用技能之一"><a href="#池建强-写作是职场人最重要的通用技能之一" class="headerlink" title="池建强_写作是职场人最重要的通用技能之一"></a>池建强_写作是职场人最重要的通用技能之一</h2><ul><li>推荐书《软件随想录》</li><li>写作可以推广你的思想，让你更加有影响</li></ul><h2 id="池建强-学习从来不该急功近利"><a href="#池建强-学习从来不该急功近利" class="headerlink" title="池建强_学习从来不该急功近利"></a>池建强_学习从来不该急功近利</h2><ul><li>１，树立目标</li><li>２，拆解</li><li>３，奖励</li><li>４，产出</li></ul><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;李运华-聊聊晋升背后的“潜规则”&quot;&gt;&lt;a href=&quot;#李运华-聊聊晋升背后的“潜规则”&quot; class=&quot;headerlink&quot; title=&quot;李
      
    
    </summary>
    
    
      <category term="直播分享" scheme="https://octopuslian.github.io/categories/%E7%9B%B4%E6%92%AD%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="直播" scheme="https://octopuslian.github.io/tags/%E7%9B%B4%E6%92%AD/"/>
    
      <category term="极客时间" scheme="https://octopuslian.github.io/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"/>
    
      <category term="感恩节" scheme="https://octopuslian.github.io/tags/%E6%84%9F%E6%81%A9%E8%8A%82/"/>
    
      <category term="职场" scheme="https://octopuslian.github.io/tags/%E8%81%8C%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>头可断血可流发型不可乱</title>
    <link href="https://octopuslian.github.io/2020/11/18/the-head-can-be-broken-and-blood-can-flow-but-the-hairstyle-can-not-be-messy/"/>
    <id>https://octopuslian.github.io/2020/11/18/the-head-can-be-broken-and-blood-can-flow-but-the-hairstyle-can-not-be-messy/</id>
    <published>2020-11-18T13:59:11.000Z</published>
    <updated>2020-11-18T14:29:10.158Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --><p>最近新出了个抗日神剧叫《雷霆战将》，被人民日报点名批评，播出一周被下架，很好奇的我看了一些片段，直呼毁三观。</p><p>《雷霆战将》约等于《亮剑3》，里面剧情和亮剑一模一样，就是名字变了，梳理了以下，糟点如下：</p><ul><li>抗日时期住别墅；(请问都住别墅了还打什么仗)</li><li>第二集就开始抛媚眼，把战争剧演成了偶像剧；</li><li>抗战时期护士穿裙子；</li><li>将军头上顶着发胶；</li><li>打仗期间还不忘抽雪茄；<br>等等…</li></ul><p>真TM无力吐槽，从亮剑翻拍，手撕鬼子，到现在又出现了《雷霆战将》，演技真让我作呕，我不晓得导演编剧和审核的人是出于什么样的目的，就从战争这个角度来看这种剧就不该出现！！！</p><p>经典不容超越和翻拍，那是我觉得不尊重的表现。</p><p>最后引用李云龙的一段配音作为结束，讽刺那些想翻拍经典博得关注和票房的人————</p><p>李云龙对赵政委说：<strong>我刚接手新一团的时候，部队发型乱，缺少护发经验，最重要的是缺少发胶，啫喱水全团不到十瓶，焗油一瓶都没有，发胶还是老牌发蜡，就这样，两个人还分不到一瓶发胶，我去找旅长要，你猜旅长怎么说，旅长说，要发胶没有，要命一条，你李云龙看我脑袋值多少发胶，就砍了去换发胶，你有能耐当团长，就想办法去弄发蜡，少拿这点破事烦我。——得嘞，我等的就是这句话，一年之后，新一团什么都有了，沙贝龙，海飞丝，焗油机，烫发机，还有几个漂亮的洗头妹，没有这些，我敢跟坂田联队硬碰硬PK发型，做梦去吧。</strong></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --&gt;&lt;p&gt;最近新出了个抗日神剧叫《雷霆战将》，被人民日报点名批评，播出一周被下架，很好奇的我看了一些片段，直呼毁三观。&lt;/p&gt;&lt;p&gt;《雷霆战将》约等于《亮剑3》，里面
      
    
    </summary>
    
    
      <category term="影评" scheme="https://octopuslian.github.io/categories/%E5%BD%B1%E8%AF%84/"/>
    
    
      <category term="神剧" scheme="https://octopuslian.github.io/tags/%E7%A5%9E%E5%89%A7/"/>
    
      <category term="吐槽" scheme="https://octopuslian.github.io/tags/%E5%90%90%E6%A7%BD/"/>
    
      <category term="毁三观" scheme="https://octopuslian.github.io/tags/%E6%AF%81%E4%B8%89%E8%A7%82/"/>
    
      <category term="雷霆战将" scheme="https://octopuslian.github.io/tags/%E9%9B%B7%E9%9C%86%E6%88%98%E5%B0%86/"/>
    
  </entry>
  
  <entry>
    <title>使用FFmpeg对视频增加转场特技功能</title>
    <link href="https://octopuslian.github.io/2020/11/17/ffmpeg-add-opengl/"/>
    <id>https://octopuslian.github.io/2020/11/17/ffmpeg-add-opengl/</id>
    <published>2020-11-17T04:02:28.000Z</published>
    <updated>2020-11-18T14:01:04.249Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --><p>先来看网上存在的一个<code>ffmpeg</code>脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Example of concatenating 3 mp4s together with 1-second transitions between them.</span></span><br><span class="line"></span><br><span class="line">tpath=<span class="string">"/ffmpeg/transitions/"</span></span><br><span class="line">x264=<span class="string">"-look_ahead 0 -ac 2 -c:v h264_qsv -profile:v high -level 3.1 -preset:v veryfast"</span></span><br><span class="line">ki=<span class="string">"-keyint_min 72 -g 72 -sc_threshold 0"</span></span><br><span class="line">br=<span class="string">"-b:v 3000k -minrate 3000k -maxrate 6000k -bufsize 6000k -b:a 128k"</span></span><br><span class="line"></span><br><span class="line">ffmpeg -hide_banner \</span><br><span class="line">  -i 1.mp4 \</span><br><span class="line">  -i 2.mp4 \</span><br><span class="line">  -i 3.mp4 \</span><br><span class="line">  -filter_complex <span class="string">" \</span></span><br><span class="line"><span class="string">    [0:a]   atrim=0:5  [a0]; \</span></span><br><span class="line"><span class="string">    [1:a]   atrim=0:5  [a1]; \</span></span><br><span class="line"><span class="string">    [2:a]   atrim=0:6  [a2]; \</span></span><br><span class="line"><span class="string">    \</span></span><br><span class="line"><span class="string">    [0:v]   split  [v000] [v010]; \</span></span><br><span class="line"><span class="string">    [1:v]   split  [v100] [v110]; \</span></span><br><span class="line"><span class="string">    [2:v]   split  [v200] [v210]; \</span></span><br><span class="line"><span class="string">    \</span></span><br><span class="line"><span class="string">    [v000]  trim=0:5                [v001];  \</span></span><br><span class="line"><span class="string">    [v010]  trim=5:6                [v011t]; \</span></span><br><span class="line"><span class="string">    [v011t] setpts=PTS-STARTPTS     [v011];  \</span></span><br><span class="line"><span class="string">    \</span></span><br><span class="line"><span class="string">    [v100]   trim=0:5               [v101];  \</span></span><br><span class="line"><span class="string">    [v110]   trim=5:6               [v111t]; \</span></span><br><span class="line"><span class="string">    [v111t]  setpts=PTS-STARTPTS    [v111];  \</span></span><br><span class="line"><span class="string">    \</span></span><br><span class="line"><span class="string">    [v200]     trim=0:5             [v201];  \</span></span><br><span class="line"><span class="string">    [v210]     trim=5:6             [v211t]; \</span></span><br><span class="line"><span class="string">    [v211t]    setpts=PTS-STARTPTS  [v211];  \</span></span><br><span class="line"><span class="string">    \</span></span><br><span class="line"><span class="string">    [v011] [v101] gltransition=duration=1:source=<span class="variable">$&#123;tpath&#125;</span>WaterDrop.glsl  [vt0]; \</span></span><br><span class="line"><span class="string">    [v111] [v201] gltransition=duration=1:source=<span class="variable">$&#123;tpath&#125;</span>crosswarp.glsl  [vt1]; \</span></span><br><span class="line"><span class="string">    \</span></span><br><span class="line"><span class="string">    [v001] [vt0] [vt1] [v211]  concat=n=4          [outv]; \</span></span><br><span class="line"><span class="string">    [a0] [a1] [a2]             concat=n=3:v=0:a=1  [outa]"</span> \</span><br><span class="line">  -map [outv] -map [outa] \</span><br><span class="line">  <span class="variable">$&#123;x264&#125;</span> <span class="variable">$&#123;ki&#125;</span> <span class="variable">$&#123;br&#125;</span> \</span><br><span class="line">  -y ffmpeg-gl-transition-concat.mp4</span><br></pre></td></tr></table></figure><h3 id="流程简介"><a href="#流程简介" class="headerlink" title="流程简介"></a>流程简介</h3><p><code>github</code>上的脚本如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Example of concatenating 3 mp4s together with 1-second transitions between them.</span></span><br><span class="line"></span><br><span class="line">./ffmpeg \</span><br><span class="line">  -i media/0.mp4 \</span><br><span class="line">  -i media/1.mp4 \</span><br><span class="line">  -i media/2.mp4 \</span><br><span class="line">  -filter_complex <span class="string">" \</span></span><br><span class="line"><span class="string">    [0:v]split[v000][v010]; \</span></span><br><span class="line"><span class="string">    [1:v]split[v100][v110]; \</span></span><br><span class="line"><span class="string">    [2:v]split[v200][v210]; \</span></span><br><span class="line"><span class="string">    [v000]trim=0:3[v001]; \</span></span><br><span class="line"><span class="string">    [v010]trim=3:4[v011t]; \</span></span><br><span class="line"><span class="string">    [v011t]setpts=PTS-STARTPTS[v011]; \</span></span><br><span class="line"><span class="string">    [v100]trim=0:3[v101]; \</span></span><br><span class="line"><span class="string">    [v110]trim=3:4[v111t]; \</span></span><br><span class="line"><span class="string">    [v111t]setpts=PTS-STARTPTS[v111]; \</span></span><br><span class="line"><span class="string">    [v200]trim=0:3[v201]; \</span></span><br><span class="line"><span class="string">    [v210]trim=3:4[v211t]; \</span></span><br><span class="line"><span class="string">    [v211t]setpts=PTS-STARTPTS[v211]; \</span></span><br><span class="line"><span class="string">    [v011][v101]gltransition=duration=1:source=./crosswarp.glsl[vt0]; \</span></span><br><span class="line"><span class="string">    [v111][v201]gltransition=duration=1[vt1]; \</span></span><br><span class="line"><span class="string">    [v001][vt0][vt1][v211]concat=n=4[outv]"</span> \</span><br><span class="line">  -map <span class="string">"[outv]"</span> \</span><br><span class="line">  -c:v libx264 -profile:v baseline -preset slow -movflags faststart -pix_fmt yuv420p \</span><br><span class="line">  -y out.mp4</span><br></pre></td></tr></table></figure><h3 id="相关过滤器功能"><a href="#相关过滤器功能" class="headerlink" title="相关过滤器功能"></a>相关过滤器功能</h3><ul><li>split，过滤器创建两个输入文件的拷贝并标记为[a],[b];</li><li>trim，修剪视频;</li><li>setpts=PTS-STARTPTS。重编码，算pts;</li></ul><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="/2020/11/17/ffmpeg-add-opengl/p.png" alt></p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="bbs.chinaffmpeg.com/forum.php?mod=viewthread&tid=391&extra=&page=3">Windows如何实现视频过渡滑入视频特效？</a></p><p><a href="https://www.cnblogs.com/nlsoft/p/10896543.html" target="_blank" rel="noopener">ffmpeg 视频过度滤镜 gltransition</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --&gt;&lt;p&gt;先来看网上存在的一个&lt;code&gt;ffmpeg&lt;/code&gt;脚本&lt;/p&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
    
      <category term="FFmpeg学习" scheme="https://octopuslian.github.io/categories/FFmpeg%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="FFmpeg" scheme="https://octopuslian.github.io/tags/FFmpeg/"/>
    
      <category term="OpenGL" scheme="https://octopuslian.github.io/tags/OpenGL/"/>
    
      <category term="视音频" scheme="https://octopuslian.github.io/tags/%E8%A7%86%E9%9F%B3%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg常用命令整理</title>
    <link href="https://octopuslian.github.io/2020/11/15/ffmpeg-command-finish/"/>
    <id>https://octopuslian.github.io/2020/11/15/ffmpeg-command-finish/</id>
    <published>2020-11-15T06:36:47.000Z</published>
    <updated>2020-11-18T14:01:00.061Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --><h2 id="检测源流信息"><a href="#检测源流信息" class="headerlink" title="检测源流信息"></a>检测源流信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i 源流地址</span><br></pre></td></tr></table></figure><h2 id="推流"><a href="#推流" class="headerlink" title="推流"></a>推流</h2><h3 id="把A-MP4和B-mp4打包进同一个ts流，并推到本机的10003端口"><a href="#把A-MP4和B-mp4打包进同一个ts流，并推到本机的10003端口" class="headerlink" title="把A.MP4和B.mp4打包进同一个ts流，并推到本机的10003端口"></a>把A.MP4和B.mp4打包进同一个ts流，并推到本机的10003端口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -i A.mp4  -re -i B.mp4  -map 0:0 -map 0:1 -map 1:0 -map 1:1  -program program_num=1:title=videoA:st=0:st=1 -program program_num=3:title=videoB:st=2:st=3 -c copy -f mpegts udp://localhost:10003</span><br></pre></td></tr></table></figure><p>以此类推</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">推一路流</span><br><span class="line">ffmpeg -re -i A.mp4 -map 0:0 -map 0:1 -program program_num=1:title=videoA:st=0:st=1  -f mpegts udp://localhost:10003</span><br><span class="line"></span><br><span class="line">推三路流</span><br><span class="line">ffmpeg -re -i shenzhen.ts  -re -i guangdong.ts -re -i girl.mp4  -map 0:0 -map 0:1 -map 1:0 -map 1:1 -map 0:0 -map 0:1 -program program_num=1:title=videoA:st=0:st=1 -program program_num=3:title=videoB:st=2:st=3 -program program_num=5:title=videoXXX:st=4:st=5 -f mpegts udp://localhost:10003</span><br></pre></td></tr></table></figure><p>循环推一路流，不做编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -stream_loop -1 -i aaa.xx -c copy -f mpegts udp://localhost:10003</span><br></pre></td></tr></table></figure><h3 id="命令参数解释"><a href="#命令参数解释" class="headerlink" title="命令参数解释"></a>命令参数解释</h3><ul><li>re:realtime 推的速度，按当前帧率推</li><li>map 0:0 第一个流的视频</li><li>map 0:1 第一个流的音频</li><li>map 1:0 第二个流的视频</li><li>map 1:1 第二个流的音频</li><li>program_num=1:title=videoA:st=0:st=1 0,1合成一个视频videoA</li><li>program program_num=3:title=videoB:st=2:st=3 2,3合成一个视频videoB</li><li>-stream_loop 循环推流</li><li>-c copy 将视频中压缩的数据复制</li><li>-c:v libh264 将视频流强制转换为h264编码</li></ul><h2 id="查看流中的program信息"><a href="#查看流中的program信息" class="headerlink" title="查看流中的program信息"></a>查看流中的program信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffprobe -show_programs -print_format json -timeout 5000000 -i udp://localhost:10003</span><br></pre></td></tr></table></figure><ul><li>注意:这个命令有返回值，<code>0</code>表示执行成功，<code>1</code>表示失败。</li></ul><h2 id="将流中的program-1和program-3分别截取5s钟的时间，生成了两个文件"><a href="#将流中的program-1和program-3分别截取5s钟的时间，生成了两个文件" class="headerlink" title="将流中的program 1和program 3分别截取5s钟的时间，生成了两个文件"></a>将流中的program 1和program 3分别截取5s钟的时间，生成了两个文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -timeout 5000000 -i udp://localhost:10003  -t 0:0:5  -map p:1 -c copy  1.mp4 -t 0:0:5 -map p:3 -c copy 3.mp4</span><br></pre></td></tr></table></figure><ul><li>注意。此时推的是复合流。</li></ul><h2 id="对视频流抽帧"><a href="#对视频流抽帧" class="headerlink" title="对视频流抽帧"></a>对视频流抽帧</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i 源流地址 -vframes 1 -vf scale=90:51 图片存放路径</span><br></pre></td></tr></table></figure><h2 id="重复推流"><a href="#重复推流" class="headerlink" title="重复推流"></a>重复推流</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -re -stream_loop -1 -i aaa.xx -c copy -f mpegts udp://localhost:10003</span><br><span class="line"></span><br><span class="line">./ffmpeg -re  -i -stream_loop -1 startslient.mp3  -c:a aac -f flv rtmp://123.56.17.184/live/znn</span><br></pre></td></tr></table></figure><h2 id="将流保存成文件"><a href="#将流保存成文件" class="headerlink" title="将流保存成文件"></a>将流保存成文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i 流地址 -c copy 文件名</span><br><span class="line"></span><br><span class="line">例如:</span><br><span class="line">ffmpeg -i udp://localhost:10003 -c copy test.ts</span><br></pre></td></tr></table></figure><h2 id="检测源流中是否有静音"><a href="#检测源流中是否有静音" class="headerlink" title="检测源流中是否有静音"></a>检测源流中是否有静音</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i silence.mp3 -af silencedetect=noise=0.0001 -f null -</span><br><span class="line">(默认音频中如果有2秒是静音，就认为是有静音的)</span><br><span class="line"></span><br><span class="line">持续让ffmpeg检测音频5秒</span><br><span class="line">ffmpeg -i silence.mp3 -af silencedetect=noise=0.0001 -t 0:0:5 -f null -</span><br></pre></td></tr></table></figure><h2 id="切分视频片段"><a href="#切分视频片段" class="headerlink" title="切分视频片段"></a>切分视频片段</h2><h3 id="切分纯视频片段"><a href="#切分纯视频片段" class="headerlink" title="切分纯视频片段"></a>切分纯视频片段</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.flv -vsync 0 -filter_complex &quot;[0:v]select=&apos;between(t-start_t,8.250,10.000)&apos;[xv];[xv]setpts=&apos;PTS-STARTPTS&apos;[vout];[vout]scale=1920:1080,pad=1920:1080:0:0:black[vout2]&quot; -map &quot;[vout2]&quot; -c:v libx264 test.ts</span><br></pre></td></tr></table></figure><h3 id="切分纯音频片段"><a href="#切分纯音频片段" class="headerlink" title="切分纯音频片段"></a>切分纯音频片段</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.mp3 -filter_complex &quot;[0:a]aselect=&apos;between(t,0.000,26.250)&apos;[xa];[xa]asetpts=&apos;NB_CONSUMED_SAMPLES/SAMPLE_RATE*1/TB&apos;[aout] &quot; -map &quot;[aout]&quot; out.mp3</span><br></pre></td></tr></table></figure><h3 id="切分带音频的视频片段"><a href="#切分带音频的视频片段" class="headerlink" title="切分带音频的视频片段"></a>切分带音频的视频片段</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i test.flv -filter_complex &quot;[0:v]select=&apos;between(t-start_t,5.250,10.000)&apos;[xv];[xv]setpts=&apos;PTS-STARTPTS&apos;[vout];[vout]scale=[vout2]&quot; -r 25 -map &quot;[vout2]&quot; -c:v libx264 -x264-params sps-id=6 out.ts</span><br></pre></td></tr></table></figure><h3 id="命令参数解释-1"><a href="#命令参数解释-1" class="headerlink" title="命令参数解释"></a>命令参数解释</h3><ul><li>-vsync 0：打印ffmpeg详细日志的开关</li><li>black：添加黑边</li><li>libx264：编码</li></ul><h2 id="合并视频片段"><a href="#合并视频片段" class="headerlink" title="合并视频片段"></a>合并视频片段</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f concat -safe 0 -i test.txt -c copy out.mp4</span><br></pre></td></tr></table></figure><ul><li>test.txt：一个文件列表，里面存放着要合并的视频片段名</li><li>-f concat -safe 0：打开文件时会用到</li></ul><h2 id="合并视频的同时添加图片和文字水印"><a href="#合并视频的同时添加图片和文字水印" class="headerlink" title="合并视频的同时添加图片和文字水印"></a>合并视频的同时添加图片和文字水印</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -f concat -safe 0 -i test.txt -t 27.040 -loop 1 -i 1080P%05d.png -filter_complex &quot;[0:v][1:v]overlay=x=0:y=885:enable=&apos;between(t,0,30)&apos;[out];[out]drawtext=fontfile=simhei.ttf:text=&apos;name&apos;:x=414:y=928:fontsize=60:fontcolor=white:enable=&apos;between(t,0,30)&apos;[out];[out]drawtext=fontfile=simhei.ttf:text=&apos;title&apos;:x=630:y=933:fontsize=52:fontcolor=white:enable=&apos;between(t,0,30)&apos;&quot; -y -c:v libx264 out.mp4</span><br></pre></td></tr></table></figure><ul><li>-loop 1，让png序列循环</li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://superuser.com/questions/1335639/how-can-i-overlay-png-image-sequence-but-start-at-particular-frame-using-ffmpeg" target="_blank" rel="noopener">how-can-i-overlay-png-image-sequence-but-start-at-particular-frame-using-ffmpeg</a></p><p><a href="https://blog.csdn.net/m0_37684310/article/details/78257779" target="_blank" rel="noopener">利用ffmpeg实现添加图片水印和文字水印，添加多个水印</a></p><p><a href="https://www.jianshu.com/p/c0e151775075" target="_blank" rel="noopener">使用ffmpeg给视频添加图片及文字水印</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;检测源流信息&quot;&gt;&lt;a href=&quot;#检测源流信息&quot; class=&quot;headerlink&quot; title=&quot;检测源流信息&quot;&gt;&lt;/a&gt;检测源流信息&lt;/h
      
    
    </summary>
    
    
      <category term="FFmpeg学习" scheme="https://octopuslian.github.io/categories/FFmpeg%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="FFmpeg" scheme="https://octopuslian.github.io/tags/FFmpeg/"/>
    
      <category term="视音频" scheme="https://octopuslian.github.io/tags/%E8%A7%86%E9%9F%B3%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>当我提完离职的时候</title>
    <link href="https://octopuslian.github.io/2020/11/09/when-i-mentioned-my-resignation/"/>
    <id>https://octopuslian.github.io/2020/11/09/when-i-mentioned-my-resignation/</id>
    <published>2020-11-09T13:54:47.000Z</published>
    <updated>2020-11-18T14:05:08.233Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --><p>第一次提离职，难免有些紧张，当我梳理好离职的话语，按下回车的那一刻，仿佛世界一下就安静了。</p><p>这些天来我反复对比离职的利与弊，却往往忽略的最重要的一点————那就是我的内心所思所想。我当然想每个月看到自己有好几千的收入，但是为了这收入，我需要忍受，仿佛这些收入就是来慰藉我这个月的委屈。</p><p>接下来就是交接工作，希望早点完成然后搬新家开始我自己的计划。</p><p>朋友问我后面打算怎么办，我就说先把今年考研过了，然后回趟家陪陪父母，明年3月联系好友帮忙内推BAT等大厂，当然前提也要我自己做足准备才行。</p><p>从小学-初中-高中-大学，我慢慢发现我的人生轨迹就是一个<code>sin</code>函数，在某一阶段会跌入低谷，陷入迷茫，无法自拔，然后等过上2-4个月就如同凤凰涅槃一样重获新生。</p><p>加油，我的路还很长，但年轻的资本却只剩不多，我要将我有限的经历投入到有意义的事情中去。</p><p>GOOD LUCK !</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --&gt;&lt;p&gt;第一次提离职，难免有些紧张，当我梳理好离职的话语，按下回车的那一刻，仿佛世界一下就安静了。&lt;/p&gt;&lt;p&gt;这些天来我反复对比离职的利与弊，却往往忽略的最重要的
      
    
    </summary>
    
    
      <category term="职场生涯" scheme="https://octopuslian.github.io/categories/%E8%81%8C%E5%9C%BA%E7%94%9F%E6%B6%AF/"/>
    
    
      <category term="职场" scheme="https://octopuslian.github.io/tags/%E8%81%8C%E5%9C%BA/"/>
    
      <category term="离职" scheme="https://octopuslian.github.io/tags/%E7%A6%BB%E8%81%8C/"/>
    
      <category term="心情" scheme="https://octopuslian.github.io/tags/%E5%BF%83%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>我的理想生活(1)</title>
    <link href="https://octopuslian.github.io/2020/10/21/my-dream-life-first/"/>
    <id>https://octopuslian.github.io/2020/10/21/my-dream-life-first/</id>
    <published>2020-10-21T14:52:52.000Z</published>
    <updated>2020-10-21T15:18:59.732Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --><p>今天和@hanxu老友聊起以后想从事的工作，借此情形记录下来，不知未来十年或二十年可否实现。</p><p>我的理想生活，必须要自由，自由到不需要按时打卡上下班，不需要将自己的身躯固定在格子间里，不需要看某些人的脸色行事，不需要维持表面装出来的微笑表情，不需要整天盯着手机收发消息；</p><p>我的理想生活，必须要充实，充实到可以尽情做自己想做的事情，它带给我的快乐远远超过这件事的本身；</p><p>我的理想生活，必须要有它所存在的意义，而这样的意义我也在不停的寻找，六年的时间里，我放佛找到了些许轮廓：我可以尝试翻译国外的经典书籍，首先要要求自己的翻译水平达到一定的境界；我可以做多次不求回报的志愿者；我可以走遍千山万水，拍下别人只能在电视前看到的美景（比如抖音的<strong>韩船长</strong>）；</p><p>我的理想生活，必须要与美食同行，我要吃遍大江南北的特色小吃，品尝奇特的酸甜苦辣咸，就像生活的各种滋味一样；</p><p>我的理想生活，必须要见一见我的好兄弟们，和他们敞开心扉畅聊三天三夜，大口吃肉大口喝酒大声嚷嚷，因为我TM心里憋了一肚子气，已经太久没有大声说过话了…</p><p>我的理想生活，必须要去尝试极限运动，即使不小心发生了事故，我也无憾，因为我将长眠于我热爱的事业上，与其等着死，不如忙着生；</p><p>我的理想生活，必须要在离开这个世界之前，写出一本自传，告诉这个世界，我曾经来过，并带走了美好的回忆。</p><p>最后引用《死亡诗社》里的一首诗作为结束：</p><p><strong>我步入丛林</strong></p><p><strong>因为我希望活得随意</strong></p><p><strong>我希望活得深刻</strong></p><p><strong>吸取生命所有的精华</strong></p><p><strong>把非生命的一切都击溃</strong></p><p><strong>以免我在弥留之际</strong></p><p><strong>发现自己从未真正活过。</strong></p><p><img src="/2020/10/21/my-dream-life-first/1.jpg" alt></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --&gt;&lt;p&gt;今天和@hanxu老友聊起以后想从事的工作，借此情形记录下来，不知未来十年或二十年可否实现。&lt;/p&gt;&lt;p&gt;我的理想生活，必须要自由，自由到不需要按时打卡上下
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://octopuslian.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活" scheme="https://octopuslian.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="梦想" scheme="https://octopuslian.github.io/tags/%E6%A2%A6%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>爱笑的眼睛</title>
    <link href="https://octopuslian.github.io/2020/10/20/smiling-eyes/"/>
    <id>https://octopuslian.github.io/2020/10/20/smiling-eyes/</id>
    <published>2020-10-20T15:17:36.000Z</published>
    <updated>2020-10-21T14:53:33.400Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --><p>“离开你我才发现自己，那爱笑的眼睛，流过泪，像躲不过的暴风雨….” ————林俊杰《爱笑的眼睛》</p><h2 id="离开学校"><a href="#离开学校" class="headerlink" title="离开学校"></a>离开学校</h2><p>虽然离开学校已经两年了，但我偶尔还是会规划自己的暑假生活，想着7月去哪玩，8月去吃什么…等等，我不能做梦了，我已经没有寒暑假，oh shit !</p><p>我时常还是怀念上学的时光，没有人打扰的实验室 &amp; 图书馆四楼的计算机专业书架和三楼的文学小说书架 &amp; 800一年的宿舍和食堂5元的两荤一素一汤 &amp; 良师益友…</p><h2 id="离开家人"><a href="#离开家人" class="headerlink" title="离开家人"></a>离开家人</h2><p>远离故乡，远离家人，来到一座陌生的城市求职生存，我突然算了下，从大学到现在六年时间里，我们相处的时间竟然不足100天。</p><p>我时常想念母亲做的新疆拌面和岐山臊子面，父亲做的红烧肉和手抓饭，和妹妹抢电脑打拳皇，经常2:3她赢，殊不知其实是我故意摁错了几个发绝招的键位，哈哈哈…</p><h2 id="离开家乡"><a href="#离开家乡" class="headerlink" title="离开家乡"></a>离开家乡</h2><p>有得必有失，有舍必有得，这是我小时候时常听到的一句话。</p><p>我失去了熟悉的环境，失去了和父母相处的日子，失去了学校安逸的时光，换来了两年时间的反思和顿悟，以及见识了最真实的自己。</p><h2 id="你有没有自己的忍道？"><a href="#你有没有自己的忍道？" class="headerlink" title="你有没有自己的忍道？"></a>你有没有自己的忍道？</h2><p>我时常回忆起《火影忍者》里的李洛克和旋涡鸣人的场景，为了贯彻自己的忍道，李洛克开了八门遁甲，鸣人不断学习忍术和挨打，最终李洛克得到老师认可，鸣人当上火影。有时我在想，这样的场景我可以复现吗？</p><h2 id="那爱笑的眼睛"><a href="#那爱笑的眼睛" class="headerlink" title="那爱笑的眼睛"></a>那爱笑的眼睛</h2><p>眼睛是心灵的窗户，我喜欢正视对方的眼睛，因为可以发现很多内在不易表现的东西。</p><p>而我也喜欢对着镜子看自己，有时看到乐观和坚毅，有时看到伤感和迷茫，也许这才是真实的我，热泪与梦想交织，在希望和失望，在迷茫和坚定自己的过程中，螺旋式缓慢成长。</p><p><strong>离开你我才找回自己，那爱笑的眼睛，再见到你，我一定让自己假装很坚定。</strong></p><p><img src="/2020/10/20/smiling-eyes/1.jpg" alt></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 18 2020 23:26:09 GMT+0800 (CST) --&gt;&lt;p&gt;“离开你我才发现自己，那爱笑的眼睛，流过泪，像躲不过的暴风雨….” ————林俊杰《爱笑的眼睛》&lt;/p&gt;&lt;h2 id=&quot;离开学校&quot;&gt;&lt;a href=&quot;#离开
      
    
    </summary>
    
    
      <category term="随笔" scheme="https://octopuslian.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="成长" scheme="https://octopuslian.github.io/tags/%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
</feed>

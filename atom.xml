<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>以写作调身心</title>
  
  <subtitle>熟能生巧，勤能补拙；念念不忘，必有回响。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://octopuslian.github.io/"/>
  <updated>2021-07-18T14:18:43.313Z</updated>
  <id>https://octopuslian.github.io/</id>
  
  <author>
    <name>Neo Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go基础冲刺营_Day1_Golang基础语法和Web框架起步</title>
    <link href="https://octopuslian.github.io/2021/07/18/geekbang-live-go-basic-sprint-day-1/"/>
    <id>https://octopuslian.github.io/2021/07/18/geekbang-live-go-basic-sprint-day-1/</id>
    <published>2021-07-18T14:59:27.000Z</published>
    <updated>2021-07-18T14:18:43.313Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --><h2 id="环境按照"><a href="#环境按照" class="headerlink" title="环境按照"></a>环境按照</h2><p>略</p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="main函数要点"><a href="#main函数要点" class="headerlink" title="main函数要点"></a>main函数要点</h3><ul><li>无参数、无返回值</li><li>main方法必须要在main包里面</li><li><code>go run main.go</code>就可以执行</li><li>如果文件不叫<code>main.go</code>，则需要<code>go build</code>之后再<code>go run</code></li></ul><h3 id="包声明"><a href="#包声明" class="headerlink" title="包声明"></a>包声明</h3><ul><li>语法形式：package xxx</li><li>字母和下划线的组合</li><li>可以和文件夹不同名字</li><li>同一个文件夹下的声明一致</li><li>引入包语法形式：import [alias] xxx</li><li>如果一个包引入了但是没有使用，会报错</li><li>匿名引入：前面多一个下划线</li></ul><h3 id="string声明"><a href="#string声明" class="headerlink" title="string声明"></a>string声明</h3><ul><li>双引号引起来，则内部双引号需要使用<code>\</code>转义</li><li><code>引号引起来，则内部</code> 需要\转义</li></ul><h3 id="string和基础类型"><a href="#string和基础类型" class="headerlink" title="string和基础类型"></a>string和基础类型</h3><h4 id="string长度"><a href="#string长度" class="headerlink" title="string长度"></a>string长度</h4><ul><li>字节长度：和编码无关，用<code>len(str)</code>获取</li><li>字符数量：和编码无关，用编码库计算</li></ul><p><strong>新人入门第一坑</strong>：<code>len</code>统计的是字节，而不是字符。</p><h4 id="strings包"><a href="#strings包" class="headerlink" title="strings包"></a>strings包</h4><ul><li>string 的拼接直接使用 + 号就可以。 注意的是，某些语言支持 string 和别的类型拼接， 但是golang 不可以</li><li>strings 主要方法（你所需要的全部都可以找到） ：<br>• 查找和替换<br>• 大小写转换<br>• 子字符串相关<br>• 相等</li></ul><h4 id="rune类型"><a href="#rune类型" class="headerlink" title="rune类型"></a>rune类型</h4><ul><li>rune， 直观理解， 就是字符</li><li>rune 不是 byte!</li><li>rune 本质是 int32， 一个 rune 四个字节</li><li>rune 在很多语言里面是没有的， 与之对应的是， golang 没有 char 类型。 rune 不是数字，也不是 char， 也不是 byte！</li><li>实际中不太常用</li></ul><h4 id="bool-int-uint-float-家族"><a href="#bool-int-uint-float-家族" class="headerlink" title="bool, int, uint, float 家族"></a>bool, int, uint, float 家族</h4><ul><li>bool: true, false</li><li>int8, int16, int32, int64, int</li><li>uint8, uint16, uint32, uint64, uint</li><li>float32, float64</li></ul><h4 id="byte-类型"><a href="#byte-类型" class="headerlink" title="byte 类型"></a>byte 类型</h4><ul><li>byte， 字节， 本质是 uint8</li><li>对应的操作包在 bytes 上</li></ul><h4 id="类型总结"><a href="#类型总结" class="headerlink" title="类型总结"></a>类型总结</h4><ul><li>golang 的数字类型明确标注了长度、 有无符号</li><li>golang 不会帮你做类型转换， 类型不同无法通过编译。 也因此， string 只能和string 拼接</li><li>golang 有一个很特殊的 rune 类型， 接近一般语言的 char 或者 character 的概念， 非面试情况下， 可以理解为 “ rune = 字符”</li><li>string 遇事不决找 strings 包</li></ul><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><h4 id="变量声明-var"><a href="#变量声明-var" class="headerlink" title="变量声明 var"></a>变量声明 var</h4><p>• var， 语法： var name type = value<br>• 局部变量<br>• 包变量<br>• 块声明</p><ul><li>驼峰命名</li><li>首字符是否大写控制了访问性： 大写包外可访问；</li><li>golang 支持类型推断</li></ul><h4 id="变量声明-1"><a href="#变量声明-1" class="headerlink" title="变量声明 :="></a>变量声明 :=</h4><ul><li>只能用于局部变量， 即方法内部</li><li>golang 使用类型推断来推断类型。 数字会被理解为 int 或者 float64。 （所以要其它类型的数字， 就得用 var 来声明）</li></ul><h4 id="变量声明易错点"><a href="#变量声明易错点" class="headerlink" title="变量声明易错点"></a>变量声明易错点</h4><ul><li>变量声明了没有使用</li><li>类型不匹配</li><li>同作用域下， 变量只能声明一次</li></ul><h4 id="常量声明-const"><a href="#常量声明-const" class="headerlink" title="常量声明 const"></a>常量声明 const</h4><ul><li>首字符是否大写控制了访问性： 大写包外可访问；</li><li>驼峰命名</li><li>支持类型推断</li><li>无法修改值</li></ul><h3 id="方法声明与调用"><a href="#方法声明与调用" class="headerlink" title="方法声明与调用"></a>方法声明与调用</h3><h4 id="方法声明"><a href="#方法声明" class="headerlink" title="方法声明"></a>方法声明</h4><ul><li>关键字 func</li><li>方法名字： 首字母是否大写决定了作用域</li><li>参数列表： [<name type>]</name></li><li>返回列表: [<name type>]</name></li></ul><h4 id="方法声明（推荐写法）"><a href="#方法声明（推荐写法）" class="headerlink" title="方法声明（推荐写法）"></a>方法声明（推荐写法）</h4><ul><li>参数列表含有参数名</li><li>返回值不具有返回值名</li></ul><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><ul><li>使用 _ 忽略返回值</li></ul><h4 id="方法声明与调用总结"><a href="#方法声明与调用总结" class="headerlink" title="方法声明与调用总结"></a>方法声明与调用总结</h4><ul><li>golang 支持多返回值， 这是一个很大的不同点</li><li>golang 方法的作用域和变量作用域一样， 通过大小写控制</li><li>golang 的返回值是可以有名字的， 可以通过给予名字让调用方清楚知道你返回的是什么</li></ul><h3 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h3><p>数组和别的语言的数组差不多， 语法是： [cap]type</p><ul><li><ol><li>初始化要指定长度（或者叫做容量）</li></ol></li><li><ol start="2"><li>直接初始化</li></ol></li><li><ol start="3"><li>arr[i]的形式访问元素</li></ol></li><li><ol start="4"><li>len 和 cap 操作用于获取数组长度</li></ol></li></ul><p>切片,语法： []type</p><ul><li><ol><li>直接初始化</li></ol></li><li><ol start="2"><li>make初始化:make([]type, length, capacity)</li></ol></li><li><ol start="3"><li>arr[i] 的形式访问元素</li></ol></li><li><ol start="4"><li>append 追加元素</li></ol></li><li><ol start="5"><li>len 获取元素数量</li></ol></li><li><ol start="6"><li>cap 获取切片容容量</li></ol></li><li><ol start="7"><li>推荐写法： s1 := make([]type, 0, capacity)</li></ol></li></ul><p><img src="/2021/07/18/geekbang-live-go-basic-sprint-day-1/%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87.png" alt></p><h3 id="子切片"><a href="#子切片" class="headerlink" title="子切片"></a>子切片</h3><p>数组和切片都可以通过[start:end] 的形式来获取子切片:</p><ul><li><ol><li>arr[start:end]， 获得[start, end)之间的元素</li></ol></li><li><ol start="2"><li>arr[:end]， 获得[0, end) 之间的元素</li></ol></li><li><ol start="3"><li>arr[start:]， 获得[start, len(arr))之间的元素</li></ol></li></ul><p><strong>Tip： 左闭右开原则</strong></p><h3 id="如何理解切片"><a href="#如何理解切片" class="headerlink" title="如何理解切片"></a>如何理解切片</h3><p>最直观的对比： ArrayList， 即基于数组的 List 的实现， 切片的底层也是数组</p><p>跟 ArrayList 的区别：</p><ul><li><ol><li>切片操作是有限的， 不支持随机增删（即没有 add, delete 方法， 需要自己写代码）</li></ol></li><li><ol start="2"><li>只有 append 操作</li></ol></li><li><ol start="3"><li>切片支持子切片操作， 和原本切片是共享底层数组</li></ol></li></ul><p><strong>Tip： 遇事不决用切片， 不容易错</strong></p><h3 id="共享底层（optional）"><a href="#共享底层（optional）" class="headerlink" title="共享底层（optional）"></a>共享底层（optional）</h3><p>核心： 共享数组</p><p>子切片和切片究竟会不会互相影响， 就抓住一点： 它们是不是还共享数组？<br>什么意思？ 就是如果它们结构没有变化， 那肯定是共享的；<br>但是结构变化了， 就可能不是共享了<br>有余力的同学可以运行一下 ShareSlice()</p><p><img src="/2021/07/18/geekbang-live-go-basic-sprint-day-1/shareslice.png" alt></p><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>for 和别的语言差不多， 有三种形式：</p><ul><li><ol><li>for {} ， 类似 while 的无限循环</li></ol></li><li><ol start="2"><li>for i， 一般的按照下标循环</li></ol></li><li><ol start="3"><li>for range 最为特殊的 range 遍历</li></ol></li><li><ol start="4"><li>break 和 continue 和别的语言一样</li></ol></li></ul><h3 id="if-else"><a href="#if-else" class="headerlink" title="if - else"></a>if - else</h3><p>带局部变量声明的 if- else：</p><ul><li><ol><li>distance 只能在 if 块， 或者后边所有的 else 块里面使用</li></ol></li><li><ol start="2"><li>脱离了 if - else 块， 则不能再使用</li></ol></li></ul><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch 和别的语言差不多<br>switch 后面可以是基础类型和字符串， 或者满足特定条件的结构体<br>最大的差别：终于不用加 break 了</p><p><strong>Tip： 大多数时候， switch 后面只会用基础类型或者字符串</strong></p><h2 id="课后练习"><a href="#课后练习" class="headerlink" title="课后练习"></a>课后练习</h2><ul><li>计算斐波那契数列</li><li>实现切片的 Add 和 Delete 方法</li><li>去 leetcode 上试试（先看答案， 再尝试用 go 写出来） ：</li><li><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/</a></li><li><a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/search-insert-position/</a></li><li>我们课上用了很多 fmt 来格式化字符串， 那么如何输出：</li><li>3.1 保留两位小数的数字</li><li>3.2 将[]byte 输出为16进制</li><li>预习 type 的用法</li></ul><h2 id="最简单的Web服务器"><a href="#最简单的Web服务器" class="headerlink" title="最简单的Web服务器"></a>最简单的Web服务器</h2><p><img src="/2021/07/18/geekbang-live-go-basic-sprint-day-1/web.png" alt></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;环境按照&quot;&gt;&lt;a href=&quot;#环境按照&quot; class=&quot;headerlink&quot; title=&quot;环境按照&quot;&gt;&lt;/a&gt;环境按照&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="Share-live" scheme="https://octopuslian.github.io/categories/Share-live/"/>
    
    
      <category term="Golang" scheme="https://octopuslian.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>如何设计一个秒杀系统</title>
    <link href="https://octopuslian.github.io/2021/07/18/interview-seckill-system-design/"/>
    <id>https://octopuslian.github.io/2021/07/18/interview-seckill-system-design/</id>
    <published>2021-07-18T14:09:53.000Z</published>
    <updated>2021-07-18T14:16:13.634Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --><h1 id="秒杀系统架构设计都有哪些关键点"><a href="#秒杀系统架构设计都有哪些关键点" class="headerlink" title="秒杀系统架构设计都有哪些关键点"></a>秒杀系统架构设计都有哪些关键点</h1><p><strong>秒杀其实主要解决两个问题，一个是并发读，一个是并发写。</strong></p><p>秒杀的整体架构可以概括为“稳、准、快”几个关键字。</p><p>所谓“稳”，就是整个系统架构要满足高可用，流量符合预期时肯定要稳定，就是超出预期时也同样不能掉链子，你要保证秒杀活动顺利完成，即秒杀商品顺利地卖出去，这个是最基本的前提。</p><p>所谓“准”，就是秒杀 10 台 iPhone，那就只能成交 10 台，多一台少一台都不行。一旦库存不对，那平台就要承担损失，所以“准”就是要求保证数据的一致性。</p><p>所谓“快”，“快”其实很好理解，它就是说系统的性能要足够高，否则你怎么支撑这么大的流量呢？不光是服务端要做极致的性能优化，而且在整个请求链路上都要做协同的优化，每个地方快一点，整个系统就完美了。</p><h1 id="设计秒杀系统时应该注意的5个架构原则"><a href="#设计秒杀系统时应该注意的5个架构原则" class="headerlink" title="设计秒杀系统时应该注意的5个架构原则"></a>设计秒杀系统时应该注意的5个架构原则</h1><p><strong>秒杀系统本质上就是一个满足大并发、高性能和高可用的分布式系统。</strong></p><h2 id="架构原则1-数据要尽量少"><a href="#架构原则1-数据要尽量少" class="headerlink" title="架构原则1. 数据要尽量少"></a>架构原则1. 数据要尽量少</h2><p>所谓“数据要尽量少”，首先是指用户请求的数据能少就少。请求的数据包括上传给系统的数据和系统返回给用户的数据（通常就是网页）。</p><h3 id="为什么“数据要尽量少”呢？"><a href="#为什么“数据要尽量少”呢？" class="headerlink" title="为什么“数据要尽量少”呢？"></a>为什么“数据要尽量少”呢？</h3><p>因为首先这些数据在网络上传输需要时间，其次不管是请求数据还是返回数据都需要服务器做处理，而服务器在写网络时通常都要做压缩和字符编码，这些都非常消耗 CPU，所以减少传输的数据量可以显著减少 CPU 的使用。例如，我们可以简化秒杀页面的大小，去掉不必要的页面装修效果，等等。</p><p>其次，“数据要尽量少”还要求系统依赖的数据能少就少，包括系统完成某些业务逻辑需要读取和保存的数据，这些数据一般是和后台服务以及数据库打交道的。调用其他服务会涉及数据的序列化和反序列化，而这也是 CPU 的一大杀手，同样也会增加延时。而且，数据库本身也容易成为一个瓶颈，所以和数据库打交道越少越好，数据越简单、越小则越好。</p><h2 id="架构原则2-请求数要尽量少"><a href="#架构原则2-请求数要尽量少" class="headerlink" title="架构原则2. 请求数要尽量少"></a>架构原则2. 请求数要尽量少</h2><p>用户请求的页面返回后，浏览器渲染这个页面还要包含其他的额外请求，比如说，这个页面依赖的 CSS/JavaScript、图片，以及 Ajax 请求等等都定义为“额外请求”，这些额外请求应该尽量少。因为浏览器每发出一个请求都多少会有一些消耗，例如建立连接要做三次握手，有的时候有页面依赖或者连接数限制，一些请求（例如 JavaScript）还需要串行加载等。另外，如果不同请求的域名不一样的话，还涉及这些域名的 DNS 解析，可能会耗时更久。所以你要记住的是，减少请求数可以显著减少以上这些因素导致的资源消耗。</p><h2 id="架构原则3-路径要尽量短"><a href="#架构原则3-路径要尽量短" class="headerlink" title="架构原则3. 路径要尽量短"></a>架构原则3. 路径要尽量短</h2><p>所谓“路径”，就是用户发出请求到返回数据这个过程中，需求经过的中间的节点数。</p><p>通常，这些节点可以表示为一个系统或者一个新的 Socket 连接（比如代理服务器只是创建一个新的 Socket 连接来转发请求）。每经过一个节点，一般都会产生一个新的 Socket 连接。</p><p>然而，每增加一个连接都会增加新的不确定性。从概率统计上来说，假如一次请求经过 5个节点，每个节点的可用性是 99.9% 的话，那么整个请求的可用性是：99.9% 的 5 次方，约等于 99.5%。</p><p>所以缩短请求路径不仅可以增加可用性，同样可以有效提升性能（减少中间节点可以减少数据的序列化与反序列化），并减少延时（可以减少网络传输耗时)。</p><h2 id="架构原则4-依赖要尽量少"><a href="#架构原则4-依赖要尽量少" class="headerlink" title="架构原则4. 依赖要尽量少"></a>架构原则4. 依赖要尽量少</h2><p>所谓依赖，指的是要完成一次用户请求必须依赖的系统或者服务，这里的依赖指的是强依赖。</p><p>举个例子，比如说你要展示秒杀页面，而这个页面必须强依赖商品信息、用户信息，还有其他如优惠券、成交列表等这些对秒杀不是非要不可的信息（弱依赖），这些弱依赖在紧急情况下就可以去掉。</p><p>要减少依赖，我们可以给系统进行分级，比如 0 级系统、1 级系统、2 级系统、3 级系统，0 级系统如果是最重要的系统，那么 0 级系统强依赖的系统也同样是最重要的系统，以此类推。</p><h2 id="架构原则5-不要有单点"><a href="#架构原则5-不要有单点" class="headerlink" title="架构原则5. 不要有单点"></a>架构原则5. 不要有单点</h2><p>系统中的单点可以说是系统架构上的一个大忌，因为单点意味着没有备份，风险不可控，我们设计分布式系统最重要的原则就是“消除单点”。</p><p>那如何避免单点呢？我认为关键点是避免将服务的状态和机器绑定，即把服务无状态化，这样服务就可以在机器中随意移动。</p><p>如何那把服务的状态和机器解耦呢？这里也有很多实现方式。例如把和机器相关的配置动态化，这些参数可以通过配置中心来动态推送，在服务启动时动态拉取下来，我们在这些配置中心设置一些规则来方便地改变这些映射关系。</p><p>应用无状态化是有效避免单点的一种方式，但是像存储服务本身很难无状态化，因为数据要存储在磁盘上，本身就要和机器绑定，那么这种场景一般要通过冗余多个备份的方式来解决单点问题。</p><h1 id="如何才能做好动静分离？有哪些方案可选？"><a href="#如何才能做好动静分离？有哪些方案可选？" class="headerlink" title="如何才能做好动静分离？有哪些方案可选？"></a>如何才能做好动静分离？有哪些方案可选？</h1><h2 id="何为动静数据"><a href="#何为动静数据" class="headerlink" title="何为动静数据"></a>何为动静数据</h2><p><strong>动态数据”和“静态数据”的主要区别就是看页面中输出的数据是否和URL、浏览者、时间、地域相关，以及是否含有 Cookie 等私密数据。</strong></p><h3 id="怎样对静态数据做缓存"><a href="#怎样对静态数据做缓存" class="headerlink" title="怎样对静态数据做缓存"></a>怎样对静态数据做缓存</h3><ul><li>第一，你应该把静态数据缓存到离用户最近的地方。</li><li>第二，静态化改造就是要直接缓存 HTTP 连接。</li><li>第三，让谁来缓存静态数据也很重要。</li></ul><h2 id="如何做动静分离的改造"><a href="#如何做动静分离的改造" class="headerlink" title="如何做动静分离的改造"></a>如何做动静分离的改造</h2><ul><li><ol><li>URL 唯一化。</li></ol></li><li><ol start="2"><li>分离浏览者相关的因素。</li></ol></li><li><ol start="3"><li>分离时间因素。</li></ol></li><li><ol start="4"><li>异步化地域因素。</li></ol></li><li><ol start="5"><li>去掉 Cookie。</li></ol></li></ul><h2 id="动静分离的几种架构方案"><a href="#动静分离的几种架构方案" class="headerlink" title="动静分离的几种架构方案"></a>动静分离的几种架构方案</h2><h3 id="方案-1：实体机单机部署"><a href="#方案-1：实体机单机部署" class="headerlink" title="方案 1：实体机单机部署"></a>方案 1：实体机单机部署</h3><h3 id="方案-2：统一-Cache-层"><a href="#方案-2：统一-Cache-层" class="headerlink" title="方案 2：统一 Cache 层"></a>方案 2：统一 Cache 层</h3><h3 id="方案-3：上-CDN"><a href="#方案-3：上-CDN" class="headerlink" title="方案 3：上 CDN"></a>方案 3：上 CDN</h3><h1 id="二八原则：有针对性地处理好系统的“热点数据”"><a href="#二八原则：有针对性地处理好系统的“热点数据”" class="headerlink" title="二八原则：有针对性地处理好系统的“热点数据”"></a>二八原则：有针对性地处理好系统的“热点数据”</h1><h2 id="为什么要关注热点"><a href="#为什么要关注热点" class="headerlink" title="为什么要关注热点"></a>为什么要关注热点</h2><p>首先，热点请求会大量占用服务器处理资源，虽然这个热点可能只占请求总量的亿分之一，然而却可能抢占 90% 的服务器资源，如果这个热点请求还是没有价值的无效请求，那么对系统资源来说完全是浪费。</p><p>其次，即使这些热点是有效的请求，我们也要识别出来做针对性的优化，从而用更低的代价来支撑这些热点请求。</p><h2 id="什么是“热点”"><a href="#什么是“热点”" class="headerlink" title="什么是“热点”"></a>什么是“热点”</h2><p>热点分为热点操作和热点数据。</p><p>所谓“热点操作”，例如大量的刷新页面、大量的添加购物车、双十一零点大量的下单等都属于此类操作。对系统来说，这些操作可以抽象为“读请求”和“写请求”，这两种热点请求的处理方式大相径庭，读请求的优化空间要大一些，而写请求的瓶颈一般都在存储层，优化的思路就是根据 CAP 理论做平衡。</p><p>而“热点数据”就是用户的热点请求对应的数据。而热点数据又分为“静态热点数据”和“动态热点数据”。</p><ul><li><p>所谓“静态热点数据”，就是能够提前预测的热点数据。例如，我们可以通过卖家报名的方式提前筛选出来，通过报名系统对这些热点商品进行打标。另外，我们还可以通过大数据分析来提前发现热点商品，比如我们分析历史成交记录、用户的购物车记录，来发现哪些商品可能更热门、更好卖，这些都是可以提前分析出来的热点。</p></li><li><p>所谓“动态热点数据”，就是不能被提前预测到的，系统在运行过程中临时产生的热点。例如，卖家在抖音上做了广告，然后商品一下就火了，导致它在短时间内被大量购买。</p></li></ul><h2 id="发现热点数据"><a href="#发现热点数据" class="headerlink" title="发现热点数据"></a>发现热点数据</h2><h2 id="处理热点数据"><a href="#处理热点数据" class="headerlink" title="处理热点数据"></a>处理热点数据</h2><p>处理热点数据通常有几种思路：一是优化，二是限制，三是隔离。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>优化热点数据最有效的办法就是缓存热点数据，如果热点数据做了动静分离，那么可以长期缓存静态数据。但是，缓存热点数据更多的是“临时”缓存，即不管是静态数据还是动态数据，都用一个队列短暂地缓存数秒钟，由于队列长度有限，可以采用LRU 淘汰算法替换。</p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>限制更多的是一种保护机制，限制的办法也有很多，例如对被访问商品的ID 做一致性 Hash，然后根据 Hash 做分桶，每个分桶设置一个处理队列，这样可以把热点商品限制在一个请求队列里，防止因某些热点商品占用太多的服务器资源，而使其他请求始终得不到服务器的处理资源。</p><h3 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h3><p>秒杀系统设计的第一个原则就是将这种热点数据隔离出来，不要让 1%的请求影响到另外的 99%，隔离出来后也更方便对这 1% 的请求做针对性的优化。</p><p>具体到“秒杀”业务，我们可以在以下几个层次实现隔离。</p><ul><li><ol><li>业务隔离。把秒杀做成一种营销活动，卖家要参加秒杀这种营销活动需要单独报名，从技术上来说，卖家报名后对我们来说就有了已知热点，因此可以提前做好预热。</li></ol></li><li><ol start="2"><li>系统隔离。系统隔离更多的是运行时的隔离，可以通过分组部署的方式和另外 99% 分开。秒杀可以申请单独的域名，目的也是让请求落到不同的集群中。</li></ol></li><li><ol start="3"><li>数据隔离。秒杀所调用的数据大部分都是热点数据，比如会启用单独的 Cache 集群或者MySQL 数据库来放热点数据，目的也是不想 0.01% 的数据有机会影响 99.99% 数据。</li></ol></li></ul><h1 id="流量削峰这事应该怎么做？"><a href="#流量削峰这事应该怎么做？" class="headerlink" title="流量削峰这事应该怎么做？"></a>流量削峰这事应该怎么做？</h1><h2 id="为什么要削峰"><a href="#为什么要削峰" class="headerlink" title="为什么要削峰"></a>为什么要削峰</h2><p>削峰的存在，一是可以让服务端处理变得更加平稳，二是可以节省服务器的资源成本。针对秒杀这一场景，削峰从本质上来说就是更多地延缓用户请求的发出，以便减少和过滤掉一些无效请求，它遵从“请求数要尽量少”的原则。</p><p>流量削峰的一些操作思路：排队、答题、分层过滤，这三个都是无损（即不会损失用户的发出请求）的实现方案。</p><h2 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h2><p>要对流量进行削峰，最容易想到的解决方案就是用消息队列来缓冲瞬时流量，把同步的直接调用转换成异步的间接推送，中间通过一个队列在一端承接瞬时的流量洪峰，在另一端平滑地将消息推送出去。在这里，消息队列就像“水库”一样， 拦蓄上游的洪水，削减进入下游河道的洪峰流量，从而达到减免洪水灾害的目的。</p><p>用消息队列来缓冲瞬时流量的方案，如下图所示：</p><p><img src="/2021/07/18/interview-seckill-system-design/%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9D%A5%E7%BC%93%E5%86%B2%E7%9E%AC%E6%97%B6%E6%B5%81%E9%87%8F.png" alt></p><p>但是，如果流量峰值持续一段时间达到了消息队列的处理上限，例如本机的消息积压达到了存储空间的上限，消息队列同样也会被压垮，这样虽然保护了下游的系统，但是和直接把请求丢弃也没多大的区别。就像遇到洪水爆发时，即使是有水库恐怕也无济于事。</p><p>除了消息队列，类似的排队方式还有很多，例如：</p><ol><li>利用线程池加锁等待也是一种常用的排队方式；</li><li>先进先出、先进后出等常用的内存排队算法的实现方式；</li><li>把请求序列化到文件中，然后再顺序地读文件（例如基于 MySQL binlog 的同步机制）来恢复请求等方式。</li></ol><h2 id="答题"><a href="#答题" class="headerlink" title="答题"></a>答题</h2><p>主要是为了增加购买的复杂度，从而达到两个目的:<br>第一个目的是防止部分买家使用秒杀器在参加秒杀时作弊。<br>第二个目的其实就是延缓请求，起到对请求流量进行削峰的作用，从而让系统能够更好地支持瞬时的流量高峰。</p><p>秒杀答题的设计思路：</p><p><img src="/2021/07/18/interview-seckill-system-design/%E7%A7%92%E6%9D%80%E7%AD%94%E9%A2%98.png" alt></p><p>如上图所示，整个秒杀答题的逻辑主要分为 3 部分：</p><ul><li><ol><li>题库生成模块，这个部分主要就是生成一个个问题和答案，其实题目和答案本身并不需要很复杂，重要的是能够防止由机器来算出结果，即防止秒杀器来答题。</li></ol></li><li><ol start="2"><li>题库的推送模块，用于在秒杀答题前，把题目提前推送给详情系统和交易系统。题库的推送主要是为了保证每次用户请求的题目是唯一的，目的也是防止答题作弊。</li></ol></li><li><ol start="3"><li>题目的图片生成模块，用于把题目生成为图片格式，并且在图片里增加一些干扰因素。这也同样是为防止机器直接来答题，它要求只有人才能理解题目本身的含义。这里还要注意一点，由于答题时网络比较拥挤，我们应该把题目的图片提前推送到 CDN 上并且要进行预热，不然的话当用户真正请求题目时，图片可能加载比较慢，从而影响答题的体验。</li></ol></li></ul><p>真正答题的逻辑比较简单，可以理解为：<strong>当用户提交的答案和题目对应的答案做比较，如果通过了就继续进行下一步的下单逻辑，否则就失败。我们可以把问题和答案用下面这样的key 来进行 MD5 加密</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">问题 key：userId+itemId+question_Id+time+PK</span><br><span class="line">答案 key：userId+itemId+answer+PK</span><br></pre></td></tr></table></figure><p>验证的逻辑如下图所示：</p><p><img src="/2021/07/18/interview-seckill-system-design/%E7%AD%94%E9%A2%98%E7%9A%84%E9%AA%8C%E8%AF%81%E9%80%BB%E8%BE%91.png" alt></p><p>注意，这里面的验证逻辑，除了验证问题的答案以外，还包括用户本身身份的验证，例如是否已经登录、用户的Cookie 是否完整、用户是否重复频繁提交等。</p><p>除了做正确性验证，我们还可以对提交答案的时间做些限制，例如从开始答题到接受答案要超过 1s，因为小于 1s 是人为操作的可能性很小，这样也能防止机器答题的情况。</p><h2 id="分层过滤"><a href="#分层过滤" class="headerlink" title="分层过滤"></a>分层过滤</h2><p>分层过滤其实就是采用“漏斗”式设计来处理请求的，如下图所示：</p><p><img src="/2021/07/18/interview-seckill-system-design/%E5%88%86%E5%B1%82%E8%BF%87%E6%BB%A4.png" alt></p><p>假如请求分别经过 CDN、前台读系统（如商品详情系统）、后台系统（如交易系统）和数据库这几层，那么：</p><ul><li>大部分数据和流量在用户浏览器或者 CDN 上获取，这一层可以拦截大部分数据的读取；</li><li>经过第二层（即前台系统）时数据（包括强一致性的数据）尽量得走 Cache，过滤一些无效的请求；</li><li>再到第三层后台系统，主要做数据的二次检验，对系统做好保护和限流，这样数据量和请求就进一步减少；</li><li>最后在数据层完成数据的强一致性校验。</li></ul><p>分层过滤的核心思想是：<strong>在不同的层次尽可能地过滤掉无效请求，让“漏斗”最末端的才是有效请求。</strong></p><p>分层校验的基本原则是：</p><ul><li><ol><li>将动态请求的读数据缓存（Cache）在 Web 端，过滤掉无效的数据读；</li></ol></li><li><ol start="2"><li>对读数据不做强一致性校验，减少因为一致性校验产生瓶颈的问题；</li></ol></li><li><ol start="3"><li>对写数据进行基于时间的合理分片，过滤掉过期的失效请求；</li></ol></li><li><ol start="4"><li>对写请求做限流保护，将超出系统承载能力的请求过滤掉；</li></ol></li><li><ol start="5"><li>对写数据进行强一致性校验，只保留最后有效的数据。</li></ol></li></ul><p>分层校验的目的是：在读系统中，尽量减少由于一致性校验带来的系统瓶颈，但是尽量将不影响性能的检查条件提前，如用户是否具有秒杀资格、商品状态是否正常、用户答题是否正确、秒杀是否已经结束、是否非法请求、营销等价物是否充足等；在写数据系统中，主要对写的数据（如“库存”）做一致性检查，最后在数据库层保证数据的最终准确性（如“库存”不能减为负数）。</p><h1 id="影响性能的因素有哪些？又该如何提高系统的性能？"><a href="#影响性能的因素有哪些？又该如何提高系统的性能？" class="headerlink" title="影响性能的因素有哪些？又该如何提高系统的性能？"></a>影响性能的因素有哪些？又该如何提高系统的性能？</h1><h2 id="影响性能的因素"><a href="#影响性能的因素" class="headerlink" title="影响性能的因素"></a>影响性能的因素</h2><h3 id="响应时间和-QPS"><a href="#响应时间和-QPS" class="headerlink" title="响应时间和 QPS"></a>响应时间和 QPS</h3><p>对于大部分的 Web 系统而言，响应时间一般都是由 CPU 执行时间和线程等待时间（比如RPC、IO 等待、Sleep、Wait 等）组成，即服务器在处理一个请求时，一部分是 CPU 本身在做运算，还有一部分是在各种等待。</p><h3 id="线程数对-QPS-的影响"><a href="#线程数对-QPS-的影响" class="headerlink" title="线程数对 QPS 的影响"></a>线程数对 QPS 的影响</h3><p>线程数 = [(线程等待时间 + 线程 CPU 时间) / 线程 CPU 时间] × CPU 数量</p><p>所以：要提升性能我们就要减少 CPU 的执行时间，另外就是要设置一个合理的并发线程数，通过这两方面来显著提升服务器的性能。</p><h2 id="如何发现瓶颈"><a href="#如何发现瓶颈" class="headerlink" title="如何发现瓶颈"></a>如何发现瓶颈</h2><p>我们定位的场景是秒杀，它的瓶颈更多地发生在 CPU 上。</p><p>那么，如何发现 CPU 的瓶颈呢？其实有很多 CPU 诊断工具可以发现 CPU 的消耗，最常用的就是 JProfiler 和 Yourkit 这两个工具，它们可以列出整个请求中每个函数的 CPU 执行时间，可以发现哪个函数消耗的 CPU 时间最多，以便你有针对性地做优化。</p><h2 id="如何优化系统"><a href="#如何优化系统" class="headerlink" title="如何优化系统"></a>如何优化系统</h2><h3 id="减少编码"><a href="#减少编码" class="headerlink" title="减少编码"></a>减少编码</h3><p>Java 的编码运行比较慢，这是 Java 的一大硬伤。在很多场景下，只要涉及字符串的操作（如输入输出操作、I/O 操作）都比较耗 CPU 资源，不管它是磁盘 I/O 还是网络 I/O，因为都需要将字符转换成字节，而这个转换必须编码。</p><p>每个字符的编码都需要查表，而这种查表的操作非常耗资源，所以减少字符到字节或者相反的转换、减少字符编码会非常有成效。减少编码就可以大大提升性能。</p><p>那么如何才能减少编码呢？<br>例如，网页输出是可以直接进行流输出的，即用resp.getOutputStream() 函数写数据，把一些静态的数据提前转化成字节，等到真正往外写的时候再直接用 OutputStream() 函数写，就可以减少静态数据的编码转换。</p><h3 id="减少序列化"><a href="#减少序列化" class="headerlink" title="减少序列化"></a>减少序列化</h3><p>序列化也是 Java 性能的一大天敌，减少 Java 中的序列化操作也能大大提升性能。又因为序列化往往是和编码同时发生的，所以减少序列化也就减少了编码。</p><p>序列化大部分是在 RPC 中发生的，因此避免或者减少 RPC 就可以减少序列化，当然当前的序列化协议也已经做了很多优化来提升性能。有一种新的方案，就是可以将多个关联性比较强的应用进行“合并部署”，而减少不同应用之间的 RPC 也可以减少序列化的消耗。</p><p>所谓“合并部署”，就是把两个原本在不同机器上的不同应用合并部署到一台机器上，当然不仅仅是部署在一台机器上，还要在同一个 Tomcat 容器中，且不能走本机的 Socket，这样才能避免序列化的产生。</p><h3 id="Java-极致优化"><a href="#Java-极致优化" class="headerlink" title="Java 极致优化"></a>Java 极致优化</h3><p>Java 和通用的 Web 服务器（如 Nginx 或 Apache 服务器）相比，在处理大并发的 HTTP请求时要弱一点，所以一般我们都会对大流量的 Web 系统做静态化改造，让大部分请求和数据直接在 Nginx 服务器或者 Web 代理服务器（如 Varnish、Squid 等）上直接返回（这样可以减少数据的序列化与反序列化），而 Java 层只需处理少量数据的动态请求。针对这些请求，我们可以使用以下手段进行优化：</p><ul><li><p>直接使用 Servlet 处理请求。避免使用传统的 MVC 框架，这样可以绕过一大堆复杂且用处不大的处理逻辑，节省 1ms 时间（具体取决于你对 MVC 框架的依赖程度）。</p></li><li><p>直接输出流数据。使用 resp.getOutputStream() 而不是 resp.getWriter() 函数，可以省掉一些不变字符数据的编码，从而提升性能；数据输出时推荐使用 JSON 而不是模板引擎（一般都是解释执行）来输出页面。</p></li></ul><h3 id="并发读优化"><a href="#并发读优化" class="headerlink" title="并发读优化"></a>并发读优化</h3><p>如何彻底解决单点的瓶颈：<br>答案是采用应用层的 LocalCache，即在秒杀系统的单机上缓存商品相关的数据。</p><p>那么，又如何缓存（Cache）数据呢？你需要划分成动态数据和静态数据分别进行处理：</p><ul><li>像商品中的“标题”和“描述”这些本身不变的数据，会在秒杀开始之前全量推送到秒杀机器上，并一直缓存到秒杀结束；</li><li>像库存这类动态数据，会采用“被动失效”的方式缓存一定时间（一般是数秒），失效后再去缓存拉取最新的数据。</li></ul><p>疑惑：像库存这种频繁更新的数据，一旦数据不一致，会不会导致超卖？<br>这就要用到前面介绍的读数据的分层校验原则了，读的场景可以允许一定的脏数据，因为这里的误判只会导致少量原本无库存的下单请求被误认为有库存，可以等到真正写数据时再保证最终的一致性，通过在数据的高可用性和一致性之间的平衡，来解决高并发的数据读取问题。</p><h1 id="秒杀系统“减库存”设计的核心逻辑"><a href="#秒杀系统“减库存”设计的核心逻辑" class="headerlink" title="秒杀系统“减库存”设计的核心逻辑"></a>秒杀系统“减库存”设计的核心逻辑</h1><h2 id="减库存有哪几种方式"><a href="#减库存有哪几种方式" class="headerlink" title="减库存有哪几种方式"></a>减库存有哪几种方式</h2><p>在正常的电商平台购物场景中，用户的实际购买过程一般分为两步：下单和付款。</p><p>那如果你是架构师，你会在哪个环节完成减库存的操作呢？总结来说，减库存操作一般有如下几个方式：</p><ul><li><p>下单减库存，即当买家下单后，在商品的总库存中减去买家购买数量。下单减库存是最简单的减库存方式，也是控制最精确的一种，下单时直接通过数据库的事务机制控制商品库存，这样一定不会出现超卖的情况。但是你要知道，有些人下完单可能并不会付款。</p></li><li><p>付款减库存，即买家下单后，并不立即减库存，而是等到有用户付款后才真正减库存，否则库存一直保留给其他买家。但因为付款时才减库存，如果并发比较高，有可能出现买家下单后付不了款的情况，因为可能商品已经被其他人买走了。</p></li><li><p>预扣库存，这种方式相对复杂一些，买家下单后，库存为其保留一定的时间（如 10 分钟），超过这个时间，库存将会自动释放，释放后其他买家就可以继续购买。在买家付款前，系统会校验该订单的库存是否还有保留：如果没有保留，则再次尝试预扣；如果库存不足（也就是预扣失败）则不允许继续付款；如果预扣成功，则完成付款并实际地减去库存。</p></li></ul><h2 id="减库存可能存在的问题"><a href="#减库存可能存在的问题" class="headerlink" title="减库存可能存在的问题"></a>减库存可能存在的问题</h2><h2 id="大型秒杀中如何减库存？"><a href="#大型秒杀中如何减库存？" class="headerlink" title="大型秒杀中如何减库存？"></a>大型秒杀中如何减库存？</h2><p>目前来看，业务系统中最常见的就是预扣库存方案，像你在买机票、买电影票时，下单后一般都有个“有效付款时间”，超过这个时间订单自动释放，这都是典型的预扣库存方案。</p><p>由于参加秒杀的商品，一般都是“抢到就是赚到”，所以成功下单后却不付款的情况比较少，再加上卖家对秒杀商品的库存有严格限制，所以秒杀商品采用“下单减库存”更加合理。另外，理论上由于“下单减库存”比“预扣库存”以及涉及第三方支付的“付款减库存”在逻辑上更为简单，所以性能上更占优势。</p><p>下单减库存”在数据一致性上，主要就是保证大并发请求时库存数据不能为负数，也就是要保证数据库中的库存字段值不能为负数，一般我们有多种解决方案：一种是在应用程序中通过事务来判断，即保证减后库存不能为负数，否则就回滚；另一种办法是直接设置数据库的字段数据为无符号整数，这样减后库存字段值小于零时会直接执行 SQL 语句来报错；再有一种就是使用 CASE WHEN 判断语句，例如这样的SQL 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> item <span class="keyword">SET</span> inventory = <span class="keyword">CASE</span> <span class="keyword">WHEN</span> inventory &gt;= xxx <span class="keyword">THEN</span></span><br><span class="line">inventory-xxx <span class="keyword">ELSE</span> inventory <span class="keyword">END</span></span><br></pre></td></tr></table></figure><h2 id="秒杀减库存的极致优化"><a href="#秒杀减库存的极致优化" class="headerlink" title="秒杀减库存的极致优化"></a>秒杀减库存的极致优化</h2><p>由于 MySQL 存储数据的特点，同一数据在数据库里肯定是一行存储（MySQL），因此会有大量线程来竞争 InnoDB 行锁，而并发度越高时等待线程会越多，TPS（TransactionPer Second，即每秒处理的消息数）会下降，响应时间（RT）会上升，数据库的吞吐量就会严重受影响。</p><p>这就可能引发一个问题，就是单个热点商品会影响整个数据库的性能， 导致 0.01% 的商品影响 99.99% 的商品的售卖，这是我们不愿意看到的情况。一个解决思路是遵循前面介绍的原则进行隔离，把热点商品放到单独的热点库中。但是这无疑会带来维护上的麻烦，比如要做热点数据的动态迁移以及单独的数据库等。</p><p>而分离热点商品到单独的数据库还是没有解决并发锁的问题，我们应该怎么办呢？要解决并发锁的问题，有两种办法：</p><ul><li><p>应用层做排队。按照商品维度设置队列顺序执行，这样能减少同一台机器对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库连接的数量，防止热点商品占用太多的数据库连接。</p></li><li><p>数据库层做排队。应用层只能做到单机的排队，但是应用机器数本身很多，这种排队方式控制并发的能力仍然有限，所以如果能在数据库层做全局排队是最理想的。阿里的数据库团队开发了针对这种 MySQL 的 InnoDB 层上的补丁程序（patch），可以在数据库层上对单行记录做到并发排队。</p></li></ul><p>疑惑：排队和锁竞争不都是要等待吗，有啥区别？</p><p>MySQL中，InnoDB 内部的死锁检测，以及 MySQL Server 和InnoDB 的切换会比较消耗性能。<br>淘宝的 MySQL 核心团队还做了很多其他方面的优化，如COMMIT_ON_SUCCESS 和 ROLLBACK_ON_FAIL 的补丁程序，配合在 SQL 里面加提示（hint），在事务里不需要等待应用层提交（COMMIT），而在数据执行完最后一条 SQL后，直接根据 TARGET_AFFECT_ROW 的结果进行提交或回滚，可以减少网络等待时间（平均约 0.7ms）。</p><p>另外，数据更新问题除了前面介绍的热点隔离和排队处理之外，还有些场景（如对商品的lastmodifytime 字段的）更新会非常频繁，在某些场景下这些多条 SQL 是可以合并的，一定时间内只要执行最后一条 SQL 就行了，以便减少对数据库的更新操作。</p><h1 id="准备Plan-B：如何设计兜底方案"><a href="#准备Plan-B：如何设计兜底方案" class="headerlink" title="准备Plan B：如何设计兜底方案?"></a>准备Plan B：如何设计兜底方案?</h1><h2 id="高可用建设应该从哪里着手"><a href="#高可用建设应该从哪里着手" class="headerlink" title="高可用建设应该从哪里着手"></a>高可用建设应该从哪里着手</h2><p>说到系统的高可用建设，它其实是一个系统工程，需要考虑到系统建设的各个阶段，也就是说它其实贯穿了系统建设的整个生命周期：</p><p><img src="/2021/07/18/interview-seckill-system-design/%E9%AB%98%E5%8F%AF%E7%94%A8%E5%BB%BA%E8%AE%BE.png" alt></p><ol><li><p>架构阶段：架构阶段主要考虑系统的可扩展性和容错性，要避免系统出现单点问题。例如多机房单元化部署，即使某个城市的某个机房出现整体故障，仍然不会影响整体网站的运转。</p></li><li><p>编码阶段：编码最重要的是保证代码的健壮性，例如涉及远程调用问题时，要设置合理的超时退出机制，防止被其他系统拖垮，也要对调用的返回结果集有预期，防止返回的结果超出程序处理范围，最常见的做法就是对错误异常进行捕获，对无法预料的错误要有默认处理结果。</p></li><li><p>测试阶段：测试主要是保证测试用例的覆盖度，保证最坏情况发生时，我们也有相应的处理流程。</p></li><li><p>发布阶段：发布时也有一些地方需要注意，因为发布时最容易出现错误，因此要有紧急的回滚机制。</p></li><li><p>运行阶段：运行时是系统的常态，系统大部分时间都会处于运行态，运行态最重要的是对系统的监控要准确及时，发现问题能够准确报警并且报警数据要准确详细，以便于排查问题。</p></li><li><p>故障发生：故障发生时首先最重要的就是及时止损，例如由于程序问题导致商品价格错误，那就要及时下架商品或者关闭购买链接，防止造成重大资产损失。然后就是要能够及时恢复服务，并定位原因解决问题。</p></li></ol><p>为什么系统的高可用建设要放到整个生命周期中全面考虑？<br>因为我们在每个环节中都可能犯错，而有些环节犯的错，你在后面是无法弥补的。例如在架构阶段，你没有消除单点问题，那么系统上线后，遇到突发流量把单点给挂了，你就只能干瞪眼，有时候想加机器都加不进去。所以高可用建设是一个系统工程，必须在每个环节都做好。</p><p>那么针对秒杀系统，我们重点介绍在遇到大流量时，应该从哪些方面来保障系统的稳定运行，所以更多的是看如何针对运行阶段进行处理，这就引出了接下来的内容：降级、限流和拒绝服务。</p><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>所谓“降级”，就是当系统的容量达到一定程度时，限制或者关闭系统的某些非核心功能，从而把有限的资源保留给更核心的业务。它是一个有目的、有计划的执行过程，所以对降级我们一般需要有一套预案来配合执行。如果我们把它系统化，就可以通过预案系统和开关系统来实现降级。</p><p>降级方案可以这样设计：当秒杀流量达到 5w/s 时，把成交记录的获取从展示 20 条降级到只展示 5 条。“从 20 改到 5”这个操作由一个开关来实现，也就是设置一个能够从开关系统动态获取的系统参数。</p><p><img src="/2021/07/18/interview-seckill-system-design/%E5%BC%80%E5%85%B3%E7%B3%BB%E7%BB%9F.png" alt></p><p>执行降级无疑是在系统性能和用户体验之间选择了前者，降级后肯定会影响一部分用户的体验，例如在双 11 零点时，如果优惠券系统扛不住，可能会临时降级商品详情的优惠信息展示，把有限的系统资源用在保障交易系统正确展示优惠信息上，即保障用户真正下单时的价格是正确的。所以降级的核心目标是牺牲次要的功能和用户体验来保证核心业务流程的稳定，是一个不得已而为之的举措。</p><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>如果说降级是牺牲了一部分次要的功能和用户的体验效果，那么限流就是更极端的一种保护措施了。限流就是当系统容量达到瓶颈时，我们需要通过限制一部分流量来保护系统，并做到既可以人工执行开关，也支持自动化保护的措施。</p><p>总体来说，限流既可以是在客户端限流，也可以是在服务端限流。此外，限流的实现方式既要支持 URL 以及方法级别的限流，也要支持基于QPS 和线程的限流</p><p><img src="/2021/07/18/interview-seckill-system-design/%E9%99%90%E6%B5%81%E7%B3%BB%E7%BB%9F.png" alt></p><ul><li><p>客户端限流，好处可以限制请求的发出，通过减少发出无用请求从而减少对系统的消耗。缺点就是当客户端比较分散时，没法设置合理的限流阈值：如果阈值设的太小，会导致服务端没有达到瓶颈时客户端已经被限制；而如果设的太大，则起不到限制的作用。</p></li><li><p>服务端限流，好处是可以根据服务端的性能设置合理的阈值，而缺点就是被限制的请求都是无效的请求，处理这些无效的请求本身也会消耗服务器资源。</p></li></ul><p>在限流的实现手段上来讲，基于 QPS 和线程数的限流应用最多，最大 QPS 很容易通过压测提前获取，例如我们的系统最高支持 1w QPS 时，可以设置 8000 来进行限流保护。线程数限流在客户端比较有效，例如在远程调用时我们设置连接池的线程数，超出这个并发线程请求，就将线程进行排队或者直接超时丢弃。</p><p>限流无疑会影响用户的正常请求，所以必然会导致一部分用户请求失败，因此在系统处理这种异常时一定要设置超时时间，防止因被限流的请求不能 fast fail（快速失败）而拖垮系统。</p><h2 id="拒绝服务"><a href="#拒绝服务" class="headerlink" title="拒绝服务"></a>拒绝服务</h2><p>如果限流还不能解决问题，最后一招就是直接拒绝服务了。</p><p>当系统负载达到一定阈值时，例如 CPU 使用率达到 90% 或者系统 load 值达到 2*CPU 核数时，系统直接拒绝所有请求，这种方式是最暴力但也最有效的系统保护方式。例如秒杀系统，我们在如下几个环节设计过载保护：</p><ul><li>在最前端的 Nginx 上设置过载保护，当机器负载达到某个值时直接拒绝</li><li>HTTP 请求并返回 503 错误码，在 Java 层同样也可以设计过载保护。</li></ul><p>拒绝服务可以说是一种不得已的兜底方案，用以防止最坏情况发生，防止因把服务器压跨而长时间彻底无法提供服务。像这种系统过载保护虽然在过载时无法提供服务，但是系统仍然可以运作，当负载下降时又很容易恢复，所以每个系统和每个环节都应该设置这个兜底方案，对系统做最坏情况下的保护。</p><h1 id="答疑解惑"><a href="#答疑解惑" class="headerlink" title="答疑解惑"></a>答疑解惑</h1><h2 id="应用层用队列接受请求，然后结果怎么返回？"><a href="#应用层用队列接受请求，然后结果怎么返回？" class="headerlink" title="应用层用队列接受请求，然后结果怎么返回？"></a>应用层用队列接受请求，然后结果怎么返回？</h2><h2 id="静态化的方案中关于-Hash-分组的问题"><a href="#静态化的方案中关于-Hash-分组的问题" class="headerlink" title="静态化的方案中关于 Hash 分组的问题"></a>静态化的方案中关于 Hash 分组的问题</h2><h2 id="如何才能做好动静分离？有哪些方案可选？以及关于-Cache-失效的问题"><a href="#如何才能做好动静分离？有哪些方案可选？以及关于-Cache-失效的问题" class="headerlink" title="如何才能做好动静分离？有哪些方案可选？以及关于 Cache 失效的问题"></a>如何才能做好动静分离？有哪些方案可选？以及关于 Cache 失效的问题</h2><p>首先，咱们要有个共识，有 Cache 的地方就必然存在失效问题。为啥要失效？因为要保证<br>数据的一致性。所以要用到 Cache 必然会问如何保证 Cache 和 DB 的数据一致性，如果<br>Cache 有分组的话，还要保证一个分组中多个实例之间数据的一致性，就像保证 MySQL<br>的主从一致一样。</p><p>其实，失效有主动失效和被动失效两种方式。</p><p>被动失效，主要处理如模板变更和一些对时效性不太敏感数据的失效，采用设置一定时间长度（如只缓存 3 秒钟）这种自动失效的方式。当然，你也要开发一个后台管理界面，以便能够在紧急情况下手工失效某些 Cache。</p><p>主动失效，一般有 Cache 失效中心监控数据库表变化发送失效请求、系统发布也需要清空 Cache 数据等几种场景。其中失效中心承担了主要的失效功能，这个失效中心的逻辑图如下：</p><p><img src="/2021/07/18/interview-seckill-system-design/%E5%A4%B1%E6%95%88%E4%B8%AD%E5%BF%83.png" alt></p><p>失效中心会监控关键数据表的变更（有个中间件来解析 MySQL 的 binglog，然后发现有Insert、Update、Delete 等操作时，会把变更前的数据以及要变更的数据转成一个消息发送给订阅方），通过这种方式来发送失效请求给 Cache，从而清除 Cache 数据。如果这种失效有失效中心将失效请求发送给每个 CDN 节点上的 Console 机，然后 Console 机来发送失效请求给每台 Cache 机器。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.zhihu.com/question/54895548/answer/1352510403" target="_blank" rel="noopener">知乎_如何设计秒杀系统？</a><br><a href="https://www.bilibili.com/video/BV1DV411B7Jq" target="_blank" rel="noopener">B站_淘宝秒杀系统怎么设计？</a><br><a href="https://zhuanlan.zhihu.com/p/86017321" target="_blank" rel="noopener">这是我读过写得最好的【秒杀系统架构】分析与实战！</a><br><a href="https://github.com/tyjwan/second-kill-system/blob/main/%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F.md" target="_blank" rel="noopener">github文档_tyjwan_设计一个秒杀系统</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzIwODkzOTc1MQ==&mid=2247483938&idx=1&sn=05c11475c9da399cec711c05782e917f&chksm=977a3daaa00db4bcd7c5d27064bee7fb1f6795b87ef84e7ae198fa4206a85ba17cf1c05a24c5&token=904636431&lang=zh_CN&scene=21#wechat_redirect" target="_blank" rel="noopener">千万级 高并发 “秒杀” 架构设计（含源码）</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAxODcyNjEzNQ==&mid=2247489300&idx=1&sn=27788b31b4b89146a6dd971bc23238d0&chksm=9bd0ba8caca7339ad915c461399369bd54aa846a6e67ca99e1100f1cf77b1dc000d700ec67dd&scene=21#wechat_redirect" target="_blank" rel="noopener">秒杀架构模型设计</a><br><a href="https://zhuanlan.zhihu.com/p/92307325" target="_blank" rel="noopener">知乎_《进大厂系列》系列-秒杀系统设计</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;秒杀系统架构设计都有哪些关键点&quot;&gt;&lt;a href=&quot;#秒杀系统架构设计都有哪些关键点&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="System-Design" scheme="https://octopuslian.github.io/categories/System-Design/"/>
    
    
      <category term="系统设计" scheme="https://octopuslian.github.io/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="秒杀系统" scheme="https://octopuslian.github.io/tags/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-34-find-first-and-last-position-of-element-in-sorted-array | 在排序数组中查找元素的第一个和最后一个位置</title>
    <link href="https://octopuslian.github.io/2021/07/17/leetcode-34-find-first-and-last-position-of-element-in-sorted-array/"/>
    <id>https://octopuslian.github.io/2021/07/17/leetcode-34-find-first-and-last-position-of-element-in-sorted-array/</id>
    <published>2021-07-17T12:33:01.000Z</published>
    <updated>2021-07-17T16:20:16.701Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p><strong>进阶：你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">0 &lt;= nums.length &lt;= 105</span><br><span class="line">-109 &lt;= nums[i] &lt;= 109</span><br><span class="line">nums 是一个非递减数组</span><br><span class="line">-109 &lt;= target &lt;= 109</span><br></pre></td></tr></table></figure><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><h3 id="常规解法-暴力-O-n"><a href="#常规解法-暴力-O-n" class="headerlink" title="常规解法-暴力-O(n)"></a>常规解法-暴力-O(n)</h3><ul><li>利用数组有序的特点，从头到尾遍历一次数组</li><li>在遍历的开始，检查遍历到的元素是否等于target，遇到刚好等于target的时候，记录当前位置</li><li>接着遍历，检查遍历到大元素是否不等于target，遇到刚好不等于target的时候，记录当前位置的前一个位置即可</li></ul><h3 id="进阶解法-二分查找-O-log-n"><a href="#进阶解法-二分查找-O-log-n" class="headerlink" title="进阶解法-二分查找-O(log n)"></a>进阶解法-二分查找-O(log n)</h3><ul><li>基本思想：在一个区间范围里看处在中间位置的元素的值nums[mid]与目标元素target的大小关系，进而决定目标值落在哪一个部分里</li><li>目标元素target在有序数组中很可能存在多个</li><li>使用二分查找方法看到的处在中间元素的值nums[mid]恰好等于目标元素target的时候，还需要继续查找（继续做二分查找）</li></ul><p>方法1：使用<code>sort.SearchInts</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRange</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    leftmost := sort.SearchInts(nums, target)  <span class="comment">//sort.SearchInts封装好的二分查找</span></span><br><span class="line">    <span class="keyword">if</span> leftmost == <span class="built_in">len</span>(nums) || nums[leftmost] != target &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;  <span class="comment">//不存在，范围[-1,-1]</span></span><br><span class="line">    &#125;</span><br><span class="line">    rightmost := sort.SearchInts(nums, target + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> []<span class="keyword">int</span>&#123;leftmost, rightmost&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2：自己实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRange</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    left := search(nums, target)</span><br><span class="line">    <span class="keyword">if</span> left == <span class="built_in">len</span>(nums) || nums[left] != target &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="keyword">int</span>&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    right := search(nums, target+<span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> []<span class="keyword">int</span>&#123;left, right&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">l, r := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line"><span class="comment">// [l, r]</span></span><br><span class="line"><span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">mid := l + (r-l)&gt;&gt;<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> nums[mid] &lt; target &#123;</span><br><span class="line">l = mid + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">r = mid - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/lai-gen-gao-shou-xue-xie-er-fen-cha-zhao-y602/" target="_blank" rel="noopener">leetcode题解_来跟高手学写二分查找</a><br><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-mo-ban-go-by-xilepeng-d60d/" target="_blank" rel="noopener">leetcode题解_二分查找+模板go</a><br><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/go-er-fen-cha-zhao-de-bian-chong-by-wo-s-lajb/" target="_blank" rel="noopener">leetcode题解_Go 二分查找的变种</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="二分查找" scheme="https://octopuslian.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-704-binary-search | 二分查找</title>
    <link href="https://octopuslian.github.io/2021/07/17/leetcode-704-binary-search/"/>
    <id>https://octopuslian.github.io/2021/07/17/leetcode-704-binary-search/</id>
    <published>2021-07-17T10:25:59.000Z</published>
    <updated>2021-07-17T10:47:50.359Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">你可以假设 nums 中的所有元素是不重复的。</span><br><span class="line">n 将在 [1, 10000]之间。</span><br><span class="line">nums 的每个元素都将在 [-9999, 9999]之间。</span><br></pre></td></tr></table></figure><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><p>中规中矩的一道专门考察二分查找的题目，直接上代码，注释写的很详细了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    left,right := <span class="number">0</span>,<span class="built_in">len</span>(nums)<span class="number">-1</span>  <span class="comment">//初始化左右指针</span></span><br><span class="line">    <span class="keyword">for</span> ;left &lt;= right; &#123;</span><br><span class="line">        mid := (left + right) / <span class="number">2</span>  <span class="comment">//定中间指针</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; target &#123; <span class="comment">//如果中间指针下标所对应的值大于target</span></span><br><span class="line">            right--  <span class="comment">//右指针向左移动一位</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; target &#123; <span class="comment">//如果中间指针下标所对应的值小于target</span></span><br><span class="line">            left++ <span class="comment">//左指针向右移动一位</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] == target &#123; <span class="comment">//如果中间指针下标所对应的值等于target</span></span><br><span class="line">            <span class="keyword">return</span> mid  <span class="comment">//返回mid</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>  <span class="comment">//否则返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意一个细节：用二分查找的前提一定是这个<code>nums</code>数组是有序的，否则要先做排序。</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
      <category term="二分查找" scheme="https://octopuslian.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>Golang插件-golangci-lint 基本介绍</title>
    <link href="https://octopuslian.github.io/2021/07/16/golang-extension-golangci-lint-introduce/"/>
    <id>https://octopuslian.github.io/2021/07/16/golang-extension-golangci-lint-introduce/</id>
    <published>2021-07-15T16:24:00.000Z</published>
    <updated>2021-07-15T16:26:02.244Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --><h2 id="golangci-lint-基本介绍"><a href="#golangci-lint-基本介绍" class="headerlink" title="golangci-lint 基本介绍"></a>golangci-lint 基本介绍</h2><p>golangci-lint 是一个 Go linters 聚合器。</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>⚡ 非常快：并行运行 linter，重用 Go 构建缓存并缓存分析结果。<br>⚙️ 基于 Yaml 的配置。<br>🖥 与 VS Code、Sublime Text、GoLand、GNU Emacs、Vim、Atom、GitHub Actions 的集成。<br>🥇 包含 48 个linters，无需安装。<br>📈 由于调整了默认设置，误报的最小数量。<br>🔥带有颜色、源代码行和标记标识符的漂亮输出。</p><h2 id="golangci-lint-各配置项介绍"><a href="#golangci-lint-各配置项介绍" class="headerlink" title="golangci-lint 各配置项介绍"></a>golangci-lint 各配置项介绍</h2><table><thead><tr><th align="center">名字</th><th align="left">描述</th><th align="center">预设</th></tr></thead><tbody><tr><td align="center">deadcode</td><td align="left">找到未使用的代码</td><td align="center">没用过</td></tr><tr><td align="center">errcheck</td><td align="left">errcheck是用于在Go程序中检查未选中错误的程序。在某些情况下，这些未选中的错误可能是关键错误</td><td align="center">错误</td></tr><tr><td align="center">gosimple</td><td align="left">Linter for Go 源代码，专门用于简化代码</td><td align="center">样式</td></tr><tr><td align="center">govet</td><td align="left">Vet 检查 Go 源代码并报告可疑结构，例如参数与格式字符串不一致的 Printf 调用</td><td align="center">错误</td></tr><tr><td align="center">ineffassign</td><td align="left">检测何时不使用对现有变量的赋值</td><td align="center">没用过</td></tr><tr><td align="center">staticheck</td><td align="left">查找未使用的结构字段</td><td align="center">没用过</td></tr><tr><td align="center">typecheck</td><td align="left">就像 Go 编译器的前端一样，解析和类型检查 Go 代码</td><td align="center">错误</td></tr><tr><td align="center">unused</td><td align="left">检查未使用常量，变量，函数和类型的Go代码</td><td align="center">没用过</td></tr><tr><td align="center">varcheck</td><td align="left">查找未使用的全局变量和常量</td><td align="center">没用过</td></tr><tr><td align="center">asciicheck</td><td align="left">简单的 linter 检查您的代码是否不包含非 ASCII 标识符</td><td align="center">错误、样式</td></tr><tr><td align="center">bodyclose</td><td align="left">检查 HTTP 响应体是否成功关闭</td><td align="center">性能、错误</td></tr><tr><td align="center">cyclop</td><td align="left">检查函数和包的圈复杂度</td><td align="center">复杂性</td></tr><tr><td align="center">depguard</td><td align="left">Go linter 检查包导入是否在可接受的包列表中</td><td align="center">样式、导入、模块</td></tr><tr><td align="center">dogsled</td><td align="left">检查具有太多空白标识符的分配（例如 x, , , _, := f()）</td><td align="center">样式</td></tr><tr><td align="center">dupl</td><td align="left">代码克隆检测工具</td><td align="center">样式</td></tr><tr><td align="center">durationcheck</td><td align="left">检查两个持续时间相乘</td><td align="center">错误</td></tr><tr><td align="center">errorlint</td><td align="left">errorlint 是一个 linter，可用于查找会导致 Go 1.13 中引入的错误包装方案出现问题的代码。</td><td align="center">错误</td></tr><tr><td align="center">exhaustive</td><td align="left">检查枚举 switch 语句的详尽程度</td><td align="center">错误、样式</td></tr><tr><td align="center">exhaustivestruct</td><td align="left">检查所有结构的字段是否已初始化</td><td align="center">样式、测试</td></tr><tr><td align="center">exportloopref</td><td align="left">检查指向封闭循环变量的指针</td><td align="center">错误</td></tr><tr><td align="center">forbidigo</td><td align="left">禁止标识符</td><td align="center">样式</td></tr><tr><td align="center">forcetypeassert</td><td align="left">查找强制类型断言</td><td align="center">错误、样式</td></tr><tr><td align="center">funlen</td><td align="left">用于检测长功能的工具</td><td align="center">复杂性</td></tr><tr><td align="center">gci</td><td align="left">gci 控制 golang 包导入顺序并使其始终具有确定性；检查是否存在全局变量；该分析器检查任何发现的全局变量和错误。</td><td align="center">格式、导入</td></tr><tr><td align="center">gochecknoglobals</td><td align="left">全局变量是在包作用域中声明并且可以读取的变量，并由包内的任何函数写入。 全局变量可能导致难以跟踪的副作用。 一个函数中的代码可能改变变量状态，而另一个不相关的代码块可能是受其影响。</td><td align="center">样式</td></tr><tr><td align="center">gocognit</td><td align="left">检查 Go 代码中是否不存在 init 函数</td><td align="center">样式</td></tr><tr><td align="center">asciicheck</td><td align="left">计算和检查功能的认知复杂性</td><td align="center">复杂性</td></tr><tr><td align="center">goconst</td><td align="left">查找可以被常量替换的重复字符串</td><td align="center">样式</td></tr><tr><td align="center">gocritic</td><td align="left">提供许多诊断程序来检查错误、性能和样式问题。无需通过动态规则重新编译即可扩展。动态规则是使用 AST 模式、过滤器、报告消息和可选建议以声明方式编写的。</td><td align="center">样式、性能</td></tr><tr><td align="center">gocyclo</td><td align="left">计算并检查功能的循环复杂性</td><td align="center">样式</td></tr><tr><td align="center">godot</td><td align="left">检查评论是否在一段时间内结束</td><td align="center">样式、评论</td></tr><tr><td align="center">godox</td><td align="left">用于检测FIXME，TODO和其他注释关键词的工具</td><td align="center">样式、评论</td></tr><tr><td align="center">goerr113</td><td align="left">Golang Linter检查错误处理表达式</td><td align="center">样式、错误</td></tr><tr><td align="center">gofmt</td><td align="left">GOFMT检查代码是否是GOFMT-ed。默认情况下，此工具将使用-s选项运行以检查代码简化</td><td align="center">格式</td></tr><tr><td align="center">gofumpt</td><td align="left">gofumpt检查代码是否是gofumpt-ed</td><td align="center">格式</td></tr><tr><td align="center">goheader</td><td align="left">Checks是文件标题与模式匹配</td><td align="center">样式</td></tr><tr><td align="center">goimports</td><td align="left">Goimports 完成了 gofmt 所做的一切。 此外，它还检查未使用的导入</td><td align="center">格式、引入</td></tr><tr><td align="center">golint ⚠</td><td align="left">linter 的存储库已由所有者存档。 被revive取代。</td><td align="center">样式</td></tr><tr><td align="center">gomnd</td><td align="left">检测幻数的分析器。</td><td align="center">样式</td></tr><tr><td align="center">gomoddirectives</td><td align="left">管理 go.mod 中“replace”、“retract”和“excludes”指令的使用。</td><td align="center">样式、模块</td></tr><tr><td align="center">gomodguard</td><td align="left">允许和阻止list linter 用于直接 Go 模块依赖项。 这与 depguard 不同，depguard 有不同的块类型，例如版本约束和模块推荐。</td><td align="center">样式、引入、模块</td></tr><tr><td align="center">goprintffuncname</td><td align="left">检查打印类函数是否以结尾命名为f</td><td align="center">样式</td></tr><tr><td align="center">gosec</td><td align="left">检查安全问题的源代码</td><td align="center">错误</td></tr><tr><td align="center">ifshort</td><td align="left">尽可能检查您的代码是否对 if 语句使用了简短的语法</td><td align="center">样式</td></tr><tr><td align="center">importas</td><td align="left">强制使用一致的导入别名</td><td align="center">样式</td></tr><tr><td align="center">interfacer ⚠</td><td align="left">LINTER的存储库已被所有者存档</td><td align="center">样式</td></tr><tr><td align="center">lll</td><td align="left">报告排长队</td><td align="center">样式</td></tr><tr><td align="center">makezero</td><td align="left">使用非零初始长度查找切片声明</td><td align="center">样式、错误</td></tr><tr><td align="center">maligned ⚠</td><td align="left">linter 的存储库已由所有者存档。 替换为 govet ‘fieldalignment’。</td><td align="center">性能</td></tr><tr><td align="center">misspell</td><td align="left">在评论中查找常见拼写错误的英语单词</td><td align="center">样式、评论</td></tr><tr><td align="center">nakedret</td><td align="left">在大于指定函数长度的函数中查找裸返回</td><td align="center">样式</td></tr><tr><td align="center">nestif</td><td align="left">报告深度嵌套的 if 语句</td><td align="center">复杂性</td></tr><tr><td align="center">nilerr</td><td align="left">找到即使检查错误不是nil，也可以找到返回nil的代码。</td><td align="center">错误</td></tr><tr><td align="center">nlreturn</td><td align="left">nlreturn在返回和分支机构语句之前检查新行以增加代码清晰度</td><td align="center">样式</td></tr><tr><td align="center">noctx</td><td align="left">noctx发现没有context.context的发送HTTP请求</td><td align="center">性能、错误</td></tr><tr><td align="center">nolintlint</td><td align="left">报告不良或不足的Nolint指令</td><td align="center">样式</td></tr><tr><td align="center">paralleltest</td><td align="left">paralleltest 在你的 Go 测试中检测到 t.Parallel() 方法的缺失使用</td><td align="center">样式、测试</td></tr><tr><td align="center">prealloc</td><td align="left">查找可能预先分配的切片声明</td><td align="center">性能</td></tr><tr><td align="center">predeclared</td><td align="left">找到隐藏 Go 预先声明的标识符之一的代码</td><td align="center">样式</td></tr><tr><td align="center">promlinter</td><td align="left">通过 promlint 检查 Prometheus 指标命名</td><td align="center">样式</td></tr><tr><td align="center">revive</td><td align="left">用于 Go 的快速、可配置、可扩展、灵活且美观的 linter。 直接替换 golint。</td><td align="center">样式</td></tr><tr><td align="center">rowserrcheck</td><td align="left">检查是否已成功检查行的错误</td><td align="center">错误、SQL</td></tr><tr><td align="center">scopelint ⚠</td><td align="left">所有者已弃用了Linter的存储库。由exportloopref替换。</td><td align="center">错误</td></tr><tr><td align="center">sqlclosecheck</td><td align="left">检查sql.rows和sql.stmt是否已关闭。</td><td align="center">错误、SQL</td></tr><tr><td align="center">stylecheck</td><td align="left">STYLECHECK是GOLINT的替代品</td><td align="center">样式</td></tr><tr><td align="center">tagliatelle</td><td align="left">检查struct标签。</td><td align="center">样式</td></tr><tr><td align="center">testpackage</td><td align="left">LINTE让您使用单独的_test包</td><td align="center">样式、测试</td></tr><tr><td align="center">thelper</td><td align="left">T Helper检测Golang测试助手没有T.helper（）单元格，并检查测试助手的一致性</td><td align="center">样式</td></tr><tr><td align="center">tparallel</td><td align="left">parallel 检测 Go 测试代码中 t.Parallel() 方法的不当使用</td><td align="center">样式、测试</td></tr><tr><td align="center">unconvert</td><td align="left">删除不必要的类型转换</td><td align="center">样式</td></tr><tr><td align="center">unparam</td><td align="left">报告未使用的功能参数</td><td align="center">未使用</td></tr><tr><td align="center">wastedassign</td><td align="left">WastedAssign找到浪费的分配声明。</td><td align="center">样式</td></tr><tr><td align="center">whitespace</td><td align="left">检测前导和尾随空格的工具</td><td align="center">样式</td></tr><tr><td align="center">wrapcheck</td><td align="left">检查从外部包返回的错误是否已包装</td><td align="center">样式、错误</td></tr><tr><td align="center">wsl</td><td align="left">强制您使用空行</td><td align="center">样式</td></tr></tbody></table><p>例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"--skip-dirs=vendor"</span>,</span><br><span class="line"><span class="string">"--fast"</span>,</span><br><span class="line"><span class="string">"--enable-all"</span>,</span><br><span class="line"><span class="string">"--disable=gochecknoglobals"</span>,</span><br><span class="line"><span class="string">"--disable=lll"</span>,</span><br><span class="line"><span class="string">"--disable=gofmt"</span>,</span><br><span class="line"><span class="string">"--disable=depguard"</span>,</span><br><span class="line"><span class="string">"--disable=misspell"</span>,</span><br><span class="line"><span class="string">"--disable=gocritic"</span>,</span><br><span class="line"><span class="string">"--disable=gochecknoinits"</span>,</span><br><span class="line"><span class="string">"--disable=funlen"</span>,</span><br><span class="line"><span class="string">"--disable=wsl"</span>,</span><br><span class="line"><span class="string">"--disable=gomnd"</span>,</span><br><span class="line"><span class="string">"--disable=gosec"</span>,</span><br><span class="line"><span class="string">"--disable=nestif"</span>,</span><br><span class="line"><span class="string">"--disable=exhaustivestruct"</span>,</span><br><span class="line"><span class="string">"--disable=godot"</span>,</span><br><span class="line"><span class="string">"--disable=nlreturn"</span>,</span><br><span class="line"><span class="string">"--disable=makezero"</span>,</span><br><span class="line"><span class="string">"--disable=tagliatelle"</span>,</span><br><span class="line"><span class="string">"--disable=gocognit"</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;golangci-lint-基本介绍&quot;&gt;&lt;a href=&quot;#golangci-lint-基本介绍&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="Learn-go" scheme="https://octopuslian.github.io/categories/Learn-go/"/>
    
    
      <category term="Golang" scheme="https://octopuslian.github.io/tags/Golang/"/>
    
      <category term="插件" scheme="https://octopuslian.github.io/tags/%E6%8F%92%E4%BB%B6/"/>
    
      <category term="golangci-lint" scheme="https://octopuslian.github.io/tags/golangci-lint/"/>
    
  </entry>
  
  <entry>
    <title>VSCode下Golang的配置以及Git分支合并注意事项</title>
    <link href="https://octopuslian.github.io/2021/07/16/golang-vscode-setting-and-git-featuregolang-vscode-setting-and-git-featuregolang-vscode-setting-and-git-feature/"/>
    <id>https://octopuslian.github.io/2021/07/16/golang-vscode-setting-and-git-featuregolang-vscode-setting-and-git-featuregolang-vscode-setting-and-git-feature/</id>
    <published>2021-07-15T16:03:45.000Z</published>
    <updated>2021-07-15T16:19:46.420Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --><h2 id="Golang环境配置"><a href="#Golang环境配置" class="headerlink" title="Golang环境配置"></a>Golang环境配置</h2><h3 id="1-Golang-编译环境安装"><a href="#1-Golang-编译环境安装" class="headerlink" title="1. Golang 编译环境安装"></a>1. Golang 编译环境安装</h3><ul><li><a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">点击下载Golang编译环境安装文件</a></li><li>或者<a href="https://studygolang.com/dl" target="_blank" rel="noopener">https://studygolang.com/dl</a></li></ul><p>完成后，安装文件</p><p>安装完成后，配置windows的系统环境变量，增加<code>golang\bin</code>目录</p><p><img src="/2021/07/16/golang-vscode-setting-and-git-featuregolang-vscode-setting-and-git-featuregolang-vscode-setting-and-git-feature/go1.png" alt><br><img src="/2021/07/16/golang-vscode-setting-and-git-featuregolang-vscode-setting-and-git-featuregolang-vscode-setting-and-git-feature/go2.png" alt></p><ul><li><a href="http://mingw-w64.org/doku.php/download" target="_blank" rel="noopener">点击下载Mingw</a></li></ul><p>完成后，解压文件，生成一个全新文件夹<code>mingw64</code>，将此放到任意位置</p><p>进入<code>mingw64\bin</code>文件夹，拷贝<code>mingw32-make.exe</code>文件，并重命名为<code>make.exe</code></p><p>配置windows的系统环境变量，增加<code>mingw64\bin</code>目录</p><p><img src="/2021/07/16/golang-vscode-setting-and-git-featuregolang-vscode-setting-and-git-featuregolang-vscode-setting-and-git-feature/mg1.png" alt></p><ul><li><p><a href="https://code.visualstudio.com/Download/" target="_blank" rel="noopener">点击下载VSCode</a></p></li><li><p>打开<code>VSCode</code>，进入Extensions，下载其他插件</p></li></ul><p><img src="/2021/07/16/golang-vscode-setting-and-git-featuregolang-vscode-setting-and-git-featuregolang-vscode-setting-and-git-feature/cha-jian.png" alt></p><h3 id="3-检验插件是否运作的方法"><a href="#3-检验插件是否运作的方法" class="headerlink" title="3. 检验插件是否运作的方法"></a>3. 检验插件是否运作的方法</h3><h4 id="检查插件goimport是否运作"><a href="#检查插件goimport是否运作" class="headerlink" title="检查插件goimport是否运作"></a>检查插件goimport是否运作</h4><p><img src="/2021/07/16/golang-vscode-setting-and-git-featuregolang-vscode-setting-and-git-featuregolang-vscode-setting-and-git-feature/1.png" alt></p><h4 id="检查插件golangci-lint是否运作"><a href="#检查插件golangci-lint是否运作" class="headerlink" title="检查插件golangci-lint是否运作"></a>检查插件golangci-lint是否运作</h4><p><img src="/2021/07/16/golang-vscode-setting-and-git-featuregolang-vscode-setting-and-git-featuregolang-vscode-setting-and-git-feature/2.png" alt></p><p><code>golangci-lint</code>会自动帮助开发者检查代码有明显语法错误的地方</p><h2 id="代码合并注意事项"><a href="#代码合并注意事项" class="headerlink" title="代码合并注意事项"></a>代码合并注意事项</h2><h3 id="Git分支构成"><a href="#Git分支构成" class="headerlink" title="Git分支构成"></a>Git分支构成</h3><p>分支划分如下：</p><ul><li>master：与线上版本保持绝对一致；</li><li>develop：开发分支，由下文提到的release、feature、hotfix分支合并过后的代码；</li><li>feature：实际功能点开发分支，建议每个功能新建一个feature， 具有关联关系的功能公用一个feature分支；</li><li>release：每一次开发完成之后，从develop创建出来的分支，以此分支为基准，进行测试；</li><li>hotfix：该分支主要用于修复线上bug；</li></ul><p>命名规范约定如下：</p><ul><li>feature分支命名：feature-name</li><li>release分支命名：release-name</li><li>hotfix分支命名：hotfix-name</li></ul><p>比如有一个「优化分布式Session」的需求，可在develop分支的基础上创建新分支 feature-optimize_distributed_session进行开发，开发完成后合并到develop分支。</p><h3 id="分支详细介绍和处理流程"><a href="#分支详细介绍和处理流程" class="headerlink" title="分支详细介绍和处理流程"></a>分支详细介绍和处理流程</h3><p><strong>master分支</strong><br>主分支，与线上运行的版本始终保持一致，任何时候都不要直接修改master分支。</p><p>一个版本的release分支、hotfix分支开发完成后，会合并代码到master分支，也就是说master分支主要来源于release分支和hotfix分支。</p><p><strong>develop分支</strong><br>开发分支，始终保持最新完成以及bug修复后的代码，新增功能时基于该分支创建feature分支。</p><p>一个版本的release分支、hotfix分支开发完成后，也会合并到develop分支，另外，一个版本的feature功能开发完成后，也会合并到develop分支。也就是说develop分支来源于feature、release、hotfix分支。</p><p><strong>feature分支</strong><br>开发新功能或优化现有功能时，会创建feature分支，以develop为基础创建。一般会有多个功能同时开发，但上线时间可能不同，在适当的时候将特定的feature分支合并到develop分支，并创建release分支，进入测试状态。</p><p><strong>release分支</strong><br>当一组feature开发完成，会首先合并到develop分支，开始进入提测阶段时，会创建release分支。</p><p>以release分支代码为基准提测，测试过程中若存在bug需要修复，则直接由开发者在release分支修复并提交。</p><p>测试完成之后，合并release分支到master和develop分支，此时master为最新代码，用作上线。</p><p><strong>hotfix分支</strong><br>线上出现紧急问题时，需要及时修复，以master分支为基线，创建hotfix分支，修复完成后，需要合并到master分支和develop分支。</p><p><strong>特殊情况处理和注意点</strong></p><p>Q:develop分支已存在未上线的feature代码, 此时需要紧急上线一个新功能, 但develop的代码不能上，如何处理？</p><ul><li>以master为基线创建feature， 在完成之后，代码合并到master分支；</li><li>为了保证develop是最新代码，需要从master合并到develop分支；</li></ul><p>Q:以develop为基线，创建了f1和f2两个feature分支之后, f1,f2开发一半的时候，发现两个分支代码需要有依赖怎么办？</p><ul><li>最好在开发开始前确定两个功能是否相关,若相关则只创建一个分支,两个功能在一起开发;</li><li>如果已经创建，则需要合并到一个分支；</li></ul><p>一定要保证commit历史记录的整洁，代码合并时，根据情况选择merge或rebase;<br>使用rebase注意，一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行衍合操作；</p><p><strong>提交说明规范：</strong></p><ul><li>提交说明最好限制在一行以内，50个字符以下，简明扼要地描述更新内容，空开一行后，再展开详细注解；</li><li>如果关联jira，写上jira地址；</li></ul><h3 id="不同业务代码的管理需求差异"><a href="#不同业务代码的管理需求差异" class="headerlink" title="不同业务代码的管理需求差异"></a>不同业务代码的管理需求差异</h3><p><img src="/2021/07/16/golang-vscode-setting-and-git-featuregolang-vscode-setting-and-git-featuregolang-vscode-setting-and-git-feature/3.png" alt></p><h3 id="工作中常见的场景"><a href="#工作中常见的场景" class="headerlink" title="工作中常见的场景"></a>工作中常见的场景</h3><p><strong>开发周期中，所有的功能在当前周期都能完成，需求评审确认通过且开发任务符合预期：</strong><br>时间线：D1→D2→D3→D4→S3→M2 。因为经过评估在下一个发布时间前开发人员能够将D1到D4的4个功能完成开发，所以在次期间我们只需要保证这个分支的功能能正常演进即可，尽量不要引进太多的分支。</p><p><strong>开发周期中，所有功能在当前周期完成，需求评审确认通过，少部分功能上线时间待定，任务进度符合预期：</strong><br>这个时候可能存在2条线，大部分人参与当前版本的功能开发（develop分支的演进），少部分人进行未来版本上线的需求开发（F1，F2，F3）。F3→S2 这个合并尽量等到需求拍定上线版本后合并到stage给测试人员测试。</p><p><strong>线上BUG的修复：</strong><br>确认BUG后，如果是测试人员反馈回来的一般会是在JIRA 上提单，我们可以根据jira的issue Id，在master 上 创建一个bugfix-jira-xx，接下来在这个分支上完成补丁的开发（B1→B2），之后合并补丁到stage分支进行测试环境的部署（B2→S4），等待测试人员的验证，验证完成后将补丁合并到master和develop分支（B2→M3，B2→D5），并打一个小版本号的tag。</p><p><strong>有个新功能，老板想立马上线，但是发版的时间还没到：</strong><br>这种情况，把这个功能当成一个超前的feature处理，我们上面说的feature是一个未来版本的功能，可以走未来版本的测试上线流程，这里的feature 是一个超前的功能，我们需要走类似bugfix的流程，进行一个快速的开发上线。</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Golang环境配置&quot;&gt;&lt;a href=&quot;#Golang环境配置&quot; class=&quot;headerlink&quot; title=&quot;Golang环
      
    
    </summary>
    
    
      <category term="Learn-go" scheme="https://octopuslian.github.io/categories/Learn-go/"/>
    
    
      <category term="Go" scheme="https://octopuslian.github.io/tags/Go/"/>
    
      <category term="Git" scheme="https://octopuslian.github.io/tags/Git/"/>
    
      <category term="VSCode" scheme="https://octopuslian.github.io/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>一定要有B计划 -&gt; 再见，天真的我</title>
    <link href="https://octopuslian.github.io/2021/07/14/always-to-have-plan-B/"/>
    <id>https://octopuslian.github.io/2021/07/14/always-to-have-plan-B/</id>
    <published>2021-07-13T16:13:17.000Z</published>
    <updated>2021-07-15T16:21:55.760Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 18 2021 22:19:00 GMT+0800 (GMT+08:00) --><p>记得最开始看到这句话，是在《小时代1》中那个帅气的混血儿，因为拿错演讲稿，但依旧有条不紊的说了自己准备的<code>planB</code>开场白。</p><p>当时觉得不以为然，心想秘书都帮你安排好了，何必多此一举，现在想想，我真是天真啊…</p><p>感谢社会大学在这一周给我上了精彩的一课，为了等这一刻，你们估计也已经蓄谋很久了吧，没关系的，我心态很好，我有家人，有朋友，有一定的资源人脉，而你们也只能在这里继续啃食下一个天真的灵魂。</p><p>再一次，对这块天府之国上的企业感到失望，我不会哭，因为我要假装坚强，我不会气馁，因为打不死的会让我变的更强，我也不会随意的发牢骚，而是要在黑夜里坚持不懈的练拳头。</p><p>再见了，天真的自己。</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 18 2021 22:19:00 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;记得最开始看到这句话，是在《小时代1》中那个帅气的混血儿，因为拿错演讲稿，但依旧有条不紊的说了自己准备的&lt;code&gt;planB&lt;/code&gt;开场
      
    
    </summary>
    
    
      <category term="Essay" scheme="https://octopuslian.github.io/categories/Essay/"/>
    
    
      <category term="职场" scheme="https://octopuslian.github.io/tags/%E8%81%8C%E5%9C%BA/"/>
    
      <category term="危机意识" scheme="https://octopuslian.github.io/tags/%E5%8D%B1%E6%9C%BA%E6%84%8F%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Django的MTV架构</title>
    <link href="https://octopuslian.github.io/2021/06/24/django-mtv/"/>
    <id>https://octopuslian.github.io/2021/06/24/django-mtv/</id>
    <published>2021-06-23T16:00:34.000Z</published>
    <updated>2021-06-23T16:08:39.467Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 18 2021 22:19:00 GMT+0800 (GMT+08:00) --><h2 id="MTV架构"><a href="#MTV架构" class="headerlink" title="MTV架构"></a>MTV架构</h2><p><img src="/2021/06/24/django-mtv/1.png" alt></p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><ul><li>不重复造轮子</li><li>MVT</li><li>快速开发</li><li>灵活易于扩展</li><li>松耦合</li><li>显式优于隐式</li></ul><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>Python实现，代码干净整洁</li><li>提供管理后台，能快速开发</li><li>复用度高</li><li>易于扩展</li><li>内置的安全框架</li><li>丰富的第三方类库</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>单体应用，不易并行开发</li><li>不适合非常小的几行代码的项目</li><li>不适合高并发面向C端的互联网项目</li></ul><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 18 2021 22:19:00 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;MTV架构&quot;&gt;&lt;a href=&quot;#MTV架构&quot; class=&quot;headerlink&quot; title=&quot;MTV架构&quot;&gt;&lt;/a&gt;MTV架构&lt;
      
    
    </summary>
    
    
      <category term="Learn-Django" scheme="https://octopuslian.github.io/categories/Learn-Django/"/>
    
    
      <category term="Django" scheme="https://octopuslian.github.io/tags/Django/"/>
    
      <category term="MTV" scheme="https://octopuslian.github.io/tags/MTV/"/>
    
  </entry>
  
  <entry>
    <title>T项目合作第一次感到不爽</title>
    <link href="https://octopuslian.github.io/2021/06/16/trs-career-first-feel-not-well/"/>
    <id>https://octopuslian.github.io/2021/06/16/trs-career-first-feel-not-well/</id>
    <published>2021-06-16T15:47:59.000Z</published>
    <updated>2021-06-16T16:02:21.239Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --><p>今天是和<code>T</code>项目合伙人的第4or5次开线上腾讯会议，为了一个数据库表的问题争论了10几分钟，才发现问题原来出在我这里，我把问题想复杂了，导致<code>Th</code>童鞋进度慢了两周，额，好吧，在此说声抱歉….</p><p>目前产品原型图、人员都固定了，就照着做就行。然而没想到还是会出现这样那样的问题，<code>Lzd</code>都感到无语了。</p><p>但是，我想，也许这就是一个磨合的过程吧，如果不是这次项目合伙，我也不会频繁的和你沟通、从而了解你的野心、你的执行力，甚至不知道川大南门那附近的一家好吃的小笼包店，嘻嘻…</p><p>后面的路，我想我得抓紧赶业务流程了，感谢目前公司带我的<code>leader</code>，耐心指导我的编码风格，让我一点一点的走上正轨，让我慢慢掌握了<code>gorm</code>和<code>gin</code>这两个主流后端框架。</p><p>加油，办法总比困难多，迎难而上解决掉，让自己不断成长！</p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;今天是和&lt;code&gt;T&lt;/code&gt;项目合伙人的第4or5次开线上腾讯会议，为了一个数据库表的问题争论了10几分钟，才发现问题原来出在我这里，我
      
    
    </summary>
    
    
      <category term="Career-notes" scheme="https://octopuslian.github.io/categories/Career-notes/"/>
    
    
      <category term="合伙" scheme="https://octopuslian.github.io/tags/%E5%90%88%E4%BC%99/"/>
    
      <category term="事业" scheme="https://octopuslian.github.io/tags/%E4%BA%8B%E4%B8%9A/"/>
    
      <category term="挫败" scheme="https://octopuslian.github.io/tags/%E6%8C%AB%E8%B4%A5/"/>
    
  </entry>
  
  <entry>
    <title>七年前的高考</title>
    <link href="https://octopuslian.github.io/2021/06/07/seven-years-ago-china-gao-kao/"/>
    <id>https://octopuslian.github.io/2021/06/07/seven-years-ago-china-gao-kao/</id>
    <published>2021-06-07T14:46:15.000Z</published>
    <updated>2021-06-07T16:43:47.426Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --><p><strong>本以为自己离开了地狱走向天堂，却不知离开的才是天堂，走向的才是地狱。</strong></p><h2 id="什么是地狱、什么是天堂？"><a href="#什么是地狱、什么是天堂？" class="headerlink" title="什么是地狱、什么是天堂？"></a>什么是地狱、什么是天堂？</h2><p>在我看来，只要是愿意将时光定格在某个时刻，并且保持身心愉悦，它就是天堂，反之即是地狱。</p><p>曾经的我非常怀念高三那段时光，虽然有成堆的试卷要做，但老班说做不完就别做了，睡眠要紧，每一章前几道题一眼就看出答案的就别做了…哈哈哈，这句话至今印象深刻。</p><p>那时候的我，单纯且乐观，对待一切事物都是尽力就好，不留遗憾。心情不好的时候，约上一个朋友操场散心，亦或是放学留下来打球释放压力，大家开开心心的数着高考的倒计时日历…</p><p>然后，高考结束，从此各奔东西。</p><h2 id="散"><a href="#散" class="headerlink" title="散"></a>散</h2><p>曾经我以为，只要心在，无论身处何方，我们一定还会再见的。</p><p>然而，我忽视了物理学中对原子的质量和动量的描述，即使我一直按照自己的轨迹往前走，但还是无法预测同伴们的轨迹，以至于感到渐行渐远的无奈。</p><h2 id="关于死亡与疾病"><a href="#关于死亡与疾病" class="headerlink" title="关于死亡与疾病"></a>关于死亡与疾病</h2><p>曾经我以为，死亡跟我们这些20岁左右的没关系，直到大三那年回去，一位朋友说有个和我们一届毕业的去年得癌症去世了，我哦了一下，刚毕业一年，我的高中好牛油<code>S</code>因为肺结核，各种吃药化疗瘦了好几圈，我的大学好朋友<code>Y</code>得了甲状腺癌，甲状腺切掉了一半，今年和我一起入职的新同事，去医院检查出早期肺癌，庆幸于自己捡了一条命回来，我的高中物理老师告诉我，曾经带我的英语李老师得了癌症去世…</p><p>原来，死亡一直围绕在我身边，随时找到身体防御系统的漏洞准备入侵，只是我并不知情。</p><h2 id="关于我的高考"><a href="#关于我的高考" class="headerlink" title="关于我的高考"></a>关于我的高考</h2><p>我是2014年参加的高考，犹记得高考前一天晚上，父亲开车带我去爬山，让我把心里的气大声吼出来，妹妹在旁边送给我美好的祝福，我看着夕阳西下，微风吹拂过脸庞，带着阵阵凉意，我在山上站了一会，然后对父亲说，走吧，明天考试。</p><p>第一天的考试，感觉发挥还行，语文作文字写飘了；第二天考完数学，去上卫生间的时候听旁边人说“有个人太紧张，复读了一年来考试，竟然考完忘记把选择题答案涂上去”，吓的我赶紧回忆了一下，哦还好，我涂了；下午考完理综，没有想象中如脱缰野马飞奔而出，而是静静的走出校园，坐上公交回学校拿答案，然后再看一眼自己的母校，再见了，我的中学时光。</p><h2 id="录取通知到了"><a href="#录取通知到了" class="headerlink" title="录取通知到了"></a>录取通知到了</h2><p><strong>潜伏在波涛下寂静无声，跃升于惊涛上乘风化龙。</strong></p><p>录取通知到的那天，我记得很清楚，家里人很开心，我也感到幸运，被喜欢的专业录取。</p><p>四年后，我毕业了，参加工作，入职、成长、离职，跳槽，认识了各个阶级的人，看到曾经的一个个目标在逐步实现，小时候对大人世界的困惑和迷茫也慢慢散去。</p><p>回想起这七年来，让我明白了两件事：</p><ul><li>永远不要做一个被一眼就看透的人；</li><li>韩信的胯下之辱确实让人难以忍受，但当一个人的心中有着更高的山峰想去攀登时，他就不会在意脚下的泥沼。</li></ul><p>曾经的我如同一个无知且单纯的少年，害怕考试，害怕身边的人离我远去。感谢这七年的成长，当我回首自己的中学时光，我确实虚度了它，没有把精力全部放在做题上，但如果时光倒流，我想我依旧会去选择逃课、看小说，选择去追喜欢的女生，选择去做一些刺激的事情…如今那个少年已经不在。</p><h2 id="梦醒、破茧"><a href="#梦醒、破茧" class="headerlink" title="梦醒、破茧"></a>梦醒、破茧</h2><p>前几天做梦，梦见高中好基友凡儿在高考前终于肾结石好了，排出了一个拳头大的石头，然后明天是高考，结果我的准考证还没有打印，路过车站时看到了她那扎着马尾的侧颜，我心中默念高考加油，结果准备打印准考证时手机都碎了，这是铁了心不让我高考啊，凡儿还问我该怎么办，考场座位号都晓得不，但我随即淡定的笑了笑，说道没事，以后还有的是机会…</p><p><img src="/2021/06/07/seven-years-ago-china-gao-kao/gao.jpg" alt></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;本以为自己离开了地狱走向天堂，却不知离开的才是天堂，走向的才是地狱。&lt;/strong&gt;&lt;/p&gt;&lt;h2 id=&quot;什么是地狱、什么是
      
    
    </summary>
    
    
      <category term="Essay" scheme="https://octopuslian.github.io/categories/Essay/"/>
    
    
      <category term="高考" scheme="https://octopuslian.github.io/tags/%E9%AB%98%E8%80%83/"/>
    
      <category term="回忆" scheme="https://octopuslian.github.io/tags/%E5%9B%9E%E5%BF%86/"/>
    
      <category term="初心" scheme="https://octopuslian.github.io/tags/%E5%88%9D%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-日志&amp;指标&amp;链路追踪</title>
    <link href="https://octopuslian.github.io/2021/05/10/goatc-10-log-metrics-and-link-tracking/"/>
    <id>https://octopuslian.github.io/2021/05/10/goatc-10-log-metrics-and-link-tracking/</id>
    <published>2021-05-10T09:12:07.000Z</published>
    <updated>2021-06-09T15:24:28.073Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><p><a href="https://github.com/golang/glog" target="_blank" rel="noopener">https://github.com/golang/glog</a> 是 google 提供的一个不维护的日志库，glog 有其他语言的一些版本，对我当时使用 log 库有很大的影响。它包含如下日志级别：</p><ul><li>Info</li><li>Warning</li><li>Error</li><li>Fatal(会中断程序执行)</li></ul><p>还有类似 log4go，loggo，zap 等其他第三方日志库，他们还提供了设置日志级别的可见行，一般提供日志级别：</p><ul><li>Trace</li><li>Debug</li><li>Info</li><li>Warning</li><li>Error</li><li>Critical</li></ul><h4 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h4><p>没人看警告，因为从定义上讲，没有什么出错。也许将来会出问题，但这听起来像是别人的问题。我们尽可能的消除警告级别，它要么是一条信息性消息，要么是一个错误。我们参考 Go 语言设计额哲学，所有警告都是错误，其他语言的 warning 都可以忽略，除非 IDE 或者在 CICD 流程中强制他们为 error，然后逼着程序员们尽可能去消除。同样的，如果想要最终消除 warning 可以记录为 error，让代码作者重视起来。</p><h4 id="Fatal"><a href="#Fatal" class="headerlink" title="Fatal"></a>Fatal</h4><p>记录消息后，直接调用 os.Exit(1)，这意味着：</p><ul><li>在其他 goroutine defer 语句不会被执行；</li><li>各种 buffers 不会被 flush，包括日志的；</li><li>临时文件或者目录不会被移除；</li></ul><p>不要使用 fatal 记录日志，而是向调用者返回错误。如果错误一直持续到 main.main。main.main 那就是在退出之前做处理任何清理操作的正确位置。</p><h4 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h4><p>也有很多人，在错误发生的地方要立马记录日志，尤其要使用 error 级别记录。</p><ul><li>处理 error；</li><li>把 error 抛给调用者，在顶部打印日志；</li></ul><p>如果您选择通过日志记录来处理错误，那么根据定义，它不再是一个错误 — 您已经处理了它。记录错误的行为会处理错误，因此不再适合将其记录为错误。</p><h4 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h4><p>相信只有两件事你应该记录：</p><ul><li>开发人员在开发或调试软件时关心的事情。</li><li>用户在使用软件时关心的事情。</li></ul><p>显然，它们分别是调试和信息级别。<br>log.Info 只需将该行写入日志输出。不应该有关闭它的选项，因为用户只应该被告知对他们有用的事情。如果发生了一个无法处理的错误，它就会抛出到 main.main。main.main 程序终止的地方。在最后的日志消息前面插入 fatal 前缀，或者直接写入 os.Stderr。<br>log.Debug，是完全不同的事情。它由开发人员或支持工程师控制。在开发过程中，调试语句应该是丰富的，而不必求助于 trace 或 debug2（您知道自己是谁）级别。日志包应该支持细粒度控制，以启用或禁用调试，并且只在包或更精细的范围内启用或禁用调试语句。</p><p>我们如何设计和思考的：<a href="https://github.com/go-kratos/kratos/tree/v2.0.x/log" target="_blank" rel="noopener">https://github.com/go-kratos/kratos/tree/v2.0.x/log</a></p><h3 id="日志选型"><a href="#日志选型" class="headerlink" title="日志选型"></a>日志选型</h3><p>一个完整的集中式日志系统，需要包含以下几个主要特点：</p><ul><li>收集－能够采集多种来源的日志数据；</li><li>传输－能够稳定的把日志数据传输到中央系统；</li><li>存储－如何存储日志数据；</li><li>分析－可以支持 UI 分析；</li><li>警告－能够提供错误报告，监控机制；</li></ul><p>开源界鼎鼎大名 ELK stack，分别表示：Elasticsearch , Logstash, Kibana , 它们都是开源软件。新增了一个 FileBeat，它是一个轻量级的日志收集处理工具(Agent)，Filebeat 占用资源少，适合于在各个服务器上搜集日志后传输给 Logstash，官方也推荐此工具。</p><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/elk.png" alt></p><p>此架构由 Logstash 分布于各个节点上搜集相关日志、数据，并经过分析、过滤后发送给远端服务器上的 Elasticsearch 进行存储。</p><p>Elasticsearch 将数据以分片的形式压缩存储并提供多种 API 供用户查询，操作。用户亦可以更直观的通过配置 Kibana Web方便的对日志查询，并根据数据生成报表。</p><p>因为 logstash 属于 server 角色，必然出现流量集中式的热点问题，因此我们不建议使用这种部署方式，同时因为 还需要做大量 match 操作（格式化日志），消耗的 CPU 也很多，不利于 scale out。</p><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/2.png" alt></p><p>此种架构引入了消息队列机制，位于各个节点上的 Logstash Agent 先将数据/日志传递给 Kafka，并将队列中消息或数据间接传递给 Logstash，Logstash 过滤、分析后将数据传递给Elasticsearch 存储。最后由 Kibana 将日志和数据呈现给用户。因为引入了 Kafka，所以即使远端 Logstash server 因故障停止运行，数据将会先被存储下来，从而避免数据丢失。</p><p>更进一步的：将收集端 logstash 替换为 beats，更灵活，消耗资源更少，扩展性更强。</p><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/3.png" alt><br><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/4.png" alt></p><h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><ul><li>接入方式收敛；</li><li>日志格式规范；</li><li>日志解析对日志系统透明；</li><li>系统高吞吐、低延迟；</li><li>系统高可用、容量可扩展、高可运维性；</li></ul><h3 id="格式规范"><a href="#格式规范" class="headerlink" title="格式规范"></a>格式规范</h3><p>JSON作为日志的输出格式：</p><ul><li>time: 日志产生时间，ISO8601格式；</li><li>level: 日志等级，ERROR、WARN、 INFO、DEBUG；</li><li>app_id: 应用id，用于标示日志来源；</li><li>instance_id: 实例 id，用于区分同一应用不同实例，即 hostname；</li></ul><h3 id="设计与实现"><a href="#设计与实现" class="headerlink" title="设计与实现"></a>设计与实现</h3><p>日志从产生到可检索，经历几个阶段：</p><ul><li>生产 &amp; 采集</li><li>传输 &amp; 切分</li><li>存储 &amp; 检索</li></ul><h4 id="采集"><a href="#采集" class="headerlink" title="采集"></a>采集</h4><p>logstash：</p><ul><li>监听 tcp/udp</li><li>适用于通过网络上报日志的方式</li></ul><p>filebeat：</p><ul><li>直接采集本地生成的日志文件</li><li>适用于日志无法定制化输出的应用</li></ul><p>logagent：</p><ul><li>物理机部署，监听 unixsocket</li><li>日志系统提供各种语言 SDK</li><li>直接读取本地日志文件</li></ul><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/5.png" alt></p><h4 id="logagent设计"><a href="#logagent设计" class="headerlink" title="logagent设计"></a>logagent设计</h4><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/6.png" alt></p><h4 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h4><p>基于 flume + Kafka 统一传输平台<br>基于 LogID 做日志分流：</p><ul><li>一般级别</li><li>低级别</li><li>高级别（ERROR）</li></ul><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/7.png" alt></p><h4 id="切分"><a href="#切分" class="headerlink" title="切分"></a>切分</h4><p>从kafka消费日志，解析日志，写入elasticsearch<br>bili-index: 自研，golang 开发，逻辑简单，性能 高, 可定制化方便。</p><ul><li>日志规范产生的日志(log agent 收集)<br>logstash: es 官方组件，基于 jruby 开发，功能强大， 资源消耗高，性能低。</li><li>处理未按照日志规范产生的日志(filebeat、logstash 收集)，需配置各种日志解析规则。</li></ul><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/8.png" alt></p><h4 id="存储和检索"><a href="#存储和检索" class="headerlink" title="存储和检索"></a>存储和检索</h4><p>elasticsearch多集群架构：日志分级、高可用<br>单数据集群内: master node + data node(hot/stale) + client node</p><ul><li>每日固定时间进行热-&gt;冷迁移</li><li>Index 提前一天创建，基于 template 进行mapping 管理</li><li>检索基于 kibana</li></ul><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/9.png" alt></p><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>使用自定义协议，对 SDK 质量、版本升级都有比较高的要求，因此我们长期会使用“本地文件”的方案实现：<br>采集本地日志文件：位置不限，容器内 or 物理机<br>配置自描述：不做中心化配置，配置由 app/paas 自身提供，agent 读取配置并生效<br>日志不重不丢：多级队列，能够稳定地处理日志收集过程中各种异常<br>可监控：实时监控运行状态<br>完善的自我保护机制：限制自身对于宿主机资源的消耗，限制发送速度</p><h4 id="容器日志采集"><a href="#容器日志采集" class="headerlink" title="容器日志采集"></a>容器日志采集</h4><p>容器内应用日志采集：基于 overlay2，直接从物理机上查找对应日志文件。</p><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/10.png" alt></p><h2 id="链路追踪"><a href="#链路追踪" class="headerlink" title="链路追踪"></a>链路追踪</h2><h3 id="设计目标-1"><a href="#设计目标-1" class="headerlink" title="设计目标"></a>设计目标</h3><ul><li>无处不在的部署</li><li>持续的监控</li><li>低消耗</li><li>应用级的透明</li><li>延展性</li><li>低延迟</li></ul><h3 id="Dapper"><a href="#Dapper" class="headerlink" title="Dapper"></a>Dapper</h3><p>参考 Google Dapper 论文实现，为每个请求都生成一个全局唯一的 traceid，端到端透传到上下游所有节点，每一层生成一个 spanid，通过traceid 将不同系统孤立的调用日志和异常信息串联一起，通过 spanid 和 level 表达节点的父子关系。</p><p>核心概念：</p><ul><li>Tree</li><li>Span</li><li>Annotation</li></ul><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/11.png" alt></p><h3 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h3><p>在跟踪树结构中，树节点是整个架构的基本单元，而每一个节点又是对 span 的引用。虽然 span 在日志文件中只是简单的代表 span 的开始和结束时间，他们在整个树形结构中却是相对独立的。</p><p>核心概念：</p><ul><li>TraceID</li><li>SpanID</li><li>ParentID</li><li>Family &amp; Title</li></ul><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/12.png" alt></p><h3 id="植入点"><a href="#植入点" class="headerlink" title="植入点"></a>植入点</h3><p>Dapper 可以以对应用开发者近乎零浸入的成本对分布式控制路径进行跟踪，几乎完全依赖于基于少量通用组件库的改造。如下：<br>当一个线程在处理跟踪控制路径的过程中，Dapper 把这次跟踪的上下文的在 ThreadLocal中进行存储，在 Go 语言中，约定每个方法首参数为 context（上下文）<br>覆盖通用的中间件&amp;通讯框架、不限于：redis、memcache、rpc、http、database、queue。</p><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/13.png" alt></p><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/14.png" alt></p><h3 id="跟踪消耗"><a href="#跟踪消耗" class="headerlink" title="跟踪消耗"></a>跟踪消耗</h3><p>处理跟踪消耗：</p><ul><li>正在被监控的系统在生成追踪和收集追踪数据的消耗导致系统性能下降，</li><li>需要使用一部分资源来存储和分析跟踪数据，是Dapper性能影响中最关键的部分：<blockquote><p>因为收集和分析可以更容易在紧急情况下被关闭，ID生成耗时、创建Span等；<br>修改agent nice值，以防在一台高负载的服务器上发生cpu竞争；</p></blockquote></li></ul><p>采样：</p><ul><li>如果一个显着的操作在系统中出现一次，他就会出现上千次，基于这个事情我们不全量收集数据。</li></ul><p>有意思的论文：Uncertainty in Aggregate Estimates from Sampled Distributed Traces</p><h3 id="跟踪采样"><a href="#跟踪采样" class="headerlink" title="跟踪采样"></a>跟踪采样</h3><p>固定采样，1/1024：<br>这个简单的方案是对我们的高吞吐量的线上服务来说是非常有用，因为那些感兴趣的事件(在大吞吐量的情况下)仍然很有可能经常出现，并且通常足以被捕捉到。然而，在较低的采样率和较低的传输负载下可能会导致错过重要事件，而想用较高的采样率就需要能接受的性能损耗。对于这样的系统的解决方案就是覆盖默认的采样率，这需要手动干预的，这种情况是我们试图避免在 Dapper 中出现的。</p><p>应对积极采样：<br>我们理解为单位时间期望采集样本的条目，在高 QPS 下，采样率自然下降，在低 QPS 下，采样率自然增加；比如1s内某个接口采集1条。</p><p>二级采样：<br>容器节点数量多，即使使用积极采样仍然会导致采样样本非常多，所以需要控制写入中央仓库的数据的总规模，利用所有 span 都来自一个特定的跟踪并分享同一个 traceid 这个事实，虽然这些 span 有可能横跨了数千个主机。</p><p>对于在收集系统中的每一个 span，我们用hash算法把 traceid 转成一个标量Z ，这里0&lt;=Z&lt;=1，我们选择了运行期采样率，这样就可以优雅的去掉我们无法写入到仓库中的多余数据，我们还可以通过调节收集系统中的二级采样率系数来调整这个运行期采样率，最终我们通过后端存储压力把策略下发给 agent采集系统，实现精准的二级采样。</p><p>下游采样：<br>越被依赖多的服务，网关层使用积极采样以后，对于 downstream 的服务采样率仍然很高。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>搜索：按照 Family（服务名）、Title（接口）、时间、调用者等维度进行搜索<br>详情：根据单个 traceid，查看整体链路信息，包含 span、level 统计，span 详情，依赖的服务、组件信息等；<br>全局依赖图：由于服务之间的依赖是动态改变的，所以不可能仅从配置信息上推断出所有这些服务之间的依赖关系，能够推算出任务各自之间的依赖，以及任务和其他软件组件之间的依赖。<br>依赖搜索：搜索单个服务的依赖情况，方便我们做“异地多活”时候来全局考虑资源的部署情况，以及区分服务是否属于多活范畴，也可以方便我们经常性的梳理依赖服务和层级来优化我们的整体架构可用性。<br>推断环依赖：一个复杂的业务架构，很难避免全部是层级关系的调用，但是我们要尽可能保证一点：调用栈永远向下，即：不产生环依赖。</p><h3 id="经验-amp-优化"><a href="#经验-amp-优化" class="headerlink" title="经验&amp;优化"></a>经验&amp;优化</h3><p>性能优化：<br>1、不必要的串行调用；2、缓存读放大；3、数据库写放大；4、服务接口聚合调用；</p><p>异常日志系统集成：<br>如果这些异常发生在 Dapper 跟踪采样的上下文中，那么相应的 traceid 和 spanid 也会作为元数据记录在异常日志中。异常监测服务的前端会提供一个链接，从特定的异常信息的报告直接导向到他们各自的分布式跟踪；</p><p>用户日志集成：<br>在请求的头中返回 traceid，当用户遇到故障或者上报客服我们可以根据 traceid 作为整个请求链路的关键字，再根据接口级的服务依赖接口所涉及的服务并行搜索 ES Index，聚合排序数据，就比较直观的诊断问题了；</p><p>容量预估：<br>根据入口网关服务，推断整体下游服务的调用扇出来精确预估流量再各个系统的占比；</p><p>网络热点&amp;易故障点：<br>我们内部 RPC 框架还不够统一，以及基础库的组件部分还没解决拿到应用层协议大小，如果我们收集起来，可以很简单的实现流量热点、机房热点、异常流量等情况。同理容易失败的 span，很容易统计出来，方便我们辨识服务的易故障点；</p><p>opentraceing：<br>标准化的推广，上面几个特性，都依赖 span TAG 来进行计算，因此我们会逐步完成标准化协议，也更方便我们开源，而不是一个内部“特殊系统”；</p><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>Monitoring：</p><ul><li>延迟、流量、错误、饱和度</li><li>长尾问题</li><li>依赖资源 (Client/Server ‘s view)</li></ul><p>opentracing (Google Dapper)：</p><ul><li>jaeger</li><li>zipkin</li></ul><p>Logging：</p><ul><li>traceid关联</li></ul><p>Metric：</p><ul><li>Prometheus + Granfana</li></ul><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/15.png" alt></p><p>涉及到 net、cache、db、rpc 等资源类型的基础库，首先监控维度4个黄金指标：</p><ul><li>延迟（耗时，需要区分正常还是异常）</li><li>流量（需要覆盖来源，即：caller）</li><li>错误（覆盖错误码或者 HTTP Status Code）</li><li>饱和度（服务容量有多“满”）</li></ul><p>系统层面：</p><ul><li>CPU，Memory，IO，Network，TCP/IP 状态等，FD（等其他），Kernel：Context Switch</li><li>Runtime：各类 GC、Mem 内部状态等</li></ul><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/16.png" alt></p><ul><li>线上打开 Profiling 的端口；</li><li>使用服务发现找到节点信息，以及提供快捷的方式快速可以 WEB 化查看进程的 Profiling 信息（火焰图等）；</li><li>watchdog，使用内存、CPU 等信号量触发自动采集；</li></ul><p><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/17-1.png" alt><br><img src="/2021/05/10/goatc-10-log-metrics-and-link-tracking/17-2.png" alt></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://dave.cheney.net/2015/11/05/lets-talk-about-logging" target="_blank" rel="noopener">https://dave.cheney.net/2015/11/05/lets-talk-about-logging</a><br><a href="https://www.ardanlabs.com/blog/2013/11/using-log-package-in-go.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2013/11/using-log-package-in-go.html</a><br><a href="https://www.ardanlabs.com/blog/2017/05/design-philosophy-on-logging.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2017/05/design-philosophy-on-logging.html</a><br><a href="https://dave.cheney.net/2017/01/23/the-package-level-logger-anti-pattern" target="_blank" rel="noopener">https://dave.cheney.net/2017/01/23/the-package-level-logger-anti-pattern</a><br><a href="https://help.aliyun.com/document_detail/28979.html?spm=a2c4g.11186623.2.10.3b0a729amtsBZe" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/28979.html?spm=a2c4g.11186623.2.10.3b0a729amtsBZe</a><br><a href="https://developer.aliyun.com/article/703229" target="_blank" rel="noopener">https://developer.aliyun.com/article/703229</a><br><a href="https://developer.aliyun.com/article/204554" target="_blank" rel="noopener">https://developer.aliyun.com/article/204554</a><br><a href="https://developer.aliyun.com/article/251629" target="_blank" rel="noopener">https://developer.aliyun.com/article/251629</a><br><a href="https://www.elastic.co/cn/what-is/elk-stack" target="_blank" rel="noopener">https://www.elastic.co/cn/what-is/elk-stack</a><br><a href="https://my.oschina.net/itblog/blog/547250" target="_blank" rel="noopener">https://my.oschina.net/itblog/blog/547250</a><br><a href="https://www.cnblogs.com/aresxin/p/8035137.html" target="_blank" rel="noopener">https://www.cnblogs.com/aresxin/p/8035137.html</a><br><a href="https://www.elastic.co/cn/products/beats/filebeat" target="_blank" rel="noopener">https://www.elastic.co/cn/products/beats/filebeat</a><br><a href="https://www.elastic.co/guide/en/beats/filebeat/5.6/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/beats/filebeat/5.6/index.html</a><br><a href="https://www.elastic.co/cn/products/logstash" target="_blank" rel="noopener">https://www.elastic.co/cn/products/logstash</a><br><a href="https://www.elastic.co/guide/en/logstash/5.6/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/logstash/5.6/index.html</a><br><a href="https://www.elastic.co/cn/products/kibana" target="_blank" rel="noopener">https://www.elastic.co/cn/products/kibana</a><br><a href="https://www.elastic.co/guide/en/kibana/5.5/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/kibana/5.5/index.html</a><br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/5.6/index.html</a><br><a href="https://elasticsearch.cn/" target="_blank" rel="noopener">https://elasticsearch.cn/</a><br><a href="https://blog.aliasmee.com/post/graylog-log-system-architecture/" target="_blank" rel="noopener">https://blog.aliasmee.com/post/graylog-log-system-architecture/</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;日志&quot;&gt;&lt;a href=&quot;#日志&quot; class=&quot;headerlink&quot; title=&quot;日志&quot;&gt;&lt;/a&gt;日志&lt;/h2&gt;&lt;h3 id=&quot;
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="golang" scheme="https://octopuslian.github.io/tags/golang/"/>
    
      <category term="日志" scheme="https://octopuslian.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-分布式缓存和分布式事务</title>
    <link href="https://octopuslian.github.io/2021/05/06/goatc-8-distributed-cache-and-affair/"/>
    <id>https://octopuslian.github.io/2021/05/06/goatc-8-distributed-cache-and-affair/</id>
    <published>2021-05-06T13:43:07.000Z</published>
    <updated>2021-06-09T14:56:56.299Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --><h2 id="缓存选型"><a href="#缓存选型" class="headerlink" title="缓存选型"></a>缓存选型</h2><h3 id="memcache"><a href="#memcache" class="headerlink" title="memcache"></a>memcache</h3><p>memcache 提供简单的 kv cache 存储，value 大小不超过1mb。</p><p>我使用 memcache 作为大文本或者简单的 kv结构使用。</p><p>memcache 使用了slab 方式做内存管理，存在一定的浪费，如果大量接近的 item，建议调整 memcache 参数来优化每一个 slab 增长的 ratio、可以通过设置 slab_automove &amp; slab_reassign 开启memcache 的动态/手动 move slab，防止某些 slab 热点导致内存足够的情况下引发 LRU。</p><p>大部分情况下，简单 KV 推荐使用 Memcache，吞吐和相应都足够好。</p><p>每个 slab 包含若干大小为1M的内存页，这些内存又被分割成多个 chunk，每个 chunk存储一个 item；<br>在 memcache 启动初始化时，每个 slab 都预分配一个 1M 的内存页，由slabs_preallocate 完成(也可将相应代码注释掉关闭预分配功能)。</p><p>chunk 的增长因子由 -f 指定，默认1.25，起始大小为48字节。<br>内存池有很多种设计，可以参考下: nginx ngx_pool_t，tcmalloc 的设计等等。</p><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><p>redis 有丰富的数据类型，支持增量方式的修改部分数据，比如排行榜，集合，数组等。</p><p>比较常用的方式是使用 redis 作为数据索引，比如评论的列表 ID，播放历史的列表 ID 集合，我们的关系链列表 ID。</p><p>redis 因为没有使用内存池，所以是存在一定的内存碎片的，一般会使用 jemalloc 来优化内存分配，需要编译时候使用 jemalloc 库代替 glib 的 malloc 使用。</p><h3 id="redis-vs-memcache"><a href="#redis-vs-memcache" class="headerlink" title="redis vs memcache"></a>redis vs memcache</h3><p>Redis 和 Memcache 最大的区别其实是 redis 单线程(新版本双线程)，memcache 多线程，所以 QPS 可能两者差异不大，但是吞吐会有很大的差别，比如大数据 value 返回的时候，redis qps 会抖动下降的的很厉害，因为单线程工作，其他查询进不来(新版本有不少的改善)。</p><p>所以建议纯 kv 都走 memcache，比如我们的关系链服务中用了 hashs 存储双向关系，但是我们也会使用 memcache 档一层来避免hgetall 导致的吞吐下降问题。</p><p>我们系统中多次使用 memcache + redis 双缓存设计。</p><p><img src="/2021/05/06/goatc-8-distributed-cache-and-affair/memcache-vs-redis.png" alt></p><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>早期使用 twemproxy 作为缓存代理，但是在使用上有如下一些痛点：</p><ul><li>单进程单线程模型和 redis 类似，在处理一些大 key 的时候可能出现 io 瓶颈；</li><li>二次开发成本难度高，难以于公司运维平台进行深度集成；</li><li>不支持自动伸缩，不支持 autorebalance 增删节点需要重启才能生效；</li><li>运维不友好，没有控制面板；</li></ul><p>业界开源的的其他代理工具：</p><ul><li>codis: 只支持 redis 协议，且需要使用 patch版本的 redis；</li><li>mcrouter: 只支持 memcache 协议，C 开发，与运维集成开发难度高；</li></ul><p>从集中式访问缓存到 Sidecar 访问缓存：</p><ul><li>微服务强调去中心化；</li><li>LVS 运维困难，容易流量热点，随下游扩容而扩容，连接不均衡等问题；</li><li>Sidecar 伴生容器随 App 容器启动而启动，配置简化；</li></ul><h3 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h3><p>一致性 hash 是将数据按照特征值映射到一个首尾相接的 hash 环上，同时也将节点（按照 IP 地址或者机器名 hash）映射到这个环上。</p><p>对于数据，从数据在环上的位置开始，顺时针找到的第一个节点即为数据的存储节点。</p><p>余数分布式算法由于保存键的服务器会发生巨大变化而影响缓存的命中率，但Consistent Hashing 中，只有在园（continuum）上增加服务器的地点逆时针方向的第一台服务器上的键会受到影响。</p><ul><li>平衡性(Balance)：尽可能分布到所有的缓冲中去</li><li>单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲区加入到系统中，那么哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲区中去，而不会被映射到旧的缓冲集合中的其他缓冲区。</li><li>分散性(Spread)：相同内容被存储到不同缓冲中去，降低了系统存储的效率，需要尽量降低分散性。</li><li>负载(Load)：哈希算法应能够尽量降低缓冲的负荷。</li><li>平滑性(Smoothness)：缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的。</li></ul><p>一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。</p><p>此时必然造成大量数据集中到 Node A 上，而只有极少量会定位到 Node B 上。为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。</p><p>具体做法可以在服务器 ip 或主机名的后面增加编号来实现。</p><p><img src="/2021/05/06/goatc-8-distributed-cache-and-affair/yi-zhi-hash.png" alt></p><p>例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算<br>“Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点。<br>同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到<br>“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到 Node A 上。这样就解决了服务节点少时数据倾斜的问题。</p><p>参考微信红包的写合并优化：<br><a href="https://www.cnblogs.com/chinanetwind/articles/9460820.html" target="_blank" rel="noopener">https://www.cnblogs.com/chinanetwind/articles/9460820.html</a></p><p>在网关层，使用一致性 hash，对红包 id 进行分片，命中到某一个逻辑服务器处理，在进程内做写操作的合并，减少存储层的单行锁争用。<br>我认为更好的做法是 有界负载一致性 hash。</p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>数据分片的 hash 方式也是这个思想，即按照数据的某一特征（key）来计算哈希值，并将哈希值与系统中的节点建立映射关系,从而将哈希值不同的数据分布到不同的节点上。</p><p>按照 hash 方式做数据分片，映射关系非常简单；需要管理的元数据也非常之少，只需要记录节点的数目以及 hash 方式就行了。</p><p>当加入或者删除一个节点的时候，大量的数据需要移动。比如在这里增加一个节点 N3，因此 hash 方式变为了 mod 4。</p><p>均衡问题：原始数据的特征值分布不均匀，导致大量的数据集中到一个物理节点上；第二，对于可修改的记录数据，单条记录的数据变大。<br>高级玩法是抽象 slot，基于 Hash 的 Slot Sharding，例如 Redis-Cluster。</p><h3 id="Slot"><a href="#Slot" class="headerlink" title="Slot"></a>Slot</h3><p>redis-cluster 把16384 槽按照节点数量进行平均分配，由节点进行管理。</p><p>对每个 key 按照 CRC16 规则进行 hash 运算，把 hash 结果对16383进行取余，把余数发送给 Redis 节点。</p><p>需要注意的是：Redis Cluster 的节点之间会共享消息，每个节点都会知道是哪个节点负责哪个范围内的数据槽</p><h2 id="缓存模式"><a href="#缓存模式" class="headerlink" title="缓存模式"></a>缓存模式</h2><h3 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h3><p>Storage 和 Cache 同步更新容易出现数据不一致。</p><p>模拟 MySQL Slave 做数据复制，再把消息投递到 Kafka，保证至少一次消费：</p><ul><li>同步操作DB；</li><li>同步操作Cache；</li><li>利用Job消费消息，重新补偿一次缓存操作</li></ul><p>保证时效性和一致性。</p><p>读/写同时操作：<br>读操作，读缓存，缓存 MISS<br>读操作，读 DB，读取到数据<br>写操作，更新 DB 数据<br>写操作 SET/DELETE Cache（可 Job 异步操作）<br>读操作，SET操作数据回写缓存（可 Job 异步操作）</p><p>这种交互下，由于4和5操作步骤都是设置缓存，导致写入的值互相覆盖；并且操作的顺序性不确定，从而导致 cache 存在脏缓存的情况。</p><p><img src="/2021/05/06/goatc-8-distributed-cache-and-affair/shu-ju-yi-zhi.png" alt></p><h3 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h3><p>微服务拆分细粒度原子业务下的整合服务（聚合服务），用于提供粗粒度的接口，以及二级缓存加速，减少扇出的 rpc 网络请求，减少延迟。<br>最重要是保证多级缓存的一致性：</p><ul><li>清理的优先级是有要求的，先优先清理下游再上游；</li><li>下游的缓存expire要大于上游，里面穿透回源；</li></ul><p>天下大势分久必合，适当的微服务合并也是不错的做法，再使用 DDD 思路以及我们介绍的目录结构组织方式，区分不同的 Usecase。</p><h3 id="热点缓存"><a href="#热点缓存" class="headerlink" title="热点缓存"></a>热点缓存</h3><p>对于热点缓存 Key，按照如下思路解决：</p><ul><li>小表广播，从 RemoteCache 提升为LocalCache，App 定时更新，甚至可以让运营平台支持广播刷新 LocalCache；</li><li>主动监控防御预热，比如直播房间页高在线情况下直接外挂服务主动防御；</li><li>基础库框架支持热点发现，自动短时的 short-live cache；</li><li>多 Cluster 支持；<br>多 Key 设计: 使用多副本，减小节点热点的问题<br>使用多副本 ms_1,ms_2,ms_3 每个节点保存一份数据，使得请求分散到多个节点，避免单点热点问题。</li></ul><h3 id="穿透缓存"><a href="#穿透缓存" class="headerlink" title="穿透缓存"></a>穿透缓存</h3><ul><li><p>singlefly<br>对关键字进行一致性 hash，使其某一个维度的 key 一定命中某个节点，然后在节点内使用互斥锁，保证归并回源，但是对于批量查询无解；</p></li><li><p>分布式锁<br>设置一个 lock key，有且只有一个人成功，并且返回，交由这个人来执行回源操作，其他候选者轮训 cache 这个 lock key，如果不存在去读数据缓存，hit 就返回，miss 继续抢锁；</p></li><li><p>队列<br>如果 cache miss，交由队列聚合一个key，来 load 数据回写缓存，对于 miss 当前请求可以使用 singlefly 保证回源，如评论架构实现。适合回源加载数据重的任务，比如评论 miss 只返回第一页，但是需要构建完成评论数据索引。</p></li><li><p>lease<br>通过加入 lease 机制，可以很好避免这两个问题，lease 是 64-bit 的 token，与客户端请求的 key 绑定，对于过时设置，在写入时验证 lease，可以解决这个问题；对于 thundering herd，每个key 10s 分配一次，当 client 在没有获取到 lease 时，可以稍微等一下再访问 cache，这时往往cache 中已有数据。（基础库支持 &amp; 修改 cache 源码）；</p></li></ul><h2 id="缓存技巧"><a href="#缓存技巧" class="headerlink" title="缓存技巧"></a>缓存技巧</h2><h3 id="Incast-Congestion"><a href="#Incast-Congestion" class="headerlink" title="Incast Congestion"></a>Incast Congestion</h3><p>如果在网路中的包太多，就会发生 Incast Congestion 的问题（可以理解为，network 有很多switch，router 啥的，一旦一次性发一堆包，这些包同时到达 switch，这些 switch 就会忙不过来）。</p><p>应对这个问题就是不要让大量包在同一时间发送出去，在客户端限制每次发出去的包的数量（具体实现就是客户端弄个队列）。</p><p>每次发送的包的数量称为“Window size”。这个值太小的话，发送太慢，自然延迟会变高；这个值太大，发送的包太多把 network switch 搞崩溃了，就可能发生比如丢包之类的情况，可能被当作 cache miss，这样延迟也会变高。所以这个值需要调，一般会在 proxy 层面实现。</p><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><ul><li>易读性的前提下，key 设置尽可能小，减少资源的占用，redis value 可以用 int 就不要用string，对于小于 N 的 value，redis 内部有 shared_object 缓存。</li><li>拆分 key。主要是用在 redis 使用 hashes 情况下。同一个 hashes key 会落到同一个 redis 节点，hashes 过大的情况下会导致内存及请求分布的不均匀。考虑对 hash 进行拆分为小的hash，使得节点内存均匀及避免单节点请求热点。</li><li>空缓存设置。对于部分数据，可能数据库始终为空，这时应该设置空缓存，避免每次请求都缓存 miss 直接打到 DB。</li><li>空缓存保护策略。</li><li>读失败后的写缓存策略（降级后一般读失败不触发回写缓存）。</li><li>序列化使用 protobuf，尽可能减少 size。</li><li>工具化浇水代码</li></ul><h3 id="memcache-小技巧"><a href="#memcache-小技巧" class="headerlink" title="memcache 小技巧"></a>memcache 小技巧</h3><ul><li>flag 使用：标识 compress、encoding、large value 等；</li><li>memcache 支持 gets，尽量读取，尽可能的 pipeline，减少网络往返；</li><li>使用二进制协议，支持 pipeline delete，UDP 读取、TCP 更新；</li></ul><h3 id="redis-小技巧"><a href="#redis-小技巧" class="headerlink" title="redis 小技巧"></a>redis 小技巧</h3><ul><li>增量更新一致性：EXPIRE、ZADD/HSET 等，保证索引结构体务必存在的情况下去操作新增数据；</li><li>BITSET: 存储每日登陆用户，单个标记位置（boolean），为了避免单个 BITSET 过大或者热点，需要使用 region sharding，比如按照mid求余 %和/ 10000，商为 KEY、余数作为offset；</li><li>List:抽奖的奖池、顶弹幕，用于类似 Stack PUSH/POP操作；</li><li>Sortedset: 翻页、排序、有序的集合，杜绝 zrange 或者 zrevrange 返回的集合过大；</li><li>Hashs: 过小的时候会使用压缩列表、过大的情况容易导致 rehash 内存浪费，也杜绝返回hgetall，对于小结构体，建议直接使用 memcache KV；</li><li>String: SET 的 EX/NX 等 KV 扩展指令，SETNX 可以用于分布式锁、SETEX 聚合了SET + EXPIRE；</li><li>Sets: 类似 Hashs，无 Value，去重等；</li><li>尽可能的 PIPELINE 指令，但是避免集合过大；</li><li>避免超大 Value；</li></ul><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>讲到事务，又得搬出经典的转账问题了：<br>支付宝账户表：A (id, user_id, amount)<br>余额宝账户表：B (id, user_id, amount)<br>用户的 user_id = 1，从支付宝转帐1万快到余额宝分为两个步骤：<br>支付宝表扣除1万：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> A <span class="keyword">SET</span> amount = amount - <span class="number">10000</span> <span class="keyword">WHERE</span> user_id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>余额宝表增加1万：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> B <span class="keyword">SET</span> amount = amount + <span class="number">10000</span> <span class="keyword">WHERE</span> user_id = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>如何保证数据一致性呢？<br>单个数据库，我们保证 ACID 使用 数据库事务。</p><h3 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h3><p>如何可靠的保存消息凭证？<br>要解决消息可靠存储，我们实际上需要解决的问题是，本地的 mysql 存储和 message 存储的一致性问题。</p><ul><li>Transactional outbox</li><li>Polling publisher</li><li>Transaction log tailing</li><li>2PC Message Queue</li></ul><p>事务消息一旦被可靠的持久化，我们整个分布式事务，变为了最终一致性，消息的消费才能保障最终业务数据的完整性，所以我们要尽最大努力，把消息送达到下游的业务消费方，称为：Best Effort。只有消息被消费，整个交易才能算是完整完结。</p><h3 id="Best-Effort"><a href="#Best-Effort" class="headerlink" title="Best Effort"></a>Best Effort</h3><p>即尽最大努力交付，主要用于在这样一种场景：不同的服务平台之间的事务性保证。<br>比如我们在电商购物，使用支付宝支付；又比如玩网游的时候，通过 App Store 充值。<br>拿购物为例，电商平台与支付平台是相互独立的，隶属于不同的公司，即使是同一个公司也很可能是独立的部门。<br>“ 做过支付宝交易接口的同学都知道，我们一般会在支付宝的回调页面和接口里，解密参数，然后调用系统中更新交易状态相关的服务，将订单更新为付款成功。<br>同时，只有当我们回调页面中输出了success 字样或者标识业务处理成功相应状态码时，支付宝才会停止回调请求。否则，支付宝会每间隔一段时间后，再向客户方发起回调请求，直到输出成功标识为止。”</p><h3 id="Transactional-outbox"><a href="#Transactional-outbox" class="headerlink" title="Transactional outbox"></a>Transactional outbox</h3><p>Transactional outbox，支付宝在完成扣款的同时，同时记录消息数据，这个消息数据与业务数据保存在同一数据库实例里（消息记录表表名为 msg）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EGIN TRANSACTION</span><br><span class="line">    <span class="keyword">UPDATE</span> A <span class="keyword">SET</span> amount = amount - <span class="number">10000</span> <span class="keyword">WHERE</span> user_id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> msg(user_id, amount, <span class="keyword">status</span>) <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="number">10000</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">TRANSACTION</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>上述事务能保证只要支付宝账户里被扣了钱，消息一定能保存下来。当上述事务提交成功后，我们想办法将此消息通知余额宝，余额宝处理成功后发送回复成功消息，支付宝收到回复后删除该条消息数据。</p><h3 id="Polling-publisher"><a href="#Polling-publisher" class="headerlink" title="Polling publisher"></a>Polling publisher</h3><p>Polling publisher，我们定时的轮训 msg 表，把 status = 1 的消息统统拿出来消费，可以按照自增 id 排序，保证顺序消费。在这里我们独立了一个 pay_task 服务，把拖出来的消息 publish 给我们消息队列，balance 服务自己来消费队列，或者直接 rpc 发送给 balance 服务。</p><p>实际我们第一个版本的 archive-service 在使用 CQRS 时，就用的这个模型，Pull 的模型，从延迟来说不够好，Pull 太猛对 Database 有一定压力，Pull 频次低了，延迟比较高。</p><h3 id="Transaction-log-tailing"><a href="#Transaction-log-tailing" class="headerlink" title="Transaction log tailing"></a>Transaction log tailing</h3><p>Transaction log tailing，上述保存消息的方式使得消息数据和业务数据紧耦合在一起，从架构上看不够优雅，而且容易诱发其他问题。<br>有一些业务场景，可以直接使用主表被 canal 订阅使用，有一些业务场景自带这类 message 表，比如订单或者交易流水，可以直接使用这类流水表作为 message 表使用。</p><p>使用 canal 订阅以后，是实时流式消费数据，在消费者 balance 或者 balance-job 必须努力送达到。</p><p>我们发现，所有努力送达的模型，必须是先预扣（预占资源）的做法。</p><h3 id="幂等"><a href="#幂等" class="headerlink" title="幂等"></a>幂等</h3><p>还有一个很严重的问题就是消息重复投递，如果相同的消息被重复投递两次，那么我们余额宝账户将会增加2万而不是1万了。</p><p>为什么相同的消息会被重复投递？比如余额宝处理完消息 msg 后，发送了处理成功的消息给支付宝，正常情况下支付宝应该要删除消息msg，但如果支付宝这时候悲剧的挂了，重启后一看消息 msg 还在，就会继续发送消息 msg。</p><ul><li><p>全局唯一 ID+ 去重表<br>在余额宝这边增加消息应用状态表 msg_apply，通俗来说就是个账本，用于记录消息的消费情况，每次来一个消息，在真正执行之前，先去消息应用状态表中查询一遍，如果找到说明是重复消息，丢弃即可，如果没找到才执行，同时插入到消息应用状态表（同一事务）。</p></li><li><p>版本号</p></li></ul><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p>两阶段提交协议(Two Phase Commitment Protocol)中，涉及到两种角色</p><ul><li>一个事务协调者（coordinator）：负责协调多个参与者进行事务投票及提交(回滚)</li><li>多个事务参与者（participants）：即本地事务执行者</li></ul><p>总共处理步骤有两个<br>（1）投票阶段（voting phase）：协调者将通知事务参与者准备提交或取消事务，然后进入表决过程。参与者将告知协调者自己的决策：同意（事务参与者本地事务执行成功，但未提交）或取消（本地事务执行故障）；<br>（2）提交阶段（commit phase）：收到参与者的通知后，协调者再向参与者发出通知，根据反馈情况决定各参与者是否要提交还是回滚；</p><h3 id="2PC-Message-Queue"><a href="#2PC-Message-Queue" class="headerlink" title="2PC Message Queue"></a>2PC Message Queue</h3><p><img src="/2021/05/06/goatc-8-distributed-cache-and-affair/affair.png" alt></p><h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><p>TCC 是 Try、Conﬁrm、Cancel 三个词语的缩写，TCC 要求每个分支事务实现三个操作：预处理 Try、确认 Conﬁrm、撤销 Cancel。<br>Try 操作做业务检查及资源预留，Conﬁrm 做业务确认操作，Cancel 实现一个与 Try 相反的操作即回滚操作。<br>TM 首先发起所有的分支事务的 Try 操作，任何一个分支事务的 Try 操作执行失败，TM 将会发起所有分支事务的 Cancel 操作，若 Try 操作全部成功，TM 将会发起所有分支事务的 Conﬁrm 操作，其中 Conﬁrm/Cancel 操作若执行失败，TM 会进行重试。</p><p>需要注意：</p><ul><li>空回滚</li><li>防悬挂</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://blog.csdn.net/chen_kkw/article/details/82724330" target="_blank" rel="noopener">https://blog.csdn.net/chen_kkw/article/details/82724330</a><br><a href="https://zhuanlan.zhihu.com/p/328728595" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/328728595</a><br><a href="https://www.cnblogs.com/chinanetwind/articles/9460820.html" target="_blank" rel="noopener">https://www.cnblogs.com/chinanetwind/articles/9460820.html</a><br><a href="https://medium.com/vimeo-engineering-blog/" target="_blank" rel="noopener">https://medium.com/vimeo-engineering-blog/</a> improving-load-balancing-with-a-new-consistent-hashing-algorithm-9f1bd75709ed<br><a href="https://www.jianshu.com/p/5fa447c60327" target="_blank" rel="noopener">https://www.jianshu.com/p/5fa447c60327</a><br><a href="https://writings.sh/post/consistent-hashing-algorithms-part-1-the-problem-and-the-concept" target="_blank" rel="noopener">https://writings.sh/post/consistent-hashing-algorithms-part-1-the-problem-and-the-concept</a><br><a href="https://www.cnblogs.com/williamjie/p/11132211.html" target="_blank" rel="noopener">https://www.cnblogs.com/williamjie/p/11132211.html</a></p><p><a href="https://blog.csdn.net/hosaos/article/details/89136666" target="_blank" rel="noopener">https://blog.csdn.net/hosaos/article/details/89136666</a><br><a href="https://zhuanlan.zhihu.com/p/183753774" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/183753774</a><br><a href="https://www.cnblogs.com/dyzcs/p/13780668.html" target="_blank" rel="noopener">https://www.cnblogs.com/dyzcs/p/13780668.html</a><br><a href="https://blog.csdn.net/bjweimengshu/article/details/79607522" target="_blank" rel="noopener">https://blog.csdn.net/bjweimengshu/article/details/79607522</a><br><a href="https://microservices.io/patterns/data/event-sourcing.html" target="_blank" rel="noopener">https://microservices.io/patterns/data/event-sourcing.html</a><br><a href="https://microservices.io/patterns/data/saga.html" target="_blank" rel="noopener">https://microservices.io/patterns/data/saga.html</a><br><a href="https://microservices.io/patterns/data/polling-publisher.html" target="_blank" rel="noopener">https://microservices.io/patterns/data/polling-publisher.html</a><br><a href="https://microservices.io/patterns/data/polling-publisher.html" target="_blank" rel="noopener">https://microservices.io/patterns/data/polling-publisher.html</a><br><a href="https://microservices.io/patterns/data/transaction-log-tailing.html" target="_blank" rel="noopener">https://microservices.io/patterns/data/transaction-log-tailing.html</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;缓存选型&quot;&gt;&lt;a href=&quot;#缓存选型&quot; class=&quot;headerlink&quot; title=&quot;缓存选型&quot;&gt;&lt;/a&gt;缓存选型&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="golang" scheme="https://octopuslian.github.io/tags/golang/"/>
    
      <category term="分布式" scheme="https://octopuslian.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="缓存" scheme="https://octopuslian.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="事务" scheme="https://octopuslian.github.io/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="redis" scheme="https://octopuslian.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-网络编程</title>
    <link href="https://octopuslian.github.io/2021/05/05/goatc-9-network-programming-practice/"/>
    <id>https://octopuslian.github.io/2021/05/05/goatc-9-network-programming-practice/</id>
    <published>2021-05-05T14:00:45.000Z</published>
    <updated>2021-06-09T14:56:57.377Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --><h2 id="网络通信协议"><a href="#网络通信协议" class="headerlink" title="网络通信协议"></a>网络通信协议</h2><p>互联网的核心是一系列协议，总称为”互联网协议”（Internet Protocol Suite），正是这一些协议规定了电脑如何连接和组网。</p><p>主要协议分为：</p><ul><li>Socket：接口抽象层</li><li>TCP / UDP：面向连接(可靠) / 无连接(不可靠)</li><li>HTTP1.1 / HTTP2 / QUIC（HTTP3）：超文本传输协议</li></ul><h3 id="Socket-抽象层"><a href="#Socket-抽象层" class="headerlink" title="Socket 抽象层"></a>Socket 抽象层</h3><p>应用程序通常通过“套接字”向网络发出请求或者应答网络请求。</p><p>一种通用的面向流的网络接口</p><p>主要操作：</p><ul><li>建立、接受连接</li><li>读写、关闭、超时</li><li>获取地址、端口</li></ul><h3 id="TCP-可靠连接，面向连接的协议"><a href="#TCP-可靠连接，面向连接的协议" class="headerlink" title="TCP 可靠连接，面向连接的协议"></a>TCP 可靠连接，面向连接的协议</h3><p>TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一种面向连接（连接导向）的、可靠的、基于字节流的传输层（Transport layer）通信协议，因为是面向连接的协议。</p><p>服务端流程：</p><ul><li>监听端口</li><li>接收客户端请求建立连接</li><li>创建 goroutine 处理连接</li></ul><p>客户端流程：</p><ul><li>建立与服务端的连接</li><li>进行数据收发</li><li>关闭连接</li></ul><h3 id="UDP-不可靠连接，允许广播或多播"><a href="#UDP-不可靠连接，允许广播或多播" class="headerlink" title="UDP 不可靠连接，允许广播或多播"></a>UDP 不可靠连接，允许广播或多播</h3><p>UDP 协议（User Datagram Protocol）中文名称是用户数据报协议，是 OSI（Open System Interconnection，开放式系统互联）参考模型中一种无连接的传输层协议。</p><p>一个简单的传输层协议：</p><ul><li>不需要建立连接</li><li>不可靠的、没有时序的通信</li><li>数据报是有长度（65535-20=65515）</li><li>支持多播和广播</li><li>低延迟，实时性比较好</li><li>应用于用于视频直播、游戏同步</li></ul><h3 id="HTTP-超文本传输协议"><a href="#HTTP-超文本传输协议" class="headerlink" title="HTTP 超文本传输协议"></a>HTTP 超文本传输协议</h3><p>HTTP(HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议，它详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议。</p><p>请求报文：</p><ul><li>Method: HEAD/GET/POST/PUT/DELETE</li><li>Accept：text/html、application/json</li><li>Content-Type:</li><li>application/json</li><li>application/x-www-form-urlencoded</li><li>请求正文</li></ul><p>响应报文：</p><ul><li>状态行(200/400/500)</li><li>响应头(Response Header)</li><li>响应正文</li></ul><h3 id="HTTP-超文本传输协议-演进"><a href="#HTTP-超文本传输协议-演进" class="headerlink" title="HTTP 超文本传输协议-演进"></a>HTTP 超文本传输协议-演进</h3><p>HTTP 发展史：</p><ul><li>1991 年发布初代 HTTP/0.9 版</li><li>1996 年发布 HTTP/1.0 版</li><li>1997 年是 HTTP/1.1 版，是到今天为止传输最广泛的版本</li><li>2015 年发布了 HTTP/2.0 版，优化了 HTTP/1.1 的性能和安全性</li><li>2018 年发布的 HTTP/3.0 版，使用 UDP 取代 TCP 协议</li></ul><p>HTTP2：<br>二进制分帧，按帧方式传输<br>多路复用，代替原来的序列和阻塞机制<br>头部压缩，通过 HPACK 压缩格式<br>服务器推送，服务端可以主动推送资源</p><p>HTTP3：<br>连接建立延时低，一次往返可建立HTTPS连接<br>改进的拥塞控制，高效的重传确认机制<br>切换网络保持连接，从4G切换到WIFI不用重建连接</p><h2 id="Go-网络编程基础"><a href="#Go-网络编程基础" class="headerlink" title="Go 网络编程基础"></a>Go 网络编程基础</h2><p>基础概念：</p><ul><li>Socket：数据传输</li><li>Encoding：内容编码</li><li>Session：连接会话状态</li><li>C/S模式：通过客户端实现双端通信</li><li>B/S模式：通过浏览器即可完成数据的传输</li></ul><p>简单例子<br>• 通过TCP/UDP实现网络通信</p><p>网络轮询器</p><ul><li>多路复用模型</li><li>多路复用模块</li><li>文件描述符</li><li>Goroutine 唤醒</li></ul><h3 id="TCP简单例子"><a href="#TCP简单例子" class="headerlink" title="TCP简单例子"></a>TCP简单例子</h3><h3 id="UDP简单例子"><a href="#UDP简单例子" class="headerlink" title="UDP简单例子"></a>UDP简单例子</h3><h3 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h3><p>Linux下主要的IO模型分为:</p><ul><li>Blocking IO - 阻塞IO</li><li>Nonblocking IO - 非阻塞IO</li><li>IO multiplexing - IO 多路复用</li><li>Signal-driven IO - 信号驱动式IO（异步阻塞）</li><li>Asynchronous IO - 异步IO</li></ul><p>同步：调用端会一直等待服务端响应，直到返回结果<br>异步：调用端发起调用之后不会立刻返回，不会等待服务端响应<br>阻塞：服务端返回结果之前，客户端线程会被挂起，此时线程不可被 CPU 调度，线程暂停运行<br>非阻塞：在服务端返回前，函数不会阻塞调用端线程，而会立刻返回</p><p><img src="/2021/05/05/goatc-9-network-programming-practice/io.png" alt></p><h3 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h3><p>Go 语言在采用 I/O 多路复用 模型处理 I/O 操作，但是他没有选择最常见的系统调用 select。虽然 select 也可以提供 I/O 多路复用的能力，但是使用它有比较多的限制：</p><ul><li>监听能力有限 — 最多只能监听 1024 个文件描述符；</li><li>内存拷贝开销大 — 需要维护一个较大的数据结构存储文件描述符，该结构需要拷贝到内核中；</li><li>时间复杂度 𝑂(𝑛) — 返回准备就绪的事件个数后，需要遍历所有的文件描述符；</li></ul><p>I/O多路复用：进程阻塞于 select，等待多个 IO 中的任一个变为可读，select调 用返回，通知相应 IO 可以读。 它可以支持单线程响应多个请求这种模式。</p><p><img src="/2021/05/05/goatc-9-network-programming-practice/iomm.png" alt></p><h3 id="多路复用模块"><a href="#多路复用模块" class="headerlink" title="多路复用模块"></a>多路复用模块</h3><p>为了提高 I/O 多路复用的性能<br>不同的操作系统也都实现了自己的 I/O 多路复用函数，例如：epoll、kqueue 和 evport 等<br>Go 语言为了提高在不同操作系统上的 I/O 操作性能，使用平台特定的函数实现了多个版本的网络轮询模块：</p><p>src/runtime/netpoll_epoll.go<br>src/runtime/netpoll_kqueue.go<br>src/runtime/netpoll_solaris.go<br>src/runtime/netpoll_windows.go<br>src/runtime/netpoll_aix.go<br>src/runtime/netpoll_fake.go</p><h2 id="Goim-长连接-TCP-编程"><a href="#Goim-长连接-TCP-编程" class="headerlink" title="Goim 长连接 TCP 编程"></a>Goim 长连接 TCP 编程</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul><li><p>Comet<br>长连接管理层，主要是监控外网 TCP/Websocket端口，并且通过设备 ID 进行绑定 Channel实 现，以及实现了 Room 合适直播等大房间消息广播。</p></li><li><p>Logic<br>逻辑层，监控连接 Connect、Disconnect 事件，可自定义鉴权，进行记录 Session 信息（设备 ID、ServerID、用户 ID），业务可通过设备 ID、用户 ID、RoomID、全局广播进行消息推送。</p></li><li><p>Job<br>通过消息队列的进行推送消峰处理，并把消息推送到对应 Comet 节点。</p></li></ul><p><strong>各个模块之间通过 gRPC 进行通信。</strong></p><p><img src="/2021/05/05/goatc-9-network-programming-practice/long-tcp-gai-lan.png" alt></p><h3 id="协议设计"><a href="#协议设计" class="headerlink" title="协议设计"></a>协议设计</h3><p>主要以包/针方式：<br>Package Length，包长度<br>Header Length，头长度<br>Protocol Version，协议版本<br>Operation，操作码<br>Sequence 请求序号 ID<br>Body，包内容</p><p>Operation:</p><ul><li>Auth</li><li>Heartbeat</li><li>Message</li></ul><p>Sequence</p><ul><li>按请求、响应对应递增 ID</li></ul><h3 id="边缘节点"><a href="#边缘节点" class="headerlink" title="边缘节点"></a>边缘节点</h3><p>Comet 长连接连续节点，通常部署在距离用户比较近，通过 TCP 或者 Websocket 建立连接，并且通过应用层 Heartbeat 进行保活检测，保证连接可用性。</p><p>节点之间通过云 VPC 专线通信，按地区部署分布。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>长连接负载均衡比较特殊，需要按一定的负载算法进行分配节点，可以通过 HTTPDNS 方式，请求获致到对应的节点 IP 列表，例如，返回固定数量 IP，按一定的权重或者最少连接数进行排序，客户端通过 IP 逐个重试连接；</p><ul><li>Comet 注册 IP 地址，以及节点权重，定时 Renew当前节点连接数量；</li><li>Balancer 按地区经纬度计算，按最近地区（经纬度）提供 Comet 节点 IP 列表，以及权重计算排序；</li><li>BFF 返回对应的长连接节点 IP，客户端可以通过 IP直接连；</li><li>客户端 按返回IP列表顺序，逐个连接尝试建立长连接</li></ul><h3 id="心跳保活机制"><a href="#心跳保活机制" class="headerlink" title="心跳保活机制"></a>心跳保活机制</h3><p>长连接断开的原因：<br>长连接所在进程被杀死<br>NAT 超时<br>网络状态发生变化，如移动网络 &amp; Wifi 切换、断开、重连<br>其他不可抗因素（网络状态差、DHCP 的租期等等 ）</p><p>高效维持长连接方案：<br>进程保活（防止进程被杀死）<br>心跳保活（阻止 NAT 超时）<br>断线重连（断网以后重新连接网络）</p><p>自适应心跳时间：<br>心跳可选区间，[min=60s，max=300s]<br>心跳增加步长，step=30s<br>心跳周期探测，success=current + step、fail=current - step</p><h3 id="用户鉴权和-Session-信息"><a href="#用户鉴权和-Session-信息" class="headerlink" title="用户鉴权和 Session 信息"></a>用户鉴权和 Session 信息</h3><p>用户鉴权，在长连接建立成功后，需要先进行连接鉴权，并且绑定对应的会话信息；</p><p>Connect，建立连接进行鉴权，保存Session信息：</p><ul><li>DeviceID，设备唯一 ID</li><li>Token，用户鉴权 Token，认证得到用户 ID</li><li>CometID，连接所在 comet 节点</li></ul><p>Disconnect，断开连接，删除对应Session信息：</p><ul><li>DeviceID，设备唯一 ID</li><li>CometID，连接所在 Comet 节点</li><li>UserID，用户 ID</li></ul><p>Session，会话信息通过Redis保存连接路由信息：</p><ul><li>连接维度，通过 设备 ID 找到所在 Comet 节点</li><li>用户维度，通过 用户 ID 找到对应的连接和 Comet所在节点</li></ul><h3 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h3><p>Comet 长连接层，实现连接管理和消息推送：</p><p>Protocol，TCP/Websocket 协议监听；</p><ul><li>Packet，长连接消息包，每个包都有固定长度；</li><li>Channel，消息管道相当于每个连接抽象，最终TCP/Websocket 中的封装，进行消息包的读写分发；</li><li>Bucket，连接通过 DeviceID 进行管理，用于读写锁拆散，并且实现房间消息推送，类似 Nginx Worker；</li><li>Room，房间管理通过 RoomID 进行管理，通过链表进行Channel遍历推送消息；</li></ul><p>每个 Bucket 都有独立的 Goroutine 和读写锁优化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Buckets &#123;  channels <span class="keyword">map</span>[<span class="keyword">string</span>]*Channel</span><br><span class="line">  rooms <span class="keyword">map</span>[<span class="keyword">string</span>]*Room&#125;</span><br></pre></td></tr></table></figure><h3 id="Logic"><a href="#Logic" class="headerlink" title="Logic"></a>Logic</h3><p>Logic 业务逻辑层，处理连接鉴权、消息路由，用户会话管理；</p><p>主要分为三层：</p><ul><li>sdk，通过 TCP/Websocket 建立长连接，进行重连、心跳保活；</li><li>goim，主要负责连接管理，提供消息长连能力；</li><li>backend，处理业务逻辑，对推送消息过虑，以及持久化相关等；</li></ul><h3 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h3><p>业务通过对应的推送方式，可以对连接设备、房间、用户ID进行推送，通过Session信息定位到所在的Comet连接节点，并通过Job推送消息；</p><p>通过Kafka进行推送消峰，保证消息逐步推送成功；</p><p>支持的多种推送方式：</p><ul><li>Push(DeviceID, Message)</li><li>Push(UserID, Message)</li><li>Push(RoomID, Message)</li><li>Push(Message)</li></ul><h3 id="推拉结合"><a href="#推拉结合" class="headerlink" title="推拉结合"></a>推拉结合</h3><p>在长连接中，如果想把消息通知所有人，主要有两种模式：一种是自己拿广播通知所有人，这叫“推”模式；一种是有人主动来找你要，这叫“拉”模式。；</p><p>在业务系统中，通常会有三种可能的做法：</p><ul><li>推模式，有新消息时服务器主动推给客户端；</li><li>拉模式，由前端主动发起拉取消息的请求；</li><li>推拉结合模式，有新消息实时通知，客户端再进行新的消息摘取；</li></ul><h3 id="读写扩散"><a href="#读写扩散" class="headerlink" title="读写扩散"></a>读写扩散</h3><p>一般消息系统中，通常会比较关注消息存储；<br>主要进行考虑“读”、“写”扩散，也就是性能问题；<br>在不同场景，可能选择不同的方式：</p><p>读扩散，在IM系统里的读扩散通常是每两个相关联的人就有一个信箱，或者每个群一个信箱。<br>优点：写操作（发消息）很轻量，只用写自己信箱<br>缺点：读操作（读消息）很重，需要读所有人信箱<br>写扩散，每个人都只从自己的信箱里读取消息，但写（发消息）的时候需要所有人写一份<br>优点：读操作很轻量<br>缺点：写操作很重，尤其是对于群聊来说</p><h3 id="唯一-ID-设计"><a href="#唯一-ID-设计" class="headerlink" title="唯一 ID 设计"></a>唯一 ID 设计</h3><p>唯一 ID，需要保证全局唯一，绝对不会出现重复的 ID，且 ID 整体趋势递增。<br>通常情况下，ID 的设计主要有以下几大类：</p><ul><li>UUID</li><li>基于 Snowflake 的 ID 生成方式</li><li>基于申请 DB 步长的生成方式</li><li>基于 Redis 或者 DB 的自增 ID生成方式</li><li>特殊的规则生成唯一 ID</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/" target="_blank" rel="noopener">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-netpoller/</a><br><a href="https://www.liwenzhou.com/posts/Go/15_socket/" target="_blank" rel="noopener">https://www.liwenzhou.com/posts/Go/15_socket/</a><br><a href="https://hit-alibaba.github.io/interview/basic/network/HTTP.html" target="_blank" rel="noopener">https://hit-alibaba.github.io/interview/basic/network/HTTP.html</a><br><a href="https://cloud.tencent.com/developer/article/1030660" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1030660</a><br><a href="https://juejin.cn/post/6844903827536117774" target="_blank" rel="noopener">https://juejin.cn/post/6844903827536117774</a><br><a href="https://xie.infoq.cn/article/19e95a78e2f5389588debfb1c" target="_blank" rel="noopener">https://xie.infoq.cn/article/19e95a78e2f5389588debfb1c</a><br><a href="https://tech.meituan.com/2019/03/07/open-source-project-leaf.html" target="_blank" rel="noopener">https://tech.meituan.com/2019/03/07/open-source-project-leaf.html</a><br><a href="https://mp.weixin.qq.com/s/8WmASie_DjDDMQRdQi1FDg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/8WmASie_DjDDMQRdQi1FDg</a><br><a href="https://www.imooc.com/article/265871" target="_blank" rel="noopener">https://www.imooc.com/article/265871</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;网络通信协议&quot;&gt;&lt;a href=&quot;#网络通信协议&quot; class=&quot;headerlink&quot; title=&quot;网络通信协议&quot;&gt;&lt;/a&gt;网络通
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="golang" scheme="https://octopuslian.github.io/tags/golang/"/>
    
      <category term="网络编程" scheme="https://octopuslian.github.io/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-播放历史架构设计</title>
    <link href="https://octopuslian.github.io/2021/05/05/goatc-7-play-history-architecture-design/"/>
    <id>https://octopuslian.github.io/2021/05/05/goatc-7-play-history-architecture-design/</id>
    <published>2021-05-05T13:05:21.000Z</published>
    <updated>2021-06-09T14:56:54.896Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --><h2 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h2><p>为了大部分用户的基本功能体验，满足用户需求，例如播放历史查看、播放进度同步等。离线型用户，app 本地保留历史记录数据。<br>同样的，也要考虑平台化，视频、文章、漫画等业务扩展接入。</p><ul><li>变更功能：添加记录、删除记录、清空历史。</li><li>读取功能：按照 timeline 返回 top N，点查获取进度信息。</li><li>其他功能：暂停/恢复记录，首次观察增加经验等。</li></ul><p><strong>历史记录类型的业务，是一个极高 tps 写入，高 qps 读取的业务服务。分析清楚系统的 hot path，投入优化，而不是哪哪都去优化。</strong></p><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul><li><p>BFF: app-interface、history<br>历史 BFF 层接受来自外部用户的读请求，依赖其他例如稿件、漫画服务来组装完整的面向历史业务（页面）需要的数据的组合。同时接受来自内部其他业务线的写请求，通常都是业务方自己进行业务 ID 的判定，然后投递到历史服务的 BFF 写接口中。最终 BFF 是打包在 app-interface 大杂烩 BFF 中，考虑到隔离性，读写流量很大，独立成 history BFF 服务。</p></li><li><p>Service: history-service<br>服务层，去平台业务的逻辑，专注在历史数据的持久化上(因为对于播放类业务，BFF 专注平台业务数据组织，service 负责数据的读、写、删、清理等操作。播放进度是非常高频同步的，需要考虑性能优化)。</p></li></ul><p><strong>使用 write-back 的思路，把状态数据先入分布式缓存，再回写数据库。</strong></p><ul><li><p>Job: history-job<br>job 消费上游 kafka 的数据，利用消息队列的堆积能力，对于存储层的差速(消费能力跟不上生产速度时)，可以进行一定的数据反压。配合上游 service 批量打包过来的数据持久化。</p></li><li><p>Upstream: some-app，some-api<br>整个历史服务还会被一些外部 gRPC 服务所依赖，所以 history 还充当了内网的 gRPC Provider，这些上游服务，使用历史服务的写接口，把自己业务的数据进行持久化。</p></li></ul><p><strong>历史服务最重要的设计，就是批量打包(pipeline)聚合数据。将高频、密集的写请求先入缓存(write-back)，批量消费减少对存储的直接压力，类似的设计随处可见。</strong></p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/gai-lan.png" alt></p><h3 id="history-service"><a href="#history-service" class="headerlink" title="history service"></a>history service</h3><p>专注在历史数据处理。</p><p>写的核心逻辑:<br>用户观看的稿件、漫画等，带有进度信息的数据，同一个 id 最后一次的数据即可，即 last-write win，高频的用户端同步逻辑，只需要最后一次数据持久化即可。我们可以在 in-process 内存中，定时定量来聚合不同用户的“同一个对象的最后一次进度”，使用 kafka 消息队列来消除写入峰值。但同时我们需要保证用户数据可以实时被观察到，不能出现上报进度后，需要一阵子才能体现进度变化。所以我们即在内存中打包数据，同时实时写入到 redis 中，这样即保证了实时，又避免海量写入冲击存储。</p><p>kafka 是为高吞吐设计，超高频的写入并不是最优，所以内存聚合和分片算法比较重要，按照 uid 来sharding 数据，写放大仍然很大，这里我们使用 region sharding，打包一组数据当作一个 kafka message(比如 uid % 100数据打包)。</p><p>写逻辑的数据流向: 实时写 redis -&gt; 内存维护用户数据 -&gt; 定时/定量写入到 kafka。</p><p>读的核心逻辑:<br>历史数据，实时写入 redis 后，不会无限制的存储，会按量截断，所以分布式缓存中数据不是完整数据，历史数据从 redis sortedset 中读取后，如果发现尾部数据不足，会触发 cache-aside 模式，从存储中回捞数据，但是不会重新回填缓存，因为拉取过去更久远的数据，属于用户纬度的低频度行为。历史数据通常是按照 timeline 来组织，游标的 key 可以使用时间戳进行翻页或者下拉。</p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/history-service.png" alt></p><h3 id="history-job"><a href="#history-job" class="headerlink" title="history job"></a>history job</h3><p>获取打包好的用户数据，进行批量持久化。</p><p>上游 history-service 按照 uid region sharding 聚合好的数据，在 job 中消费取出，为了节约传输过程，以及 history-service 的 in-process cache 的内存使用，我们只维护了用户的 uid 以及 id 列表，最小化存储和传输。因为数据是不完整的，我们额外需要从 redis 中按照 id 对应的数据内容，再持久化。从原来的 N 条记录变为一个用户一条记录。</p><p>对于存储的选型，我们认为 HBase 非常合适高密度写入。后续我们会单独讨论我们经历过的几次存储迭代和选型。</p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/history-job.png" alt></p><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><p>history 作为 BFF，对用户端提供统一的用户记录记录入口接口，同时也对内提供 gRPC 写入历史接口。如果业务场景中不存在统一的用户入口访问历史记录，可以去掉 BFF 层，直接使用 history-service 提供读接口，这样需要每个业务方自己实现自己的数据组装。</p><p>我们也有类似用户首次播放、观看等加经验或者奖励积分类似的操作，所以我们这里依赖 redis，进行判定用户当天是否是首次访问，我们比较容易想到使用 bitmap 或者 bloom filter 来进行判断，然后往下游 kafka 投递消息，而不直接依赖业务的某个服务。</p><p>Q：因为我们有关闭历史记录的功能，这样每次写入操作都需要前置读取一次，是否打开了开关，同样的每次首次发送奖励也是一样，你有更好的办法吗？</p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/history.png" alt></p><h2 id="存储设计"><a href="#存储设计" class="headerlink" title="存储设计"></a>存储设计</h2><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p>我们最早的主力存储选型是: HBase。</p><p>数据写入: PUT mid, values，只需要写入到 column_family 的 info 列簇，rowkey 使用用户 id md5 以后的头两位 + 用户，避免 rowkey 热点密集到一个 region 中，导致写/读热点。 对于 column_family: info，存储一个列 obj_id + obj_type，例如 稿件业务:1、稿件ID: 100，100_1 作为列名，对于 value 使用 protobuf 序列化一个结构体接入。所以只需要单次更新 kv store。另外我们使用 HBase TTL 的能力，只需要保存90天的用户数据即可。(删除同理)</p><p>数据读取: 列表获取为 GET mid，直接获取1000条，在内存中排序和翻页。点查 GET mid columns，在茫茫多视频查看当前视频的阅读进度，cache miss 会非常严重，虽然支持点查，但是对于上层 cache miss 后，不再回源请求 HBase。</p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/database-design.png" alt></p><h3 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h3><p>数据写入: 每次产生的历史数据，需要立马更新 redis，使用 sorted set 基于时间排序的列表，member 为业务 ID。同时存储一份数据到 redis string 中，使用 protobuf 序列化完整的数据内容。为了避免 redis 中单个用户数据无限增长，需要超过一定量后对数据进行截断。<br>数据读取: 分为两个场景，一个是历史页面，这时候使用 sorted set，排序查找即可，拿到列表后，mget 批量获取history_content 内容。<br>另外一个是点查进度，比如我们点击进入一个视频详情页，这时候直接查找 history_content 进行点查，不再回源 HBase，因为命中率太低。</p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/cache-design.png" alt></p><p>首次触发某行为，增加经验的，我们在缓存设计中，经常使用 bitmap(roaring bitmap)、bloom filter 缓存加速访问，但是在使用缓存时，需要注意规避热点问题，某个key sharding 命中 node 是固定的，因此我们可以利用构建多组 bitmap 或 bloom filter，来进行打散。</p><p>prefix_key = hash(mid) % 1000</p><p>根据 prefix_key 找到对应的 cache 再进行操作，这样 1000 个 key 尽可能均匀的分布到更小集合的 node，而不会产生数据热点。</p><p>Q：但是仍然每次触发行为，都为前置判定，有更好的优化方案吗？</p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/cache-design2.png" alt></p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/cache-design3.png" alt></p><h2 id="可用性设计"><a href="#可用性设计" class="headerlink" title="可用性设计"></a>可用性设计</h2><h3 id="Write-Back"><a href="#Write-Back" class="headerlink" title="Write Back"></a>Write Back</h3><p>在 history-service 中实时写入 redis 数据，因此只需要重点优化缓存架构中，扛住峰值的流量写入。之后在服务内存中，使用 map[int]map[int]struct{} 聚合数据，之后利用 chan 在内部发送每个小消息，再聚合成一个大map，在 sendproc 中，使用 timer 和 定量判定逻辑，发送到下游 kafka 中。</p><p>在 history-job 中，获取消息后，重新去 redis 中回捞数据即: history-content，然后构建完整的数据批量写入到 HBase 中。</p><p>这里存在两个风险:<br>1、history-service 重启过程中，预聚合的消息丢失；<br>2、history-job 读取 redis 构建数据，但 redis 丢失；</p><p><strong>我们在这里进行了 trade-off，高收敛比的设计，意味着存在数据丢失的风险，对于历史场景，非 L0 的业务服务/数据，我们认为极端情况下可接受。</strong></p><p><img src="/2021/05/05/goatc-7-play-history-architecture-design/wb.png" alt></p><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>经过 BFF history 的流量 per-request 都会发送给 history-service，我们最容易想到的优化就是聚合上移来减少发送给下游的 rpc。但是按照 mid region sharding 的思路非常具有业务的耦合性，所以不应该把逻辑上移，而只是数据上移，所以可以考虑简单 batch put 请求，做一个无逻辑的数据聚合再发送给 history-service，这样可以大大的减少内网的流量，节约资源。</p><p>我们发现经过 API Gateway 的流量都会触发高频的 per-rpc auth，给内网的 identify-service 带来了不少压力。我们认为大部分历史行为通过心跳的方式同步进度，为何不连接一个长连接，长连接服务再握手后先进行用户级的身份验证，之后维持身份信息，而不是每次发送 request 都进行验证，这样可以大大减少内网的 identify-service 的流量。</p><p>我们内网使用 boardcast(goim) 服务维护长连接，长连接一次验证，不断使用。</p><h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>用户首次触发的行为，需要发送消息给下游系统进行触发其他奖励等。如何减少这类一天只用一次的标记位缓存请求？</p><p>使用 in-process localcache，只有高频的用户访问，带来的收益就越大，我们很容易想到使用 LRU 维护这个集合，但用户分布很广，很难覆盖，命中率很低。</p><p>越源头解决架构问题，通常越简单，效率越高。</p><p>我们在写操作(高频请求)中，把当前的 flag 返回到 API 协议中，作为一个日期值，客户端保存到本地，下次请求的时候带上，如果发现该值在，获取以后直接使用不再请求缓存，例如: 2021-1-1，发现当前时间还是2021-1-1，直接不再请求 redis，如果发现当前时间是2021-1-2，需要触发一次 redis 访问，返回新的 flag 到客户端，这样把状态广播同步到任何其他设备，可以大大减少判定缓存。</p><p>实现成本在于，你认为的代价高低。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://en.wikipedia.org/wiki/Cache#Writing_Policies" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Cache#Writing_Policies</a><br><a href="https://blog.csdn.net/jiaomeng/article/details/1495500" target="_blank" rel="noopener">https://blog.csdn.net/jiaomeng/article/details/1495500</a><br><a href="https://blog.csdn.net/yizishou/article/details/78342499" target="_blank" rel="noopener">https://blog.csdn.net/yizishou/article/details/78342499</a><br><a href="https://blog.csdn.net/caoshangpa/article/details/78783749" target="_blank" rel="noopener">https://blog.csdn.net/caoshangpa/article/details/78783749</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;功能模块&quot;&gt;&lt;a href=&quot;#功能模块&quot; class=&quot;headerlink&quot; title=&quot;功能模块&quot;&gt;&lt;/a&gt;功能模块&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="架构设计" scheme="https://octopuslian.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="golang" scheme="https://octopuslian.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-微服务可用性设计</title>
    <link href="https://octopuslian.github.io/2021/05/05/goatc-5-microservice-availability-design/"/>
    <id>https://octopuslian.github.io/2021/05/05/goatc-5-microservice-availability-design/</id>
    <published>2021-05-05T04:43:20.000Z</published>
    <updated>2021-06-09T14:56:50.187Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --><h2 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h2><p>隔离，本质上是对系统或资源进行分割，从而实现当系统发生故障时能限定传播范围和影响范围，即发生故障后只有出问题的服务不可用，保证其他服务仍然可用。</p><p>服务隔离：动静分离、读写分离<br>轻重隔离：核心、快慢、热点<br>物理隔离:线程、进程、集群、机房</p><h3 id="服务隔离"><a href="#服务隔离" class="headerlink" title="服务隔离"></a>服务隔离</h3><h4 id="动静隔离"><a href="#动静隔离" class="headerlink" title="动静隔离:"></a>动静隔离:</h4><p>小到 CPU 的 cacheline false sharing、数据库 mysql 表设计中避免 bufferpool 频繁过期，隔离动静表，大到架构设计中的图片、静态资源等缓存加速。本质上都体现的一样的思路，即加速/缓存访问变换频次小的。比如 CDN 场景中，将静态资源和动态 API 分离，也是体现了隔离的思路:</p><ul><li>降低应用服务器负载，静态文件访问负载全部通过CDN。</li><li>对象存储存储费用最低。</li><li>海量存储空间，无需考虑存储架构升级。</li><li>静态CDN带宽加速，延迟低。</li></ul><h4 id="读写分离：主从、Replicaset、CQRS。"><a href="#读写分离：主从、Replicaset、CQRS。" class="headerlink" title="读写分离：主从、Replicaset、CQRS。"></a>读写分离：主从、Replicaset、CQRS。</h4><h3 id="轻重隔离"><a href="#轻重隔离" class="headerlink" title="轻重隔离"></a>轻重隔离</h3><h4 id="核心隔离"><a href="#核心隔离" class="headerlink" title="核心隔离"></a>核心隔离</h4><p>业务按照 Level 进行资源池划分(L0/L1/L2)。</p><ul><li>核心/非核心的故障域的差异隔离(机器资源、依赖资源)。</li><li>多集群，通过冗余资源来提升吞吐和容灾能力。</li></ul><h4 id="快慢隔离"><a href="#快慢隔离" class="headerlink" title="快慢隔离"></a>快慢隔离</h4><p>我们可以把服务的吞吐想象为一个池，当突然洪流进来时，池子需要一定时间才能排放完，这时候其他支流在池子里待的时间取决于前面的排放能力，耗时就会增高，对小请求产生影响。</p><p>日志传输体系的架构设计中，整个流都会投放到一个 kafka topic 中(早期设计目的: 更好的顺序IO)，流内会区分不同的 logid，logid 会有不同的 sink 端，它们之前会出现差速，比如 HDFS 抖动吞吐下降，ES 正常水位，全局数据就会整体反压。</p><ul><li>按照各种纬度隔离：sink、部门、业务、logid、重要性(S/A/B/C)。</li></ul><p>业务日志也属于某个 logid，日志等级就可以作为隔离通道。</p><h4 id="热点隔离"><a href="#热点隔离" class="headerlink" title="热点隔离"></a>热点隔离</h4><p>何为热点？热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 Top K 数据，并对其访问进行缓存。比如：</p><ul><li>小表广播: 从 remotecache 提升为 localcache，app 定时更新，甚至可以让运营平台支持广播刷新 localcache。</li><li>主动预热: 比如直播房间页高在线情况下bypass 监控主动防御。</li></ul><h3 id="物理隔离"><a href="#物理隔离" class="headerlink" title="物理隔离"></a>物理隔离</h3><h4 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h4><p>主要通过线程池进行隔离，也是实现服务隔离的基础。把业务进行分类并交给不同的线程池进行处理，当某个线程池处理一种业务请求发生问题时，不会讲故障扩散和影响到其他线程池，保证服务可用。</p><p>对于 Go 来说，所有 IO 都是 Nonblocking，且托管给了 Runtime，只会阻塞Goroutine，不阻塞 M，我们只需要考虑 Goroutine 总量的控制，不需要线程模型语言的线程隔离。</p><h4 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h4><p>容器化(docker)，容器编排引擎(k8s)。</p><h4 id="集群隔离"><a href="#集群隔离" class="headerlink" title="集群隔离"></a>集群隔离</h4><p>逻辑上是一个应用，物理上部署多套应用，通过 cluster 区分。</p><h3 id="Case-Stduy"><a href="#Case-Stduy" class="headerlink" title="Case Stduy"></a>Case Stduy</h3><ul><li>早期转码集群被超大视频攻击，导致转码大量延迟。</li><li>入口Nginx(SLB)故障，影响全机房流量入口故障。</li><li>缩略图服务，被大图实时缩略吃完所有 CPU，导致正常的小图缩略被丢弃，大量503。</li><li>数据库实例 cgroup 未隔离，导致大 SQL 引起的集体故障。</li><li>INFO 日志量过大，导致异常 ERROR 日志采集延迟。</li></ul><h2 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h2><p>超时控制，我们的组件能够快速失效(fail fast)，因为我们不希望等到断开的实例直到超时。没有什么比挂起的请求和无响应的界面更令人失望。这不仅浪费资源，而且还会让用户体验变得更差。我们的服务是互相调用的，所以在这些延迟叠加前，应该特别注意防止那些超时的操作。</p><ul><li>网路传递具有不确定性。</li><li>客户端和服务端不一致的超时策略导致资源浪费。</li><li>“默认值”策略。</li><li>高延迟服务导致 client 浪费资源等待，使用超时传递: 进程间传递 + 跨进程传递。</li></ul><h3 id="Case-Stduy-1"><a href="#Case-Stduy-1" class="headerlink" title="Case Stduy"></a>Case Stduy</h3><ul><li>SLB 入口 Nginx 没配置超时导致连锁故障。</li><li>服务依赖的 DB 连接池漏配超时，导致请求阻塞，最终服务集体 OOM。</li><li>下游服务发版耗时增加，而上游服务配置超时过短，导致上游请求失败。</li></ul><h2 id="过载保护"><a href="#过载保护" class="headerlink" title="过载保护"></a>过载保护</h2><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。令牌桶算法的描述如下：</p><ul><li>假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌。</li><li>桶中最多存放 b 个令牌，当桶满时，新添加的令牌被丢弃或拒绝。</li><li>当一个 n 个字节大小的数据包到达，将从桶中删除n 个令牌，接着数据包被发送到网络上。</li><li>如果桶中的令牌不足 n 个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。</li></ul><h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>作为计量工具(The Leaky Bucket Algorithm as a Meter)时，可以用于流量整形(Traffic Shaping)和流量控制(TrafficPolicing)，漏桶算法的描述如下：</p><ul><li>一个固定容量的漏桶，按照常量固定速率流出水滴。</li><li>如果桶是空的，则不需流出水滴。</li><li>可以以任意速率流入水滴到漏桶。</li><li>如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的。</li></ul><h3 id="如何计算接近峰值时的系统吞吐？"><a href="#如何计算接近峰值时的系统吞吐？" class="headerlink" title="如何计算接近峰值时的系统吞吐？"></a>如何计算接近峰值时的系统吞吐？</h3><ul><li>CPU: 使用一个独立的线程采样，每隔 250ms 触发一次。在计算均值时，使用了简单滑动平均去除峰值的影响。</li><li>Inflight: 当前服务中正在进行的请求的数量。</li><li>Pass&amp;RT: 最近5s，pass 为每100ms采样窗口内成功请求的数量，rt 为单个采样窗口中平均响应时间。</li></ul><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>限流是指在一段时间内，定义某个客户或应用可以接收或处理多少个请求的技术。例如，通过限流，你可以过滤掉产生流量峰值的客户和微服务，或者可以确保你的应用程序在自动扩展(Auto Scaling)失效前都不会出现过载的情况。</p><ul><li>令牌桶、漏桶 针对单个节点，无法分布式限流。</li><li>QPS 限流</li><li>不同的请求可能需要数量迥异的资源来处理。</li><li>某种静态 QPS 限流不是特别准。</li></ul><p>给每个用户设置限制</p><ul><li>全局过载发生时候，针对某些“异常”进行控制。</li><li>一定程度的“超卖”配额。</li><li>按照优先级丢弃。</li><li>拒绝请求也需要成本。</li></ul><h3 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a>分布式限流</h3><p>分布式限流，是为了控制某个应用全局的流量，而非真对单个节点纬度。</p><ul><li>单个大流量的接口，使用 redis 容易产生热点。</li><li>pre-request 模式对性能有一定影响，高频的网络往返。</li></ul><p>Q：如何来分配资源？<br>A：“最大最小公平分享”(Max-Min Fairness)。</p><p>最大最小公平分配算法的形式化定义如下：</p><ul><li>资源按照需求递增的顺序进行分配。</li><li>不存在用户得到的资源超过自己的需求。</li><li>未得到满足的用户等价的分享资源。</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><a href="./goatc-5-microservice-availability-design/fen-bu-shi-xian-liu.png"></a></p><h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>每个接口配置阈值，运营工作繁重，最简单的我们配置服务级别 quota，更细粒度的，我们可以根据不同重要性设定 quota，我们引入了重要性(criticality):</p><ul><li>最重要 CRITICAL_PLUS，为最终的要求预留的类型，拒绝这些请求会造成非常严重的用户可见的问题。</li><li>重要 CRITICAL，生产任务发出的默认请求类型。拒绝这些请求也会造成用户可见的问题。但是可能没那么严重。</li><li>可丢弃的 SHEDDABLE_PLUS 这些流量可以容忍某种程度的不可用性。这是批量任务发出的请求的默认值。这些请求通常可以过几分钟、几小时后重试。</li><li>可丢弃的 SHEDDABLE 这些流量可能会经常遇到部分不可用情况，偶尔会完全不可用。</li></ul><p>gRPC 系统之间，需要自动传递重要性信息。如果后端接受到请求 A，在处理过程中发出了请求 B 和 C 给其他后端，请求 B 和 C 会使用与 A 相同的重要性属性。</p><ul><li>全局配额不足时，优先拒绝低优先级的。</li><li>全局配额，可以按照重要性分别设置。</li><li>过载保护时，低优先级的请求先被拒绝。</li></ul><h3 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h3><p>断路器(Circuit Breakers): 为了限制操作的持续时间，我们可以使用超时，超时可以防止挂起操作并保证系统可以响应。因为我们处于高度动态的环境中，几乎不可能确定在每种情况下都能正常工作的准确的时间限制。断路器以现实世界的电子元件命名，因为它们的行为是都是相同的。断路器在分布式系统中非常有用，因为重复的故障可能会导致雪球效应，并使整个系统崩溃。</p><ul><li>服务依赖的资源出现大量错误。</li><li>某个用户超过资源配额时，后端任务会快速拒绝请求，返回“配额不足”的错误，但是拒绝回复仍然会消耗一定资源。有可能后端忙着不停发送拒绝请求，导致过载。</li></ul><h3 id="Gutter"><a href="#Gutter" class="headerlink" title="Gutter"></a>Gutter</h3><p>基于熔断的 gutter kafka ，用于接管自动修复系统运行过程中的负载，这样只需要付出10%的资源就能解决部分系统可用性问题。</p><p>我们经常使用 failover 的思路，但是完整的 failover 需要翻倍的机器资源，平常不接受流量时，资源浪费。高负载情况下接管流量又不一定完整能接住。所以这里核心利用熔断的思路，是把抛弃的流量转移到 gutter 集群，如果 gutter 也接受不住的流量，重新回抛到主集群，最大力度来接受。</p><h3 id="客户端流控"><a href="#客户端流控" class="headerlink" title="客户端流控"></a>客户端流控</h3><p>positive feedback: 用户总是积极重试，访问一个不可达的服务。</p><ul><li>客户端需要限制请求频次，retry backoff 做一定的请求退让。</li><li>可以通过接口级别的error_details，挂载到每个 API 返回的响应里。</li></ul><h3 id="Case-Study"><a href="#Case-Study" class="headerlink" title="Case Study"></a>Case Study</h3><ul><li><p>二层缓存穿透、大量回源导致的核心服务故障。</p></li><li><p>异常客户端引起的服务故障(query of death)<br>(1)请求放大。<br>(2)资源数放大。</p></li><li><p>用户重试导致的大面积故障。</p></li></ul><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>通过降级回复来减少工作量，或者丢弃不重要的请求。而且需要了解哪些流量可以降级，并且有能力区分不同的请求。我们通常提供降低回复的质量来答复减少所需的计算量或者时间。我们自动降级通常需要考虑几个点：</p><ul><li>确定具体采用哪个指标作为流量评估和优雅降级的决定性指标(如，CPU、延迟、队列长度、线程数量、错误等)。</li><li>当服务进入降级模式时，需要执行什么动作？</li><li>流量抛弃或者优雅降级应该在服务的哪一层实现？是否需要在整个服务的每一层都实现，还是可以选择某个高层面的关键节点来实现？</li></ul><p>同时我们要考虑一下几点：</p><ul><li>优雅降级不应该被经常触发 - 通常触发条件现实了容量规划的失误，或者是意外的负载。</li><li>演练，代码平时不会触发和使用，需要定期针对一小部分的流量进行演练，保证模式的正常。</li><li>应该足够简单。</li></ul><p>降级本质为: <strong>提供有损服务。</strong></p><ul><li><p>UI 模块化，非核心模块降级。<br>BFF 层聚合 API，模块降级。</p></li><li><p>页面上一次缓存副本。</p></li><li><p>默认值、热门推荐等。</p></li><li><p>流量拦截 + 定期数据缓存(过期副本策略)。</p></li><li><p>处理策略<br>页面降级、延迟服务、写/读降级、缓存降级<br>抛异常、返回约定协议、Mock 数据、Fallback 处理</p></li></ul><h3 id="Case-Study-1"><a href="#Case-Study-1" class="headerlink" title="Case Study"></a>Case Study</h3><ul><li>客户端解析协议失败，app 奔溃。</li><li>客户端部分协议不兼容，导致页面失败。</li><li>local cache 数据源缓存，发版失效 + 依赖接口故障，引起的白屏。</li><li>没有 playbook，导致的 MTTR 上升。</li></ul><h2 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h2><p>当请求返回错误(例: 配额不足、超时、内部错误等)，对于 backend 部分节点过载的情况下，倾向于立刻重试，但是需要留意重试带来的流量放大:</p><ul><li>限制重试次数和基于重试分布的策略(重试比率: 10%)。</li><li>随机化、指数型递增的重试周期: exponential ackoff + jitter。</li><li>client 测记录重试次数直方图，传递到 server，进行分布判定，交由 server 判定拒绝。</li><li>只应该在失败的这层进行重试，当重试仍然失败，全局约定错误码“过载，无须重试”，避免级联重试。</li></ul><h3 id="Case-Study-2"><a href="#Case-Study-2" class="headerlink" title="Case Study"></a>Case Study</h3><ul><li><p>Nginx upstream retry 过大，导致服务雪崩。</p></li><li><p>业务不幂等，导致的重试，数据重复。<br>(1)全局唯一 ID: 根据业务生成一个全局唯一 ID，在调用接口时会传入该 ID，接口提供方会从相应的存储系统比如 redis 中去检索这个全局 ID 是否存在，如果存在则说明该操作已经执行过了，将拒绝本次服务请求；否则将相应该服务请求并将全局 ID 存入存储系统中,之后包含相同业务 ID 参数的请求将被拒绝。<br>(2)去重表: 这种方法适用于在业务中有唯一标识的插入场景。比如在支付场景中，一个订单只会支付一次，可以建立一张去重表,将订单 ID 作为唯一索引。把支付并且写入支付单据到去重表放入一个事务中了，这样当出现重复支付时，数据库就会抛出唯一约束异常,操作就会回滚。这样保证了订单只会被支付一次。<br>(3)多版本并发控制: 适合对更新请求作幂等性控制,比如要更新商品的名字，这是就可以在更新的接口中增加一个版本号来做幂等性控制。</p></li><li><p>多层级重试传递，放大流量引起雪崩。</p></li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>数据中心内部的负载均衡</p><p>在理想情况下，某个服务的负载会完全均匀地分发给所有的后端任务。在任何时刻，最忙和最不忙的节点永远消耗同样数量的CPU。</p><p>目标：</p><ul><li>均衡的流量分发。</li><li>可靠的识别异常节点。</li><li>scale-out，增加同质节点扩容。</li><li>减少错误，提高可用性。</li></ul><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul><li>变更管理:<br>70％的问题是由变更引起的，恢复可用代码并不总是坏事。</li><li>避免过载:<br>过载保护、流量调度等。</li><li>依赖管理:<br>任何依赖都可能故障，做 chaos monkey testing，注入故障测试。</li><li>优雅降级:<br>有损服务，避免核心链路依赖故障。</li><li>重试退避:<br>退让算法，冻结时间，API retry detail 控制策略。</li><li>超时控制:<br>进程内 + 服务间 超时控制。</li><li>极限压测 + 故障演练。</li><li>扩容 + 重启 + 消除有害流量。</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="http://www.360doc.com/content/16/1124/21/31263000_609259745.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/16/1124/21/31263000_609259745.shtml</a><br><a href="http://www.infoq.com/cn/articles/basis-frameworkto-implement-micro-service/" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/basis-frameworkto-implement-micro-service/</a><br><a href="http://www.infoq.com/cn/news/2017/04/linkerd-celebrates-one-year" target="_blank" rel="noopener">http://www.infoq.com/cn/news/2017/04/linkerd-celebrates-one-year</a><br><a href="https://medium.com/netflix-techblog/netflix-edge-load-balancing-695308b5548c" target="_blank" rel="noopener">https://medium.com/netflix-techblog/netflix-edge-load-balancing-695308b5548c</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAwNjQwNzU2NQ==&amp;mid=402841629&amp;idx=1&amp;sn=f598fec9b370b8a6f2062233b31122e0&amp;mpshare=1&amp;scene=23&amp;srcid=0404qP0fH8zRiIiFzQBiuzuU#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAwNjQwNzU2NQ==&amp;mid=402841629&amp;idx=1&amp;sn=f598fec9b370b8a6f2062233b31122e0&amp;mpshare=1&amp;scene=23&amp;srcid=0404qP0fH8zRiIiFzQBiuzuU#rd</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzIzMzk2NDQyMw==&amp;mid=2247486641&amp;idx=1&amp;sn=1660fb41b0c5b8d8d6eacdfc1b26b6a6&amp;source=41#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzIzMzk2NDQyMw==&amp;mid=2247486641&amp;idx=1&amp;sn=1660fb41b0c5b8d8d6eacdfc1b26b6a6&amp;source=41#wechat_redirect</a><br><a href="https://blog.acolyer.org/2018/11/16/overload-control-for-scaling-wechat-microservices/" target="_blank" rel="noopener">https://blog.acolyer.org/2018/11/16/overload-control-for-scaling-wechat-microservices/</a><br><a href="https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf" target="_blank" rel="noopener">https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf</a><br><a href="https://github.com/alibaba/Sentinel/wiki/系统负载保护" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel/wiki/系统负载保护</a><br><a href="https://blog.csdn.net/okiwilldoit/article/details/81738782" target="_blank" rel="noopener">https://blog.csdn.net/okiwilldoit/article/details/81738782</a><br><a href="http://alex-ii.github.io/notes/2019/02/13/predictive_load_balancing.html" target="_blank" rel="noopener">http://alex-ii.github.io/notes/2019/02/13/predictive_load_balancing.html</a><br><a href="https://blog.csdn.net/m0_38106113/article/details/81542863" target="_blank" rel="noopener">https://blog.csdn.net/m0_38106113/article/details/81542863</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;隔离&quot;&gt;&lt;a href=&quot;#隔离&quot; class=&quot;headerlink&quot; title=&quot;隔离&quot;&gt;&lt;/a&gt;隔离&lt;/h2&gt;&lt;p&gt;隔离，本质
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="架构设计" scheme="https://octopuslian.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="微服务" scheme="https://octopuslian.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="golang" scheme="https://octopuslian.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-评论系统架构设计</title>
    <link href="https://octopuslian.github.io/2021/05/04/goatc-6-comment-system-architecture-design/"/>
    <id>https://octopuslian.github.io/2021/05/04/goatc-6-comment-system-architecture-design/</id>
    <published>2021-05-04T14:41:57.000Z</published>
    <updated>2021-06-09T14:56:53.082Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --><p><strong>架构设计最重要的就是理解整个产品体系在系统中的定位。搞清楚系统背后的背景，才能做出最佳的设计和抽象。不要做需求的翻译机，先理解业务背后的本质，事情的初衷。</strong></p><h2 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h2><p>评论系统，我们往小里做就是视频评论系统，往大里做就是评论平台，可以接入各种业务形态。</p><ul><li>发布评论: 支持回复楼层、楼中楼。</li><li>读取评论: 按照时间、热度排序。</li><li>删除评论: 用户删除、作者删除。</li><li>管理评论: 作者置顶、后台运营管理(搜索、删除、审核等)。</li></ul><h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><ul><li><p>BFF: comment<br>复杂评论业务的服务编排，比如访问账号服务进行等级判定，同时需要在 BFF 面向移动端/WEB场景来设计 API，这一层抽象把评论的本身的内容列表处理(加载、分页、排序等)进行了隔离，关注在业务平台化逻辑上。</p></li><li><p>Service: comment-service<br>服务层，去平台业务的逻辑，专注在评论功能的 API 实现上，比如发布、读取、删除等，关注在稳定性、可用性上，这样让上游可以灵活组织逻辑把基础能力和业务能力剥离。</p></li><li><p>Job: comment-job<br>消息队列的最大用途是消峰处理。</p></li></ul><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/gai-lan.png" alt></p><h3 id="comment-service"><a href="#comment-service" class="headerlink" title="comment service"></a>comment service</h3><p>专注在评论数据处理。</p><p>读的核心逻辑:<br>Cache-Aside 模式，先读取缓存，再读取存储。早期 cache rebuild 是做到服务里的，对于重建逻辑，一般会使用 read ahead 的思路，即预读，用户访问了第一页，很有可能访问第二页，所以缓存会超前加载，避免频繁 cache miss。当缓存抖动是否，特别容易引起集群 hundering herd 现象，大量的请求会触发 cache rebuild，因为使用了预加载，容易导致服务 OOM。所以我们开到回源的逻辑里，我们使用了消息队列来进行逻辑异步化，对于当前请求只返回 mysql 中部分数据即止。</p><p>写的核心逻辑:<br>我们担心类似“明星出轨”等热点事件的发生，而且写和读相比较，写可以认为是透穿到存储层的，系统的瓶颈往往就来自于存储层，或者有状态层。对于写的设计上，我们认为刚发布的评论有极短的延迟(通常小于几 ms)对用户可见是可接受的，把对存储的直接冲击下放到消息队列，按照消息反压的思路，即如果存储 latency 升高，消费能力就下降，自然消息容易堆积，系统始终以最大化方式消费。</p><p>Kafka 是存在 partition 概念的，可以认为是物理上的一个小队列，一个 topic 是由一组 partition 组成的，所以 Kafka 的吞吐模型理解为: 全局并行，局部串行的生产消费方式。对于入队的消息，可以按照 hash(comment_subject) % N(partitions) 的方式进行分发。那么某个 partition 中的 评论主题的数据一定都在一起，这样方便我们串行消费。<br>同样的，我们处理回源消息也是类似的思路。</p><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/comment-service.png" alt></p><h3 id="comment-admin"><a href="#comment-admin" class="headerlink" title="comment admin"></a>comment admin</h3><p>mysql binlog 中的数据被 canal 中间件流式消费，获取到业务的原始 CRUD 操作，需要回放录入到 es 中，但是 es 中的数据最终是面向运营体系提供服务能力，需要检索的数据维度比较多，在入 es 前需要做一个异构的 joiner，把单表变宽预处理好 join 逻辑，然后倒入到 es 中。<br>一般来说，运营后台的检索条件都是组合的，使用 es 的好处是避免依赖 mysql 来做多条件组合检索，同时 mysql 毕竟是 oltp 面向线上联机事务处理的。通过冗余数据的方式，使用其他引擎来实现。<br>es 一般会存储检索、展示、primary key 等数据，当我们操作编辑的时候，找到记录的 primary key，最后交由 comment-admin 进行运营测的 CRUD 操作。</p><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/comment-admin.png" alt></p><h3 id="comment"><a href="#comment" class="headerlink" title="comment"></a>comment</h3><p>comment 作为 BFF，是面向端，面向平台，面向业务组合的服务。所以平台扩展的能力，我们都在 comment 服务来实现，方便统一和准入平台，以统一的接口形式提供平台化的能力。</p><ul><li>依赖其他 gRPC 服务，整合统一平台测的逻辑(比如发布评论用户等级限定)。</li><li>直接向端上提供接口，提供数据的读写接口，甚至可以整合端上，提供统一的端上 SDK。</li><li>需要对非核心依赖的 gRPC 服务进行降级，当这些服务不稳定时。</li></ul><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/comment.png" alt></p><h2 id="存储设计"><a href="#存储设计" class="headerlink" title="存储设计"></a>存储设计</h2><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p>数据写入: 事务更新 comment_subject，comment_index，comment_content 三张表，其中 content 属于非强制需要一致性考虑的。可以先写入 content，之后事务更新其他表。即便 content 先成功，后续失败仅仅存在一条 ghost 数据。</p><p>数据读取: 基于 obj_id + obj_type 在 comment_index 表找到评论列表，WHERE root = 0 ORDER BY floor。之后根据 comment_index 的 id 字段捞出 comment_content 的评论内容。对于二级的子楼层，WHERE parent/root IN (id…)。</p><p>因为产品形态上只存在二级列表，因此只需要迭代查询两次即可。对于嵌套层次多的，产品上，可以通过二次点击支持。</p><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/database-design.png" alt></p><h3 id="索引内容分离"><a href="#索引内容分离" class="headerlink" title="索引内容分离"></a>索引内容分离</h3><p>comment_index: 评论楼层的索引组织表，实际并不包含内容。comment_content: 评论内容的表，包含评论的具体内容。其中 comment_index 的 id 字段和 comment_content 是1对1的关系，这里面包含几种设计思想。</p><ul><li>表都有主键，即 cluster index，是物理组织形式存放的，comment_content 没有 id，是为了减少一次 二级索引查找，直接基于主键检索，同时 comment_id 在写入要尽可能的顺序自增。</li><li>索引、内容分离，方便 mysql datapage 缓存更多的 row，如果和 context 耦合，会导致更大的 IO。长远来看 content 信息可以直接使用 KV storage 存储。</li></ul><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/suo-yin-nei-rong-fen-li.png" alt></p><h3 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h3><p>comment_subject_cache: 对应主题的缓存，value 使用 protobuf 序列化的方式存入。我们早期使用 memcache 来进行缓存，因为 redis 早期单线程模型，吞吐能力不高。</p><p>comment_index_cache: 使用 redis sortedset 进行索引的缓存，索引即数据的组织顺序，而非数据内容。参考过百度的贴吧，他们使用自己研发的拉链存储来组织索引，我认为 mysql 作为主力存储，利用 redis 来做加速完全足够，因为 cache miss 的构建，我们前面讲过使用 kafka 的消费者中处理，预加载少量数据，通过增量加载的方式逐渐预热填充缓存，而 redis sortedset skiplist 的实现，可以做到 O(logN) + O(M) 的时间复杂度，效率很高。</p><p>sorted set 是要增量追加的，因此必须判定 key 存在，才能 zdd。</p><p>comment_content_cache: 对应评论内容数据，使用 protobuf 序列化的方式存入。类似的我们早期使用 memcache 进行缓存。</p><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/cache-design.png" alt></p><h2 id="可用性设计"><a href="#可用性设计" class="headerlink" title="可用性设计"></a>可用性设计</h2><h3 id="Singleflight"><a href="#Singleflight" class="headerlink" title="Singleflight"></a>Singleflight</h3><p>对于热门的主题，如果存在缓存穿透的情况，会导致大量的同进程、跨进程的数据回源到存储层，可能会引起存储过载的情况，如何只交给同进程内，一个人去做加载存储?</p><p>使用归并回源的思路:<br><a href="https://pkg.go.dev/golang.org/x/sync/singleflight" target="_blank" rel="noopener">https://pkg.go.dev/golang.org/x/sync/singleflight</a></p><p>同进程只交给一个人去获取 mysql 数据，然后批量返回。同时这个 lease owner 投递一个 kafka 消息，做 index cache 的 recovery 操作。这样可以大大减少 mysql 的压力，以及大量透穿导致的密集写 kafka 的问题。</p><p>更进一步的，后续连续的请求，仍然可能会短时 cache miss，我们可以在进程内设置一个 short-lived flag，标记最近有一个人投递了 cache rebuild 的消息，直接 drop。</p><p>Q：为什么我们不用分布式锁之类的思路？</p><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/singleflight.png" alt></p><h3 id="热点"><a href="#热点" class="headerlink" title="热点"></a>热点</h3><p>流量热点是因为突然热门的主题，被高频次的访问，因为底层的 cache 设计，一般是按照主题 key 进行一致性 hash 来进行分片，但是热点 key 一定命中某一个节点，这时候 remote cache 可能会变为瓶颈，因此做 cache 的升级 local cache 是有必要的，我们一般使用单进程自适应发现热点的思路，附加一个短时的 ttl local cache，可以在进程内吞掉大量的读请求。<br>在内存中使用 hashmap 统计每个 key 的访问频次，这里可以使用滑动窗口统计，即每个窗口中，维护一个 hashmap，之后统计所有未过去的 bucket，汇总所有 key 的数据。<br>之后使用小堆计算 TopK 的数据，自动进行热点识别。</p><p><img src="/2021/05/04/goatc-6-comment-system-architecture-design/hot.png" alt></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;strong&gt;架构设计最重要的就是理解整个产品体系在系统中的定位。搞清楚系统背后的背景，才能做出最佳的设计和抽象。不要做需求的翻译机，先理解业
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="架构设计" scheme="https://octopuslian.github.io/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="golang" scheme="https://octopuslian.github.io/tags/golang/"/>
    
      <category term="评论系统" scheme="https://octopuslian.github.io/tags/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-工程化实践</title>
    <link href="https://octopuslian.github.io/2021/05/04/goatc-4-go-engineering-practice/"/>
    <id>https://octopuslian.github.io/2021/05/04/goatc-4-go-engineering-practice/</id>
    <published>2021-05-04T08:26:13.000Z</published>
    <updated>2021-06-09T14:56:48.906Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --><h1 id="工程项目结构"><a href="#工程项目结构" class="headerlink" title="工程项目结构"></a>工程项目结构</h1><h2 id="Standard-Go-Project-Layout"><a href="#Standard-Go-Project-Layout" class="headerlink" title="Standard Go Project Layout"></a>Standard Go Project Layout</h2><h3 id="cmd"><a href="#cmd" class="headerlink" title="/cmd"></a>/cmd</h3><p>本项目的主干。<br>每个应用程序的目录名应该与你想要的可执行文件的名称相匹配(例如，/cmd/myapp)。<br>不要在这个目录中放置太多代码。如果你认为代码可以导入并在其他项目中使用，那么它应该位于 /pkg 目录中。如果代码不是可重用的，或者你不希望其他人重用它，请将该代码放到 /internal 目录中。</p><h3 id="internal"><a href="#internal" class="headerlink" title="/internal"></a>/internal</h3><p>私有应用程序和库代码。这是你不希望其他人在其应用程序或库中导入代码。请注意，这个布局模式是由 Go 编译器本身执行的。有关更多细节，请参阅Go 1.4 release notes。</p><p>注意，你并不局限于顶级 internal 目录。在项目树的任何级别上都可以有多个内部目录。</p><p>你可以选择向 internal 包中添加一些额外的结构，以分隔共享和非共享的内部代码。这不是必需的(特别是对于较小的项目)，但是最好有有可视化的线索来显示预期的包的用途。你的实际应用程序代码可以放在 /internal/app 目录下(例如 /internal/app/myapp)，这些应用程序共享的代码可以放在 /internal/pkg 目录下(例如 /internal/pkg/myprivlib)。</p><h3 id="pkg"><a href="#pkg" class="headerlink" title="/pkg"></a>/pkg</h3><p>外部应用程序可以使用的库代码(例如 /pkg/mypubliclib)。其他项目会导入这些库，所以在这里放东西之前要三思:-)注意，internal 目录是确保私有包不可导入的更好方法，因为它是由 Go 强制执行的。/pkg 目录仍然是一种很好的方式，可以显式地表示该目录中的代码对于其他人来说是安全使用的好方法。</p><p>/pkg 目录内，可以参考 go 标准库的组织方式，按照功能分类。/internla/pkg 一般用于项目内的 跨多个应用的公共共享代码，但其作用域仅在单个项目工程内。</p><p><strong>当根目录包含大量非 Go 组件和目录时，这也是一种将 Go 代码分组到一个位置的方法，这使得运行各种 Go 工具变得更加容易组织。</strong></p><h2 id="Kit-Project-Layout"><a href="#Kit-Project-Layout" class="headerlink" title="Kit Project Layout"></a>Kit Project Layout</h2><p>基础库 kit 为独立项目，公司级建议只有一个，按照功能目录来拆分会带来不少的管理工作，因此建议合并整合。</p><p>by [Package Oriented Design]</p><blockquote><p>“To this end, the Kit project is not allowed to have a vendor folder. If any of packages are dependent on 3rd party packages, they must always build against the latest version of those dependences.”</p></blockquote><p>kit 项目必须具备的特点:</p><ul><li>统一</li><li>标准库方式布局</li><li>高度抽象</li><li>支持插件</li></ul><h2 id="Service-Application-Project-Layout"><a href="#Service-Application-Project-Layout" class="headerlink" title="Service Application Project Layout"></a>Service Application Project Layout</h2><h3 id="api"><a href="#api" class="headerlink" title="/api"></a>/api</h3><p>API 协议定义目录，xxapi.proto protobuf 文件，以及生成的 go 文件。我们通常把 api 文档直接在 proto 文件中描述。</p><h3 id="configs"><a href="#configs" class="headerlink" title="/configs"></a>/configs</h3><p>配置文件模板或默认配置。</p><h3 id="test"><a href="#test" class="headerlink" title="/test"></a>/test</h3><p>额外的外部测试应用程序和测试数据。你可以随时根据需求构造 /test 目录。对于较大的项目，有一个数据子目录是有意义的。例如，你可以使用 /test/data 或 /test/testdata (如果你需要忽略目录中的内容)。请注意，Go 还会忽略以“.”或“_”开头的目录或文件，因此在如何命名测试数据目录方面有更大的灵活性。<br>不应该包含：/src</p><p>有些 Go 项目确实有一个 src 文件夹，但这通常发生在开发人员有 Java 背景，在那里它是一种常见的模式。不要将项目级别 src 目录与 Go 用于其工作空间的 src 目录。</p><p>一个 gitlab 的 project 里可以放置多个微服务的app(类似 monorepo)。也可以按照 gitlab 的 group 里建立多个 project，每个 project 对应一个 app。<br>多 app 的方式，app 目录内的每个微服务按照自己的全局唯一名称，比如 “account.service.vip” 来建立目录，如: account/vip/*。<br>和 app 平级的目录 pkg 存放业务有关的公共库（非基础框架库）。如果应用不希望导出这些目录，可以放置到 myapp/internal/pkg 中。</p><h1 id="API设计"><a href="#API设计" class="headerlink" title="API设计"></a>API设计</h1><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p>“A high-performance, open-source universal RPC framework”</p><ul><li>多语言：语言中立，支持多种语言。</li><li>轻量级、高性能：序列化支持 PB(Protocol Buffer)和 JSON，PB 是一种语言无关的高性能序列化框架。<br>可插拔</li><li>IDL：基于文件定义服务，通过 proto3 工具生成指定语言的数据结构、服务端接口以及客户端 Stub。</li></ul><p>设计理念</p><ul><li><p>移动端：基于标准的 HTTP2 设计，支持双向流、消息头压缩、单 TCP 的多路复用、服务端推送等特性，这-些特性使得 gRPC 在移动端设备上更加省电和节省网络流量。</p></li><li><p>服务而非对象、消息而非引用：促进微服务的系统间粗粒度消息交互设计理念。</p></li><li><p>负载无关的：不同的服务需要使用不同的消息类型和编码，例如 protocol buffers、JSON、XML和Thrift。</p></li><li><p>流: Streaming API。</p></li><li><p>阻塞式和非阻塞式：支持异步和同步处理在客户端和服务端间交互的消息序列。</p></li><li><p>元数据交换：常见的横切关注点，如认证或跟踪，依赖数据交换。</p></li><li><p>标准化状态码：客户端通常以有限的方式响应 API 调用返回的错误。</p></li></ul><p><strong>不要过早关注性能问题，先标准化。</strong></p><p>为了统一检索和规范 API，我们内部建立了一个统一的 bapis 仓库，整合所有对内对外 API。</p><p>API 仓库，方便跨部门协作。<br>版本管理，基于 git 控制。<br>规范化检查，API lint。<br>API design review，变更 diff。<br>权限管理，目录 OWNERS。</p><h2 id="API-Compatibility"><a href="#API-Compatibility" class="headerlink" title="API Compatibility"></a>API Compatibility</h2><p>向后兼容(非破坏性)的修改<br>给 API 服务定义添加 API 接口<br>从协议的角度来看，这始终是安全的。</p><p>给请求消息添加字段<br>只要客户端在新版和旧版中对该字段的处理不保持一致，添加请求字段就是兼容的。</p><p>给响应消息添加字段<br>在不改变其他响应字段的行为的前提下，非资源（例如，ListBooksResponse）的响应消息可以扩展而不必破坏客户端的兼容性。即使会引入冗余，先前在响应中填充的任何字段应继续使用相同的语义填充。</p><p>向后不兼容(破坏性)的修改<br>删除或重命名服务，字段，方法或枚举值<br>从根本上说，如果客户端代码可以引用某些东西，那么删除或重命名它都是不兼容的变化，这时必须修改major 版本号。<br>修改字段的类型<br>即使新类型是传输格式兼容的，这也可能会导致客户端库生成的代码发生变化，因此必须增加major版本号。 对于编译型静态语言来说，会容易引入编译错误。<br>修改现有请求的可见行为<br>客户端通常依赖于 API 行为和语义，即使这样的行为没有被明确支持或记录。 因此，在大多数情况下，修改 API 数据的行为或语义将被消费者视为是破坏性的。如果行为没有加密隐藏，您应该假设用户已经发现它，并将依赖于它。<br>给资源消息添加 读取/写入 字段</p><h2 id="API-Naming-Conventions"><a href="#API-Naming-Conventions" class="headerlink" title="API Naming Conventions"></a>API Naming Conventions</h2><p>包名为应用的标识(APP_ID)，用于生成 gRPC 请求路径，或者 proto 之间进行引用 Message。文件中声明的包名称应该与产品和服务名称保持一致。带有版本的 API 的软件包名称必须以此版本结尾。<br>my.package.v1，为 API 目录，定义service相关接口，用于提供业务使用。</p><p>// RequestURL: /<package_name>.<version>.<service_name>/{method}<br>package<package_name>.<version>;</version></package_name></service_name></version></package_name></p><h2 id="API-Primitive-Fields"><a href="#API-Primitive-Fields" class="headerlink" title="API Primitive Fields"></a>API Primitive Fields</h2><p>gRPC 默认使用 Protobuf v3 格式，因为去除了 required 和 optional 关键字，默认全部都是 optional 字段。如果没有赋值的字段，默认会基础类型字段的默认值，比如 0 或者 “”。<br>Protobuf v3 中，建议使用：<a href="https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wrappers.proto" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wrappers.proto</a><br>Warpper 类型的字段，即包装一个 message，使用时变为指针。</p><p>Protobuf 作为强 schema 的描述文件，也可以方便扩展，是不是用于配置文件定义也可？</p><h2 id="API-Errors"><a href="#API-Errors" class="headerlink" title="API Errors"></a>API Errors</h2><p>使用一小组标准错误配合大量资源<br>例如，服务器没有定义不同类型的“找不到”错误，而是使用一个标准 google.rpc.Code.NOT_FOUND 错误代码并告诉客户端找不到哪个特定资源。状态空间变小降低了文档的复杂性，在客户端库中提供了更好的惯用映射，并降低了客户端的逻辑复杂性，同时不限制是否包含可操作信息(/google/rpc/error_details)。<br>错误传播<br>如果您的 API 服务依赖于其他服务，则不应盲目地将这些服务的错误传播到您的客户端。在翻译错误时，我们建议执行以下操作：<br>隐藏实现详细信息和机密信息。<br>调整负责该错误的一方。例如，从另一个服务接收 INVALID_ARGUMENT 错误的服务器应该将 INTERNAL 传播给它自己的调用者。</p><p>全局错误码<br>全局错误码，是松散、易被破坏契约的，基于我们上述讨论的，在每个服务传播错误的时候，做一次翻译，这样保证每个服务 + 错误枚举，应该是唯一的，而且在 proto 定义中是可以写出来文档的。</p><h2 id="API-Design"><a href="#API-Design" class="headerlink" title="API Design"></a>API Design</h2><h1 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h1><h2 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/gomods/athens</span><br><span class="line">https://goproxy.cn</span><br><span class="line"></span><br><span class="line">https://blog.golang.org/modules2019</span><br><span class="line">https://blog.golang.org/using-go-modules</span><br><span class="line">https://blog.golang.org/migrating-to-go-modules</span><br><span class="line">https://blog.golang.org/module-mirror-launch</span><br><span class="line">https://blog.golang.org/publishing-go-modules</span><br><span class="line">https://blog.golang.org/v2-go-modules</span><br><span class="line">https://blog.golang.org/module-compatibility</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="Unittest"><a href="#Unittest" class="headerlink" title="Unittest"></a>Unittest</h2><p>小型测试带来优秀的代码质量、良好的异常处理、优雅的错误报告；大中型测试会带来整体产品质量和数据验证。<br>不同类型的项目，对测试的需求不同，总体上有一个经验法则，即70/20/10原则：70%是小型测试，20%是中型测试，10%是大型测试。<br>如果一个项目是面向用户的，拥有较高的集成度，或者用户接口比较复杂，他们就应该有更多的中型和大型测试；如果是基础平台或者面向数据的项目，例如索引或网络爬虫，则最好有大量的小型测试，中型测试和大型测试的数量要求会少很多。</p><p>“自动化实现的，用于验证一个单独函数或独立功能模块的代码是否按照预期工作，着重于典型功能性问题、数据损坏、错误条件和大小差一错误（译注：大小差一(off-by-one)错误是一类常见的程序设计错误）等方面的验证”<br>- 《Google软件测试之道》</p><p>单元测试的基本要求：<br>快速<br>环境一致<br>任意顺序<br>并行</p><p>基于 docker-compose 实现跨平台跨语言环境的容器依赖管理方案，以解决运行 unittest 场景下的(mysql, redis, mc)容器依赖问题:<br>本地安装 Docker。<br>无侵入式的环境初始化。<br>快速重置环境。<br>随时随地运行(不依赖外部服务)。<br>语义式 API 声明资源。</p><p>真实外部依赖，而非 in-process 模拟。<br>正确的对容器内服务进行健康检测，避免unittest 启动时候资源还未 ready。<br>应该交由 app 自己来初始化数据，比如 db 的scheme，初始的 sql 数据等，为了满足测试的一致性，在每次结束后，都会销毁容器。<br>在单元测试开始前，导入封装好的 testing 库，方便启动和销毁容器。<br>对于 service 的单元测试，使用 gomock 等库把 dao mock 掉，所以在设计包的时候，应该面向抽象编程。<br>在本地执行依赖 Docker，在 CI 环境里执行Unittest，需要考虑在物理机里的 Docker 网络，或者在 Docker 里再次启动一个 Docker。</p><p>利用 go 官方提供的: Subtests + Gomock 完成整个单元测试。<br>/api<br>比较适合进行集成测试，直接测试 API，使用 API 测试框架(例如: yapi)，维护大量业务测试 case。<br>/data<br>docker compose 把底层基础设施真实模拟，因此可以去掉 infra 的抽象层。<br>/biz<br>依赖 repo、rpc client，利用 gomock 模拟 interface 的实现，来进行业务单元测试。<br>/service<br>依赖 biz 的实现，构建 biz 的实现类传入，进行单元测试。<br>基于 git branch 进行 feature 开发，本地进行 unittest，之后提交 gitlab merge request 进行 CI 的单元测试，基于 feature branch 进行构建，完成功能测试，之后合并 master，进行集成测试，上线后进行回归测试。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html</a><br><a href="https://www.ardanlabs.com/blog/2017/02/design-philosophy-on-packaging.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2017/02/design-philosophy-on-packaging.html</a><br><a href="https://github.com/golang-standards/project-layout" target="_blank" rel="noopener">https://github.com/golang-standards/project-layout</a><br><a href="https://github.com/golang-standards/project-layout/blob/master/README_zh.md" target="_blank" rel="noopener">https://github.com/golang-standards/project-layout/blob/master/README_zh.md</a><br><a href="https://www.cnblogs.com/zxf330301/p/6534643.html" target="_blank" rel="noopener">https://www.cnblogs.com/zxf330301/p/6534643.html</a><br><a href="https://blog.csdn.net/k6T9Q8XKs6iIkZPPIFq/article/details/109192475?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160561008419724839224387%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=160561008419724839224387&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-6-109192475.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=阿里技术专家详解DDD系列&amp;spm=1018.2118.3001.4449" target="_blank" rel="noopener">https://blog.csdn.net/k6T9Q8XKs6iIkZPPIFq/article/details/109192475?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160561008419724839224387%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=160561008419724839224387&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-6-109192475.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=阿里技术专家详解DDD系列&amp;spm=1018.2118.3001.4449</a><br><a href="https://blog.csdn.net/chikuai9995/article/details/100723540?biz_id=102&amp;utm_term=阿里技术专家详解DDD系列&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-100723540&amp;spm=1018.2118.3001.4449" target="_blank" rel="noopener">https://blog.csdn.net/chikuai9995/article/details/100723540?biz_id=102&amp;utm_term=阿里技术专家详解DDD系列&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-100723540&amp;spm=1018.2118.3001.4449</a><br><a href="https://blog.csdn.net/Taobaojishu/article/details/101444324?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160561008419724838528569%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160561008419724838528569&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-101444324.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=阿里技术专家详解DDD系列&amp;spm=1018.2118.3001.4449" target="_blank" rel="noopener">https://blog.csdn.net/Taobaojishu/article/details/101444324?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160561008419724838528569%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160561008419724838528569&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-101444324.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=阿里技术专家详解DDD系列&amp;spm=1018.2118.3001.4449</a><br><a href="https://blog.csdn.net/taobaojishu/article/details/106152641" target="_blank" rel="noopener">https://blog.csdn.net/taobaojishu/article/details/106152641</a><br><a href="https://cloud.google.com/apis/design/errors" target="_blank" rel="noopener">https://cloud.google.com/apis/design/errors</a><br><a href="https://kb.cnblogs.com/page/520743/" target="_blank" rel="noopener">https://kb.cnblogs.com/page/520743/</a><br><a href="https://zhuanlan.zhihu.com/p/105466656" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/105466656</a><br><a href="https://zhuanlan.zhihu.com/p/105648986" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/105648986</a><br><a href="https://zhuanlan.zhihu.com/p/106634373" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/106634373</a><br><a href="https://zhuanlan.zhihu.com/p/107347593" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/107347593</a><br><a href="https://zhuanlan.zhihu.com/p/109048532" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/109048532</a><br><a href="https://zhuanlan.zhihu.com/p/110252394" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/110252394</a><br><a href="https://www.jianshu.com/p/dfa427762975" target="_blank" rel="noopener">https://www.jianshu.com/p/dfa427762975</a><br><a href="https://www.citerus.se/go-ddd/" target="_blank" rel="noopener">https://www.citerus.se/go-ddd/</a><br><a href="https://www.citerus.se/part-2-domain-driven-design-in-go/" target="_blank" rel="noopener">https://www.citerus.se/part-2-domain-driven-design-in-go/</a><br><a href="https://www.citerus.se/part-3-domain-driven-design-in-go/" target="_blank" rel="noopener">https://www.citerus.se/part-3-domain-driven-design-in-go/</a><br><a href="https://www.jianshu.com/p/dfa427762975" target="_blank" rel="noopener">https://www.jianshu.com/p/dfa427762975</a><br><a href="https://www.jianshu.com/p/5732b69bd1a1" target="_blank" rel="noopener">https://www.jianshu.com/p/5732b69bd1a1</a></p><p><a href="https://www.cnblogs.com/qixuejia/p/10789612.html" target="_blank" rel="noopener">https://www.cnblogs.com/qixuejia/p/10789612.html</a><br><a href="https://www.cnblogs.com/qixuejia/p/4390086.html" target="_blank" rel="noopener">https://www.cnblogs.com/qixuejia/p/4390086.html</a><br><a href="https://www.cnblogs.com/qixuejia/p/10789621.html" target="_blank" rel="noopener">https://www.cnblogs.com/qixuejia/p/10789621.html</a><br><a href="https://zhuanlan.zhihu.com/p/46603988" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46603988</a><br><a href="https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wrappers.proto" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/wrappers.proto</a><br><a href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis" target="_blank" rel="noopener">https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis</a><br><a href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html" target="_blank" rel="noopener">https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html</a><br><a href="https://blog.csdn.net/taobaojishu/article/details/106152641" target="_blank" rel="noopener">https://blog.csdn.net/taobaojishu/article/details/106152641</a></p><p><a href="https://apisyouwonthate.com/blog/creating-good-api-errors-in-rest-graphql-and-grpc" target="_blank" rel="noopener">https://apisyouwonthate.com/blog/creating-good-api-errors-in-rest-graphql-and-grpc</a><br><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="noopener">https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html</a><br><a href="https://www.youtube.com/watch?v=oL6JBUk6tj0" target="_blank" rel="noopener">https://www.youtube.com/watch?v=oL6JBUk6tj0</a><br><a href="https://github.com/zitryss/go-sample" target="_blank" rel="noopener">https://github.com/zitryss/go-sample</a><br><a href="https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md" target="_blank" rel="noopener">https://github.com/danceyoung/paper-code/blob/master/package-oriented-design/packageorienteddesign.md</a><br><a href="https://medium.com/@eminetto/clean-architecture-using-golang-b63587aa5e3f" target="_blank" rel="noopener">https://medium.com/@eminetto/clean-architecture-using-golang-b63587aa5e3f</a><br><a href="https://hackernoon.com/golang-clean-archithecture-efd6d7c43047" target="_blank" rel="noopener">https://hackernoon.com/golang-clean-archithecture-efd6d7c43047</a><br><a href="https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1" target="_blank" rel="noopener">https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1</a><br><a href="https://medium.com/wtf-dial/wtf-dial-domain-model-9655cd523182" target="_blank" rel="noopener">https://medium.com/wtf-dial/wtf-dial-domain-model-9655cd523182</a><br><a href="https://hackernoon.com/golang-clean-archithecture-efd6d7c43047" target="_blank" rel="noopener">https://hackernoon.com/golang-clean-archithecture-efd6d7c43047</a><br><a href="https://hackernoon.com/trying-clean-architecture-on-golang-2-44d615bf8fdf" target="_blank" rel="noopener">https://hackernoon.com/trying-clean-architecture-on-golang-2-44d615bf8fdf</a><br><a href="https://manuel.kiessling.net/2012/09/28/applying-the-clean-architecture-to-go-applications/" target="_blank" rel="noopener">https://manuel.kiessling.net/2012/09/28/applying-the-clean-architecture-to-go-applications/</a><br><a href="https://github.com/katzien/go-structure-examples" target="_blank" rel="noopener">https://github.com/katzien/go-structure-examples</a><br><a href="https://www.youtube.com/watch?v=MzTcsI6tn-0" target="_blank" rel="noopener">https://www.youtube.com/watch?v=MzTcsI6tn-0</a><br><a href="https://www.appsdeveloperblog.com/dto-to-entity-and-entity-to-dto-conversion/" target="_blank" rel="noopener">https://www.appsdeveloperblog.com/dto-to-entity-and-entity-to-dto-conversion/</a><br><a href="https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/" target="_blank" rel="noopener">https://travisjeffery.com/b/2019/11/i-ll-take-pkg-over-internal/</a><br><a href="https://github.com/google/wire/blob/master/docs/best-practices.md" target="_blank" rel="noopener">https://github.com/google/wire/blob/master/docs/best-practices.md</a><br><a href="https://github.com/google/wire/blob/master/docs/guide.md" target="_blank" rel="noopener">https://github.com/google/wire/blob/master/docs/guide.md</a><br><a href="https://blog.golang.org/wire" target="_blank" rel="noopener">https://blog.golang.org/wire</a><br><a href="https://github.com/google/wire" target="_blank" rel="noopener">https://github.com/google/wire</a><br><a href="https://www.ardanlabs.com/blog/2019/03/integration-testing-in-go-executing-tests-with-docker.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2019/03/integration-testing-in-go-executing-tests-with-docker.html</a><br><a href="https://www.ardanlabs.com/blog/2019/10/integration-testing-in-go-set-up-and-writing-tests.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2019/10/integration-testing-in-go-set-up-and-writing-tests.html</a><br><a href="https://blog.golang.org/examples" target="_blank" rel="noopener">https://blog.golang.org/examples</a><br><a href="https://blog.golang.org/subtests" target="_blank" rel="noopener">https://blog.golang.org/subtests</a><br><a href="https://blog.golang.org/cover" target="_blank" rel="noopener">https://blog.golang.org/cover</a><br><a href="https://blog.golang.org/module-compatibility" target="_blank" rel="noopener">https://blog.golang.org/module-compatibility</a><br><a href="https://blog.golang.org/v2-go-modules" target="_blank" rel="noopener">https://blog.golang.org/v2-go-modules</a><br><a href="https://blog.golang.org/publishing-go-modules" target="_blank" rel="noopener">https://blog.golang.org/publishing-go-modules</a><br><a href="https://blog.golang.org/module-mirror-launch" target="_blank" rel="noopener">https://blog.golang.org/module-mirror-launch</a><br><a href="https://blog.golang.org/migrating-to-go-modules" target="_blank" rel="noopener">https://blog.golang.org/migrating-to-go-modules</a><br><a href="https://blog.golang.org/using-go-modules" target="_blank" rel="noopener">https://blog.golang.org/using-go-modules</a><br><a href="https://blog.golang.org/modules2019" target="_blank" rel="noopener">https://blog.golang.org/modules2019</a><br><a href="https://blog.codecentric.de/en/2017/08/gomock-tutorial/" target="_blank" rel="noopener">https://blog.codecentric.de/en/2017/08/gomock-tutorial/</a><br><a href="https://pkg.go.dev/github.com/golang/mock/gomock" target="_blank" rel="noopener">https://pkg.go.dev/github.com/golang/mock/gomock</a><br><a href="https://medium.com/better-programming/a-gomock-quick-start-guide-71bee4b3a6f1" target="_blank" rel="noopener">https://medium.com/better-programming/a-gomock-quick-start-guide-71bee4b3a6f1</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --&gt;&lt;h1 id=&quot;工程项目结构&quot;&gt;&lt;a href=&quot;#工程项目结构&quot; class=&quot;headerlink&quot; title=&quot;工程项目结构&quot;&gt;&lt;/a&gt;工程项
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="项目" scheme="https://octopuslian.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="golang" scheme="https://octopuslian.github.io/tags/golang/"/>
    
      <category term="工程" scheme="https://octopuslian.github.io/tags/%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-并行编程</title>
    <link href="https://octopuslian.github.io/2021/05/02/goatc-3-concurrency/"/>
    <id>https://octopuslian.github.io/2021/05/02/goatc-3-concurrency/</id>
    <published>2021-05-02T13:32:19.000Z</published>
    <updated>2021-06-23T14:58:44.560Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --><h2 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h2><h3 id="Processes-and-Threads"><a href="#Processes-and-Threads" class="headerlink" title="Processes and Threads"></a>Processes and Threads</h3><p>操作系统会为该应用程序创建一个进程。作为一个应用程序，它像一个为所有资源而运行的容器。这些资源包括内存地址空间、文件句柄、设备和线程。<br>线程是操作系统调度的一种执行路径，用于在处理器执行我们在函数中编写的代码。一个进程从一个线程开始，即主线程，当该线程终止时，进程终止。这是因为主线程是应用程序的原点。然后，主线程可以依次启动更多的线程，而这些线程可以启动更多的线程。</p><p>无论线程属于哪个进程，操作系统都会安排线程在可用处理器上运行。每个操作系统都有自己的算法来做出这些决定。</p><h2 id="Goroutines-and-Parallelism"><a href="#Goroutines-and-Parallelism" class="headerlink" title="Goroutines and Parallelism"></a>Goroutines and Parallelism</h2><p>Go 语言层面支持的 go 关键字，可以快速的让一个函数创建为 goroutine，我们可以认为 main 函数就是作为 goroutine 执行的。操作系统调度线程在可用处理器上运行，Go运行时调度 goroutines 在绑定到单个操作系统线程的逻辑处理器中运行(P)。即使使用这个单一的逻辑处理器和操作系统线程，也可以调度数十万 goroutine 以惊人的效率和性能并发运行。</p><p><strong>Concurrency is not Parallelism.（并行不意味着并发）</strong></p><p>并发(可以同时做)不是并行(不同的执行单元)。</p><p>并行是指两个或多个线程同时在不同的处理器执行代码。如果将运行时配置为使用多个逻辑处理器，则调度程序将在这些逻辑处理器之间分配 goroutine，这将导致 goroutine 在不同的操作系统线程上运行。但是，要获得真正的并行性，您需要在具有多个物理处理器的计算机上运行程序。否则，goroutines 将针对单个物理处理器并发运行，即使 Go 运行时使用多个逻辑处理器。</p><h3 id="Keep-your-busy-or-do-the-work-yourself"><a href="#Keep-your-busy-or-do-the-work-yourself" class="headerlink" title="Keep your busy or do the work yourself"></a>Keep your busy or do the work yourself</h3><p>空的select语句将永远堵塞：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Sprintln(w, <span class="string">"Hello，GopherCon SG"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">":8000"</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Incomplete-Work"><a href="#Incomplete-Work" class="headerlink" title="Incomplete Work"></a>Incomplete Work</h3><h2 id="Memory-model"><a href="#Memory-model" class="headerlink" title="Memory model"></a>Memory model</h2><p><a href="https://golang.org/ref/mem" target="_blank" rel="noopener">https://golang.org/ref/mem</a></p><p>如何保证在一个 goroutine 中看到在另一个 goroutine 修改的变量的值，如果程序中修改数据时有其他 goroutine 同时读取，那么必须将读取串行化。为了串行化访问，请使用 channel 或其他同步原语，例如 sync 和 sync/atomic 来保护数据。</p><h3 id="Happen-Before"><a href="#Happen-Before" class="headerlink" title="Happen-Before"></a>Happen-Before</h3><p>在一个 goroutine 中，读和写一定是按照程序中的顺序执行的。即编译器和处理器只有在不会改变这个 goroutine 的行为时才可能修改读和写的执行顺序。由于重排，不同的goroutine 可能会看到不同的执行顺序。例如，一个goroutine 执行 a = 1;b = 2;，另一个 goroutine 可能看到 b 在 a 之前更新。</p><h3 id="Memory-Reordering"><a href="#Memory-Reordering" class="headerlink" title="Memory Reordering"></a>Memory Reordering</h3><p>用户写下的代码，先要编译成汇编代码，也就是各种指令，包括读写内存的指令。CPU 的设计者们，为了榨干 CPU 的性能，无所不用其极，各种手段都用上了，你可能听过不少，像流水线、分支预测等等。其中，为了提高读写内存的效率，会对读写指令进行重新排列，这就是所谓的 内存重排，英文为 MemoryReordering。</p><h2 id="Package-sync"><a href="#Package-sync" class="headerlink" title="Package sync"></a>Package sync</h2><p>传统的线程模型(通常在编写 Java、C++ 和Python 程序时使用)程序员在线程之间通信需要使用共享内存。通常，共享数据结构由锁保护，线程将争用这些锁来访问数据。在某些情况下，通过使用线程安全的数据结构(如Python的Queue)，这会变得更容易。</p><p>Go 的并发原语 goroutines 和 channels 为构造并发软件提供了一种优雅而独特的方法。Go 没有显式地使用锁来协调对共享数据的访问，而是鼓励使用 chan 在 goroutine 之间传递对数据的引用。这种方法确保在给定的时间只有一个goroutine 可以访问数据。</p><p>Do not communicate by sharing memory; instead, share memory by communicating.</p><h3 id="Detecting-Race-Conditions-With-Go"><a href="#Detecting-Race-Conditions-With-Go" class="headerlink" title="Detecting Race Conditions With Go"></a>Detecting Race Conditions With Go</h3><p>data race 是两个或多个 goroutine 访问同一个资源(如变量或数据结构)，并尝试对该资源进行读写而不考虑其他 goroutine。这种类型的代码可以创建您见过的最疯狂和最随机的 bug。通常需要大量的日志记录和运气才能找到这些类型的bug。</p><p>早在6月份的Go 1.1中，Go 工具引入了一个 race detector。竞争检测器是在构建过程中内置到程序中的代码。然后，一旦你的程序运行，它就能够检测并报告它发现的任何竞争条件。它非常酷，并且在识别罪魁祸首的代码方面做了令人难以置信的工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3/8.go</span><br><span class="line">go build -race</span><br><span class="line">go test -race</span><br></pre></td></tr></table></figure><h3 id="sync-atomic"><a href="#sync-atomic" class="headerlink" title="sync.atomic"></a>sync.atomic</h3><h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><h3 id="errgroup"><a href="#errgroup" class="headerlink" title="errgroup"></a>errgroup</h3><h3 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a>sync.Pool</h3><h2 id="chan"><a href="#chan" class="headerlink" title="chan"></a>chan</h2><h3 id="Channels"><a href="#Channels" class="headerlink" title="Channels"></a>Channels</h3><p>channels 是一种类型安全的消息队列，充当两个 goroutine 之间的管道，将通过它同步的进行任意资源的交换。chan 控制 goroutines 交互的能力从而创建了 Go 同步机制。当创建的 chan 没有容量时，称为无缓冲通道。反过来，使用容量创建的 chan 称为缓冲通道。</p><h3 id="Unbuffered-Channels"><a href="#Unbuffered-Channels" class="headerlink" title="Unbuffered Channels"></a>Unbuffered Channels</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>无缓冲 chan 没有容量，因此进行任何交换前需要两个 goroutine 同时准备好。当 goroutine 试图将一个资源发送到一个无缓冲的通道并且没有goroutine 等待接收该资源时，该通道将锁住发送 goroutine 并使其等待。当 goroutine 尝试从无缓冲通道接收，并且没有 goroutine 等待发送资源时，该通道将锁住接收 goroutine 并使其等待。</p><p>无缓冲信道的本质是保证同步。</p><h3 id="Buffered-Channels"><a href="#Buffered-Channels" class="headerlink" title="Buffered Channels"></a>Buffered Channels</h3><p>buffered channel 具有容量，因此其行为可能有点不同。当 goroutine 试图将资源发送到缓冲通道，而该通道已满时，该通道将锁住 goroutine并使其等待缓冲区可用。如果通道中有空间，发送可以立即进行，goroutine 可以继续。当goroutine 试图从缓冲通道接收数据，而缓冲通道为空时，该通道将锁住 goroutine 并使其等待资源被发送。</p><h3 id="Latencies-due-to-under-sized-buffer"><a href="#Latencies-due-to-under-sized-buffer" class="headerlink" title="Latencies due to under-sized buffer"></a>Latencies due to under-sized buffer</h3><p>我们在 chan 创建过程中定义的缓冲区大小可能会极大地影响性能。我将使用密集使用 chan 的扇出模式来查看不同缓冲区大小的影响。在我们的基准测试中，一个 producer 将在通道中注入百万个整数元素，而5个 worker 将读取并将它们追加到一个名为 total 的结果变量中。</p><h3 id="Go-Concurrency-Patterns"><a href="#Go-Concurrency-Patterns" class="headerlink" title="Go Concurrency Patterns"></a>Go Concurrency Patterns</h3><ul><li><p>Timing out</p></li><li><p>Moving on</p></li><li><p>Pipeline</p></li><li><p>Fan-out, Fan-in</p></li><li><p>Cancellation<br>Close 先于 Receive 发生(类似 Buffered)。<br>不需要传递数据，或者传递 nil。<br>非常适合去掉和超时控制。</p></li><li><p>Contex<br><a href="https://blog.golang.org/concurrency-timeouts" target="_blank" rel="noopener">https://blog.golang.org/concurrency-timeouts</a><br><a href="https://blog.golang.org/pipelines" target="_blank" rel="noopener">https://blog.golang.org/pipelines</a><br><a href="https://talks.golang.org/2013/advconc.slide#1" target="_blank" rel="noopener">https://talks.golang.org/2013/advconc.slide#1</a><br><a href="https://github.com/go-kratos/kratos/tree/master/pkg/sync" target="_blank" rel="noopener">https://github.com/go-kratos/kratos/tree/master/pkg/sync</a></p></li></ul><h2 id="Package-context"><a href="#Package-context" class="headerlink" title="Package context"></a>Package context</h2><h3 id="Request-scoped-context"><a href="#Request-scoped-context" class="headerlink" title="Request-scoped context"></a>Request-scoped context</h3><p>在 Go 服务中，每个传入的请求都在其自己的goroutine 中处理。请求处理程序通常启动额外的 goroutine 来访问其他后端，如数据库和 RPC服务。处理请求的 goroutine 通常需要访问特定于请求(request-specific context)的值，例如最终用户的身份、授权令牌和请求的截止日期(deadline)。当一个请求被取消或超时时，处理该请求的所有 goroutine 都应该快速退出(fail fast)，这样系统就可以回收它们正在使用的任何资源。</p><p>Go 1.7 引入一个 context 包，它使得跨 API 边界的请求范围元数据、取消信号和截止日期很容易传递给处理请求所涉及的所有 goroutine(显示传递)。</p><h3 id="Do-not-store-Contexts-inside-a-struct-type"><a href="#Do-not-store-Contexts-inside-a-struct-type" class="headerlink" title="Do not store Contexts inside a struct type"></a>Do not store Contexts inside a struct type</h3><h3 id="context-WithValue"><a href="#context-WithValue" class="headerlink" title="context.WithValue"></a>context.WithValue</h3><h3 id="Debugging-or-tracing-data-is-safe-to-pass-in-a-Context"><a href="#Debugging-or-tracing-data-is-safe-to-pass-in-a-Context" class="headerlink" title="Debugging or tracing data is safe to pass in a Context"></a>Debugging or tracing data is safe to pass in a Context</h3><h3 id="When-a-Context-is-canceled-all-Contexts-derived-from-it-are-also-canceled"><a href="#When-a-Context-is-canceled-all-Contexts-derived-from-it-are-also-canceled" class="headerlink" title="When a Context is canceled, all Contexts derived from it are also canceled"></a>When a Context is canceled, all Contexts derived from it are also canceled</h3><h3 id="All-blocking-long-operations-should-be-cancelable"><a href="#All-blocking-long-operations-should-be-cancelable" class="headerlink" title="All blocking/long operations should be cancelable"></a>All blocking/long operations should be cancelable</h3><h2 id="Final-Notes"><a href="#Final-Notes" class="headerlink" title="Final Notes"></a>Final Notes</h2><ul><li>Incoming requests to a server should create a Context.</li><li>Outgoing calls to servers should accept a Context.</li><li>Do not store Contexts inside a struct type; instead, pass a Context explicitly to each function that needs it.</li><li>The chain of function calls between them must propagate the Context.</li><li>Replace a Context using WithCancel, WithDeadline, WithTimeout, or WithValue.</li><li>When a Context is canceled, all Contexts derived from it are also canceled.</li><li>The same Context may be passed to functions running in different goroutines; Contexts are safe for simultaneous use by multiple goroutines.</li><li>Do not pass a nil Context, even if a function permits it. Pass a TODO context if you are unsure about which Context to use.</li><li>Use context values only for request-scoped data that transits processes and APIs, not for passing optional parameters to functions.</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2018/11/goroutine-leaks-the-forgotten-sender.html</a><br><a href="https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2019/04/concurrency-trap-2-incomplete-work.html</a><br><a href="https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/01/concurrency-goroutines-and-gomaxprocs.html</a><br><a href="https://dave.cheney.net/practical-go/presentations/qcon-china.html#_concurrency" target="_blank" rel="noopener">https://dave.cheney.net/practical-go/presentations/qcon-china.html#_concurrency</a><br><a href="https://golang.org/ref/mem" target="_blank" rel="noopener">https://golang.org/ref/mem</a><br><a href="https://blog.csdn.net/caoshangpa/article/details/78853919" target="_blank" rel="noopener">https://blog.csdn.net/caoshangpa/article/details/78853919</a><br><a href="https://blog.csdn.net/qcrao/article/details/92759907" target="_blank" rel="noopener">https://blog.csdn.net/qcrao/article/details/92759907</a><br><a href="https://cch123.github.io/ooo/" target="_blank" rel="noopener">https://cch123.github.io/ooo/</a><br><a href="https://blog.golang.org/codelab-share" target="_blank" rel="noopener">https://blog.golang.org/codelab-share</a><br><a href="https://dave.cheney.net/2018/01/06/" target="_blank" rel="noopener">https://dave.cheney.net/2018/01/06/</a></p><p><code>if-aligned-memory-writes-are-atomic-why-do-we-need-the-sync-atomic-package</code></p><p><a href="http://blog.golang.org/race-detector" target="_blank" rel="noopener">http://blog.golang.org/race-detector</a><br><a href="https://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races" target="_blank" rel="noopener">https://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races</a><br><a href="https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/06/ice-cream-makers-and-data-races-part-ii.html</a><br><a href="https://medium.com/a-journey-with-go/" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/</a></p><p><code>go-how-to-reduce-lock-contention-with-the-atomic-package-ba3b2664b549</code></p><p><a href="https://medium.com/a-journey-with-go/go-discovery-of-the-trace-package-e5a821743c3c" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-discovery-of-the-trace-package-e5a821743c3c</a><br><a href="https://medium.com/a-journey-with-go/go-mutex-and-starvation-3f4f4e75ad50" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-mutex-and-starvation-3f4f4e75ad50</a><br><a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html</a><br><a href="https://medium.com/a-journey-with-go/go-buffered-and-unbuffered-channels-29a107c00268" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-buffered-and-unbuffered-channels-29a107c00268</a><br><a href="https://medium.com/a-journey-with-go/go-ordering-in-select-statements-fd0ff80fd8d6" target="_blank" rel="noopener">https://medium.com/a-journey-with-go/go-ordering-in-select-statements-fd0ff80fd8d6</a><br><a href="https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2017/10/the-behavior-of-channels.html</a><br><a href="https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/02/the-nature-of-channels-in-go.html</a><br><a href="https://www.ardanlabs.com/blog/2013/10/my-channel-select-bug.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2013/10/my-channel-select-bug.html</a><br><a href="https://blog.golang.org/io2013-talk-concurrency" target="_blank" rel="noopener">https://blog.golang.org/io2013-talk-concurrency</a><br><a href="https://blog.golang.org/waza-talk" target="_blank" rel="noopener">https://blog.golang.org/waza-talk</a><br><a href="https://blog.golang.org/io2012-videos" target="_blank" rel="noopener">https://blog.golang.org/io2012-videos</a><br><a href="https://blog.golang.org/concurrency-timeouts" target="_blank" rel="noopener">https://blog.golang.org/concurrency-timeouts</a><br><a href="https://blog.golang.org/pipelines" target="_blank" rel="noopener">https://blog.golang.org/pipelines</a><br><a href="https://www.ardanlabs.com/blog/2014/02/running-queries-concurrently-against.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/02/running-queries-concurrently-against.html</a><br><a href="https://blogtitle.github.io/go-advanced-concurrency-patterns-part-3-channels/" target="_blank" rel="noopener">https://blogtitle.github.io/go-advanced-concurrency-patterns-part-3-channels/</a><br><a href="https://www.ardanlabs.com/blog/2013/05/thread-pooling-in-go-programming.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2013/05/thread-pooling-in-go-programming.html</a><br><a href="https://www.ardanlabs.com/blog/2013/09/pool-go-routines-to-process-task.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2013/09/pool-go-routines-to-process-task.html</a><br><a href="https://blogtitle.github.io/categories/concurrency/" target="_blank" rel="noopener">https://blogtitle.github.io/categories/concurrency/</a><br><a href="https://medium.com/@cep21/how-to-correctly-use-context-context-in-go-1-7-8f2c0fafdf39" target="_blank" rel="noopener">https://medium.com/@cep21/how-to-correctly-use-context-context-in-go-1-7-8f2c0fafdf39</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Goroutine&quot;&gt;&lt;a href=&quot;#Goroutine&quot; class=&quot;headerlink&quot; title=&quot;Goroutine
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="Golang" scheme="https://octopuslian.github.io/tags/Golang/"/>
    
      <category term="并行" scheme="https://octopuslian.github.io/tags/%E5%B9%B6%E8%A1%8C/"/>
    
      <category term="并发" scheme="https://octopuslian.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="goroutine" scheme="https://octopuslian.github.io/tags/goroutine/"/>
    
      <category term="channel" scheme="https://octopuslian.github.io/tags/channel/"/>
    
  </entry>
  
  <entry>
    <title>Go进阶-异常处理</title>
    <link href="https://octopuslian.github.io/2021/05/02/goatc-2-error/"/>
    <id>https://octopuslian.github.io/2021/05/02/goatc-2-error/</id>
    <published>2021-05-02T13:12:25.000Z</published>
    <updated>2021-06-23T14:58:44.560Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --><h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>Golang的<code>error</code>就是普通的一个接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span>&#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Error-vs-Exception"><a href="#Error-vs-Exception" class="headerlink" title="Error vs Exception"></a>Error vs Exception</h2><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>单返回值，一般通过传递指针作为入参，返回值为 int 表示成功还是失败。</p><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><p>引入了 exception，但是无法知道被调用方会抛出什么异常。</p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>引入了 checked exception，方法的所有者必须申明，调用者必须处理。在启动时抛出大量的异常是司空见惯的事情，并在它们的调用堆栈中尽职地记录下来。Java 异常不再是异常，而是变得司空见惯了。它们从良性到灾难性都有使用，异常的严重性由函数的调用者来区分。</p><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p>Go 的处理异常逻辑是不引入 exception，支持多参数返回，所以你很容易的在函数签名中带上实现了 error interface 的对象，交由调用者来判定。</p><p>如果一个函数返回了 value, error，你不能对这个 value 做任何假设，必须先判定 error。唯一可以忽略 error 的是，如果你连 value 也不关心。</p><p>Go 中有 panic 的机制，如果你认为和其他语言的 exception 一样，那你就错了。当我们抛出异常的时候，相当于你把 exception 扔给了调用者来处理。</p><p>比如，你在 C++ 中，把 string 转为 int，如果转换失败，会抛出异常。或者在 java 中转换 string 为 date 失败时，会抛出异常。</p><p>Go panic 意味着 fatal error(就是挂了)。不能假设调用者来解决 panic，意味着代码不能继续运行。<br>使用多个返回值和一个简单的约定，Go 解决了让程序员知道什么时候出了问题，并为真正的异常情况保留了 panic。</p><p>对于真正意外的情况，那些表示不可恢复的程序错误，例如索引越界、不可恢复的环境问题、栈溢出，我们才使用 panic。对于其他的错误情况，我们应该是期望使用 error 来进行判定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">you only need to check the error value if you care about the result.  -- Dave  </span><br><span class="line">This blog post from Microsoft’s engineering blog in 2005 still holds true today, namely:  </span><br><span class="line">My point isn’t that exceptions are bad. My point is that exceptions are too hard and I’m not smart enough to handle them.</span><br></pre></td></tr></table></figure><ul><li>简单。</li><li>考虑失败，而不是成功(Plan for failure, not success)。</li><li>没有隐藏的控制流。</li><li>完全交给你来控制 error。</li><li>Error are values。</li></ul><h2 id="Error-Type"><a href="#Error-Type" class="headerlink" title="Error Type"></a>Error Type</h2><h3 id="Sentinel-Error"><a href="#Sentinel-Error" class="headerlink" title="Sentinel Error"></a>Sentinel Error</h3><p>预定义的特定错误，我们叫为 sentinel error，这个名字来源于计算机编程中使用一个特定值来表示不可能进行进一步处理的做法。所以对于 Go，我们使用特定的值来表示错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err == ErrSomething &#123; … &#125;</span><br></pre></td></tr></table></figure><p>类似的 io.EOF，更底层的 syscall.ENOENT。</p><p>使用 sentinel 值是最不灵活的错误处理策略，因为调用方必须使用 == 将结果与预先声明的值进行比较。当您想要提供更多的上下文时，这就出现了一个问题，因为返回一个不同的错误将破坏相等性检查。</p><p>甚至是一些有意义的 fmt.Errorf 携带一些上下文，也会破坏调用者的 == ，调用者将被迫查看 error.Error() 方法的输出，以查看它是否与特定的字符串匹配。</p><ul><li><p>不依赖检查 error.Error 的输出。<br>不应该依赖检测 error.Error 的输出，Error 方法存在于 error 接口主要用于方便程序员使用，但不是程序(编写测试可能会依赖这个返回)。这个输出的字符串用于记录日志、输出到 stdout 等。</p></li><li><p>Sentinel errors 成为你 API 公共部分<br>如果您的公共函数或方法返回一个特定值的错误，那么该值必须是公共的，当然要有文档记录，这会增加 API 的表面积。<br>如果 API 定义了一个返回特定错误的 interface，则该接口的所有实现都将被限制为仅返回该错误，即使它们可以提供更具描述性的错误。<br>比如 io.Reader。像 io.Copy 这类函数需要 reader 的实现者比如返回 io.EOF 来告诉调用者没有更多数据了，但这又不是错误。</p></li><li><p>Sentinel errors 在两个包之间创建了依赖<br>sentinel errors 最糟糕的问题是它们在两个包之间创建了源代码依赖关系。例如，检查错误是否等于 io.EOF，您的代码必须导入 io 包。这个特定的例子听起来并不那么糟糕，因为它非常常见，但是想象一下，当项目中的许多包导出错误值时，存在耦合，项目中的其他包必须导入这些错误值才能检查特定的错误条件(in the form of an import loop)。</p></li><li><p>结论: 尽可能避免 sentinel errors<br>我的建议是避免在编写的代码中使用 sentinel errors。在标准库中有一些使用它们的情况，但这不是一个您应该模仿的模式。</p></li></ul><p><strong>Error type 是实现了 error 接口的自定义类型。</strong></p><h3 id="Opaque-errors"><a href="#Opaque-errors" class="headerlink" title="Opaque errors"></a>Opaque errors</h3><p>在我看来，这是最灵活的错误处理策略，因为它要求代码和调用者之间的耦合最少。<br>我将这种风格称为不透明错误处理，因为虽然您知道发生了错误，但您没有能力看到错误的内部。作为调用者，关于操作的结果，您所知道的就是它起作用了，或者没有起作用(成功还是失败)。<br>这就是不透明错误处理的全部功能–只需返回错误而不假设其内容。</p><ul><li>Assert errors for behaviour, not type<br>在少数情况下，这种二分错误处理方法是不够的。例如，与进程外的世界进行交互(如网络活动)，需要调用方调查错误的性质，以确定重试该操作是否合理。在这种情况下，我们可以断言错误实现了特定的行为，而不是断言错误是特定的类型或值。</li></ul><h2 id="Handling-Error"><a href="#Handling-Error" class="headerlink" title="Handling Error"></a>Handling Error</h2><h3 id="Indented-flow-is-for-errors"><a href="#Indented-flow-is-for-errors" class="headerlink" title="Indented flow is for errors"></a>Indented flow is for errors</h3><p>无错误的正常流程代码，将成为一条直线，而不是缩进的代码。</p><h3 id="Eliminate-error-handling-by-eliminating-errors"><a href="#Eliminate-error-handling-by-eliminating-errors" class="headerlink" title="Eliminate error handling by eliminating errors"></a>Eliminate error handling by eliminating errors</h3><p>(后面再细说)</p><h3 id="Wrap-erros"><a href="#Wrap-erros" class="headerlink" title="Wrap erros"></a>Wrap erros</h3><p>在程序的顶部，程序的主体将把错误打印到屏幕或日志文件中，打印出来的只是：没有这样的文件或目录。</p><p>没有生成错误的 file:line 信息。没有导致错误的调用堆栈的堆栈跟踪。这段代码的作者将被迫进行长时间的代码分割，以发现是哪个代码路径触发了文件未找到错误。</p><p>这种模式与 sentinel errors 或 type assertions 的使用不兼容，因为将错误值转换为字符串，将其与另一个字符串合并，然后将其转换回 fmt.Errorf 破坏了原始错误，导致等值判定失败。</p><p>Go 中的错误处理契约规定，在出现错误的情况下，不能对其他返回值的内容做出任何假设。由于 JSON 序列化失败，buf 的内容是未知的，可能它不包含任何内容，但更糟糕的是，它可能包含一个半写的 JSON 片段。</p><p>由于程序员在检查并记录错误后忘记 return，损坏的缓冲区将被传递给 WriteAll，这可能会成功，因此配置文件将被错误地写入。但是，该函数返回的结果是正确的。</p><p>日志记录与错误无关且对调试没有帮助的信息应被视为噪音，应予以质疑。记录的原因是因为某些东西失败了，而日志包含了答案。</p><ul><li>错误要被日志记录。</li><li>应用程序处理错误，保证100%完整性。</li><li>之后不再报告当前错误。</li></ul><h2 id="Go-1-13-errors"><a href="#Go-1-13-errors" class="headerlink" title="Go 1.13 errors"></a>Go 1.13 errors</h2><p>最简单的错误检查：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">//something went wrong</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><p>我们在数据库操作的时候，比如 dao 层中当遇到一个 sql.ErrNoRows 的时候，是否应该 Wrap 这个 error，抛给上层。为什么，应该怎么做请写出代码？</p><h2 id="Go-2-Error-Inspection"><a href="#Go-2-Error-Inspection" class="headerlink" title="Go 2 Error Inspection"></a>Go 2 Error Inspection</h2><p><a href="https://go.googlesource.com/proposal/+/master/design/29934-error-values.md" target="_blank" rel="noopener">https://go.googlesource.com/proposal/+/master/design/29934-error-values.md</a></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://dave.cheney.net/2012/01/18/why-go-gets-exceptions-right" target="_blank" rel="noopener">https://dave.cheney.net/2012/01/18/why-go-gets-exceptions-right</a><br><a href="https://dave.cheney.net/2015/01/26/errors-and-exceptions-redux" target="_blank" rel="noopener">https://dave.cheney.net/2015/01/26/errors-and-exceptions-redux</a><br><a href="https://dave.cheney.net/2014/11/04/error-handling-vs-exceptions-redux" target="_blank" rel="noopener">https://dave.cheney.net/2014/11/04/error-handling-vs-exceptions-redux</a><br><a href="https://rauljordan.com/2020/07/06/why-go-error-handling-is-awesome.html" target="_blank" rel="noopener">https://rauljordan.com/2020/07/06/why-go-error-handling-is-awesome.html</a><br><a href="https://morsmachine.dk/error-handling" target="_blank" rel="noopener">https://morsmachine.dk/error-handling</a><br><a href="https://blog.golang.org/error-handling-and-go" target="_blank" rel="noopener">https://blog.golang.org/error-handling-and-go</a><br><a href="https://www.ardanlabs.com/blog/2014/10/error-handling-in-go-part-i.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/10/error-handling-in-go-part-i.html</a><br><a href="https://www.ardanlabs.com/blog/2014/11/error-handling-in-go-part-ii.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2014/11/error-handling-in-go-part-ii.html</a><br><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully" target="_blank" rel="noopener">https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully</a><br><a href="https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html" target="_blank" rel="noopener">https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html</a><br><a href="https://blog.golang.org/errors-are-values" target="_blank" rel="noopener">https://blog.golang.org/errors-are-values</a><br><a href="https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package" target="_blank" rel="noopener">https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package</a><br><a href="https://www.ardanlabs.com/blog/2017/05/design-philosophy-on-logging.html" target="_blank" rel="noopener">https://www.ardanlabs.com/blog/2017/05/design-philosophy-on-logging.html</a><br><a href="https://crawshaw.io/blog/xerrors" target="_blank" rel="noopener">https://crawshaw.io/blog/xerrors</a><br><a href="https://blog.golang.org/go1.13-errors" target="_blank" rel="noopener">https://blog.golang.org/go1.13-errors</a><br><a href="https://medium.com/gett-engineering/error-handling-in-go-53b8a7112d04" target="_blank" rel="noopener">https://medium.com/gett-engineering/error-handling-in-go-53b8a7112d04</a><br><a href="https://medium.com/gett-engineering/error-handling-in-go-1-13-5ee6d1e0a55c" target="_blank" rel="noopener">https://medium.com/gett-engineering/error-handling-in-go-1-13-5ee6d1e0a55c</a></p><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Error&quot;&gt;&lt;a href=&quot;#Error&quot; class=&quot;headerlink&quot; title=&quot;Error&quot;&gt;&lt;/a&gt;Error&lt;
      
    
    </summary>
    
    
      <category term="GoATC" scheme="https://octopuslian.github.io/categories/GoATC/"/>
    
    
      <category term="Golang" scheme="https://octopuslian.github.io/tags/Golang/"/>
    
      <category term="error" scheme="https://octopuslian.github.io/tags/error/"/>
    
      <category term="异常" scheme="https://octopuslian.github.io/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 42.trapping-rain-water | 接雨水</title>
    <link href="https://octopuslian.github.io/2021/04/25/leetcode-42-trapping-rain-water/"/>
    <id>https://octopuslian.github.io/2021/04/25/leetcode-42-trapping-rain-water/</id>
    <published>2021-04-25T05:57:53.000Z</published>
    <updated>2021-04-25T05:59:55.292Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><h2 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trap</span><span class="params">(height []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> left, right, leftMax, rightMax, res <span class="keyword">int</span></span><br><span class="line">right = <span class="built_in">len</span>(height) - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line"><span class="keyword">if</span> height[left] &lt; height[right] &#123;</span><br><span class="line"><span class="keyword">if</span> height[left] &gt;= leftMax &#123;</span><br><span class="line"><span class="comment">//设置左边最高柱子</span></span><br><span class="line">leftMax = height[left]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//右边必定有柱子挡水，所以，遇到所有值小于等于leftMax的，全部加入水池</span></span><br><span class="line">res += leftMax - height[left]</span><br><span class="line">&#125;</span><br><span class="line">left++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> height[right] &gt; rightMax &#123; </span><br><span class="line"><span class="comment">//设置右边最高柱子</span></span><br><span class="line">rightMax = height[right] </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//左边必定有柱子挡水，所以，遇到所有值小于等于rightMax的，全部加入水池</span></span><br><span class="line">res += rightMax - height[right] </span><br><span class="line">&#125;</span><br><span class="line">right--</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat --><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Jul 18 2021 22:19:01 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="LeetCode-Solutions" scheme="https://octopuslian.github.io/categories/LeetCode-Solutions/"/>
    
    
      <category term="leetcode" scheme="https://octopuslian.github.io/tags/leetcode/"/>
    
  </entry>
  
</feed>

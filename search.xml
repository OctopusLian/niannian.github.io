<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>English_Article 1：The Product-Minded Software Engineer</title>
    <url>/2020/06/14/geekbang-column-article-1-the-product-minded-software-engineer/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><p><a href="https://blog.pragmaticengineer.com/the-product-minded-engineer/?utm_source=wanqu.co&utm_campaign=Wanqu+Daily&utm_medium=website" target="_blank" rel="noopener">The Product-Minded Software Engineer</a></p><h1 id="导读：背景知识对于理解文章究竟有多重要？"><a href="#导读：背景知识对于理解文章究竟有多重要？" class="headerlink" title="导读：背景知识对于理解文章究竟有多重要？"></a>导读：背景知识对于理解文章究竟有多重要？</h1><h2 id="背景知识的重要性"><a href="#背景知识的重要性" class="headerlink" title="背景知识的重要性"></a>背景知识的重要性</h2><p>这个标题“The Product-Minded Software Engineer”中有两个关键词，product-minded（产品思维）和 engineer（工程师）。这篇文章的主题是产品思维，那我们就要先去了解一些背景知识。</p><h2 id="核心词汇：minded"><a href="#核心词汇：minded" class="headerlink" title="核心词汇：minded"></a>核心词汇：minded</h2><p>我们一般会在 minded 前面加一个形容词或名词，用连字符连接，通过连用构成复合形容词，表示“具有某种（前面形容词定义的）思维（或态度、性格）”。我们通过几个例句，来感受一下 minded 这个词的使用场景。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：The United States is a sports-minded country, with millions of fans who follow football, baseball, basketball and hockey, among other sports.</span><br><span class="line">翻译：美国是一个体育意识很强的国家，有数以百万计的球迷关注足球、棒球、篮球和曲棍球等体育运动。</span><br><span class="line"></span><br><span class="line">例句：Two dozen states have asked the D.C. Circuit to block a new climate-change-minded federal law that they say will inflate electricity bills for families.</span><br><span class="line">翻译：二十多个州要求华盛顿特区巡回法院阻止一项新的关注气候变化的联邦法律，他们说这项法律将增加家庭的电费账单。</span><br><span class="line"></span><br><span class="line">例句：They are business-minded yet warm-hearted when it comes to those less fortunate, and prove that they can transform their theoretical academic knowledge into sustainable business practices through social projects.</span><br><span class="line">翻译：对于那些不幸的人，他们既有商业头脑，又有古道热肠。他们证明自己能够通过社会项目，将理论上的学术知识转化为可持续的商业实践。</span><br></pre></td></tr></table></figure><h1 id="什么时候适合用“词根词缀法”来背单词？"><a href="#什么时候适合用“词根词缀法”来背单词？" class="headerlink" title="什么时候适合用“词根词缀法”来背单词？"></a>什么时候适合用“词根词缀法”来背单词？</h1><p>先来精读文章第一段：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Proactive with product ideas/opinions</span><br><span class="line">Product-minded engineers don’t settle for getting a specification and jumping to implement it. They think about other ideas and approach the product manager with these. They often challenge existing specifications, suggesting alternative product approaches, that might work better.  </span><br><span class="line"></span><br><span class="line">1. 积极主动地对待产品理念或观点</span><br><span class="line">具有产品思维的工程师不会满足于拿到设计说明后就匆匆忙忙地立即执行。他们会思考其他的创意，并找产品经理提出这些想法。他们经常挑战现有的设计规范，建议可能更优的替代性方法。</span><br></pre></td></tr></table></figure><h2 id="知识讲解"><a href="#知识讲解" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="proactive"><a href="#proactive" class="headerlink" title="proactive"></a>proactive</h3><p>它的意思是“积极、主动的”，它的反义词是 reactive，“消极、被动的”。</p><p>我们先来看一个例句，通过这个例句我们来学习这两个词的含义。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：The difference between proactive people and reactive people is that proactive people take initiative, and they come up with ideas to get things done despite the conditions they are in. Reactive people, on the other hand, usually are the ones to react to a situation rather than take initiative to create a situation.  </span><br><span class="line"></span><br><span class="line">翻译：积极主动的人和消极被动的人之间的区别在于，积极主动的人会采取主动，无论他们所处的环境如何，都会想出办法来完成任务；而消极被动型的人通常只会对形势做出被动的反应，而不会主动采取行动去创造形势。</span><br></pre></td></tr></table></figure><p>讲到 reactive， 想到了 reactive programming（响应式编程）。</p><p>同样道理，Pro- 和 Re- 这一对反义前缀，能够帮助我们更好地理解和记忆其他单词。例如 progress（前进、进化）和 regress（后退、退化）。它们的英语解释如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Progress is to move, go, or proceed forward; to advance.</span><br><span class="line"></span><br><span class="line">Regress is to move backwards to an earlier stage; to devolve.</span><br></pre></td></tr></table></figure><h3 id="settle-for-settle"><a href="#settle-for-settle" class="headerlink" title="settle for / settle"></a>settle for / settle</h3><p>英文解释：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">settle for (something):</span><br><span class="line"></span><br><span class="line">to accept something less ideal or worse than what one really wanted;</span><br><span class="line">to agree to accept something (even though something else would be better);</span><br><span class="line">accept or be satisfied with as a compromise.</span><br></pre></td></tr></table></figure><p>简单来说，settle for 就是“勉强同意接受，将就或者凑合”的意思。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：He demanded a bigger raise but decided to settle for what they offered.</span><br><span class="line">翻译：他原本要求更高的涨薪，但最后决定人家给多少拿多少，凑合一下算了。</span><br><span class="line"></span><br><span class="line">例句：I could never settle for such a quiet life; I want excitement.</span><br><span class="line">翻译：我不能将就如此单调的生活。我需要刺激。</span><br></pre></td></tr></table></figure><p>同样，settle 这个动词有“停留、安顿”的含义，也可以衍生出“将就、凑合、妥协”的意思。苹果公司创始人乔布斯在他著名的斯坦福大学毕业典礼演讲中就有这么一段，你可以感受一下：</p><blockquote><p>And that is as true for your work as it is for your lovers. Your work is going to fill a large &gt;part of your life, and the only way to be truly satisfied is to do what you believe is great &gt;work. And the only way to do great work is to love what you do. If you haven’t found it yet, &gt;keep looking. <strong>Don’t settle</strong>. As with all matters of the heart, you’ll know when you find it. &gt;And, like any great relationship, it just gets better and better as the years roll on. So &gt;keep looking until you find it. <strong>Don’t settle</strong>.</p></blockquote><p>在这段话里，乔帮主两次提到“Don’t settle”，就是让我们跟随自己的内心，去寻找我们倾心的工作或爱情，找到了，你的心会告诉你，往后的日子历久弥新会越来越好；还没找到的话，千万不要放弃，不要妥协，不可以将就和凑合。</p><h3 id="specification"><a href="#specification" class="headerlink" title="specification"></a>specification</h3><p>在工程中，指的是“设计说明书、设计规范”的意思：a detailed description of the design and materials used to make something.</p><h3 id="jump-to"><a href="#jump-to" class="headerlink" title="jump to"></a>jump to</h3><p>顾名思义是“匆匆忙忙、很快，甚至有些草率”的意思。</p><h4 id="第一种用法：jump-to-conclusions-to-guess-the-facts-about-a-situation-without-having-enough-information"><a href="#第一种用法：jump-to-conclusions-to-guess-the-facts-about-a-situation-without-having-enough-information" class="headerlink" title="第一种用法：jump to conclusions: to guess the facts about a situation without having enough information."></a>第一种用法：jump to conclusions: to guess the facts about a situation without having enough information.</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：Don’t jump to conclusions! Perhaps it was his daughter he was dancing with.</span><br><span class="line">翻译：别匆忙下结论，和他跳舞的没准是他女儿呢。</span><br></pre></td></tr></table></figure><h4 id="第二种用法：jump-to-it-informal-used-to-tell-someone-to-do-something-quickly"><a href="#第二种用法：jump-to-it-informal-used-to-tell-someone-to-do-something-quickly" class="headerlink" title="第二种用法：jump to it (informal): used to tell someone to do something quickly."></a>第二种用法：jump to it (informal): used to tell someone to do something quickly.</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：I told you to tidy this room - now jump to it!</span><br><span class="line">翻译：（俚语）早就让你打扫房间，怎么还这样乱！快去！</span><br></pre></td></tr></table></figure><h4 id="第三种用法：jump-to-sb’s-defence-to-quickly-defend-someone"><a href="#第三种用法：jump-to-sb’s-defence-to-quickly-defend-someone" class="headerlink" title="第三种用法：jump to sb’s defence: to quickly defend someone."></a>第三种用法：jump to sb’s defence: to quickly defend someone.</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：Whenever anyone criticizes her husband, she immediately jumps to his defence.</span><br><span class="line">翻译：每当有人批评她的丈夫时，她会立即为他辩护。</span><br></pre></td></tr></table></figure><h3 id="approach"><a href="#approach" class="headerlink" title="approach"></a>approach</h3><p>这一段出现了两次 approach，分别有不同的意思。第一处是动词，意思是“找（某人）谈话、与（某人）打交道”，第二处是名词，意思是“（处理）方法”。这些都是最早从 to go or come near in place or in time 或者 come near in quality or character, resemble, become similar 等含义中衍生出来的意思。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：The workers approached the manager with a request for shorter working hours.</span><br><span class="line">翻译：工人们找经理要求减少工作时间。</span><br><span class="line"></span><br><span class="line">例句：Those officials were approached with bribes.</span><br><span class="line">翻译：这些官员是被贿赂买通的。在特定语境中，approach a government officer 本身就有企图贿赂政府官员的意思。</span><br><span class="line"></span><br><span class="line">例句：His sober approach to the crisis averted a catastrophe.</span><br><span class="line">翻译：他对危机的冷静处理避免了一场大灾难。</span><br></pre></td></tr></table></figure><h1 id="到底要不要学语法？什么时候学比较好？"><a href="#到底要不要学语法？什么时候学比较好？" class="headerlink" title="到底要不要学语法？什么时候学比较好？"></a>到底要不要学语法？什么时候学比较好？</h1><p>精读文章的第二段：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. Interest in the business, user behavior and data on this</span><br><span class="line">When coming with ideas, product-minded engineers don&apos;t just get these from thin air. They take the time to understand how the business works, how the product fits in, and what its goals are. They are also empathetic about how the product makes users feel and how those users benefit from using this product. They often dive straight to data about business and user metrics, getting their hands on this data however they can. They might access it directly - if this is possible - or approach the product manager or data scientists to get this kind of information. They do this because of their curious nature. This is the next trait I&apos;ve observed.</span><br><span class="line"></span><br><span class="line">2. 工程师对业务、用户行为和数据的兴趣</span><br><span class="line">具有产品思维的工程师们的想法和创意都不是凭空得来的。他们会花时间去了解企业是如何商业运作的，产品又是如何配合商业运作，以及最终要达到什么样的商业目标。此外，他们也会去换位思考，试图理解产品将给用户带来什么感受，以及用户如何从使用产品中受益。他们通常会直接去深入研究商业数据和用户测量指标，并尽其所能获取这些数据。如果可能的话，他们会直接访问相关数据，或者找产品经理、数据专家去要这些信息。工程师们这样做，往往是出于他们好奇的天性。这也是我观察到的下一个特征。</span><br></pre></td></tr></table></figure><p>所有的英语句子，无论长短多少、变态与否，都可以归入三类：简单句、并列句和复合句。</p><h2 id="知识讲解-1"><a href="#知识讲解-1" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="状语（分词短语做时间状语）"><a href="#状语（分词短语做时间状语）" class="headerlink" title="状语（分词短语做时间状语）"></a>状语（分词短语做时间状语）</h3><blockquote><p>When coming with ideas, product-minded engineers don’t just get these from thin air.</p></blockquote><p>这段话的第一句就是分词短语做时间状语。<strong>所谓状语，顾名思义，就是对动作的状态进行描述的句子成分，可以是单词（副词）、短语（分词短语）或句子（状语从句）。状语可以用来说明地点、时间、原因、目的、结果、条件、方向、程度、频率、方式、伴随等等。</strong></p><p>看几个分词短语做时间状语的超级简单的例句，一般都带有引导时间状语的关系连词，例如 before、after、when 等，分词短语紧随其后。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：She normally boils the water before drinking it.</span><br><span class="line">翻译：她喝水之前通常会把水烧开。</span><br><span class="line"></span><br><span class="line">例句：After talking to you I always feel better.</span><br><span class="line">翻译：每次和你聊完之后，我都感觉心里舒服多了。</span><br><span class="line"></span><br><span class="line">例句：When opened, keep in refrigerator.</span><br><span class="line">翻译：开罐之后，需要冷藏。</span><br></pre></td></tr></table></figure><h3 id="thin-air"><a href="#thin-air" class="headerlink" title="thin air"></a>thin air</h3><p>英文解释：nowhere to be found in a giant void；nihility; nothingness; nullity; void; the state of nonexistence。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：You need to work hard—opportunities don’t just come out of thin air.</span><br><span class="line">翻译：你得努力啦，机会不会凭空产生 / 天上不会掉馅饼。</span><br><span class="line"></span><br><span class="line">例句：The magician pulled a bouquet of flowers out of thin air.</span><br><span class="line">翻译：魔术师妙手空空变出一捧花来。</span><br><span class="line"></span><br><span class="line">例句：With her children almost grown up, she found herself having to conjure a career from thin air.</span><br><span class="line">翻译：孩子们都快长大了，她发现自己需要凭空变出个工作来。</span><br></pre></td></tr></table></figure><p>和 thin air 搭配的介词，通常是 out of 或者 from。</p><h3 id="动词宾语从句"><a href="#动词宾语从句" class="headerlink" title="动词宾语从句"></a>动词宾语从句</h3><blockquote><p>They take the time to understand how the business works, how the product fits in, and what its goals are.</p></blockquote><p>这句话首先是用不定式 to do 做状语，表示目的。程序员花时间干什么？to understand，是一个及物动词，去了解，了解什么？后面跟的就是宾语从句，而且是三个并列的宾语从句。</p><h3 id="take-time"><a href="#take-time" class="headerlink" title="take (time)"></a>take (time)</h3><p>take the time 是非常地道的搭配，如果非要说 spend the time，当然别人也能理解，但一听就是不地道的英语。另外，take 还可以和具体的时间搭配在一起，你可以把 the time 换成具体的事情，表示“做什么事情需要花多少时间”。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：I took three hours to get home last night.</span><br><span class="line">翻译：昨天晚上回家花了我三个小时。</span><br><span class="line"></span><br><span class="line">例句：The journey home last night took me three hours.</span><br><span class="line"></span><br><span class="line">例句：It took me three hours to get home last night.</span><br></pre></td></tr></table></figure><h3 id="fit-in"><a href="#fit-in" class="headerlink" title="fit in"></a>fit in</h3><p>fit in 的第一个意思是“融入”，英文解释是：To become assimilated into and accepted by a group。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：I just don’t fit in with any of the kids at my new school.</span><br><span class="line">翻译：我和新学校的小孩们都合不来。</span><br></pre></td></tr></table></figure><p>fit in 的第二个意思是“适合”，英文解释是：To blend or work harmoniously with something。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：Working in a research lab really fits in with my shy personality.</span><br><span class="line">翻译：在科研实验室工作非常适合我腼腆的性格。</span><br></pre></td></tr></table></figure><h3 id="介词宾语从句"><a href="#介词宾语从句" class="headerlink" title="介词宾语从句"></a>介词宾语从句</h3><blockquote><p>They are also empathetic about how the product makes users feel and how those users benefit &gt;from using this product. They often dive straight to data about business and user metrics, &gt;getting their hands on this data however they can.</p></blockquote><p>这句话说，他们会共情，会去换位思考。思考什么？about 这个介词后面跟了两个并列的宾语从句。第一，思考产品将给用户带来什么感受；第二，思考用户如何从使用产品中受益。</p><p>最后半句是分词短语做状语，这个街角我们已经走过好几次了。这里的状语表示伴随状态，程序员们会直接去研究商业数据和用户指标，getting hands on，表示“同时动手获取这些数据”。</p><h3 id="empathy-和-sympathy"><a href="#empathy-和-sympathy" class="headerlink" title="empathy 和 sympathy"></a>empathy 和 sympathy</h3><p>empathy 和 sympathy 这两个单词的拼写很相像，含义似乎相似，但其实完全不一样。</p><p>empathy 表示“感同身受”，它的英文解释是：an individual’s ability to understand what another person is going through, by perceiving himself in the same situation，指一个人通过把自己放到相同的情境中感知自己，来理解另一个人正在经历的事情的能力。而有时候我们说“共情”，是强调“理解、共鸣”的意思。你可以通过下面这个例句再感受一下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：He is empathetic with the jobless youth, as he was also struggling for a job in his early years.</span><br><span class="line">翻译：他对失业的年轻人感同身受，因为他自己早年也为找工作挣扎过。</span><br></pre></td></tr></table></figure><p>而 Sympathy 表示“同情”，它的英文解释是：the feeling of sorrow for the hardships, problems and pain caused to another person，指“对另一个人造成的困难、问题和痛苦感到悲伤或怜悯”，更强调“同情、悲悯”。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：All Tony’s friends joined in sending their sympathies to his widow Jean.</span><br><span class="line">翻译：托尼的所有朋友都向他的遗孀琼表示了同情。</span><br></pre></td></tr></table></figure><h3 id="dive"><a href="#dive" class="headerlink" title="dive"></a>dive</h3><p>dive 的本意是“跳水”，就是头和两臂先入水的那种，plunge head first into water。它也可以指“鱼类、潜水艇或人类，借助呼吸设备潜水到更深的水下，(of a fish, a submarine, or a vessel used for underwater exploration) go to a deeper level in water (using breathing equipment)。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：The fish dive down to about 1,400 feet and then swim southwest.</span><br><span class="line">翻译：那条鱼潜到大约 1400 英尺的深度，然后向西南方向游去。</span><br></pre></td></tr></table></figure><p>除此之外，dive 还可以指“飞机或鸟类在空中俯冲”，(of an aircraft or bird) plunge steeply downward through the air。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：The aircraft dove for the ground to avoid the attack.</span><br><span class="line">翻译：飞机向地面俯冲以躲避攻击。</span><br></pre></td></tr></table></figure><p>在此基础上，我们可以通过“一头扎进去”这个意思，进一步引申出“立即开始采取行动、深入分析研究”等含义。例如本段话里的 dive to，就有程序员“立刻开始深入挖掘数据”的意思。比较常见的搭配还有 deep dive。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：Although this article does not provide a deep dive into the programming language, some Objective-C fundamentals are provided below.</span><br><span class="line">翻译：尽管本文没有深入介绍编程语言，但是下面提供了一些 Objective-C 的基础知识。</span><br><span class="line"></span><br><span class="line">例句：Each article will dive deep into these concepts, with lots of detail and source code.</span><br><span class="line">翻译：每篇文章都将深入探讨这些概念，包括大量细节和源代码。</span><br></pre></td></tr></table></figure><h3 id="user-metrics"><a href="#user-metrics" class="headerlink" title="(user) metrics"></a>(user) metrics</h3><p>software metrics 即“软件测量 / 度量”，有时候也叫 software measurements。</p><p>要想真正跳脱出软件开发的暗箱，除了定性评估以外，还需要一系列基于数值的度量指标来进行测评。同样道理，对于一个产品的用户体验，也有相应的用户测量指标。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：Software metrics are numerical ratings to measure the complexity and reliability of source code, the length and quality of the development process and the performance of the application when completed.</span><br><span class="line">翻译：软件度量使用数值评级来衡量源代码的复杂性和可靠性、开发过程的长度和质量以及应用程序完成后的性能。</span><br><span class="line"></span><br><span class="line">例句：Social media technologies have given companies access to an unprecedented flood of new analytics, metrics and user data.</span><br><span class="line">翻译：有了社交网络之后，企业获取了空前大量的新分析方法、度量指标和用户数据。</span><br></pre></td></tr></table></figure><h3 id="插入语"><a href="#插入语" class="headerlink" title="插入语"></a>插入语</h3><blockquote><p>They might access it directly - if this is possible - or approach the product manager or data &gt;scientists to get this kind of information. They do this because of their curious nature. This &gt;is the next trait I’ve observed.</p></blockquote><p>在这句话里，if this is possible 是插入语。在阅读的过程中，如果感觉句子偏长或者偏复杂，我们完全可以先忽略插入语。插入语通常夹在两个破折号或者两个逗号之间。</p><h1 id="从那些不规范的表达中，我们可以学到什么？"><a href="#从那些不规范的表达中，我们可以学到什么？" class="headerlink" title="从那些不规范的表达中，我们可以学到什么？"></a>从那些不规范的表达中，我们可以学到什么？</h1><p>文章的第三段和第四段：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3. Curiosity and a keen interest in &quot;why?&quot;</span><br><span class="line">Product-minded engineers like to understand the &quot;why?&quot; behind all things. Why build this feature for the product, why not the other one? Why ship this first milestone, instead of choosing another one, that&apos;s a lot simpler to build? How will things be measured - why don&apos;t we choose a more thorough way to measure things?</span><br><span class="line">They are autonomous in finding answers they can, by themselves. They turn to the product manager and other people in the business for other, product-related questions. Even though they ask many questions, doing this frequently, they manage not to annoy people, as they&apos;ve built up strong relationships with them.</span><br><span class="line">4. Strong communicators and great relationships with non-engineers</span><br><span class="line">Product-minded engineers like talking with people outside engineering, learning about what and why they do. They are smooth communicators, making it clear they&apos;re interested in learning more about how other disciplines work. I frequently see them grabbing coffee, lunch, or doing a hallway chat with non-engineers.</span><br><span class="line"></span><br><span class="line">软件工程师的好奇心和对“为什么”的浓厚兴趣。具有产品意识的工程师喜欢去理解所有事物背后的那个“为什么? ”。为什么产品要开发这个功能、而不开发另一个功能呢？为什么要首先发布这一里程碑，而不是选择另一个更简单的里程碑呢？如何进行测量——为什么我们不选择一种更全面彻底的度量方式来测量呢？</span><br><span class="line">他们能够自主地找到他们能够找到的答案。他们也会向产品经理和其他业务人员寻求帮助，找寻其他与产品相关问题的答案。尽管他们经常会问很多问题，但是他们都会设法不让其他人觉得不爽，因为他们已经与那些同事建立起了牢固的关系。</span><br><span class="line"></span><br><span class="line">强大的沟通能力，建立与非工程师同事良好的关系。具有产品意识的工程师喜欢与软件工程领域外的同事们交谈，了解他们在做什么、为什么做。他们善于沟通，充分显示他们对于学习其他学科工作方式的浓厚兴趣。我经常看到他们和其他专业的同事们一起喝咖啡、吃午饭或者在走廊上聊天。</span><br></pre></td></tr></table></figure><p>这几段话的意思比较直白，但存在几处写作不规范的地方，可以作为反面教材，供我们分析。</p><p><strong>首先，口语交流和书面写作对于语言精确和严谨程度的预期要求是不同的。</strong>如果只是作为口语交流，只要不影响意思的表达，出现一些语法错误或者不规范之处，并无大碍；但对于那些需要正式发表的书面稿件，例如学术论文、合约、新闻稿等，写作过程中的语言就要力求规范。</p><p><strong>其次，我们不要迷信那些英语是母语的外国人，觉得他们说的或写的每句话都一定是正确的。</strong>有时候因为各种原因，英语母语国家的人在口头和书面表达中都会出现或多或少的错误用法，其随意性甚至超过外语学习者。</p><h2 id="知识讲解-2"><a href="#知识讲解-2" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="curiosity-keen-interest"><a href="#curiosity-keen-interest" class="headerlink" title="curiosity/keen interest"></a>curiosity/keen interest</h3><ul><li><p>curiosity killed the cat，“好奇害死猫”，说的就是好奇心容易惹祸上身，即便猫有九条命都不够死，告诫别人不要多管闲事，不要到处打听和自己无关的事情。<br>Inquisitiveness can lead one into dangerous situations.</p></li><li><p>Keen interest，意思是“浓厚的兴趣”。有一个常用的英语成语也可以表示同样的意思，但是非常形象生动，(as) keen as mustard，“像芥末一样浓烈”，表示 very excited and interested；very enthusiastic。mustard 是黄芥末，由芥菜种子碾磨而成，在西方国家比较常见，一般和热狗搭配。日本料理使用的是绿芥末，wasabi，其实是山葵酱。</p></li></ul><p>类似 as X as Y 这样的英语成语还有不少，例如 as hard as nail，as hot as hell 等，第一个 as 在口语或非正式表达中可以省略。很多成语是约定俗成的传统表达方式，其中有些比喻涉及特定的文化背景。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：I gave him the job because he was willing to learn and seemed as keen as mustard.</span><br><span class="line">翻译：我给他这份工作，是因为他学习愿望强烈，兴趣（如同芥末一样）浓厚。</span><br></pre></td></tr></table></figure><h3 id="why-not-do-结构"><a href="#why-not-do-结构" class="headerlink" title="why (not) do 结构"></a>why (not) do 结构</h3><blockquote><p>Product-minded engineers like to understand the “why?” behind all things. Why build this &gt;feature for the product, why not the other one? Why ship this first milestone, instead of &gt;choosing another one, that’s a lot simpler to build? How will things be measured - why don’t ?&gt;we choose a more thorough way to measure things?</p></blockquote><p>第一句话“具有产品意识的工程师喜欢去理解所有事物背后的那个为什么”的后面，跟了三组并列的问句，来举例说明具有产品思维的工程师通常会问的问题。</p><p>注意 why+do 和 why not+do 的结构和用法。why+do 通常表示“该动作没有必要、无意义”。why not+do 通常表示“建议采取该动作”。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Why build this feature for the product? = Why do we build this feature for the product?</span><br><span class="line"></span><br><span class="line">why not the other one? = Why not build the other one? = Why don’t we build the other one?</span><br><span class="line"></span><br><span class="line">例句：Why argue with him？He will never change his mind. （注意不能说 why arguing with him?）</span><br><span class="line">翻译：干嘛和他争？他永远不会改主意的。</span><br><span class="line"></span><br><span class="line">例句：Sandy’s in bad mood. Why not give her some flowers?</span><br><span class="line">翻译：桑迪心情不好，何不送她一些花呢？</span><br><span class="line"></span><br><span class="line">例句：Why don’t you give her some flowers?</span><br><span class="line">翻译：你为什么不给她送些花呢？</span><br></pre></td></tr></table></figure><h3 id="ship-the-milestone"><a href="#ship-the-milestone" class="headerlink" title="ship the milestone"></a>ship the milestone</h3><p>“发布某一阶段的成果”或者“上市某一版产品”的意思。</p><p>ship 做动词的时候，基本含义是“船运”“运输”，在此基础上引申出“发货”“上市” “发布”等含义。milestone 由“里程碑”（a stone pillar that shows the distance in miles to or from a place）引申出了“重大事件”“阶段性成果”“重要时间节点”等含义。因此，除非你讲的是物流（例如航运行业）的事情，其他大部分语境下 ship 都是指“产品上市、发布或者发货”的意思。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：Apple will unveil a 10-inch touchscreen tablet device in January, and ship the product in March.</span><br><span class="line">翻译：苹果将于一月份推出 10 英寸触屏平板电脑，并于三月份发货。</span><br><span class="line"></span><br><span class="line">例句：We define an iteration as a phase or a milestone.</span><br><span class="line">翻译：我们将一次迭代定义为一个阶段或一个里程碑。</span><br></pre></td></tr></table></figure><h3 id="不规范的定语从句"><a href="#不规范的定语从句" class="headerlink" title="不规范的定语从句"></a>不规范的定语从句</h3><blockquote><p>Why ship this first milestone, instead of choosing another one, that’s a lot simpler to build?</p></blockquote><p>此句标黑处为限定性定语从句，修饰先行词 another one，所以这里应该去掉逗号。如果是非限定性定语从句，要保留逗号，但 that 必须改为 which。</p><h3 id="autonomous"><a href="#autonomous" class="headerlink" title="autonomous"></a>autonomous</h3><blockquote><p>They are autonomous in finding answers they can, by themselves. They turn to the product manager and &gt;other people in the business for other product-related questions.</p></blockquote><p>autonomous 一般指“地区或组织享有自治权”，英文意思是 governs or controls itself rather than being controlled by anyone else，或者指“个人独立自主、自发做一些事情（例如本句）”，英文意思是 able to do things and make decisions without help from anyone else。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A self-driving car, also known as an autonomous vehicle (AV), driverless car or robotic car, is a vehicle that can sense its environment and moving safely with little or no human input.</span><br><span class="line">自动驾驶汽车也被称为无人驾驶汽车或机器人汽车，是一种能够感知周围环境并在几乎没有人类干预的情况下安全行驶的交通工具。</span><br></pre></td></tr></table></figure><p>需要指出的是，互联网公司研发自动驾驶汽车比较喜欢用 driverless 这个词，突出无人驾驶，表示未来要取消驾驶员。而传统的汽车行业更坚持使用 autonomous 这个词，淡化“无人”的概念，并强调非由机器还是人类来驾驶汽车，这个决定最终要由人类做出，不能剥夺人类的驾驶乐趣。<strong>所以，一个简单的单词背后，代表的可能是不同行业对同一件事的不同态度。</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Oracle Autonomous Database is a cloud-based technology designed to automate many of the routine tasks required to manage Oracle databases, which Oracle says can free up DBAs to do higher-level and more strategic work.</span><br><span class="line">甲骨文自治数据库是一种基于云的技术，旨在自动化管理甲骨文数据库所需的许多日常任务。甲骨文公司表示，这可以让数据库管理员们腾出时间来做更高层次、更具战略性的工作。</span><br></pre></td></tr></table></figure><h3 id="定语从句"><a href="#定语从句" class="headerlink" title="定语从句"></a>定语从句</h3><blockquote><p>They are autonomous in finding answers <strong>they can</strong>, by themselves.</p></blockquote><p>此句标黑处为定语从句，修饰 answers，完整形式为 that they can find，也可省略 that（that 或 which 做从句谓语动词的宾语时，可省略）和 find （和前文主句中的动词 find 重合）。</p><p>此句中的定语从句和 by themselves 插入语均为冗余信息，autonomous 的含义已经非常清楚，作者一而再、再而三重复相同的意思，这就属于不规范写作。</p><h3 id="turn-to-somebody"><a href="#turn-to-somebody" class="headerlink" title="turn to (somebody)"></a>turn to (somebody)</h3><p>turn to 本身就含有“寻求帮助”的意思，我们在使用的时候可以不用再说 turn to someone for help/advise。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：Sometimes young lads just need to turn to a mother figure for a bit of a chat and reassurance.</span><br><span class="line">翻译：有时候年轻小伙子只是需要找一个母亲式的人物聊一聊，从中获得安慰。</span><br><span class="line"></span><br><span class="line">例句：Her husband was unsympathetic and she felt she had no one to turn to.</span><br><span class="line">翻译：她的丈夫不懂得体恤人，她觉得无人可以依靠。</span><br></pre></td></tr></table></figure><h3 id="分词短语做插入语（语法关系不规范）"><a href="#分词短语做插入语（语法关系不规范）" class="headerlink" title="分词短语做插入语（语法关系不规范）"></a>分词短语做插入语（语法关系不规范）</h3><blockquote><p>Even though they ask many questions, doing this frequently, they manage not to annoy people, as &gt;they’ve built up strong relationships with them.</p></blockquote><p>如果是口语表达，此句没有任何问题，意思也是明确的。但严格来讲，比较规范、符合语法的说法是 Even though they ask many questions frequently.</p><h3 id="manage-not-to"><a href="#manage-not-to" class="headerlink" title="manage (not) to"></a>manage (not) to</h3><blockquote><p>If you manage to do something, especially something difficult, you succeed in doing it.</p></blockquote><p>需要提醒特别注意的是，manage to 并不是指“试图去做”一件事情，而是强调“<strong>成功做到一件比较困难的事情</strong>”。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：Somehow, he’d managed to persuade Kay to buy one for him.</span><br><span class="line">翻译：不知用了什么方法，他成功说服凯给他买了一个。</span><br><span class="line"></span><br><span class="line">例句：How do you manage not to tell your boss to f*** off to his face?</span><br><span class="line">翻译：你是怎么做到不当着你老板的面让他滚蛋的？</span><br></pre></td></tr></table></figure><h3 id="communicator"><a href="#communicator" class="headerlink" title="communicator"></a>communicator</h3><blockquote><p>Strong communicators and great relationships with non-engineers</p></blockquote><p>英文解释是：( rather formal ) a person who is able to describe their ideas and feelings clearly to others。在本文中指“（善于）交际者、交流者”，也可以泛指“通信器材”。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：Steve Jobs was a gifted communicator, and he used this skill to capture the attention of millions.翻译：乔布斯是一个有天赋的沟通者，他用这种技巧吸引了数百万人的注意力。</span><br></pre></td></tr></table></figure><h3 id="分词短语做状语（不规范用法）"><a href="#分词短语做状语（不规范用法）" class="headerlink" title="分词短语做状语（不规范用法）"></a>分词短语做状语（不规范用法）</h3><blockquote><p>Product-minded engineers like talking with people outside engineering, learning about what and why &gt;they do. They are smooth communicators, <strong>making it clear they’re interested in</strong> learning more about how &gt;other disciplines work. I frequently see them grabbing coffee, lunch, or doing a hallway chat with &gt;non-engineers.</p></blockquote><p>此句的加黑部分是上一讲我们讲过的分词短语做状语，但它的主句 They are smooth communicators 是描写状态的系表结构，只有系动词 are，没有具体的动作，因此这种情况下用分词短语做状语在此处是不恰当的。</p><p>我们可以把这句话改写成：They communicate smoothly and show their interest in learning more about how other disciplines work。这样的话，这句话就符合语法规范了。</p><p>最后一句话，就是任正非说的，要善于用一杯咖啡去吸收宇宙的能量。</p><h1 id="tradeoff-还是-trade-off？用连字符到底对不对？"><a href="#tradeoff-还是-trade-off？用连字符到底对不对？" class="headerlink" title="tradeoff 还是 trade-off？用连字符到底对不对？"></a>tradeoff 还是 trade-off？用连字符到底对不对？</h1><p>文章的第五段：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5. Offering product/engineering tradeoffs upfront</span><br><span class="line">Because they have a strong understanding of the product &quot;why,&quot; as well as the engineering side of things, they can bring suggestions that few other people can. For example, when scoping the effort to build the product, the engineering effort to build a key feature might be significant. Many engineers would start to look for ways to reduce the effort and try to figure out what the impact of the reduced effort would mean for the feature itself.</span><br><span class="line">Product-minded engineers attack this problem from both angles: both looking for engineering tradeoffs and what the product impact is. They also start making product tradeoffs, evaluating the engineering impact. They often go back to the product manager, suggesting a completely different feature to be built, given the product impact would be similar, but the engineering effort vastly smaller.</span><br><span class="line">Juggling both the product and engineering tradeoffs and the impact of each is a unique strength product-minded engineers have. They can quickly go back-and-forth between the two sides of the same coin: product features and engineering effort and tradeoffs. Because they do it all in their head, using their engineering and product insights, they get to valuable conclusions remarkably quickly.</span><br><span class="line"></span><br><span class="line">5. 提前在产品和工程两方面做出权衡</span><br><span class="line">因为具有产品思维的工程师们对产品的原理以及软件工程都有深刻的理解，他们可以提出非常独到的建议，而很少有别人可以做到。例如，在确定产品构建的工作范围时，打造产品某项关键功能的编程工作量可能非常巨大。许多工程师会开始寻找减少工作量的方法，并试图明确减少工作量对该项关键功能可能会产生的影响。</span><br><span class="line">具有产品意识的工程师会从两个角度来解决这个问题：一方面在工程方面进行取舍，明确可能对产品产生的影响；同时在另一方面，他们还会开始对产品功能进行取舍，评估对工程工作量的影响。他们经常会去找产品经理，在保持产品体验相似的前提下，建议构建一个完全不同的功能，从而使得编程的工作量大幅降低。</span><br><span class="line">兼顾产品和工程、平衡两者的影响，是具有产品意识的工程师们拥有的独特优势。他们可以快速地在同一枚硬币的两面之间来回切换：产品特性、工程工作量和两者的平衡。由于他们利用其工程和产品两方面的洞察力，在头脑中快速完成上述权衡，所以他们能够很快得出有价值的结论。</span><br></pre></td></tr></table></figure><h2 id="知识讲解-3"><a href="#知识讲解-3" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="tradeoff"><a href="#tradeoff" class="headerlink" title="tradeoff"></a>tradeoff</h3><p>这是一个复合名词，由动词和介词 / 副词小品词直接相连构成，你也可以写成 trade-off。同时，这是一个可数名词，可以加 s 变成复数形式 tradeoffs。无疑，这个词在文章中反复出现，所以肯定是整段的关键词，也是中心思想。</p><p>所谓 tradeoff，顾名思义，首先是“交易”的意思。有交易就有讨价还价，就有妥协，就有得有失，就有鱼和熊掌不可兼得。所以这个词指的是一种取舍、一种权衡，最后达成折中平衡。英文解释：A trade-off is a situation where you make a compromise between two things, or where you exchange all or part of one thing for another.</p><p>平时我们有各种利弊要取舍，不能西瓜也要，芝麻也要。一个手机，续航也要，但是不能太厚；屏幕要最好的，但不能太贵；要安全性，但不能太麻烦；要黑科技，但系统不能不稳定、不可靠。这条英文解释进一步诠释了 tradeoff 这一层的意思：A trade-off is a balance between two opposing things, that you are willing to accept in order to achieve something.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：Life is full of trade-offs. You cannot have your cake and eat it too.</span><br><span class="line">翻译：生活充满了取舍。鱼和熊掌不可兼得。</span><br></pre></td></tr></table></figure><p>补充：“You cannot have your cake and eat it (too)”或者“You can’t eat your cake and [then still] have it (too)”是很常用的英语谚语，类似于“you can’t have the best of both worlds”。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：Depending on your system resources, there will always be some trade-offs between CPU, memory, and I/O in your tuning decisions.</span><br><span class="line">翻译：根据你的系统资源进行调优决策时，CPU、内存和 I/O 之间总是需要进行权衡。</span><br></pre></td></tr></table></figure><h3 id="复合名词"><a href="#复合名词" class="headerlink" title="复合名词"></a>复合名词</h3><p>复合名词构成的方法比较多，它可以由动词和介词 / 副词小品词组成，这在英语中很是常见。这种方式构成的复合名词与相关联的短语动词之间，意义基本相近。我们以短语动词 break out 为例来看下。</p><p>动词短语 break out 指“（战争、瘟疫）爆发、越狱”，由此我们可以引申出“摆脱局限的状态、突破”等含义。如果把 break 和 out 之间的空格去掉，这个动词短语就变成了复合名词 breakout。下面是三个例句。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：Bubble economy usually starts with false prosperity and ends in a breakout of financial crises.</span><br><span class="line">翻译：泡沫经济通常以虚假繁荣开始，以金融危机爆发告终。</span><br><span class="line"></span><br><span class="line">例句：Point Break was a breakout film for Kathryn Bigelow in 1991.</span><br><span class="line">翻译：凯瑟琳·毕格罗于 1991 年拍摄了《惊爆点》，该片突破了她之前的风格。</span><br><span class="line"></span><br><span class="line">例句：Breakout session is a relatively short meeting where a small group of attendees, drawn from a large conference or convention, discusses specific subjects or aspects of the broad theme of the main gathering.</span><br><span class="line">翻译：分组会议是大会中一个相对较短的小会，由部分与会者讨论大会主题下的某个具体议题。</span><br></pre></td></tr></table></figure><p>注意，颠倒两个单词的次序之后，还可以构成另外一个复合名词 outbreak，但这个词更多地特指“（战争、瘟疫）突然爆发、蔓延”。同时，outbreak 偶尔也可用作动词。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：Fears are growing of avian influenza outbreak following the appearance of several cases in the city.</span><br><span class="line">翻译：随着该市出现若干病例，人们对禽流感大爆发的担忧日益加剧。</span><br></pre></td></tr></table></figure><h3 id="a-few-a-little"><a href="#a-few-a-little" class="headerlink" title="(a) few/(a) little"></a>(a) few/(a) little</h3><blockquote><p>Because they have a strong understanding of the product “why,” as well as the engineering side of &gt;things, they can bring suggestions that few other people can.</p></blockquote><p>作为限定词，little 用于修饰不可数名词，few 用于修饰可数名词的复数。</p><p>需要特别注意的是，little 和 few 在不带 a 的情况下，表达的是否定的意思，表示“几乎没有”或者“很少”。比如 We have little time，表示“我们没时间了”。如果带 a，则表示肯定，“虽然不多，但有一些”。比如 We have a little time，表示“我们还有一些时间”。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：Few people can say they always tell the truth.</span><br><span class="line">翻译：几乎没有人敢说自己从不撒谎。</span><br><span class="line"></span><br><span class="line">例句：We don’t need to go shopping today. We’ve got a few potatoes and some steak.</span><br><span class="line">翻译：我们今天不需要去购物。 我们还有一些土豆和牛排。</span><br><span class="line"></span><br><span class="line">例句：I have little knowledge of computer and business, can I still learn Navisio？</span><br><span class="line">翻译：我对计算机和商业知之甚少，我还能学习 Navision 系统吗？</span><br><span class="line"></span><br><span class="line">例句：Just because she painted her room by herself, now she thinks she can do the entire house—inside and out! A little knowledge is a dangerous thing.</span><br><span class="line">翻译：仅仅因为她自己粉刷了自己的房间，现在她认为可以把整个房子里里外外都粉刷一遍！ 一知半解害死人。</span><br></pre></td></tr></table></figure><p>这一句中，“A little knowledge is a dangerous thing”是一句英语谚语，按照字面的意思来说就是，“危险的不是一个人没有知识，而是有了一点点知识之后的过度自信和膨胀”。</p><h3 id="figure-out"><a href="#figure-out" class="headerlink" title="figure out"></a>figure out</h3><blockquote><p>Many engineers would start to look for ways to reduce the effort and try to figure out what the impact &gt;of the reduced effort would mean for the feature itself.</p></blockquote><p>这是个很常用的动词短语，意思是 find the solution to (a problem or question) or understand the meaning of…，“找到问题的解决办法、搞清楚、弄明白”。这个很简单，我就不多说了，我们直接通过例句来感受使用场景。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：By 2020, scientists will figure out how to control robots via brain-machine interfaces.</span><br><span class="line">翻译：到 2020 年，科学家们将解决如何通过脑机接口来控制机器人的问题。</span><br></pre></td></tr></table></figure><h3 id="打破语言形式看实质含义"><a href="#打破语言形式看实质含义" class="headerlink" title="打破语言形式看实质含义"></a>打破语言形式看实质含义</h3><blockquote><p>Product-minded engineers attack this problem from both angles: <strong>both looking for engineering &gt;tradeoffs and what the product impact is. They also start making product tradeoffs, evaluating the &gt;engineering impact.</strong></p></blockquote><p>第一句话。作者明确说了，具有产品思维的工程师们会从两个角度来解决问题，而且后面加了冒号，那我们必然预期，冒号后面会解释这两个角度分别是什么。</p><p>接下来，冒号后面又出现了第二个 both，我们的预期就更加明确了。both…and…这个平衡的结构你肯定知道。那前面提到过的两个角度肯定会工整地在 both 后面放一个，and 后面再放一个，就像下面这几个例句：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">She is both pretty  and clever. （形容词）</span><br><span class="line">I talked to both the Director and his secretary. （名词）</span><br><span class="line">You can both borrow the flat and use our car. （动词）</span><br></pre></td></tr></table></figure><p>在 both 后面跟了一个现在分词短语，做主句中 from 的介词宾语，意思是在工程方面进行取舍。但是，and 后面却跟了一个从句，单纯从语法角度看这是 from 这个介词的宾语从句，显然形式不对等。形式不对等没关系，只要内容或者逻辑对等并列也行，我们可以解释主句讲的两个角度。但是，and 后面说的“对产品产生的影响”，是之前工程方面取舍的结果，逻辑上看并没有并列关系。</p><p>句子在这里就结束了，仿佛话说了半句，我们掉进了作者挖的坑里。从坑里爬出来，我们接着往下读，你会突然发现，原来作者另起炉灶讲的下一句话，才是前文讲的第二个角度 They also start making product tradeoffs, evaluating the engineering impact.，要在产品功能方面进行取舍，并评估对工程工作量的影响。</p><p>即便是非常严谨的学术著作，写作都有可能存在不严密的地方，更何况是这种相对随意一些的博客专栏。<strong>虽然语法上有些小瑕疵，但这种文章可以训练我们突破语言的形式外壳，去分析句子之间的逻辑关系，领会作者想要表达的实质含义。</strong></p><h3 id="独立主格结构"><a href="#独立主格结构" class="headerlink" title="独立主格结构"></a>独立主格结构</h3><blockquote><p>They often go back to the product manager, suggesting a completely different feature to be built, &gt;given the product impact would be similar, <strong>but the engineering effort vastly smaller.</strong></p></blockquote><p>工程师们经常去找产品经理，去干什么呢？后面是我们已经非常熟悉的现在分词做状语，来表示目的，去找他们提建议，建议改产品的功能，而且还是完全不同的功能。产品经理刚要急，工程师马上就接上说，当然前提条件（given 后面跟的是从句）是产品的用户体验相似，然后话锋一转，但是工程师的工作量会大幅度下降。</p><p>这里我们需要讲解一下 but 后面的<strong>独立主格结构</strong>，英文叫作 Absolute Construction。所谓独立主格，首先它是一个“格”，属于短语性质的成分，而不是一个“句子”或“从句”，因为英语中任何一个句子都要有主谓结构。例如，我们将本段最后一句话改成 but the engineering effort would be vastly smaller 的话，这就变成了一个单独的句子。</p><p>而独立主格结构没有真正的主语和谓语动词，它由名词或代词作逻辑主语，再加上分词、形容词、副词、动词不定式或介词短语作逻辑谓语来构成的，前后两部分具有逻辑主谓关系。</p><p>独立主格结构形式上与主句没有关系，但功能上相当于一个带有独立逻辑主语的状语从句。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：The wind failing, we lowered the sail. 风力减弱，我们放下了船帆。</span><br><span class="line">比较：When the wind failed, we lowered the sail. 意思相同，但属于状语从句。</span><br></pre></td></tr></table></figure><p>The wind failing 带有自己的主语 wind，从语法结构上和主句的主语 we 不发生关系。但是，所谓的“独立”并非真正独立，它从逻辑或者意思上看，还是一种从属结构，在句中通常起状语的作用，常用来表示时间、原因、条件、行为方式或伴随情况等。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：Weather permitting, we will have a barbecue tomorrow.</span><br><span class="line">翻译：如果天气好的话，明天我们一起烤肉。（表示条件）</span><br><span class="line"></span><br><span class="line">例句：The night dark and frosty, he wrapped her up with great care.</span><br><span class="line">翻译：夜又黑又冷，所以他把她裹得严严实实的。（表示原因）</span><br><span class="line"></span><br><span class="line">例句：Evenings he read aloud, his wife sewing by his side.</span><br><span class="line">翻译：晚上他朗声读书，妻子在他身边缝衣服。（表示伴随情况）</span><br><span class="line"></span><br><span class="line">例句：Almost all metals are good conductors, silver being the best of all.</span><br><span class="line">翻译：几乎所有的金属都是良导体，而银则是最好的导体。（表示补充说明）</span><br></pre></td></tr></table></figure><p>最著名（也最臭名昭著）的“独立主格结构”应该就是美国宪法修正案第二条了，它授予了美国公民合法持枪的权利。</p><blockquote><p>A well-regulated militia, being necessary to the security of a free State, the right of the people to &gt;keep and bear Arms, shall not be infringed.纪律优良之民众武装乃自由邦国安全所必需，故，人民持有并携带武器之权不受侵&gt;犯。</p></blockquote><h3 id="juggle"><a href="#juggle" class="headerlink" title="juggle"></a>juggle</h3><blockquote><p>Juggling both the product and engineering tradeoffs and the impact of each is a unique strength &gt;product-minded engineers have.</p></blockquote><p>juggle 这个词的原意是“玩杂耍的时候接连抛接几个物体”，英文解释是 to throw a set of three or more objects such as balls into the air and catch and throw them again quickly, one at a time，同时它也可以引申出“同时应付几件事情，一心多用、兼顾”等含义。我们还是通过几个例句来感受使用场景。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：I was juggling books, shopping bags and the baby.</span><br><span class="line">翻译：我手里又是书，又是购物袋，还抱着孩子，跟演杂技一样。</span><br><span class="line"></span><br><span class="line">例句：The management team meets several times a week to juggle budgets and resources.</span><br><span class="line">翻译：管理团队一周碰头几次，来兼顾预算和资源。</span><br></pre></td></tr></table></figure><p>juggle 还有一个近义词 multitask，也是指“同时做几件事情、多任务处理”。但是，和 juggle 不同的是，multitask 是不及物动词，后面不跟宾语。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：According to a study published by the American Psychological Association, you spend between 20 and 40 percent more time when you multitask.</span><br><span class="line">翻译：根据美国心理协会发表的一项研究，当你一心多用同时处理多项工作时，你所花费的时间会多 20% 到 40%。</span><br></pre></td></tr></table></figure><h3 id="back-and-forth"><a href="#back-and-forth" class="headerlink" title="back-and-forth"></a>back-and-forth</h3><blockquote><p>They can quickly go back-and-forth between the two sides of the same coin: product features and &gt;engineering effort and tradeoffs.</p></blockquote><p>back-and-forth 的意思是“来来回回”，英文解释是：moving first in one direction and then in the opposite one。但是，backward and forward 不能表示同样的意思。back 强调的是目的地、回到什么地方，比如 back home（回家）；而 backward 只是一个方向，表示“倒退”。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：I will drive back to Shanghai this weekend.</span><br><span class="line">翻译：这周末我开车回上海。</span><br></pre></td></tr></table></figure><p>至于你的车是正着开还是倒着开，这句话并不关心，只是强调要“回去”，表示目的地而不是方向。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：This lessens the back-and-forth remote traffic and can reduce deployment times.</span><br><span class="line">翻译：这样可以减少来回的远程传输，并缩短部署时间。</span><br></pre></td></tr></table></figure><h3 id="two-sides-of-the-coin"><a href="#two-sides-of-the-coin" class="headerlink" title="two sides of the coin"></a>two sides of the coin</h3><p>“一个硬币的两面”。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If two things are two sides of the same coin or opposite sides of the same coin, they are closely related to each other and cannot be separated, even though they seem to be completely different.</span><br><span class="line"></span><br><span class="line">I’ve always felt that tragedy and comedy are two sides of the same coin. Love and hate are the opposite sides of the same coin. 祸福相依、爱恨交织。/ 塞翁失马焉知非福。</span><br><span class="line"></span><br><span class="line">例句：WCF and WF are really two sides of the same coin: WCF is the interface and hosting environment for the service, while WF implements its processing logic.</span><br><span class="line">翻译：WCF 和 WF 实际上是同一枚硬币的两面：WCF 是服务的接口和托管环境，而 WF 实现其处理逻辑。</span><br></pre></td></tr></table></figure><h3 id="insight"><a href="#insight" class="headerlink" title="insight"></a>insight</h3><blockquote><p>Because they do it all in their head, using their engineering and product insights, they get to &gt;valuable conclusions remarkably quickly.</p></blockquote><p>insight 有个现成的译法叫“洞察”。“洞”字非常准确生动，有“透彻、清楚”的意思，和英文中对 insight 的解释非常吻合：If you gain insight or an insight into a complex situation or problem, you gain an accurate and deep understanding of it.</p><p>所谓洞察，简单讲就是透过现象看到本质。</p><h1 id="小心那些平淡无奇、人畜无害的简单小词！"><a href="#小心那些平淡无奇、人畜无害的简单小词！" class="headerlink" title="小心那些平淡无奇、人畜无害的简单小词！"></a>小心那些平淡无奇、人畜无害的简单小词！</h1><p>文章的第六段：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6. Pragmatic handling of edge cases</span><br><span class="line">Edge cases are a funny thing. On one extreme, engineers often forget about many of these, having to come back to addressing them, after getting feedback from people testing the product or end users. On the other hand, handling all possible edge cases in a new product or feature can take a lot of time.  </span><br><span class="line">Product-minded engineers quickly map out edge cases and think of ways to reduce work on them: often bringing solutions that require no engineering work. They are focused on the &quot;minimum lovable product concept&quot; and evaluate the impact of an edge case and the effort of handling it. They come with good middle-ground suggestions: mapping out most things that can go wrong and bring suggestions on what edge cases need to be addressed, before shipping even an early version.  </span><br><span class="line">For example, if one in a thousand users might be hit by an error, they will consider the effort to fix it and think about what happens if they don&apos;t do anything. Can customer support help the person in this case, during validation? Can the user just retry and succeed the next time? Can the product be slightly modified, so this edge case won&apos;t occur?</span><br><span class="line"></span><br><span class="line">6. 以务实的方式处理边缘案例</span><br><span class="line">边缘案例是一件很有意思的事情。有的工程师经常会忘记边缘案例的存在，最后从产品测试人员或最终用户那里得到反馈之后，才不得不回过头来解决这些问题。这是一个极端，而另一方面，如果在一个新产品或功能中试图处理所有可能的边缘情况，则可能会耗费大量的时间。</span><br><span class="line">具有产品意识的工程师会很快制定出关于边缘案例的计划，并思考如何减少工作量，并经常会找到不需要额外工作量的解决方案。他们专注于“最小可爱产品”的概念，评估边缘案例的影响和处理所需的工作量。他们会提供很好的折衷建议: 在发布早期版本之前，列出大多数可能出错的地方，并提出需要解决哪些边缘案例的建议。</span><br><span class="line">例如，对于一个千分之一的用户可能会遇到的错误，他们会考虑修复这一错误涉及的工作量，以及如果什么都不做会发生的后果。在产品验证过程中，客服专员是否可以在这个案例中帮助用户？用户下一次再遇到同样问题可以自己尝试成功解决吗？对产品进行略微调整，是否就可以避免边缘案例？</span><br></pre></td></tr></table></figure><h2 id="知识讲解-4"><a href="#知识讲解-4" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="edge-case"><a href="#edge-case" class="headerlink" title="edge case"></a>edge case</h3><p>维基百科对这个词的定义是：Edge case occurs at an extreme (maximum or minimum) operating parameter.</p><p>edge case 较为常见的译法为“边缘案例”，指“一个运行参数或条件为极值（最大值或最小值）的情况”。类似的，我们来看下 corner case 这个词。</p><p><strong>Corner case</strong> occurs outside of normal operating parameters, specifically when multiple environmental variables or conditions are simultaneously at extreme levels, even though each parameter is within the specified range for that parameter.</p><p>“边角案例”一词应该来自边缘案例，两个边缘的交叉点构成角，所以边角案例就是多个参数或条件均为极值的情形。如果音量调到最大，声音失真，这属于边缘案例；如果问题在音量最大、周边环境高湿、且同时一万人以上同时在线时才会出现，这属于边角案例。边角案例一般在复杂系统的测试或除错过程中才会出现。</p><p>Boundary case occurs when one of inputs is at or just beyond maximum or minimum limits.</p><p>还有一个词 boundary case，我们也叫“边界案例”或者“边界条件”，也是指系统输入刚好在上下限或是恰好超过上下限一点点的状态。</p><h3 id="pragmatic"><a href="#pragmatic" class="headerlink" title="pragmatic"></a>pragmatic</h3><p>它既可以强调“一种务实的态度”（A pragmatic way of dealing with something is based on practical considerations, rather than theoretical ones.），也可以用来说“一个人非常务实”（A pragmatic person deals with things in a practical way.）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：Incorporating both risk-based and customer-based analysis into your solution will yield a more pragmatic test plan.</span><br><span class="line">翻译：将基于风险和基于客户的分析整合到您的解决方案中，将会产生一个更加务实的测试计划。</span><br></pre></td></tr></table></figure><h3 id="funny"><a href="#funny" class="headerlink" title="funny"></a>funny</h3><blockquote><p>Edge cases are a funny thing.</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：</span><br><span class="line">A: Sorry I’m late. My car broke down half way here.</span><br><span class="line">B: Oh, very funny. Tell me another!</span><br><span class="line">翻译：</span><br><span class="line">A：抱歉我迟到了，我的车半路抛锚了。</span><br><span class="line">B：你得了吧，接着编。（有点类似于“呵呵”的口气）</span><br><span class="line"></span><br><span class="line">例句：It’s not funny! Someone could have been hurt.</span><br><span class="line">翻译：这不好玩（这太危险了）！没人受伤算是运气好。</span><br><span class="line"></span><br><span class="line">例句：If there has been any funny business, we’ll soon find out.</span><br><span class="line">翻译：如果这里面有任何猫腻（非法勾当），我们很快会发现的。</span><br><span class="line"></span><br><span class="line">例句：My computer keeps going funny.</span><br><span class="line">翻译：我的计算机老出故障。</span><br></pre></td></tr></table></figure><p>另外，还有一些可以用来夸人的词汇，也比较常用。这些词不含负面意思，在交流的时候，你可以放心使用。这些词有：hilarious、humorous、amusing、entertaining 等。</p><p>除了 funny 外，还有很多类似的词，使用的时候也要特别小心。例如 interesting，其实它也是“呵呵”的意思。以下是一些工作和生活中非常常见的表达：</p><ul><li>Could we consider some other options？能否考虑其他方案？（你的方案是狗屎）</li><li>It was a bit disappointing that…我感到有些失望……（你们 XXX 干的叫什么事！！！）</li><li>Oh, by the way…顺便提一句……（下面要说的可能是谈话里最重要的一件事……）</li><li>It is quite good. 还行吧。（不咋地。）</li><li>It is not bad. 不坏。（真心不错，但不要骄傲。）</li><li>With all due/the greatest respect…恕我冒昧，恕我直言……（后面跟的话就是要骂人了。）</li><li>I hear what you say…你的意见我听到了……（你给我闭嘴吧！）</li><li>It is a very brave proposal. 这真是个勇敢的提议。（我看这个愣头青大概是疯了吧！）</li><li>I almost agree…我基本同意？（同意个鬼，基本不同意。）</li></ul><h3 id="现在分词短语（做状语和主语）"><a href="#现在分词短语（做状语和主语）" class="headerlink" title="现在分词短语（做状语和主语）"></a>现在分词短语（做状语和主语）</h3><blockquote><p>On one extreme, engineers often forget about many of these, <strong>having to come back to addressing them, &gt;after getting feedback from people testing the product or end users.</strong> On the other hand, <strong>handling all &gt;possible edge cases in a new product or feature</strong> can take a lot of time.</p></blockquote><p>们用这两句话来复习一下现在分词短语做状语和做主语的情况。</p><p>这两句话讲了两个极端，一个是程序员完全忘了边缘案例这回事（一定是新手干的），还有一个就是在这个事情上花太多的时间和精力。</p><ul><li><p>第一个极端，有的工程师经常健忘。结果怎么样呢？having to come back to addressing them，现在分词做状语，表示结果，结果不得不回过头来解决这些问题。什么时候发生的事情呢？after getting feedback from people testing the product or end users， 还是现在分词做状语，表示时间，从产品测试人员或最终用户那里得到反馈之后。</p></li><li><p>另外一个极端，handling all possible edge cases in a new product or feature can take a lot of time。从 handling 这个现在分词开始一直到 feature，这整个短语都是句子的主语，表示在一个新产品或功能中试图处理所有可能的边缘情况，can take 情态动词加上实义动词做谓语，可能会耗费大量的时间。</p></li></ul><h3 id="map-out"><a href="#map-out" class="headerlink" title="map out"></a>map out</h3><blockquote><p>Product-minded engineers quickly <strong>map out</strong> edge cases and think of ways to reduce work on them: &gt;often &gt;bringing solutions that require no engineering work.</p></blockquote><p>map out 是“计划、规划、提前安排”的意思。例如，map out the future 的意思是“筹划未来”。它的英文解释是：If you map out something that you are intending to do, you work out in detail how you will do it.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：With the whole IT picture in hand, we can map out how the information flows from start to finish.</span><br><span class="line">翻译：掌握了整个 IT 蓝图之后，我们就可以规划信息从头到尾的流动方式。</span><br><span class="line"></span><br><span class="line">例句：It is important to map out the big picture first so that we can systematically identify user requirements.</span><br><span class="line">翻译：为了系统地识别用户的需求，我们首先需要制定一个全局规划。</span><br></pre></td></tr></table></figure><h3 id="focus-和-focused"><a href="#focus-和-focused" class="headerlink" title="focus 和 focused"></a>focus 和 focused</h3><blockquote><p>They are focused on the “<strong>minimum lovable product</strong> concept” and evaluate the impact of an edge case and &gt;the effort of handling it.</p></blockquote><p>focus 是动词，表示“（某人）集中精力于某件事情上”。focused 是过去分词，可作形容词，表示“（注意力、眼神、焦点、光线等）集中的，（论文、计划等）目标明确的”</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：I am exhausted, and just can’t focus on the work anymore.</span><br><span class="line">翻译：我筋疲力尽了，实在难以集中注意力工作了。</span><br><span class="line"></span><br><span class="line">例句：I think it is time you woke up and focused your thoughts on more worldly matters.</span><br><span class="line">翻译：我认为该是你清醒过来把思想集中到更为现实的问题上的时候了。</span><br><span class="line"></span><br><span class="line">例句：Every eye at the conference was focused on the rostrum.</span><br><span class="line">翻译：代表们的眼光都集中在大会主席台上。</span><br><span class="line"></span><br><span class="line">例句：Focused light rays can set something afire.</span><br><span class="line">翻译：聚焦光线可以点燃东西。</span><br><span class="line"></span><br><span class="line">例句：I spent the next year just wandering. I wasn’t focused.</span><br><span class="line">翻译：接下来的一年我一直在闲逛。没有什么明确的目标。</span><br></pre></td></tr></table></figure><p>由上面这些例句我们可以看出，本段中的 They are focused on the “minimum lovable product concept”，改为 They focus on the “minimum lovable product concept”，其实会更好一点，直接用 focus 做 They 这个主语即程序员们的谓语动词。当然，如果非要说 They are focused on（focused 做形容词）意思也勉强说得通，不能算错。</p><h3 id="minimum-lovable-product"><a href="#minimum-lovable-product" class="headerlink" title="minimum lovable product"></a>minimum lovable product</h3><p>MVP 指的是 Minimum Viable Product，按照字面含义可以直译为“最小可行产品”。这种产品只包含最简单的基本核心功能。</p><p>MLP 指的是 Minimum Lovable Product，可以直译为“最小可爱产品”。</p><p>两者之间的本质区别究竟在哪里？</p><ul><li><p>MVP is the version of a new product that brings back the maximum amount of validated learning about your customers with the least effort. （强调以最小的努力换回最大数量的经过验证的客户反馈数据；目标在于了解用户体验。）</p></li><li><p>MLP is the version of a new product that brings back the maximum amount of love from your early tribe members with the least effort. （强调以最小的努力换回最大数量的首批部落成员的爱；目标在于直接开始圈粉。）</p></li></ul><h3 id="middle-ground"><a href="#middle-ground" class="headerlink" title="middle ground"></a>middle ground</h3><blockquote><p>They come with good middle-ground suggestions: mapping out most things that can go wrong and bring bringing suggestions on what edge cases need to be addressed, before shipping even an early version.</p></blockquote><p>middle ground 的意思是“中间地带”，表示“折中、妥协之后的立场、观点、决定、协议”等等。字典里的解释是：a set of opinions, decisions, etc. that two or more groups who oppose each other can agree on; a position that is not extreme.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：More and more in this age of social media, it seems like people of differing views are unwilling to attempt to find a middle ground.</span><br><span class="line">翻译：在这个社交媒体时代，越来越多持不同观点的人似乎不愿意尝试找到一个中间立场。</span><br></pre></td></tr></table></figure><p>注意：最后一句话的 bring 应该改成 bringing。</p><h1 id="为什么虚拟语气一看就懂、一用就忘？"><a href="#为什么虚拟语气一看就懂、一用就忘？" class="headerlink" title="为什么虚拟语气一看就懂、一用就忘？"></a>为什么虚拟语气一看就懂、一用就忘？</h1><p>文章的第七、八段：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7. Quick product validation cycles</span><br><span class="line">Even before the feature they are working on is production-ready, product-minded engineers find creative ways to get early feedback. This could be doing hallway testing with colleagues, showing the work-in-progress feature to the product manager, organizing a team bug bash on the beta build, and many other, creative ways. They are continuously thinking:&quot;how can we validate that people will use this feature, the way we think they will?&quot;</span><br><span class="line"></span><br><span class="line">7. 快速的产品验证周期</span><br><span class="line">甚至在开发的产品功能可以上线之前，具有产品思维的工程师们早就已经找到创造性的方法来获取早期的反馈意见。他们可以和同事一起进行走廊测试，可以向产品经理演示尚在开发中的功能，也可以在 Beta 版本发布前组织整个团队来一场“漏洞大扫荡”，当然还有许多其他创造性的方法。他们会一直思考这个问题：“我们怎样才能验证用户们会像我们预期的那样来使用这个功能？”</span><br></pre></td></tr></table></figure><p>首先，我们从整体看一下这段话。这段话中有两个从句，第一句的前半部分 Even before the feature they are working on is production-ready，是时间状语从句，表示“在功能上线之前”。其中，even 表示“高于预期，甚至”。主语 the feature 后面跟了一个定语从句，强调是“工程师们正在开发的”。在功能上线之前，工程师们就已经找到了创造性的方法来获取早期的反馈意见。</p><p>最后一句的标黑处 people will use this feature, the way we think they will?，这是比较随意的说法，相对规范一点的说法为：people will use this feature in the way we think they will. 当然原文并不影响意思的表达和理解，无伤大雅。但是一般我看到不太规范的地方，总是忍不住要去修改，或许这也是一种“语言洁癖”的症状吧……</p><h2 id="知识讲解-5"><a href="#知识讲解-5" class="headerlink" title="知识讲解"></a>知识讲解</h2><h3 id="work-in-progress"><a href="#work-in-progress" class="headerlink" title="work-in-progress"></a>work-in-progress</h3><blockquote><p>This could be doing hallway testing with colleagues, showing the work-in-progress feature to the product manager, &gt;organizing a team bug bash on the beta build, and many other, creative ways.</p></blockquote><p>work-in-progress 是一个不可数名词，指“半成品、在制品、在建项目”，有时会缩写为 WIP。在文章中指“尚在开发过程中的应用软件”。这里是名词作形容词来修饰 feature，即“在开发中的软件的某项功能”。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：You are strongly encouraged to save your document frequently, back-up regularly, and print your work-in-progress periodically.</span><br><span class="line">翻译：强烈建议你们经常保存和备份，并且定期把写作过程中的文稿打印出来。</span><br></pre></td></tr></table></figure><h3 id="bug-bash"><a href="#bug-bash" class="headerlink" title="bug bash"></a>bug bash</h3><p>这里的 bash，原意是“猛烈击打”。我们先来看维基百科给出的 bug bash 的定义。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In software development, a bug bash is a procedure where all the developers, testers, program managers, usability researchers, designers, documentation folks, and even sometimes marketing people, put aside their regular day-to-day duties and “pound on the product”—that is, each exercises the product in every way they can think of. Because each person will use the product in slightly different (or very different) ways, and the product is getting a great deal of use in a short amount of time, this approach may reveal bugs relatively quickly.</span><br><span class="line"></span><br><span class="line">在软件开发过程中，所有开发人员、测试人员、项目经理，还有负责可研、设计、文档管理甚至营销的同事，把他们的日常工作放在一边，一起来开“捉虫大会”。换言之，每个人都用他们能想到的方式来操作产品。因为每个人使用产品的方式略有不同（或非常不同），从而使得产品在很短的时间内得到了大量的使用，有助于团队相对较快地发现产品缺陷。</span><br></pre></td></tr></table></figure><p>文章第八大段：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8. End-to-end product feature ownership</span><br><span class="line">Most experienced engineers own their work end-to-end: from getting the specification, through implementing it, all the way to rolling it out and validating that it works correctly. Product-minded engineers often go a step beyond this.</span><br><span class="line">They consider their work done only after getting results on user behavior and business metrics. After rollout, they still actively engage with product managers, data scientists, and customer support channels, to learn how the feature is being used in the real world. It can take weeks to get enough reliable data to draw conclusions. Even though they might be working on a new project, they make checking on the results one of their top priorities. It’s not a time-consuming activity, but it needs that additional persistence from someone wanting to know: how is my work really doing?</span><br><span class="line">When a feature performs worse than expected, they are curious to understand where the mismatch was. They are just as interested in finding the root cause between the product plan and the real world result, as they are to debug a hard-to-reproduce bug in the codebase. They’ll often spend a good amount of time debating hypothesizes and learnings with the product manager and data scientists.</span><br><span class="line"></span><br><span class="line">8.对产品功能从头至尾负责到底</span><br><span class="line">经验丰富的工程师们都会对他们的工作从头至尾负责到底：从拿到产品规范到部署实施，再到发布产品并最终验证产品能否正常工作。除了上述这些工作以外，具有产品意识的工程师通常会举一反三、再进一步。</span><br><span class="line">他们坚信，只有在获得用户行为和商业指标的结果之后，他们的工作才算全部完成。产品上线后，他们仍然会积极与产品经理、数据专家和客户支持渠道保持密切沟通，以便了解产品功能在现实世界中的使用情况。要获得足够得出结论的可靠数据通常需要几周时间。即使他们可能已经接手下一个新项目，他们仍然会把检查上一项目的成果作为首要任务之一。这并不是一项特别耗时的活动，但是特别需要一种锲而不舍的精神，推动那些想要知道自己的辛勤劳动究竟效果如何的工程师们，去坚持探寻答案。</span><br><span class="line">当开发的某项功能表现得不如预期时，他们会特别好奇问题出在哪里？他们对于找到产品计划和现实世界结果之间存在差距的根本原因怀有浓厚的兴趣，程度不亚于他们在代码库中找到难以复现的缺陷并成功除错。他们经常会花费大量的时间，就某些假设和心得与产品经理和数据专家展开辩论。</span><br></pre></td></tr></table></figure><h3 id="ownership"><a href="#ownership" class="headerlink" title="ownership"></a>ownership</h3><p>它由 owner（物主、所有权人）加上 ship（表示地位、状态、关系的后缀，例如 leadership/friendship/dictatorship/partnership 等等）组成，本意是“物主身份、产权关系”。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：On January 23rd, America decided to relax its rules on the foreign ownership of its airlines.</span><br><span class="line">翻译：1 月 23 日，美国决定放宽对外国持有美国航空公司所有权的管制规定。</span><br><span class="line"></span><br><span class="line">例句：Major breakthroughs have been made in the reform of China’s ownership structure.</span><br><span class="line">翻译：中国所有制结构改革也取得了重大突破。</span><br></pre></td></tr></table></figure><p>这里的 ownership 指的是“产权体制”。</p><h4 id="普及两类特别容易混淆的企业概念"><a href="#普及两类特别容易混淆的企业概念" class="headerlink" title="普及两类特别容易混淆的企业概念"></a>普及两类特别容易混淆的企业概念</h4><ul><li>在国内，论及所有制（即 ownership）的时候，我们会区分国有企业、集体企业和非公有制企业（包括私营企业）等。而西方国家在对市场中的企业类型进行划分时，更常用的是 private company 和 public company 这两个相对的概念。初学者看到这组词的时候，容易望文生义，认为 private company 是“私营企业或者民营企业”，那么 public company 一定是“公有体制下的国有企业”。如果这么理解的话，那就大错特错啦。国有企业现在约定俗成的说法叫 state-owned-enterprise，缩写是 SOE。</li></ul><p>那private company 和 public company 到底是什么意思呢？</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Privately held companies are—no surprise here—privately held. This means that, in most cases, the company is owned by its founders, management, or a group of private investors. A public company, on the other hand, is a company that has sold all or a portion of itself to the public via an initial public offering (IPO), meaning shareholders have a claim to part of the company’s assets and profits.</span><br></pre></td></tr></table></figure><p>根据这段解释，我们可以看出，private company 或者 privately held company 指的是“私人控股或持股公司”，一般由创始人、管理层或一群私人投资者拥有产权。</p><p>而 public company 其实指的是“公众持股公司”，大多数时候我们也可以称为“上市公司（listed company）”，指通过股权首次公开发行（或简称 IPO）向公众出售公司全部或部分资产的公司，当然持有股票的公众股东理论上可分享上市公司一定比例的资产和利润。</p><p>所以，在西方，区分公众公司和私人公司的标准并非对应中国的所有制形式，也不取决于规模大小（很多世界级的大型企业，例如美国的科氏工业集团、玛氏集团、彭博有限合伙企业等，都是不上市的私人企业），而是取决于公司的股份是否面向公众公开发行、是否可以自由转让。</p><p>最重要的是，一旦一个私人公司成为公众公司（英文可以叫 goes public），就不能再享有闭门经营、少数几个经营者说了算的自由，公众公司必须接受证券交易监督管理委员会的监管，满足定期向股东和公众进行信息披露的要求。公众公司也可以进行“私有化”（privatization，如果是一家上市公司，就是“退市”），私有化和公募上市是一个反向的过程。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">One of the biggest differences between the two types of companies is how they deal with public disclosure. If it’s a public U.S. company, which means it is trading on a U.S. stock exchange, it is typically required to file quarterly earnings reports (among other things) with the Securities and Exchange Commission (SEC). This information is made available to shareholders and the public. Private companies, however, are not required to disclose their financial information to anyone, since they do not trade stock on a stock exchange.</span><br></pre></td></tr></table></figure><p>由财产权引申出来，我们经常会听到 Kate owns this project 这样的话，表面意思是“凯特拥有这个项目”，指的是“这个项目的负责人是凯特”。</p><p>文章中 ownership 的意思其实也是负责某个项目或某项工作的状态。字面上看，就是把公司的事情真正当作自己的，做事一跟到底，对结果负责。这一段小标题里面的 end-to-end（端到端），也是进一步强调了 ownership 这个意思。所以，ownership 其实也用来表示一个人有责任心，有主人翁精神，是一种可贵的、自发投入的工作状态。很多企业都会在自己的公司文化中倡导员工的 ownership 意识，和公司同心同德。</p><h3 id="from…through…-all-the-way-to…"><a href="#from…through…-all-the-way-to…" class="headerlink" title="from…through… (all the way) to…"></a>from…through… (all the way) to…</h3><blockquote><p>Most experienced engineers own their work end-to-end: from getting the specification, through implementing it, all the way to rolling it out and validating that it works correctly.</p></blockquote><p>这是一个从 A 经过 B 到 C 的句型。all the way 表示“一直、自始至终”。ABC 可以是“时间、地点、一连串先后发生的事件”。此外，all the way through 也是一个惯用成语。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：I slept all the way through the film.</span><br><span class="line">翻译：整部电影我都在睡觉。</span><br></pre></td></tr></table></figure><h3 id="beyond"><a href="#beyond" class="headerlink" title="beyond"></a>beyond</h3><blockquote><p>Product-minded engineers often go a step beyond this.</p></blockquote><p>介词 beyond 在英语日常表达中很常用，是充分体现英语语言效率的高能小词。它最核心的含义就是“超出范围”。在时间、空间、能力范围以外，基本都可以用这个词。</p><p>前几年北京雾霾比较严重的日子，AQI（Air Quality Index，空气质量指数）超过 500，我们会说“爆表了”，英文表述就是 beyond index（超出了正常的指数计量范围）。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：The night session will go beyond midnight.</span><br><span class="line">翻译：夜间会议将持续到午夜以后。</span><br><span class="line"></span><br><span class="line">例句：Jenna always wondered what was beyond the horizon.</span><br><span class="line">翻译：洁娜总是纳闷地平线的那一边是什么。</span><br><span class="line"></span><br><span class="line">例句：What Jock had done was beyond my comprehension.</span><br><span class="line">翻译：我无法理解乔克的所作所为。</span><br></pre></td></tr></table></figure><h3 id="过去分词做宾语补足语"><a href="#过去分词做宾语补足语" class="headerlink" title="过去分词做宾语补足语"></a>过去分词做宾语补足语</h3><blockquote><p>They consider their work <strong>done</strong> only <strong>after getting results on user behavior and business metrics.</strong></p></blockquote><p>这句话的前半句是典型的过去分词做宾语补足语的句型，后半句则是我们已经很熟悉的状语从句，表示时间，“只有在拿到…之后，他们的工作才算完成”。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：They keep the door locked for the whole day.（过去分词做宾语补足语）</span><br><span class="line">翻译：他们把门锁了一整天。</span><br><span class="line"></span><br><span class="line">例句：I find learning Japanese difficult.（形容词做宾语补足语）</span><br><span class="line">翻译：我发现学习日语很难。</span><br></pre></td></tr></table></figure><h3 id="even-if-though"><a href="#even-if-though" class="headerlink" title="even if/though"></a>even if/though</h3><blockquote><p>Even though they might be working on a new project, they make checking on the results one of their top priorities.</p></blockquote><p>even if 和 even though 意思相近，都可用于引导表示让步的状语从句，但它们的用法存在微妙差别。</p><p><strong>even if 引导的从句一般是假设性的，并不符合真实的状况，表示“即使、就算、哪怕”等含义</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：I wouldn’t marry you even if you were the last man in the world.</span><br><span class="line">翻译：即使你是世界上最后一个男人，我也不会嫁给你。</span><br></pre></td></tr></table></figure><p><strong>even though 引导的从句，往往是在说真实发生的情况，表示“尽管、虽然”的意思。大部分情况下，我们可以直接用 though 或 although 代替，但是不可以说 even although。</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：Thomas is awarded the best teacher of the year even though he has the least experience.</span><br><span class="line">翻译：托马斯被授予年度最佳教师，尽管他的经验最少。</span><br></pre></td></tr></table></figure><p>当 even if 或 even though 引导让步状语从句时，后面可以是真实的条件句，也可以是虚拟语气。</p><p>用一句话来说，虚拟语气用来<strong>表示虚假的、与事实相反或难以实现的情况，也可以用来表示某种不确定的情形，体现主观愿望或某种强烈情感。</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句 1：If it rains tomorrow, we will cancel the event.</span><br><span class="line">例句 2：If I were you I should go to see the doctor.</span><br><span class="line">例句 3：I wish it were Sundy today.</span><br><span class="line">例句 4：I should have called Emily this morning, but I forgot.</span><br></pre></td></tr></table></figure><h3 id="priority"><a href="#priority" class="headerlink" title="priority"></a>priority</h3><p>priority 源于形容词 prior，意思是“优先的、前面的、更重要的事项”。有时候为了表示强调，我们会在 priority 前面加上 top 或者 number one，表示“重中之重、第一优先事项”。</p><p>它的词根 pri/prim/prin，表示“首先、第一、重要”等含义，我们所熟悉的 primary、prime minister/premier、prince/princess、principal、principle、primate 都带有这个前缀。</p><h3 id="persistence"><a href="#persistence" class="headerlink" title="persistence"></a>persistence</h3><blockquote><p>It’s not a time-consuming activity, but it needs that additional persistence from someone wanting to know: how is my work really doing?</p></blockquote><p>persistence 源于形容词 persistent 和动词 persist。从词根的角度看，per=through，是“从头至尾、贯穿始终”的意思（例如 permanent、perpetual 等）；sist=to stand，是“站立”的意思。例如，consist（站在一起 = 组成）、resist（站到反面 = 抵抗）。所以，合在一起这个词就是“始终站立、坚持到底”的意思。</p><p>动词 persist 一般和介词 in 搭配，意思要看上下文，较多情况下偏贬义，有“顽固坚持、执迷不悟”的意思。</p><p>几条词典的解释：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">to try to do or continue doing something in a determined but often unreasonable way. (Cambridge Advanced Learners’ Dictionary）</span><br><span class="line">if you persist in doing something, you continue to do it, even though it is difficult or other people are against it. (Collins Cobuild Essential English Dictionary)</span><br><span class="line">to go on resolutely or stubbornly in spite of opposition, importunity, or warning. (Merriam-Webster Online)</span><br></pre></td></tr></table></figure><p>通过上面来自不同词典的解释可以看到，persist 一词有褒义的含义，但更多的语境下是偏贬义的，因此需要我们根据上下文来辨别它的具体含义。你可以理解为“坚持不懈”，更多语境下它带有“不顾别人的反对、执迷不悟”的意思。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：We join, we persist, we win.</span><br><span class="line">翻译：我们参与了，我们坚持了，我们最终胜利了。</span><br><span class="line"></span><br><span class="line">例句：Why do you persist in blaming yourself for what happened?</span><br><span class="line">翻译：你何必为已发生的事没完没了地自责？</span><br><span class="line"></span><br><span class="line">例句：She had turned him down for a date before, but he persisted and asked her again.</span><br><span class="line">翻译：她以前拒绝过他的约会，但他坚持要再约她一次。</span><br></pre></td></tr></table></figure><p>同样，形容词 persistent 和名词 persistence 的含义也要看上下文，也有褒义也有贬义。褒义的时候形容坚持不懈。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：Skill comes only with practice, patience and persistence.</span><br><span class="line">翻译：只有不断练习，有耐心，有毅力，才能学会一门技艺。</span><br></pre></td></tr></table></figure><p>不过，它的近义词 persevere、perseverant 和 perseverance 则永远是褒义的，表示“孜孜以求、锲而不舍”，不用管上下文。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：By perseverance the crippled boy learned how to swim.</span><br><span class="line">翻译：由于锲而不舍，那个腿部残疾的男孩学会了游泳。</span><br></pre></td></tr></table></figure><h3 id="as…as…"><a href="#as…as…" class="headerlink" title="as…as…"></a>as…as…</h3><blockquote><p>They are just as interested in finding the root cause between the product plan and the real world result, as they are to debug a hard-to-reproduce bug in the codebase.</p></blockquote><p>as X as Y，比较活动 X 和 Y。</p><p>活动 X（即 finding…）做 interested in 的介词宾语，活动 Y 跟在第二个 as 后面，是表示比较的状语从句。句子虽然长，但框架结构很明确，强调“工程师们对活动 X（找产品问题的根源）的兴趣和活动 Y（捉虫，即找技术问题的根源）一样大”。</p><h1 id="带你一次性搞懂非限定性和限定性定语从句"><a href="#带你一次性搞懂非限定性和限定性定语从句" class="headerlink" title="带你一次性搞懂非限定性和限定性定语从句"></a>带你一次性搞懂非限定性和限定性定语从句</h1><p>文章的第九段：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9. Strong product instincts through repeated cycles of learning</span><br><span class="line">A typical project for a product-minded engineer usually goes like this:</span><br><span class="line">1.They ask a lot of questions to understand exactly why the product feature is being built.</span><br><span class="line">2.They bring suggestions and tradeoffs to the table, some of which are included in the revised spec.</span><br><span class="line">3.They build the feature quickly, getting early feedback, as they do.</span><br><span class="line">4.After shipping the feature, they actively follow up to understand if the feature lives up to the expectation.</span><br><span class="line">5.When it does not, they dig deep, to understand why it did not and learn something new about product usage in the real world.</span><br><span class="line">After each project, their product understanding deepens, and they start to develop better and better product instincts. The next time, they’ll bring even more relevant suggestions to the table. Over time, they become a goto person for product managers, their advice being sought well before projects are kicked off. They build a strong reputation outside the team, opening more doors for their continued career growth.</span><br><span class="line"></span><br><span class="line">9.通过反复循环的学习，形成强大的产品本能</span><br><span class="line">对于有产品意识的工程师来说，一个典型的项目通常是这样的：</span><br><span class="line">1. 他们会提出很多问题，来准确理解构建产品功能的原因；</span><br><span class="line">2. 他们会提供建议和取舍方案，其中某些建议会反映在修订后的产品设计规范中；</span><br><span class="line">3. 他们会很快开发出相关功能，以便尽早得到反馈意见；</span><br><span class="line">4. 在产品发布之后，他们会积极跟进了解相关产品功能是否符合预期；</span><br><span class="line">5. 如果没有达到预期，他们会深入挖掘原因，并学到产品在现实世界中使用的新知识。</span><br><span class="line">每完成一个项目，他们对产品的理解就会加深，他们开始培养起越来越好的产品直觉。等到下一个项目，他们会贡献更多有价值的建议。随着时间推移，他们会成为产品经理最愿意去讨教的大专家，在新的项目还未开始之前就会提前去征求他们的意见。他们将名声在外，为持续的职业发展打开更多的大门。</span><br></pre></td></tr></table></figure><h2 id="知识详解"><a href="#知识详解" class="headerlink" title="知识详解"></a>知识详解</h2><h3 id="instinct"><a href="#instinct" class="headerlink" title="instinct"></a>instinct</h3><p>英文解释：An inborn pattern of behavior that is characteristic of a species and is often a response to specific environmental stimuli，一种天生的行为模式，作为一个物种的群体特征，通常是对特定环境刺激的反应。</p><p>这里涉及一个常见的词根，sting/stinct/stimul=thorn/to prick，即“刺 / 刺激”的意思。in-stinct 就是“内在的刺激反应”，也就是“一种与生俱来的天性、天赋”，或者叫“本能、直觉”。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：Children do not know by instinct the difference between right and wrong.</span><br><span class="line">翻译：儿童并非生来就会分辨是非。</span><br><span class="line"></span><br><span class="line">例句：Even at school, he showed he had an instinct for business.</span><br><span class="line">翻译：他早在求学时期就表现出优秀的商业直觉（或经商天赋）。</span><br><span class="line"></span><br><span class="line">例句：Farmers are increasingly losing touch with their instinct for managing the land.</span><br><span class="line">翻译：农民正在逐渐失去经营土地的本领。</span><br></pre></td></tr></table></figure><h3 id="过去分词做前置定语"><a href="#过去分词做前置定语" class="headerlink" title="过去分词做前置定语"></a>过去分词做前置定语</h3><p>标题中的另一个词 repeated cycles，这是典型的过去分词做前置定语。需要注意的是，它有被动的含义，相当于 the cycles that are repeated。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：She says she’s got a broken heart. (=a heart that has been broken).</span><br><span class="line">翻译：她说她的心碎了。</span><br></pre></td></tr></table></figure><p>这里就是被动的含义，但是也有一些过去分词在做前置定语的时候，带有主动的含义，例如：</p><ul><li>a fallen leaf=a leaf that has fallen 一片落叶</li><li>a retired general =a general who has retired 一名退休的将军</li></ul><p>还有一些过去分词在做前置定语的时候，也带有主动的含义，但必须和副词一起使用才可以。例如下面这些：</p><ul><li>a much-travelled man = a man who travelled much 一个经常出远门的人（不可以说 a travelled man）</li><li>recently-arrived immigrants = immigrants who arrived recently 新来的移民（不可以说 arrived immigrants）</li></ul><p>下一段话中有一句 Bring well-backed product suggestions to the table。其中的 well-backed suggestions 也是同样的用法，表示工程师提的建议有充分的依据，但是直接说 backed suggestions 而不带副词 well，那就错啦。</p><p>还有些过去分词，前置定语和后置定语的意思会发生变化，例如：</p><ul><li>an adopted child=a child who is brought up by people who are not his/her biological parents 一个被收养的孩子</li><li>the solution adopted=the solution that is/was chosen 所采取的解决方案</li></ul><h3 id="bring-something-to-the-table"><a href="#bring-something-to-the-table" class="headerlink" title="bring (something) to the table"></a>bring (something) to the table</h3><blockquote><p>2.They bring suggestions and tradeoffs to the table, some of which are included in the revised spec.</p></blockquote><p>这个词组的字面含义是“把…放到桌上”，一般可以引申出“提供（意见、建议等）、贡献（技能、经验等）”的意思，to provide or offer a useful skill or attribute，表示一般提供或贡献的是能拿得出手、上得了台面、有价值的东西。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：He brings years of leadership experience to the table.</span><br><span class="line">翻译：他贡献了多年的领导经验。</span><br><span class="line"></span><br><span class="line">例句：Tell us what you bring to the table, not just what you want.</span><br><span class="line">翻译：告诉我们你能给公司带来什么，而不仅仅是你想要什么。</span><br></pre></td></tr></table></figure><h3 id="非限定性定语从句"><a href="#非限定性定语从句" class="headerlink" title="非限定性定语从句"></a>非限定性定语从句</h3><blockquote><p>They bring suggestions and tradeoffs to the table, <strong>some of which are included in the revised spec.</strong></p></blockquote><p><strong>所谓限定性，就是从句要对前面修饰的内容进行限制，缩小范围。</strong></p><p>例如，在“What is the name of the tall man who/that just came in? ”这句话中，说话的人问那个刚刚进来的高个男生叫什么名字？ “刚刚进来的”就是限定，不可以省略，否则就会变成问所有的高个男生叫什么名字了，影响前面整个句子意思的完整性。</p><p><strong>而非限定性定语从句，则是对前面的内容进行补充，增加信息。</strong></p><p>刚才文中的那句话，逗号后面的 some of which…补充说明工程师提出了建议，而且有的还会加到新版的设计规范文件里面去。逗号后面这部分信息可有可无，即使省略，也不影响前面主句意思的完整性。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">She married a man that she met on a bus.</span><br><span class="line">She married a very nice young engineer from Chicago, whom she met on a bus.</span><br></pre></td></tr></table></figure><p>从形式上看，限定性定语从句的先行词可以用 that 引导，主句与从句不需要用逗号隔开，引导词有时可以省略；而非限定性定语从句的先行词不可以用 that 引导，主句与从句需要用逗号隔开，引导词不可以省略。</p><p>我们看下面这两组句子。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一组：</span><br><span class="line">Have you got a book which/that is really easy to read? （可以用 that 引导，没有逗号）</span><br><span class="line">I lent him the Old Man and the Sea, which is really easy to read. （不可以用 that 代替 which，必须有逗号隔开）</span><br><span class="line"></span><br><span class="line">第二组：</span><br><span class="line">Did you like the wine we drank last night? （引导词可以省略）</span><br><span class="line">I poured him a glass of wine, which he drank at once. （引导词不可以省略）</span><br></pre></td></tr></table></figure><p>此外，限定性定语从句只能修饰先行词，遵循就近原则。非限定性定语从句既可以修饰先行词，也可以修饰整个句子或句子的一部分。你可以比较下面这两句话：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">We had some ice-cream which was very unusual.</span><br><span class="line">We had some ice-cream, which was very unusual.</span><br></pre></td></tr></table></figure><p>第一句话是限定性定语从句，只能修饰先行词 ice-cream ，说明这个冰激凌不一般、很难得。<br>第二句非限定性定语从句，既可以修饰先行词，也可以修饰整个句子。所以这里就有可能产生歧义，一种理解和第一句一样，还有一种理解就是从句修饰 We had some ice-cream 这件事，强调我们不太吃冰激凌，所以吃冰激凌这件事情很少见、非同寻常。但是既然专门用了非限定性定语从句，一般作者的意图就是第二种解释，来强调吃冰激凌这件事。</p><h3 id="live-up-to"><a href="#live-up-to" class="headerlink" title="live up to"></a>live up to</h3><blockquote><p>4.After shipping the feature, they actively follow up to understand if the feature <strong>lives up to</strong> the expectation.</p></blockquote><p>live up to 是一个很常用也很地道的动词短语，表示 to be as good as or have the qualities that someone predicted, expected, or hoped for，即“遵守（诺言）、符合（预期）、不辜负（期望）”等。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：We’d heard so many good things about the new restaurant, but the food didn’t live up to our expectations at all.</span><br><span class="line">翻译：我们听说很多关于这家新餐馆的赞誉，但餐食却远远没有达到我们的期望。</span><br><span class="line"></span><br><span class="line">例句：I’ve delivered the cash as you instructed. Now you must live up to your end of the bargain!</span><br><span class="line">翻译：我已经按照你说的把钱送来了。现在该你履行承诺了！</span><br></pre></td></tr></table></figure><h3 id="动词后缀-en"><a href="#动词后缀-en" class="headerlink" title="动词后缀 -en"></a>动词后缀 -en</h3><blockquote><p>After each project, their product understanding deepens, and they start to develop better and better product instincts.</p></blockquote><p>-en 是常用的动词后缀，形容词加上 -en 后缀，构成动词，表示“使得、变得”（make, become）。</p><p>例如，本句中 their product understanding deepens，deep 是形容词，表示“深、深刻”，加上 -en 后缀之后，变成动词 deepen，表示“变深、加深、使深刻”等含义，也就是工程师们对产品的理解加深了。</p><p>使用相同构词法构成的动词还有很多，例如 deaf（耳聋）加上 -en，就变成了 deafen（声音响得让人耳朵都要聋掉了）。这里列了一些类似的单词：</p><ul><li>broaden v 加宽（broad 宽）</li><li>darken 变黑（dark 黑）</li><li>dampen 使潮湿；使沮丧（damp 潮湿）</li><li>hasten 促进（haste 匆忙）</li><li>hearten 鼓励（heart 心）</li><li>sharpen 削尖（sharp 尖）</li><li>shorten 缩短（short 短）</li></ul><p>deafening silence，”震耳欲聋的安静“。这是英语里常用的矛盾修饰法（oxymoron）。</p><p>另外，-en 后缀还可以和名词一起组成形容词，例如名词 gold 加上 -en 变成 golden，成为形容词，表示“黄金的、金色的”。类似的词还有 wooden、woolen 等等。</p><p>除了 -en 之外，常用的动词后缀还有 -ate/-ify/-ise/-ize 等。</p><h3 id="relevant-irrelevant"><a href="#relevant-irrelevant" class="headerlink" title="relevant/irrelevant"></a>relevant/irrelevant</h3><blockquote><p>The next time, they’ll bring even more relevant suggestions to the table.</p></blockquote><p>这个词看似简单，只是表示“有意义的、密切相关的”（having significant and demonstrable bearing on the matter at hand），似乎没什么实质意义。类似，汉语里“有关部门”“相关问题”，听上去感觉含义很隐晦，所以很多中国同学经常会忽略这个词。但在英语中，relevant 这个词的含义一点都不隐晦哦，在很多场合，它的语气还很明确而强烈。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：These comments are not even relevant to this enquiry.</span><br><span class="line">翻译：这些意见简直文不对题，与这项调查没有关联。</span><br><span class="line"></span><br><span class="line">例句：I don’t see the relevance of your question. （名词形式）</span><br><span class="line">翻译：我不懂你提的这个问题有什么意义。（口气非常强烈甚至不礼貌）</span><br></pre></td></tr></table></figure><p>而反义词 irrelevant 的含义则更加直白，“不相关”的意思就是“无关紧要、有没有都一样”。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：Their old hard-won skills now become irrelevant.</span><br><span class="line">翻译：他们以往辛苦学会（来自不易）的技能现如今已经没什么用处了。</span><br></pre></td></tr></table></figure><h3 id="a-go-to-person"><a href="#a-go-to-person" class="headerlink" title="a go-to person"></a>a go-to person</h3><blockquote><p>Over time, they become a goto person for product managers, their advice being sought well before projects are kicked off.</p></blockquote><p>a go-to person 这个词比较口语化，意思是“一个组织里的多面手、大拿、牛人”。每个公司或多或少都有这样几个人，你遇到棘手的问题都会去咨询他或她，这些人就是 goto person。</p><h3 id="kick-off"><a href="#kick-off" class="headerlink" title="kick off"></a>kick off</h3><p>kick off 这个动词短语，最初的意思是指“足球比赛中的开球”，(of a football game, soccer game, etc.) be started or resumed after a score by a player kicking the ball from a designated spot。现在用得更多的是它的引申义，表示“（会议）开始、（项目）启动”。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例句：We’re going to kick off the new year with a huge party.</span><br><span class="line">翻译：我们将以一个盛大的晚会来开始新的一年。</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li><p>要善于“用一杯咖啡吸收宇宙能量”，其实都是一样的意思。因此，我们学英语绝非学习语言本身，在兴趣和好奇心的驱使下，广泛涉猎五花八门的百科知识，然后通过相同话题的外语“平行文本（parallel text）”的阅读或视听，来进行语言学习，是事半功倍的好方法。</p></li><li><p>培养好的态度和好的习惯。所谓好的态度，就是不要放过生活中碰到的任何一个疑问。<strong>心中苟有所开，即便札记。不则还塞之矣</strong>，意思就是说，你要是有了灵感，必须要马上记下来，不然很快就没了。</p></li><li><p>语言学习有方法但无捷径，语法如此，词根词缀也是如此。每天坚持听和读，有机会的时候加上一些说和写，不论多少，贵在坚持，细水长流，金石可断。</p></li><li><p>把学习外语想成你去一个陌生的地方旅行，别人的学习心得就是旅行攻略，而语法就是地图。无论你把地图研究得多么透彻，把街道名称倒背如流，都比不上真的踏上那片土地，亲自去挤一下当地的公交车，用脚丈量一下从酒店到山顶的几条步道，或者偶遇一家当地著名的苍蝇馆子，哪怕在街巷中迷失方向，都是非常好的体验。<strong>但请你一定不要急着想要把所有的语法规则记住背熟，现阶段跟我一起欣赏街景就好。</strong></p></li><li><p>在英语学习的过程中，我们除了要学习一个一个的单词以外，更加重要的是，要多学固定搭配和短语。就像我们学习汉语的时候，光识字是不够的，认识了单个的汉字之后，我们其实更多的在学习词语、词组或者成语。</p></li><li><p>学习语言的唯一目的就是交流，只要这个目的达到了，不管白猫黑猫，都是好猫。如果反过来，关起门来对自己很宽松，到人前又瞻前顾后、不敢开口，就很难学好外语。</p></li><li><p><strong>Stay hungry, stay foolish.”</strong>意在告诉人们，在自己精进的时候，要如饥似渴，始终保持“入口”的开放，做个吃货；但一旦付诸行动去实现自己认准的人生理想时，要如同赤子一般天真大胆，不怕别人耻笑，敢于在别人误解的目光里孤独前行，做个“傻缺”。</p></li><li><p>People don’t want to buy a quarter-inch drill. They want a quarter-inch hole（顾客不是想买一个 1/4 英寸的电钻，他们想要的是 1/4 英寸的洞！）。这句话想说的就是，顾客对产品本身不感兴趣，他们感兴趣的是产品能给他们带来什么好处。</p></li><li><p><strong>语法永远是为意思服务的。</strong>数据本身是没有价值的，就如同语言文字千变万化，浩如烟海，慢慢地获得将数据转化为洞察力的本事，才能先行一步。正如《指环王》的作者托尔金在《汉姆的农夫吉尔斯》（Farmer Giles of Ham）里提到先知的牧师时说：He was a grammarian and could doubtless see further into the future than others.（他是一个语法学家，无疑他比其他人更能预见未来。）</p></li><li><p>平时自己在阅读的时候可以慢慢养成的一些习惯——首先，阅读过程中碰到不认识的词，在不影响大意理解的前提下，我们要勇敢地无视生词，直接碾压过去。千万不要每一个词都去查，否则除了效率降低以外，阅读的乐趣也会大打折扣；其次，如果发现这个词绕不过去，影响核心内容的理解，那就一定要查了。但是也不要只查一个中文的意思就结束了，顺便做三件事情：第一，查阅英英字典，了解一下英文的解释；第二，比较全面地了解一下这个词的几个不同意思，想一想这几个意思之间的关联性；第三，多读几个例句，了解这个词活生生的用法；最后，要善于去发现一些你似乎认得，但并不真正了解的“小词”。</p></li><li><p>在英语学习的过程，我们固然希望保持精益求精的态度，少犯低级的语法错误，但也不能因噎废食，因为害怕出错就畏惧开口。</p></li><li><p><strong>词汇学习一定不能脱离上下文，背单词不如背例句，背例句不如自己模仿写例句。</strong>凡学英语，必学整句，不觉中将其句法音调整个吸入。每日选二三句，回环熟诵，此数句读音必正，出口必熟。如此半年，操英语能力必大进。</p></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>English-Study</category>
      </categories>
      <tags>
        <tag>产品</tag>
        <tag>程序员</tag>
        <tag>阅读</tag>
        <tag>语法</tag>
        <tag>词汇</tag>
      </tags>
  </entry>
  <entry>
    <title>编程入门项目一点五：升级自己的测试框架</title>
    <url>/2020/06/13/geekbang-column-upgrade-your-own-testing-framework/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="完善测试框架的功能与提示"><a href="#完善测试框架的功能与提示" class="headerlink" title="完善测试框架的功能与提示"></a>完善测试框架的功能与提示</h2><h3 id="温故知新，gtest-的输出结果"><a href="#温故知新，gtest-的输出结果" class="headerlink" title="温故知新，gtest 的输出结果"></a>温故知新，gtest 的输出结果</h3><p>第一部分，一套单元测试的相关信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[==========] Running 2 tests from 1 test suite.</span><br><span class="line">[----------] Global test environment set-up.</span><br><span class="line">[----------] 2 tests from test_is_prime</span><br></pre></td></tr></table></figure><p>第二部分，是每个单元测试运行信息的输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ RUN      ] test_is_prime.test1</span><br><span class="line">[       OK ] test_is_prime.test1 (1 ms)</span><br><span class="line">[ RUN      ] test_is_prime.test2</span><br><span class="line">gtest_test.cpp:25: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  is_prime(4)</span><br><span class="line">    Which is: 1</span><br><span class="line">  0</span><br><span class="line">gtest_test.cpp:26: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  is_prime(0)</span><br><span class="line">    Which is: 1</span><br><span class="line">  0</span><br><span class="line">gtest_test.cpp:27: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  is_prime(1)</span><br><span class="line">    Which is: 1</span><br><span class="line">  0</span><br><span class="line">[  FAILED  ] test_is_prime.test2 (0 ms)</span><br></pre></td></tr></table></figure><p>如上所示，第一个单元测试 test_is_prime.test1 运行结果正确，所用时间是 1ms；第二个单元测试 test_is_prime.test2 中，有三个判等 EXPECT 断言的结果是错误的，也就是 is_prime 函数的返回值，和测试用例中期望的返回值不符，这说明 is_prime 函数存在 Bug。</p><p>第三部分，就是这套单元测试的总结信息，以及整个程序单元测试结果的汇总信息。这段信息，有兴趣的小伙伴可以自己理解着看一下，由于不是咱们今天课程的重点，就不展开介绍了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[----------] 2 tests from test_is_prime (1 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global test environment tear-down</span><br><span class="line">[==========] 2 tests from 1 test suite ran. (1 ms total)</span><br><span class="line">[  PASSED  ] 1 test.</span><br><span class="line">[  FAILED  ] 1 test, listed below:</span><br><span class="line">[  FAILED  ] test_is_prime.test2</span><br><span class="line"></span><br><span class="line"> 1 FAILED</span><br></pre></td></tr></table></figure><h3 id="从哪些方面来完善测试框架？"><a href="#从哪些方面来完善测试框架？" class="headerlink" title="从哪些方面来完善测试框架？"></a>从哪些方面来完善测试框架？</h3><p>通过观察第二部分的输出，我们基本要从三个方面完善测试框架的输出信息。</p><ul><li>在每个测试用例运行之前，要先行输出相关测试用例的名字；</li><li>每个测试用例运行结束以后，要输出测试用例的运行时间与运行结果（OK 或者 FAILED）；</li><li>若测试用例中的 EXPECT 断言出错，需要输出错误提示信息。</li></ul><h3 id="测试用例的名字输出"><a href="#测试用例的名字输出" class="headerlink" title="测试用例的名字输出"></a>测试用例的名字输出</h3><p>首先是如何输出测试用例的名字。我们先回忆一下上节课设计的注册函数，如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST(test_name, func_name) \</span></span><br><span class="line"><span class="keyword">void</span> test_name##_##func_name(); \</span><br><span class="line">__attribute__((constructor)) \</span><br><span class="line"><span class="keyword">void</span> register_##test_name##_##func_name() &#123; \</span><br><span class="line">    test_function_arr[test_function_cnt] = test_name##_##func_name; \</span><br><span class="line">    test_function_cnt++; \</span><br><span class="line">&#125; \</span><br><span class="line"><span class="keyword">void</span> test_name##_##func_name()</span><br></pre></td></tr></table></figure><p>注册函数是随着 TEST 展开的，从展开的代码逻辑中可以看到，它只是将测试用例的函数地址记录在了函数指针数组中。要想 RUN_ALL_TESTS 函数后续能够输出测试用例的函数名称的话，我们只需要修改注册函数的功能逻辑即可，也就是让注册函数在记录函数信息的时候，增加记录对应测试用例的名称。</p><p>而这个名称信息，应该记录在哪里呢？有两种代码实现方式：</p><ul><li>1，另外开辟一个记录测试用例名称的字符串数组；</li><li>2，修改 test_function_arr 数组中的元素类型，将新增的测试用例名称以及函数地址信息打包成一个数据元素。</li></ul><p>显然，相较于第一种实现方式，第二种代码实现方式会使程序具有更好的封装特性。</p><p>面就是我们将函数指针信息和测试用例名称信息，封装成的一个新的结构体类型：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_function_info_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">test_function_t</span> func;  <span class="comment">// 测试用例函数指针，指向测试用例函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 指向测试用例名称</span></span><br><span class="line">&#125; test_function_arr[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> test_function_cnt = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>如代码所示，我们定义了一种新的数据类型，叫做 test_function_info_t。这种结构体类型包含了指向测试用例的函数指针 func 字段， 与指向测试用例名称的字符串指针 name 字段，并且我们将这种结构体类型，作为 test_function_arr 数组新的元素类型。</p><p>既然测试用例信息的存储区 test_function_arr 的数据类型发生了改变，那么负责存储信息的注册函数，与使用信息的 RUN_ALL_TESTS 函数的相关逻辑都需要作出改变。</p><p>首先，我们来看注册函数的改变。想要修改注册函数的逻辑，就是修改 TEST 宏，从功能上来说，注册函数中需要额外记录一个测试用例名称信息，示例代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST(test_name, func_name) \</span></span><br><span class="line"><span class="keyword">void</span> test_name##_##func_name(); \</span><br><span class="line">__attribute__((constructor)) \</span><br><span class="line"><span class="keyword">void</span> register_##test_name##_##func_name() &#123; \</span><br><span class="line">    test_function_arr[test_function_cnt].func = test_name##_##func_name; \</span><br><span class="line">    test_function_arr[test_function_cnt].name = #func_name <span class="string">"."</span> #test_name; \</span><br><span class="line">    test_function_cnt++; \</span><br><span class="line">&#125; \</span><br><span class="line"><span class="keyword">void</span> test_name##_##func_name()</span><br></pre></td></tr></table></figure><p>代码中主要是增加了第 6 行的逻辑，这一行的代码将 TEST 宏参数的两部分，拼成一个字符串，中间用点 (.) 连接，例如 TEST(test1, test_is_prime) 宏调用中，拼凑的字符串就是 test_is_prime.test1，和 gtest 中的输出的测试用例名称信息格式是一致的。</p><p>改完了注册函数的逻辑以后，最后调整一下 RUN_ALL_TESTS 中使用 test_function_arr 数组的逻辑代码即可：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RUN_ALL_TESTS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test_function_cnt; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[ RUN      ] %s\n"</span>, test_function_arr[i].name);  <span class="comment">//仿照 gtest 的输出格式进行调整的，在输出测试用例名称之前，先输出一段包含 RUN 英文的标志信息。</span></span><br><span class="line">        test_function_arr[i].func();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"RUN TEST DONE\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们就完成了输出测试用例名字的框架功能改造。</p><h3 id="输出测试用例的运行结果信息"><a href="#输出测试用例的运行结果信息" class="headerlink" title="输出测试用例的运行结果信息"></a>输出测试用例的运行结果信息</h3><p>以下是我们示例代码中的 2 个测试用例，在 gtest 框架下的运行结果信息输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[     OK ] test_is_prime.test1 (1 ms)</span><br><span class="line">[ FAILED ] test_is_prime.test2 (0 ms)</span><br></pre></td></tr></table></figure><p>根据输出的信息，我们可知 gtest 会统计每个测试用例运行的时间，并以毫秒为计量单位，输出此时间信息。不仅如此，gtest 还会输出与测试用例是否正确相关的信息，如果测试用例运行正确，就会输出一行包含 OK 的标志信息，否则就输出一行包含 FAILED 的标志信息。</p><p>根据我们自己测试框架的设计，这行信息只有可能是在 RUN_ALL_TESTS 函数的 for 循环中，执行完每一个测试用例函数以后输出的信息。</p><p>由此，我们面临的是两个需要解决的问题：</p><ul><li><p>1，如何统计函数过程的运行时间？<br>函数 clock() 。它的返回值代表了：从运行程序开始，到调用 clock() 函数时，经过的 CPU 时钟计时单元。并且，这个 clock() 函数的返回值，实际上反映的是我们程序的运行时间。那这个 CPU 时钟计时单元究竟是什么呢？你可以把 1 个 CPU 时钟计时单元，简单的理解成是一个单位时间长度，只不过这个单位时间长度，不是我们常说的 1 秒钟。<br>宏 CLOCKS_PER_SEC 。它实际上是一个整型值，代表多少个 CPU 时钟计时单元是 1 秒。</p></li><li><p>2，如何确定获得每一个测试用例函数的测试结果是否正确？<br>记录一个全局变量，代表测试用例结果正确与否。当测试用例中的 EXPECT_EQ 断言发生错误时，就修改这个全局变量的值，这样我们的 RUN_ALL_TESTS 函数，就可以在测试用例函数执行结束以后，得知执行过程是否有错。</p></li></ul><p>综合以上所有信息，我们可以重新设计 RUN_ALL_TESTS 函数如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> test_run_flag;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPECT_EQ(a, b) test_run_flag &amp;= ((a) == (b))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RUN_ALL_TESTS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test_function_cnt; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[ RUN      ] %s\n"</span>, test_function_arr[i].name);</span><br><span class="line">        test_run_flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> t1 = clock();</span><br><span class="line">        test_function_arr[i].func();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> t2 = clock();</span><br><span class="line">        <span class="keyword">if</span> (test_run_flag) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[       OK ] "</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[  FAILED  ] "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, test_function_arr[i].name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" (%.0lf ms)\n\n"</span>, <span class="number">1.0</span> * (t2 - t1) / CLOCKS_PER_SEC * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的第 8 行是在测试用例运行之前，记录一个开始时间值 t1；代码中的第 10 行是在测试用例函数执行完后，记录一个结束时间值 t2；在代码的第 17 行，根据 t1 、t2 以及 CLOCKS_PER_SEC 的值，计算得到测试用例函数实际运行的时间，并输出得到的结果。</p><p>这段代码中增加了一个全局变量“test_run_flag”，这个变量每次在测试用例执行之前，都会被初始化为 1，当测试用例结束执行以后，RUN_ALL_TESTS 函数中，根据 test_run_flag 变量的值，选择输出 OK 或者 FAILED 的标志信息。同时，我们可以看到，test_run_flag 变量的值只有在 EXPECT_EQ 断言中，才可能被修改。</p><h3 id="EXPECT-EQ-断言的实现"><a href="#EXPECT-EQ-断言的实现" class="headerlink" title="EXPECT_EQ 断言的实现"></a>EXPECT_EQ 断言的实现</h3><p>首先，EXPECT_EQ(a, b) 在 a，b 两部分值相等的时候，不会产生额外的输出信息，而当 a，b 两部分不相等的时候，就会输出相应的提示信息。如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gtest_test.cpp:25: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  is_prime(4)</span><br><span class="line">    Which is: 1</span><br><span class="line">  0</span><br></pre></td></tr></table></figure><p>这段输出信息，对应的是源代码中的 “EXPECT_EQ(is_prime(4), 0); ”的输出。如你所见，第 1 行的输出内容包含了源文件名（gtest_test.cpp），EXPECT_EQ 宏所在的代码位置（25），以及一个提示结果（Failure）。</p><p>对于函数调用部分，EXPECE_EQ 会输出这个函数的调用形式及返回值信息，也就是输出中的 “is_prime(4)”“Which is: 1” 这段内容。而对于数值信息，只会输出数值信息本身，也就是输出信息中第 5 行的那个 0。</p><p>实际上，要想在宏中实现类似于这种根据传入参数类型，选择输出形式的功能，对于现在的你来说可能有点困难。所以，我们可以重新设计一种输出形式，只要能够清晰地展示错误信息就可以。<br>重新设计的输出提示，如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gtest_test.cpp:25: Failure</span><br><span class="line">Expected (is_prime(4) == 0):</span><br><span class="line">    Which is: (1 == 0)</span><br></pre></td></tr></table></figure><p>修改完以后的输出信息，你可以看到，第 2 行就是传入 EXPECT_EQ 宏两部分的比较，第 3 行是这两部分实际输出值的比较。<br>重新设计了输出信息以后，就可以来看看 EXPECT_EQ 宏的实现了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPECT(a, b, comp) &#123; \</span></span><br><span class="line">    __typeof(a) val_a = (a), val_b = (b); \</span><br><span class="line">    <span class="keyword">if</span> (!(val_a comp val_b)) &#123; \</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s:%d: Failure\n"</span>, __FILE__, __LINE__); \</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Expected (%s %s %s):\n"</span>, #a, #comp, #b); \</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"    Which is: (%d %s %d)\n"</span>, val_a, #comp, val_b); \</span><br><span class="line">        test_run_flag = <span class="number">0</span>; \</span><br><span class="line">    &#125; \</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPECT_EQ(a, b) EXPECT(a, b, ==)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPECT_LT(a, b) EXPECT(a, b, &lt;)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPECT_GT(a, b) EXPECT(a, b, &gt;)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPECT_NE(a, b) EXPECT(a, b, !=)</span></span><br></pre></td></tr></table></figure><p>在这段实现中，你会发现，我们不仅实现了 EXPECT_EQ，还额外实现了 EXPECT_LT、EXPECT_GT、EXPECT_NE 等用于比较的宏。其中，LT 是英文 little 的缩写，是判断小于关系的；GT 是 great 的缩写，是判断大于关系的；NE 是 not equal 的缩写，是判断不等于关系的。而这些所有的宏，都是基于 EXPECT 宏实现的。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>工程开发中的一个基本原则：功能迭代，数据先行。也就是说，无论我们做什么样的功能开发，首先要考虑的是与数据相关的部分。</p><h2 id="链表知识在测试框架中的应用"><a href="#链表知识在测试框架中的应用" class="headerlink" title="链表知识在测试框架中的应用"></a>链表知识在测试框架中的应用</h2><h3 id="用链表存储测试用例"><a href="#用链表存储测试用例" class="headerlink" title="用链表存储测试用例"></a>用链表存储测试用例</h3><p>重新审视下面这段函数指针数组 test_function_arr 的代码设计，来思考一下这个测试框架中还有没有可以优化的地方。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_function_info_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">test_function_t</span> func;  <span class="comment">// 测试用例函数指针，指向测试用例函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 指向测试用例名称</span></span><br><span class="line">&#125; test_function_arr[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> test_function_cnt = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这段代码中，我们使用了数组来定义存储测试函数信息的存储区，这个数组的大小有 100 位，也就是说，最多可以存储 100 个测试用例函数信息。</p><h3 id="要是有程序中定义了-1000-个测试用例，怎么办呢？"><a href="#要是有程序中定义了-1000-个测试用例，怎么办呢？" class="headerlink" title="要是有程序中定义了 1000 个测试用例，怎么办呢？"></a>要是有程序中定义了 1000 个测试用例，怎么办呢？</h3><p>第一步，我们需要改变 test_function_info_t 的结构定义，也就是把原先存储测试用例函数信息的结构体类型，改装成链表结构。最简单的方法，就是在结构体的定义中，增加一个指针字段，指向下一个 test_function_info_t 类型的数据，代码如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_function_info_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">test_function_t</span> func;  <span class="comment">// 测试用例函数指针，指向测试用例函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 指向测试用例名称</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_function_info_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test_function_info_t</span> <span class="title">head</span>, *<span class="title">tail</span> = &amp;<span class="title">head</span>;</span></span><br></pre></td></tr></table></figure><p>可以看到，我们给 test_function_info_t 结构体类型增加了一个链表中的 next 字段，除此之外，我们还定义了一个虚拟头节点 head 和一个指针变量 tail。这里你需要注意，head 是虚拟头节点，后续我们会向 head 所指向链表中插入链表节点，tail 指针则指向了整个链表的最后一个节点的地址。</p><p>第二步，在准备好了数据存储结构以后，需要改写的就是函数注册的逻辑了。在改写 TEST 宏中的注册函数逻辑之前呢，我们先准备一个工具函数 add_test_function，这个工具函数的作用，就是根据传入的参数，新建一个链表节点，并且插入到整个链表的末尾：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_test_function</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">test_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_function_info_t</span> *<span class="title">node</span>;</span></span><br><span class="line">    node = (struct <span class="keyword">test_function_info_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct <span class="keyword">test_function_info_t</span>));</span><br><span class="line">    node-&gt;func = func;</span><br><span class="line">    node-&gt;name = name;</span><br><span class="line">    node-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    tail-&gt;next = node;</span><br><span class="line">    tail = node;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改写 TEST 宏中注册函数的逻辑：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST(test_name, func_name) \</span></span><br><span class="line"><span class="keyword">void</span> test_name##_##func_name(); \</span><br><span class="line">__attribute__((constructor)) \</span><br><span class="line"><span class="keyword">void</span> register_##test_name##_##func_name() &#123; \</span><br><span class="line">    add_test_function(#func_name <span class="string">"."</span> #test_name, \</span><br><span class="line">                      test_name##_##func_name); \</span><br><span class="line">&#125; \</span><br><span class="line"><span class="keyword">void</span> test_name##_##func_name()</span><br></pre></td></tr></table></figure><p>最后一步，处理完了数据写入的过程以后，来让我们修改一下使用这份数据的代码逻辑，那就是 RUN_ALL_TESTS 函数中的相关逻辑。之前，RUN_ALL_TESTS 函数中，循环遍历数组中的每一个测试用例，并且执行相关的测试用例函数，对这一部分，修改成针对于链表结构的遍历方式即可，代码如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RUN_ALL_TESTS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">test_function_info_t</span> *<span class="title">p</span> = <span class="title">head</span>.<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (; p; p = p-&gt;next) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[ RUN      ] %s\n"</span>, p-&gt;name);</span><br><span class="line">        test_run_flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> t1 = clock();</span><br><span class="line">        p-&gt;func();</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> t2 = clock();</span><br><span class="line">        <span class="keyword">if</span> (test_run_flag) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[       OK ] "</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[  FAILED  ] "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, p-&gt;name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" (%.0lf ms)\n\n"</span>, <span class="number">1.0</span> * (t2 - t1) / CLOCKS_PER_SEC * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就彻底完成了测试用例函数信息存储部分的“链表”改造过程。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>框架</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>编程入门项目一：实现一个自己的测试框架</title>
    <url>/2020/06/13/geekbang-column-implement-your-own-testing-framework/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="实现测试框架前的准备"><a href="#实现测试框架前的准备" class="headerlink" title="实现测试框架前的准备"></a>实现测试框架前的准备</h2><h3 id="初识：Google-测试框架"><a href="#初识：Google-测试框架" class="headerlink" title="初识：Google 测试框架"></a>初识：Google 测试框架</h3><p>Google 开发的单元测试框架 Google Test，我们一般称它为 gtest。</p><p>测试代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个数字 x 是否是素数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt; x; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个测试用例</span></span><br><span class="line">TEST(test1, test_is_prime) &#123;</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">3</span>), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">5</span>), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">7</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个测试用例</span></span><br><span class="line">TEST(test2, test_is_prime) &#123;</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">4</span>), <span class="number">0</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RUN_ALL_TESTS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[==========] Running 2 tests from 1 test suite.</span><br><span class="line">[----------] Global test environment set-up.</span><br><span class="line">[----------] 2 tests from test_is_prime</span><br><span class="line">[ RUN      ] test_is_prime.test1</span><br><span class="line">[       OK ] test_is_prime.test1 (1 ms)</span><br><span class="line">[ RUN      ] test_is_prime.test2</span><br><span class="line">gtest_test.cpp:25: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  is_prime(4)</span><br><span class="line">    Which is: 1</span><br><span class="line">  0</span><br><span class="line">gtest_test.cpp:26: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  is_prime(0)</span><br><span class="line">    Which is: 1</span><br><span class="line">  0</span><br><span class="line">gtest_test.cpp:27: Failure</span><br><span class="line">Expected equality of these values:</span><br><span class="line">  is_prime(1)</span><br><span class="line">    Which is: 1</span><br><span class="line">  0</span><br><span class="line">[  FAILED  ] test_is_prime.test2 (0 ms)</span><br><span class="line">[----------] 2 tests from test_is_prime (1 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global test environment tear-down</span><br><span class="line">[==========] 2 tests from 1 test suite ran. (1 ms total)</span><br><span class="line">[  PASSED  ] 1 test.</span><br><span class="line">[  FAILED  ] 1 test, listed below:</span><br><span class="line">[  FAILED  ] test_is_prime.test2</span><br><span class="line"></span><br><span class="line"> 1 FAILED TEST</span><br></pre></td></tr></table></figure><p>先看输出内容的第 4 行和第 6 行，意思是说，执行测试用例 test_is_prime.test1 和 test_is_prime.test2，这不就是上面两个以 TEST 开头的两段代码相关的输出内容么？</p><p>接下来从第 7 行到第 21 行是一段报错信息，意思就是说 is_prime(4)，is_prime(0) 与 is_prime(1) 函数返回值错误，也就意味着 is_prime 函数实现有错误，这段错误所涉及的信息，在源代码中的第二个测试用例中有涉及。</p><h3 id="对于-gtest-的三个思考"><a href="#对于-gtest-的三个思考" class="headerlink" title="对于 gtest 的三个思考"></a>对于 gtest 的三个思考</h3><p>面对刚才的演示代码和输出内容，你可能会产生如下三个问题：</p><ul><li>1，代码中的 EXPECT_EQ 是做什么的？</li><li>2，以 TEST 开头的代码段，和我们学习的函数很不一样，那它究竟是什么？</li><li>3，主函数中只调用了 RUN_ALL_TESTS 函数，为什么好像是执行了程序中所有的 TEST 代码段？这个功能是怎么实现的？</li></ul><p>第一个问题不难，查看相关 gtest 的文档资料，你就可以知道，EXPECT_EQ 是 gtest 里面自带的宏，主要作用是判断传入的两部分的值是否相等。如果不相等，就会产生类似于输出内容中第 7 行到第 21 行的输出内容。</p><p>第二个问题，以 TEST 开头的这段代码，明显不符合我们对 C 语言的语法认知，我们确实没有见过不用规定返回值类型，也不用规定参数类型的函数定义方式。关于 TEST 究竟是个什么的问题，更加合理的猜测，就是 TEST 实际上是一个宏。</p><p><strong>宏的作用，是做简单的替换。</strong>正是因为 TEST(test_is_prime, test1) 这段代码实际上是一个宏，所以展开以后，和后面的大括号中的内容一起组成了一段合法的代码内容。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>测试行为，不是测试工程师的专属，你应该把它作为一个开发工程师的习惯。</li><li>单元测试属于白盒测试范畴，Google 的 gtest 就是一种辅助我们编写单元测试的框架。</li><li>gtest 中的 TEST 本质上是一个宏，而这个宏应该展开成怎样的代码内容，还需要你认真思考，这个思考过程对你来说是很有价值的。</li></ul><h2 id="实现一个自己的测试框架"><a href="#实现一个自己的测试框架" class="headerlink" title="实现一个自己的测试框架"></a>实现一个自己的测试框架</h2><h3 id="初步实现-TEST-宏"><a href="#初步实现-TEST-宏" class="headerlink" title="初步实现 TEST 宏"></a>初步实现 TEST 宏</h3><p>我们实现的所有代码，都会写在一个名字为 <code>geek_test.h</code>的头文件中。(注意：将声明和定义写在一起，在大型工程中是会出现严重的编译错误，在实际的工程开发中，我们并不会这么做。)</p><p>我们的目的，是在不改变这份源代码的前提下，通过在 geek_test.h 中添加一些源码，使得这份代码的运行效果，能够类似于 gtest 的运行效果。</p><p>想要完成这个目标，我们就要先来思考 TEST 宏这里的内容，请你仔细观察这段由 TEST 宏定义的测试用例的相关代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TEST(test1, test_is_prime) &#123;</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">3</span>), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">5</span>), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">7</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TEST(test1, test_is_prime) 这部分应该是在调用 TEST 宏，而这部分被预处理器展开以后的内容，只有和后面大括号里的代码组合在一起，才是一段合法的 C 语言代码，也只有这样，这份代码才能通过编译。既然如此，我们就不难想到，TEST 宏展开以后，它应该是一个函数定义的头部，后面大括号里的代码，就是这个展开以后的函数头部的函数体部分，这样一切就都说得通了。</p><p>在实现 TEST 宏之前，我们还需要想清楚一个问题：由于程序中可以定义多个 TEST 测试用例，如果每一个 TEST 宏展开都是一个函数头部的话，那这个展开的函数的名字是什么呢？如果每一个 TEST 宏展开的函数名字都一样，那程序一定无法通过编译，编译器会报与函数名重复相关的错误，所以， TEST 宏是如何确定展开函数的名字呢？</p><p>注意，TEST 宏需要传入两个参数，这两个参数在输出信息中与测试用例的名字有关。那我们就该想到，可以使用这两个参数拼接出一个函数名，只要 TEST 传入的这两个参数不一样，那扩展出来的函数名就不同。最后，我们就可以初步得到如下的 TEST 宏的一个实现：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST(test_name, func_name) \</span></span><br><span class="line"><span class="keyword">void</span> test_name##_##func_name()</span><br></pre></td></tr></table></figure><p>如代码所示的 TEST 宏实现，我们将 TEST 宏的两个参数内容使用 ## 连接在一起，中间用一个额外的下划线连接，组成一个函数名字，这个函数的返回值类型是 void，无传入参数。根据这个实现，预处理器会将源代码中两处 TEST 宏的内容，替换成如下代码所示内容：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1_test_is_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">3</span>), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">5</span>), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">7</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2_test_is_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">4</span>), <span class="number">0</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="attribute：让其它函数先于主函数执行"><a href="#attribute：让其它函数先于主函数执行" class="headerlink" title="attribute：让其它函数先于主函数执行"></a><strong>attribute</strong>：让其它函数先于主函数执行</h3><p>先，我们先来看如下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello geek!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello main!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行以后，会输出一行字符串 “hello main!”。</p><p>接下来呢，我们对上述代码稍微修改，在 pre_output 函数前面加上<strong>attribute</strong>((constructor)) 。这样，pre_output 函数就会先于主函数执行，代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello geek!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello main!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码执行以后，程序会输出两行内容，第 1 行是 pre_output 函数输出的内容 “hello geek!”，第 2 行才是主函数的执行输出内容 “hello main!”。</p><p>从输出内容可以看出，<strong>加了<strong>attribute</strong>((constructor)) 以后，pre_output 函数会先于 main 主函数执行。</strong></p><h3 id="RUN-ALL-TESTS-函数设计"><a href="#RUN-ALL-TESTS-函数设计" class="headerlink" title="RUN_ALL_TESTS 函数设计"></a>RUN_ALL_TESTS 函数设计</h3><p>从主函数中调用 RUN_ALL_TESTS 函数的方式来看，RUN_ALL_TESTS 函数应该是一个返回值为整型的函数。这样，我们可以得到这样的函数声明形式：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RUN_ALL_TESTS</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>从测试框架的执行输出结果中看，RUN_ALL_TESTS 函数可以依次性地执行每一个 TEST 宏扩展出来的测试用例函数，这是怎么做到的呢？</p><p>我们可以这样认为：在主函数执行 RUN_ALL_TESTS 函数之前，有一些函数过程，就已经把测试用例函数的相关信息，记录在了一个 RUN_ALL_TESTS 函数可以访问到的地方，等到 RUN_ALL_TESTS 函数执行的时候，就可以根据这些记录的信息，依次性地执行这些测试用例函数。整个过程，如下图所示：</p><p><img src="/2020/06/13/geekbang-column-implement-your-own-testing-framework/run-all-test.jpg" alt></p><p>图中红色部分，就是我们推测的，某些完成测试用例函数信息注册的函数，它们先于主函数执行，将测试用例的信息，写入到一个公共存储区中。</p><p>接下来，我们需要考虑的就是这些注册函数，究竟将什么信息存储到了公共存储区中，才能使得 RUN_ALL_TESTS 函数可以调用到这些测试用例？你自己也可以想想是什么。答案就是这个信息是测试用例函数的函数地址，因为只有把函数地址存储到这个存储区中，才能保证 RUN_ALL_TESTS 函数可以调用它们。所以，这片公共存储区，就应该是一个函数指针数组。</p><p>那如何解决注册函数问题呢？最简单直接的设计方法，就是每多一个由 TEST 宏定义的测试用例，就配套一个注册函数，所以这个注册函数的逻辑，可以设计在 TEST 宏展开的内容中。这就需要我们对 TEST 宏进行重新设计。</p><p>我们先来完成 RUN_ALL_TESTS 函数从存储区中，读取并执行测试用例的过程：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">test_function_t</span>)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">test_function_t</span> test_function_arr[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> test_function_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RUN_ALL_TESTS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test_function_cnt; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"RUN TEST : %d\n"</span>, i + <span class="number">1</span>);</span><br><span class="line">        test_function_arr[i]();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"RUN TEST DONE\n\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中用到了函数指针相关的技巧，其中 test_function_t 是我们定义的函数指针类型，这种函数指针类型的变量，可以用来指向返回值是 void，传入参数为空的函数。</p><p>之后，定义了一个有 100 位的函数指针数组 test_function_arr，数组中的每个位置，都可以存储一个函数地址，数组中元素数量，记录在整型变量 test_function_cnt 中。这样，RUN_ALL_TESTS 函数中的逻辑就很简单了，就是依次遍历函数指针数组中的每个函数，然后依次执行这些函数，这些函数每一个都是一个测试用例。</p><h3 id="重新设计：TEST-宏"><a href="#重新设计：TEST-宏" class="headerlink" title="重新设计：TEST 宏"></a>重新设计：TEST 宏</h3><p>根据前面的分析，TEST 扩展出来的内容，不仅要有测试用例的函数头部，还需要有先于主函数执行的注册函数，主要用于注册 TEST 扩展出来的测试用例函数。由此，我们可以得出如下示例代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST(test_name, func_name) \</span></span><br><span class="line"><span class="keyword">void</span> test_name##_##func_name(); \</span><br><span class="line">__attribute__((constructor)) \</span><br><span class="line"><span class="keyword">void</span> register_##test_name##_##func_name() &#123; \</span><br><span class="line">    test_function_arr[test_function_cnt] = test_name##_##func_name; \</span><br><span class="line">    test_function_cnt++; \</span><br><span class="line">&#125; \</span><br><span class="line"><span class="keyword">void</span> test_name##_##func_name()</span><br></pre></td></tr></table></figure><p>这个新设计的 TEST 宏，除了末尾保留了原 TEST 宏内容以外，在扩展的测试用例函数头部添加了一段扩展内容，这段新添加的扩展内容，会扩展出来一个函数声明，以及一个以 register 开头的会在主函数执行之前执行的注册函数；注册函数内部的逻辑很简单，就是将测试函数的函数地址，存储在函数指针数组 test_function_arr 中，这部分区域中的数据，后续会被 RUN_ALL_TESTS 函数使用。</p><p>如果以如上 TEST 宏作为实现，原程序中的两个测试用例代码，会被展开成如下样子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1_test_is_prime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_test1_test_is_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test_function_arr[test_function_cnt] = test1_test_is_prime; </span><br><span class="line">    test_function_cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1_test_is_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">3</span>), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">5</span>), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">7</span>), <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2_test_is_prime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">__attribute__((constructor))</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">register_test2_test_is_prime</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    test_function_arr[test_function_cnt] = test2_test_is_prime; </span><br><span class="line">    test_function_cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2_test_is_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">4</span>), <span class="number">0</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">    EXPECT_EQ(is_prime(<span class="number">1</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们就算是初步完成了测试框架中关键的两个部分的设计：一个是 TEST 宏，另外一个就是 RUN_ALL_TESTS 函数。它们同时也是串起测试框架流程最重要的两部分。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li><strong>attribute</strong>((constructor)) 可以修饰函数，使修饰的函数先于主函数执行。</li><li>RUN_ALL_TESTS 之所以可以获得程序中所有测试用例的函数信息，是因为有一批注册函数，将测试用例函数记录下来了。</li><li>通过测试框架这个项目，我们再一次看到，宏可以将原本看似不合理的代码，变得合理。</li></ul><p><a href="https://github.com/geektime-practice/mygtest" target="_blank" rel="noopener">项目地址</a></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>框架</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>编程入门项目二：实现一个自己的计算器程序</title>
    <url>/2020/06/13/geekbang-column-implement-your-own-calculator-program/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="计算器程序的功能设计"><a href="#计算器程序的功能设计" class="headerlink" title="计算器程序的功能设计"></a>计算器程序的功能设计</h2><p>一般计算器功能如下：</p><ul><li>第一次出现的变量赋值语句，即为变量定义；</li><li>计算表达式的值。</li></ul><p>这两个功能，看似简单，可实际要考虑的还很多，例如：变量是否有作用域的限制啊，合法变量名的规则，表达式中支持的运算符种类啊，每一种运算符的优先级，等等。这些需要考虑的细节，每一个都会给我们的项目增加一点点难度。</p><p>为了把难度控制在一个可以实现的范围，我们对计算器功能做进一步的细致描述，同时也是降低项目实现难度，重新修订的功能定义如下：</p><ul><li>第一次出现的变量赋值语句，即为变量定义；</li><li>计算表达式的值；</li><li>没有作用域的概念，所有变量都是全局变量；</li><li>变量名只允许 26 个小写的英文字母，也就是说，程序中最多有 26 个变量；</li><li>表达式只支持四则混合运算 +、-、*、/ 以及 ()；</li><li>表达式中参与运算的值均为正整数，除法规则参考 C 语言整形之间的除法规则；</li><li>变量赋值语句和表达式语句，均各占一行。</li></ul><p>样例输入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = 3</span><br><span class="line">b = a * 3 + 5</span><br><span class="line">(a + 4) * (b + 5)</span><br></pre></td></tr></table></figure><p>可以看到，第 1 行输入，定义了变量 a，同时给 a 变量赋值为 3；第 2 行，定义了变量 b，同时给 b 变量赋值为 a * 3 + 5 的值，也就是 14；第 3 行，是一行表达式，计算的是 (a + 4) * (b + 5) 的值，最后的结果应该等于 7 * 19 = 133。</p><p>针对这份输入数据，我们的计算器程序分别输出每行表达式对应的值，也就是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">14</span><br><span class="line">133</span><br></pre></td></tr></table></figure><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>二叉树，就是每个节点下面最多有两个子节点的结构。如下图所示，就是一个二叉树结构：</p><p><img src="/2020/06/13/geekbang-column-implement-your-own-calculator-program/erchashu.jpg" alt></p><p>我们把其中的 A 节点叫做“根节点”，B 和 C 是 A 节点的两个“子节点”，同理，E 和 F 是 C 节点的两个子节点，D 是 B 节点的子节点。如果更细致地划分，以 B 为根节点的子树，处于 A 节点的左侧，所以称为 A 节点的左子树，C 称为 A 节点的右子树。反过来，我们把 A 节点称为 B 和 C 节点的父节点，同时它也是 D、E、F 节点的祖先节点。</p><h3 id="三种遍历方式"><a href="#三种遍历方式" class="headerlink" title="三种遍历方式"></a>三种遍历方式</h3><p><img src="/2020/06/13/geekbang-column-implement-your-own-calculator-program/bianlifangshi.jpg" alt></p><p>每一种遍历的方式，都是采用递归的定义方式。而所谓的前、中、后序遍历，其实说的是根节点的位置：根节点在左右子树遍历之前，那就是前序遍历；夹在左右子树中间，就是中序遍历；位于左右子树遍历之后，那就是后序遍历。</p><p>如果我们将上上图中的二叉树结构，分别按照三种方式进行遍历，会得到如下所示的遍历结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前序遍历：A B D C E F</span><br><span class="line">中序遍历：D B A E C F</span><br><span class="line">后序遍历：D B E F C A</span><br></pre></td></tr></table></figure><p>注意，在写某一种遍历结果的时候，一定是按照递归展开的方式。例如：</p><p>在中序遍历中，我们是将根节点左子树所形成的中序遍历结果（D B），放在根节点 A 的左侧，然后是根节点 A，接着是根节点右子树的中序遍历结果（E C F）。所以最后，整棵树的中序遍历结果就是 D B A E C F。</p><h2 id="思维利器：表达式树"><a href="#思维利器：表达式树" class="headerlink" title="思维利器：表达式树"></a>思维利器：表达式树</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>任何一个四则混合运算的表达式，都能转换成相对应的二叉树，而原表达式的值，等于对应二叉树的后序遍历结果。例如，下图就是一个加法表达式和它所对应的表达式树：</p><p><img src="/2020/06/13/geekbang-column-implement-your-own-calculator-program/biaodashishu.jpg" alt></p><p>在表达式树中，根节点就是运算符 +(加号)，加号的左子树是数字 3，右子树是数字 5。根据刚刚所说的对应规则，在表达式树上，按照后序遍历的顺序，得到的就是表达式的值。图 3 中的表达式树，首先遍历得到左子树的数字 3，再遍历得到右子树的数字 5，最后遍历到根节点的运算符 +(加号)，就将左右子树的值做加法，得到原表达式的结果 8。</p><p>我们来看一个稍微复杂一点儿的表达式，以及它所对应的表达式树。</p><p><img src="/2020/06/13/geekbang-column-implement-your-own-calculator-program/fuza-biaodashishu.jpg" alt></p><p>从图中可见，原表达式是 (3 + 5) * (6 - 2)，而其对应的表达式树中，已经没有了括号的影子。因为，图中表达式树的计算顺序应该是这样的：首先计算左子树所代表的 3 + 5 表达式的值，再计算右子树代表的 6 - 2 表达式的值，最后根据根节点的乘法运算，计算得到左右子树的乘积值。</p><p><strong>表达式树的这种计算顺序，与原表达式添加了括号以后的计算顺序等价。</strong></p><p>综上所述，我们可知，表达式树中越靠近根节点的运算符，优先级越低，而根节点代表了原表达式中，优先级最低的那个运算符。表达式中原有的括号，其实就是用来控制运算符之间的计算顺序的，这种计算顺序，对应的就是表达式树中的父子节点关系，这就是我们刚刚所说的，原表达式中的括号，被转换成了等价的树形结构关系的含义。</p><h3 id="利用这种思维，解决表达式计算问题"><a href="#利用这种思维，解决表达式计算问题" class="headerlink" title="利用这种思维，解决表达式计算问题"></a>利用这种思维，解决表达式计算问题</h3><p>任何一个表达式，都对应一个等价的表达式树。而这个表达式树的根节点所对应的，就是原表达式中最后一个被计算的运算符。如果我们可以找到这个运算符在原表达式中的位置，那么这个运算符所的左边部分，对应的就是表达式树根节点的左子树，运算符的右边部分，对应的就是表达式树根节点的右子树。</p><p>我们用 String 代表原表达式字符串，op 代表整个表达式中最后一个被计算的运算符，L_String 是 op 运算符左边的字符串，R_String 就是右边的字符串。</p><p>假设，我们有一个函数 get_val(String)，可以得到 String 所代表的表达式的值。那么关于 get_val(String)，我们就可以得到如下递推关系：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get_val(String) = get_val(L_String) op get_val(R_String)</span><br></pre></td></tr></table></figure><p>也就是当前表达式的值，等于左边表达式的值与右边表达式的值之间的运算结果。举例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get_val(&quot;(3+5)*(6-2)&quot;) = get_val(&quot;(3+5)&quot;) * get_val(&quot;(6-2)&quot;)</span><br></pre></td></tr></table></figure><p>如果我们能确定，表达式字符串中最后一个被计算的运算符的位置，我们就可以把原表达式字符串分成两部分，进行递归求解。所以，<strong>找到最后一个被计算的运算符的位置，才是我们完成程序的关键。</strong></p><h2 id="确定运算符顺序的技巧"><a href="#确定运算符顺序的技巧" class="headerlink" title="确定运算符顺序的技巧"></a>确定运算符顺序的技巧</h2><p>问：怎么确定表达式中每一个运算符的计算顺序呢？<br>答：可以通过给每个运算符赋予一个权重，权重越高，代表计算优先级越高。</p><p>问：怎么设置权重？<br>答：根据四则混合运算的基础规则，我们可以给 +、-、<em>、/ 运算符设定一个基础权重，例如，+、- 权重是 1，</em>、/ 权重是 2；另外，可以对括号里面的所有运算符，额外加上一个很大的权重。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>二叉树的三种遍历方式：前序遍历、中序遍历与后序遍历，它们主要是依据根节点的位置划分出来的。</li><li>我们掌握了表达式与其对应的表达式树的对应关系。</li><li>表达式树的后续遍历结果，就等于原表达式的值。这种特性，给我们设计表达式求值程序，提供了思维方面的指导。</li></ul><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 计算表达式 str 从 l 到 r 位置的值</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * pos : 根节点运算符的位置，初始化为 -1</span></span><br><span class="line"><span class="comment">    * priority : 根节点运算符的权重</span></span><br><span class="line"><span class="comment">    * temp : 由括号产生的额外权重</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">-1</span>, priority = INF - <span class="number">1</span>, temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur_priority = INF;</span><br><span class="line">        <span class="keyword">switch</span> (str[i]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'('</span>: temp += <span class="number">100</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">')'</span>: temp -= <span class="number">100</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>: cur_priority = <span class="number">1</span> + temp;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>: cur_priority = <span class="number">2</span> + temp;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * cur_priority : 当前运算符的优先级</span></span><br><span class="line"><span class="comment">        * 更新区间内最低优先级的运算符的位置</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span> (cur_priority &lt;= priority) &#123;</span><br><span class="line">            pos = i;</span><br><span class="line">            priority = cur_priority;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 如果 pos == -1，说明这一段表达式中没有运算符</span></span><br><span class="line"><span class="comment">    * 说明，这一段表达式中只有数字，也就是递归到了树的叶子结点</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] &lt; <span class="string">'0'</span> || str[i] &gt;= <span class="string">'9'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            num = num * <span class="number">10</span> + (str[i] - <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 递归计算得到运算符左边及右边表达式的值</span></span><br><span class="line"><span class="comment">    * 再根据当前运算符，得到当前表达式的值</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">int</span> a = calc(str, l, pos - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> b = calc(str, pos + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">switch</span> (str[pos]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>: <span class="keyword">return</span> a + b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>: <span class="keyword">return</span> a - b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'*'</span>: <span class="keyword">return</span> a * b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>: <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_val</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> calc(str, <span class="number">0</span>, <span class="built_in">strlen</span>(str) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%[^\n]"</span>, str) != EOF) &#123;</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s = %d\n"</span>, str, get_val(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/geektime-practice/calc" target="_blank" rel="noopener">项目地址</a></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>计算器</tag>
        <tag>二叉树</tag>
        <tag>表达式树</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划：背包问题与动态规划算法优化</title>
    <url>/2020/06/13/geekbang-column-dp-backpack-problem-and-dp-algorithm-optimization/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="初识：0-1-背包问题"><a href="#初识：0-1-背包问题" class="headerlink" title="初识：0/1 背包问题"></a>初识：0/1 背包问题</h2><p>0/1 背包问题可以说是所有背包问题的基础，它描述的场景是这样的：假设你有一个背包，载重上限是 W，你面前有 n 个物品，第 i 个物品的重量是 wi，价值是 vi，那么，在不超过背包重量上限的前提下，你能获得的最大物品价值总和是多少？</p><p>按照动态规划问题的四步走，咱们来分析一下这个问题。</p><h3 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h3><p>关于状态定义，我们首先来分析 0/1 背包问题中的自变量和因变量。</p><p>因变量比较好确定，就是问题中所求的最大价值总和。自变量呢？经过分析你会发现，物品种类和背包承重上限就是自变量，因为它们都能够影响价值总和的最大值。这样我们就可以设置一个二维的状态，状态定义如下：</p><p>0/1 背包状态定义：dp[i][j] 代表使用前 i 个物品，背包最大载重为 j 的情况下的最大价值总和。</p><h3 id="推导状态转移方程"><a href="#推导状态转移方程" class="headerlink" title="推导状态转移方程"></a>推导状态转移方程</h3><p>推导状态转移方程，也就是推导 dp[i][j] 的表达式。根据 dp[i][j] 的含义，我们可以将 dp[i][j] 可能达到最大值时的方案分成两类：一类是方案中不选择第 i 个物品的最大价值和，另一类是方案中选择了第 i 个物品的最大价值和。只需要在这两类方案的最大值中，选择一个价值和较大的方案，转移到 dp[i][j] 即可。下面，我们就分别表示一下这两种方案的公式。</p><p>不选择第 i 个物品的最大价值和，就是 dp[i - 1][j]。也就是说，在背包最大载重为 j 的情况下，前 i 个物品中，不选择第 i 个物品的最大价值和，就等于在前 i - 1 个物品中选择的最大价值和。</p><p>选择第 i 个物品的最大价值和就是 dp[i - 1][j - wi] + vi。关于这个公式的理解，可以参考我们前面讲的凑钱币问题，既然要求一定选择了第 i 个物品，那我们就可以先给第 i 个物品预留出来一个位置，然后给剩余的 i - 1 个物品留的载重空间就只剩下 j - wi 了，那么 i - 1 个物品选择的最大价值和是 dp[i - 1][j - wi]，再加上 vi 就是选择第 i 个物品时，我们能够获得最大价值和。</p><p>最终，我们得到 dp[i][j] 的状态转移方程，如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w[i]] + v[i])</span><br></pre></td></tr></table></figure><h3 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h3><p>动规算法的正确性证明，还是需要依赖于数学归纳法，下面我们开始数学归纳法的三步走。</p><p>首先，dp[0][j] = 0，就是当没有物品的时候，无论背包限重是多少，能得到的最大价值和都是 0，这也就是已知 k0 正确。</p><p>其次，假设我们已经正确计算得到了，在 i - 1 个物品的任意一种背包容量下的价值最大和值，也就是所有 dp[i - 1] 中的值。那么根据状态转移方程，我们也肯定可以正确的得到所有 dp[i] 中的值。</p><p>最后两步联立，整个求解过程对于任意 dp[i][j]，均正确。</p><p>(认真理解这个证明过程，因为接下来的程序处理过程，其实和这个证明过程是一致的。)</p><h3 id="程序设计与实现"><a href="#程序设计与实现" class="headerlink" title="程序设计与实现"></a>程序设计与实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_V 10000</span></span><br><span class="line"><span class="keyword">int</span> v[MAX_N + <span class="number">5</span>], w[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> dp[MAX_N + <span class="number">5</span>][MAX_V + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_dp</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> W)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 dp[0] 阶段</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= W; i++) dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 假设 dp[i - 1] 成立，计算得到 dp[i]</span></span><br><span class="line">    <span class="comment">// 状态转移过程，i 代表物品，j 代表背包限重</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= W; j++) &#123;</span><br><span class="line">            <span class="comment">// 不选择第 i 种物品时的最大值</span></span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="comment">// 与选择第 i 种物品的最大值作比较，并更新</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w[i] &amp;&amp; dp[i][j] &lt; dp[i - <span class="number">1</span>][j - w[i]] + v[i]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - w[i]] + v[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get_dp 函数就是求解 0/1 背包问题的过程，函数传入两个整形参数 n 和 W，分别代表了物品数量与背包最大限重。程序中有三个数组：v、w 与 dp，v[i] 代表第 i 个物品的价值，w[i]代表第 i 个物品的重量，dp[i][j] 代表背包问题相关的状态。</p><p>这一段代码，采用了正向递推的程序实现。而且，如果你注意观察 get_dp 函数的实现过程，你会惊奇地发现，这就是数学归纳法的证明过程。</p><p>首先，初始化 dp[0] 阶段的所有值，也就是保证了 k0 成立；然后从 dp[1] 开始迭代计算到 dp[n] 中所有值，每一次 dp[i]依赖的就是 dp[i - 1] 中的值，只有 dp[i - 1] 中所有值是正确的，才能保证 dp[i]中所有值是正确的，这就是数学归纳法的第二步。最后，两步联立，就证明了以 dp 数组的第一维作为阶段，进行状态转移，计算得到的所有 dp 值均是正确的。</p><h2 id="进阶：多重背包问题"><a href="#进阶：多重背包问题" class="headerlink" title="进阶：多重背包问题"></a>进阶：多重背包问题</h2><p>其实这个问题，整体和 0/1 背包问题类似，只不过从 n 个物品变成了 n 种物品，且每种物品都有不同的数量，我们可以设定第 i 种物品的数量是 ci。</p><p>现在你有一个载重上限为 15kg 的背包，有如下 4 件物品：</p><ul><li>镀金极客币，每个 4kg，每个价值 10 块钱，一共有 5 个；</li><li>胡船长手办，每个 3kg ，每个价值 7 块钱，一共有 4 个；</li><li>西瓜，每个 12kg ，每个价值 12 块钱，一共有 2 个；</li><li>哈密瓜，每个 9kg ，每个价值 8 块钱，一共有 7 个。</li></ul><p>经过分析，在不超过背包载重上限的情况下，你可以选择 3 个镀金极客币和 1 个胡船长手办装到背包里面，这种选择方案能获得最大价值为：37 块钱。</p><p>回到我们说的这个多重背包问题，你想如何求解呢？</p><p>其实最简单的解决办法，就是把 n 种物品中的每一个，都看成是 0/1 背包中的一个物品，然后按照 0/1 背包问题的求解过程来做即可。这也就是说，如果一种物品有 12 件，就相当于 0/1 背包中多了 12 件物品，我们就多做 12 轮运算，要是有 120 件呢，那就是多做 120 轮运算。</p><p>这种做法虽然可行，可显然太浪费我们计算机的计算资源了。下面就让我们看看怎么做，才能更优化。</p><h3 id="二进制拆分法"><a href="#二进制拆分法" class="headerlink" title="二进制拆分法"></a>二进制拆分法</h3><p>想象一个场景，假设你是一个卖白菜的老农，手上有 23 斤白菜和若干个筐，出于某种不知名的原因，你今天不能把称重器带到菜市场，只能提前把白菜称好装入不同的筐里贩卖给顾客。问题来了，白菜要如何分到这些筐里面，才能使得第一个顾客无论要多少斤白菜，你都能通过挑选其中的几筐白菜，从而满足顾客的需求呢？</p><ul><li><p>一种最直接的装筐方法，就是每个筐里面装 1 斤白菜，共需要 23 个筐。这样，第一个顾客要多少斤白菜，你就给他多少筐就行。这种方法简单粗暴，可是用的筐太多了。</p></li><li><p>转换一个思路去想这件事：当你准备挑几个筐满足第一个顾客需求的时候，对于每个筐来说，都有两种状态，选或者不选，这不就是二进制每位上的数字么？我们就可以把每个筐，看成是二进制相应的位权。</p></li></ul><p><img src="/2020/06/13/geekbang-column-dp-backpack-problem-and-dp-algorithm-optimization/erjinzhi.jpg" alt></p><p>可以看到，从第一个筐开始，我们依次装上 1 斤、2 斤、4 斤、8 斤，第五个筐应该装 16 斤的，可剩下的白菜不够 16 斤，所以就一起放到最后一个筐里面。这样，我们只需要 5 个筐，就装了 23 斤白菜，并且可以保证无论第一个客人要几斤白菜，都能满足他的需求。</p><h3 id="多重背包的拆分优化"><a href="#多重背包的拆分优化" class="headerlink" title="多重背包的拆分优化"></a>多重背包的拆分优化</h3><p>假设多重背包中，某一种物品有 23 件，转换到 0/1 背包问题中，就是 23 个物品，就跟前面一斤白菜装一筐的做法是一样的。我们虽然不知道，在 0/1 背包问题的最优方案中，这种物品被具体选择了多少件，可是只要我们通过一种合理的拆分方法，使得无论最优方案中选择了多少件这种商品，我们都可以组合出来。</p><p>简单粗暴地拆分成 23 份，是一种拆分方法，而二进制拆分法也是一种拆分方法，并且二进制拆分法只需要拆成 5 份物品，作为 0/1 背包问题中的 5 个单独的物品即可，这么做可以达到和拆分成 23 件物品等价的效果，并且节省了大量的计算资源。</p><p>例如，前面多重背包问题的那个例子中，按照原本简单粗暴的方式，我们是把 5 个镀金极客币、4 个胡船长手办、2 个西瓜、7 个哈密瓜，当作 18 个物品的 0/1 背包问题来求解的。但如果采用二进制拆分法，我们就会得到如下拆分方案：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1个镀金极客币，4kg每个，价值 10 块钱</span><br><span class="line">2个镀金极客币，8kg每个，价值 20 块钱</span><br><span class="line">2个镀金极客币，8kg每个，价值 20 块钱</span><br><span class="line"></span><br><span class="line">1个胡船长手办，3kg每个，价值 7 块钱</span><br><span class="line">2个胡船长手办，6kg每个，价值 14 块钱</span><br><span class="line">1个胡船长手办，3kg每个，价值 7 块钱</span><br><span class="line"></span><br><span class="line">1个西瓜，12kg每个，价值 12 块钱</span><br><span class="line">1个西瓜，12kg每个，价值 12 块钱</span><br><span class="line"></span><br><span class="line">1个哈密瓜，9kg每个，价值 8 块钱</span><br><span class="line">2个哈密瓜，18kg每个，价值 16 块钱</span><br><span class="line">4个哈密瓜，36kg每个，价值 32</span><br></pre></td></tr></table></figure><p>这种拆分方案等价于求解 11 个物品的 0/1 背包问题，比之前求解的 18 个物品的 0/1 背包问题显然要优秀。</p><p><strong>实际上，随着某个物品数量的增加，二进制拆分法的优势会愈加地明显。</strong></p><p>(想一想 32 个二进制位能表示的数字大小)</p><h3 id="程序设计与实现-1"><a href="#程序设计与实现-1" class="headerlink" title="程序设计与实现"></a>程序设计与实现</h3><p>待更新…</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>0/1 背包问题中的自变量是物品的种类和背包限重，所以我们把这两维设计到了状态定义中。</li><li>多重背包问题可以转换成 0/1 背包进行求解，转换过程不同，效率也就不同。</li><li>二进制拆分法，本质思想就是二进制的数字表示法，0/1 表示两种状态，表示选或不选。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>背包</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划：只需四步，搞定动态规划算法设计</title>
    <url>/2020/06/13/geekbang-column-dp-four-steps-get-the-design-of-dynamic-programming-algorithm/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><h3 id="数字三角形问题"><a href="#数字三角形问题" class="headerlink" title="数字三角形问题"></a>数字三角形问题</h3><p><img src="/2020/06/13/geekbang-column-dp-four-steps-get-the-design-of-dynamic-programming-algorithm/sanjiaoxing.jpg" alt></p><p>由上到下，第 i 层由 i 个数字组成，目标从第 1 层开始，每次只能向下走到相邻的两个节点，求走到最后一层路径上面数字的最大和值是多少。就像图中标红的一条线路，就是路径和值最大的一条路线，和值为 39。如果给你的是一个 n 层的数字三角形，你该如何解决这个问题呢？</p><h3 id="数学归纳法思想"><a href="#数学归纳法思想" class="headerlink" title="数学归纳法思想"></a>数学归纳法思想</h3><p>如果我们已知到第三层所有点的最大值，那么我们就可以计算得到起始点到第四层每一个的路径最大和值。所有绿色节点和蓝色节点，就是已经求出来的，起始点到其路径最大和值的点。其中的数字是根据上图中的数字三角形计算所得，比如第 2 层的 12，是由图 1 中第 1 层的 3 与原所在位置的 9，相加之和的结果。</p><p><img src="/2020/06/13/geekbang-column-dp-four-steps-get-the-design-of-dynamic-programming-algorithm/mathqiujie.jpg" alt></p><p>如果想求从起始点到红色的点，也就是第 4 行数字 9 点的路径最大和值，那么根据数字三角形的规则，我们只能从图中的两个蓝色点转移到红色点。那究竟选择从哪个点走到红色点呢？当然是选择其中和值较大的了，也就是从和值为 14 的点转移到红色点，得到的就是起始点到红色点的路径最大和值。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>若我们已知从起始点到第 i - 1 层上每个点的路径最大和值，那我们又是怎么得到从起始点到第 i 层上每个点的路径最大和值呢？请看下图：</p><p><img src="/2020/06/13/geekbang-column-dp-four-steps-get-the-design-of-dynamic-programming-algorithm/tuidao.jpg" alt></p><p>我们给每一层的节点，从左向右，从 0 开始依次编号，那么第 i 行的第 3 个点对应的坐标就是 (i, 2) 点。从第 1 层的点想要到达红色 (i, 2) 点，可以通过 (i - 1, 1) 点到达，或者通过 (i - 1, 2) 点到达。在已知从起始点到第 i-1 层上每个点的路径最大和值的前提下，从第 1 层到 (i, 2) 点的最大和值，就是在 (i - 1, 1) 和 (i - 1, 2) 这两个值中，选择一个路径和值最大的，然后转移到 (i, 2) 点，即为第 1 层到 (i, 2) 点的路径最大和值。</p><p>所以，我们基本可以确定一件事情了，如果我们要是知道第 1 层 到 i - 1 层的每个点的路径最大和值，那就很容易求得到第 i 层每个点的路径最大和值，从而推导出 i + 1 层、i + 2 层等等的路径最大和值，直到最后一层。</p><p>又因为，我们已知第 1 层到第 1 层每一个点的路径最大和值，就是起始点原本的值，所以沿着上面这个思路，就可以按照层序，来求解第一层到每一层的每个节点的路径最大和值了。</p><h2 id="动态规划算法的四步走"><a href="#动态规划算法的四步走" class="headerlink" title="动态规划算法的四步走"></a>动态规划算法的四步走</h2><h3 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h3><p>理解一个动态归划问题的状态定义，是理解其解法的第一步，也是最重要的一步。如果你在往下进行推导的时候，发现进行不下去了，那往往就是状态定义有问题，这时你就需要回到这个第一步，琢磨琢磨新的状态定义了。</p><p>并且，我们一直在强调，对于动态规划的状态定义，不仅仅是要一个数学符号，还要一个明确的语义信息，你的理解可能是：不同的语义信息，对应的不就是不同的数学符号么？那今天，我们就用同一个数学符号，表示不同的语义信息，在接下来的求解过程中，你会发现这两种不同的语义信息，所衍生出来的后续步骤过程，是完全不同的。</p><p>回到前面说的数字三角形问题，我们可以作出两种状态定义：</p><ul><li><p><strong>第一种状态定义</strong>：dp[i][j] 代表从起始点，到 (i, j) 点的路径最大值。</p></li><li><p><strong>第二种状态定义</strong>：dp[i][j] 代表从底边的某个点出发，到 (i, j) 点的路径最大值。</p></li></ul><p>为了后续讲解方便，我们假设所有坐标都是从 1 开始的，也就是第一行第一个点的坐标是 (1, 1)。你会发现，这两种状态定义，数学符号都是 dp[i][j]，而含义却完全相反，一个是从顶向下走，一个是从底向上走。对于第一种状态定义，如果数字三角形有 n 层的话，问题所求的最大值，就是在最后一层 dp[n] 中的某个值。而第二种状态定义，问题所求的最大值最终会存储在 dp[1][1] 这个状态值中。</p><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>状态转移，就是状态之间的转移，每一个状态的含义，在状态定义中规定的明明白白，而状态与状态之间的转移方式，是需要根据具体的问题以及具体的状态定义，进行具体分析。</p><p>根据刚才作的两种状态定义，我们可以分别画出来这样两种状态转移的方向：</p><p><img src="/2020/06/13/geekbang-column-dp-four-steps-get-the-design-of-dynamic-programming-algorithm/zhuangtaizhuanyi.jpg" alt></p><p>如图所示，我以左边是第一种状态定义下的状态转移方向为例，来说明它是如何转移的。首先，它是自上向下转移的，所以想要求得 dp[i][j] 的值，我们需要知道 dp[i - 1][j - 1] 和 dp[i - 1][j] 的值。因为按照“走向下个相邻两点”的规则，只有 (i - 1, j - 1) 和 (i - 1, j) 这两个点，才能能走到 (i, j)，也就是我们讲到的转移到 (i, j) 点。右边的第二种状态定义转移过程和左边的一样，只是移动方向不一样而已。</p><p>所以，根据两种状态定义，我们可以分别列出这两种状态转移方程：</p><ul><li><p>第一种状态转移方程：dp[i][j] = max(dp[i - 1][j - 1], dp[i - 1][j]) + val[i][j]</p></li><li><p>第二种状态转移方程：dp[i][j] = max(dp[i + 1][j], dp[i + 1][j + 1]) + val[i][j]</p></li></ul><p>两种转移方程，都是在能够转移到 (i, j) 点的状态值中选择一个较大值，再加上 (i, j) 原本的数值 val[i][j]，就是各自起始点到达 (i, j) 点的路径最大值，也就是两种状态定义下的 dp[i][j] 的值。</p><p>到这里，你可以看出，<strong>状态定义不一样，直接导致我们的状态转移方程就不一样。所以，虽然是相同的数学符号，定义的含义不同，就会造成后续的解法不同，同时也意味着解决问题的难度不同。</strong></p><h3 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h3><p>关于状态转移方程的正确性证明，借助的就是程序设计中最重要的数学思维：数学归纳法。</p><p>根据数学归纳法的三步走，我们试着证明一下第一种状态转移方程是正确的，也就是自上而下的状态转移方式。</p><p>第一步，我们已知在这种状态转移方式中，第一个阶段中的所有 dp 值都可以轻松获得，也就是可以很轻松的初始化 dp[1][1] 的值，应该等于 val[1][1] 的值。</p><p>第二步，我们假设如果第 i-1 阶段中的所有状态值，我们都正确的得到了。也就是正确的得到了从起始点到 i-1 层中每个点的路径最大和值。那根据状态转移方程：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j + 1]) + val[i][j] 来说，就可以正确的计算得到第 i 个阶段中的所有状态值。</p><p>第三步，两步联立，就可得出结论，所有阶段中的状态值计算均正确。那么，从起始点到底边的路径最大和值，就在最后一个阶段的若干个状态值中。</p><h3 id="程序设计与实现"><a href="#程序设计与实现" class="headerlink" title="程序设计与实现"></a>程序设计与实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i, j;</span><br><span class="line">    <span class="keyword">int</span> s[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">int</span> p[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;s[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[n][j] = s[n][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p[i + <span class="number">1</span>][j] &gt; p[i + <span class="number">1</span>][j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                p[i][j] = s[i][j] + p[i + <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">               p[i][j] = p[i + <span class="number">1</span>][j + <span class="number">1</span>] + s[i][j];</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, p[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>状态定义，是动态规划算法的重点，无论是解题还是学习，都要从这一步开始。</li><li>不同的状态定义，决定了不同的状态转移方程，同时也可能代表了不同的解题难度，所以，学习如何定义优秀的状态很重要。</li><li>动态规划中的状态转移顺序，是建立在“阶段”概念之上的，只有本阶段的状态值计算完了，下一个阶段的状态值才能得以计算。</li><li>数学归纳法，是证明动态规划状态转移方程正确性的利器，掌握了它，会让你的动态规划学习过程事半功倍！</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>动态规划</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解：容斥原理与递推算法</title>
    <url>/2020/06/09/geekbang-column-principle-of-tolerance-and-recursive-algorithm/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>众所周知，在不计算小于 1 元钱的面额的前提下，我国的纸币系统中，曾经拥有如下面值：1 元、2 元、5 元、10 元、20 元、50 元 和 100 元。假设，每一种面值的纸币，我们都有无限张，现在想用这些钱凑出 1000 元，请问你有多少种不同的方案？</p><p>这里说的不同方案，是不关注钱币之间的顺序的，例如要凑 7 元钱，可以是 1 元、5 元、1 元，也可以是 1 元、1 元、5 元，这两种方案我们视为同一种。</p><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><p>一般在计数问题中，为了保证计数准确，必须注意两个事情：一是没有重复，二是没有遗漏。</p><p>容斥原理的基本思想：<strong>先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排除出去，使得计算的结果既无遗漏又无重复。简单来说，就是在计算过程中，如果加多了，就把加多的部分减掉，如果发现又减多了，就再加回来一部分，一直到不多不少为止。</strong></p><p>例如，求 1000 以内，3 或者 5 倍数的所有数字和的问题：</p><p><img src="/2020/06/09/geekbang-column-principle-of-tolerance-and-recursive-algorithm/3-5set.jpg" alt></p><h3 id="一个递推算法例子：兔子繁殖问题"><a href="#一个递推算法例子：兔子繁殖问题" class="headerlink" title="一个递推算法例子：兔子繁殖问题"></a>一个递推算法例子：兔子繁殖问题</h3><p>假设在一片草原上，莫名其妙来了一只外星兔子，这种外星兔子呢，第一个月的时候是幼体，第二个月成长为成体，从第三个月开始，成体兔子每个月都会产生出一只克隆体的幼体兔子，而且这种兔子不会衰老，一旦成体以后，就会一直生下去。按照这种情况，请你计算出第 n 个月，草原上有多少只兔子？</p><p>给出前 6 个月，草原上兔子数量的情况：</p><p><img src="/2020/06/09/geekbang-column-principle-of-tolerance-and-recursive-algorithm/6month-tuzi.jpg" alt></p><p>第6个月的兔子数量与前两个月兔子数量关系：</p><p><img src="/2020/06/09/geekbang-column-principle-of-tolerance-and-recursive-algorithm/guanxi.jpg" alt></p><p>由于：第 6 个月的成兔数量等于第 5 个月的兔子总数，第 6 个月的幼兔数量等于第 4 个月的兔子总数，因此可以得出这样的一个结论：<strong>第 n 个月的兔子总数，等于该月的成兔数量与幼兔数量之和，也就等于第 n - 1 个月的兔子数量与第 n - 2 个月的兔子数量之和。</strong></p><h3 id="递推问题求解步骤，以兔子繁殖问题为例"><a href="#递推问题求解步骤，以兔子繁殖问题为例" class="headerlink" title="递推问题求解步骤，以兔子繁殖问题为例"></a>递推问题求解步骤，以兔子繁殖问题为例</h3><p><strong>递推问题，通常分成三步进行求解。第一步，确定递推状态，也叫做状态定义；第二步，推导递推公式；最后一步，程序设计与编写。</strong></p><h4 id="确定递推状态"><a href="#确定递推状态" class="headerlink" title="确定递推状态"></a>确定递推状态</h4><p>确定一个有明确含义的数学符号，这里重要的是这个明确含义，而非那个数学符号。</p><p>先分析问题中的自变量和因变量。自变量，就是问题中那些不受控制的量，就像兔子繁殖问题中的月份。而因变量就是那些随自变量改变而改变的量，就像兔子繁殖问题中兔子的数量，是随着月份而改变的。</p><p>所以，<strong>我们把和问题求解量相关的自变量，都作为数学符号中的参数，然后将相关问题求解量作为数学符号映射值。</strong>f(n)代表第n个月兔子的数量，在这个状态定义中，将问题求解量，也就是兔子数量，作为函数映射值的含义；而与问题求解量，即兔子数量相关的自变量只有一个，那就是月份，所以我们将月份作为函数的参数。</p><h4 id="推导递推公式"><a href="#推导递推公式" class="headerlink" title="推导递推公式"></a>推导递推公式</h4><p>在推导递推公式的时候，这里需要用到前面我们定义的递推状态，并且，使用时一定要严格遵守递推状态的语义信息。</p><p>例如，在兔子繁殖问题中，如果你想用状态 f(n) 做公式推导的时候，那么 f(n - 1) 就代表了第 n - 1 个月兔子的数量，而 f(n - 2) 就代表第 n - 2 个月兔子的数量。</p><p>一般做递推公式推导的时候，我们主要思考的事情是，当前递推状态和前几项递推状态之间的关系。例如，在兔子繁殖问题中，当我们确定了递推状态 f(n) 以后，通过分析可以得到如下递推公式：</p><p><img src="/2020/06/09/geekbang-column-principle-of-tolerance-and-recursive-algorithm/ditui.jpg" alt></p><h4 id="程序设计与编写"><a href="#程序设计与编写" class="headerlink" title="程序设计与编写"></a>程序设计与编写</h4><ul><li>1，使用循环的程序实现方式</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal_rabbit_num_loop</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123;</span><br><span class="line">        n3 = n1 + n2;</span><br><span class="line">        n1 = n2;</span><br><span class="line">        n2 = n3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2，使用递归的程序实现方式</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal_rabbit_num</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cal_rabbit_num(n - <span class="number">1</span>) + cal_rabbit_num(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="凑钱币问题解决"><a href="#凑钱币问题解决" class="headerlink" title="凑钱币问题解决"></a>凑钱币问题解决</h3><ul><li><p>第一步，让我们来确定递推状态。确定递推状态之前，我们需要分析清楚题目中的自变量与因变量。因变量比较好分析，就是方案总数，那这个方案总数都受什么影响呢？很明显，是钱币的种类和拼凑目标金额。也就是说，钱币种类发生变化，方案总数就会发生变化；同理，如果拼凑的目标金额发生变化，方案总数也一定会发生变化。所以，自变量是 2 个，钱币种类和拼凑的钱币数量。因变量是 1 个，就是方案总数。通过上面的分析，我们就可以列出状态定义：f(i, j) ，代表使用前 i 种钱币，拼凑 j 元钱的方案总数。例如，f[3][10] 就代表使用前 3 种钱币，也就是只使用 1 元、2 元、5 元，凑 10 元钱的方案总数。<br>通过上面的分析，我们就可以列出状态定义：f(i, j) ，代表使用前 i 种钱币，拼凑 j 元钱的方案总数。例如，f[3][10] 就代表使用前 3 种钱币，也就是只使用 1 元、2 元、5 元，凑 10 元钱的方案总数。</p></li><li><p>第二步，就是用这个状态定义，进行递推公式推导，关键就是分析当前项与前几项的关系。核心思想其实就是容斥原理，也就是用某几项表示 f(i, j) ，如果发现这些表示 f(i, j) 的项之间存在交集，就将交集部分减去，如果减多了再加回来一些，直到正好表示 f(i, j) 为止。<br>好在这道题目还算是一道简单的递推问题，我们可以将 f(i, j) 划分成性质不同且互为补集的两部分。在 f(i, j) 所代表的所有方案中，一部分方案是使用了第 i 种钱币的，另外一部分方案中是没有使用第 i 种钱币的，我们就用这个性质，将 f(i, j) 表示成两项相加之和的形式。<br>例如，在用前三种钱币，拼凑 10 元钱的所有方案中，可以按照方案中是否使用第 3 种钱币，也就是是否使用了 5 元钱，将所有方案划分成两类。<br>其中一类方案不包含第 3 种钱币，也就是不用 5 元这个钱币，这些方案的数量，等价于使用前 2 种钱币拼凑 10 元钱的方案总数，也就是 f[2][10] 的值。另外一类方案中，使用了至少 1 张 5 块钱，那么我们可以在这些方案中，都拿掉一张 5 元钱，剩余的部分组成的方案数量，就等于 f[3][5]，也就是用前 3 种钱币凑 5 元钱的方案总数。</p></li></ul><p><strong>这样我们就推导出了递推公式：f[3][10] = f[2][10] + f[3][5]。</strong></p><p><img src="/2020/06/09/geekbang-column-principle-of-tolerance-and-recursive-algorithm/couqianbi.jpg" alt></p><p>在 f(i, j) 代表的所有方案中，没有使用第 i 种钱币，拼凑 j 元钱的方案数量，就是 f(i - 1, j)，代表使用前 i - 1 种钱币拼凑 j 元钱的方案总数。剩下的使用了第 i 种钱币的方案中，由于都存在第 i 种钱币至少 1 张，假设第 i 种钱币的面额是 val[i]，也就意味着，我们可以使用前 i 种钱币，凑 j - val[i] 的钱数，给第 i 种钱币留出一个位置，这么做所对应的方案总数就是 f(i, j - val[i])。</p><p>最终，我们推导出了递推公式：<strong>f(i, j) = f(i - 1, j) + f(i, j - val[i])</strong>。其中，边界条件是 f(1, k * val[1]) = 1，也就是用在只使用第 1 种钱币的条件下，想要凑第 1 种钱币的整数倍面额的方案总数都是 1。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal_coins</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span> &amp;&amp; j % val[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cal_coins(i - <span class="number">1</span>, j) + cal_coins(i, j - val[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cal_coins(<span class="number">3</span>, n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(有bug，待修正)</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>递推问题第一步是要确定递推状态，也就是给出一个数学符号，以及数学符号的相关描述。</li><li>在设计递推状态的时候，主要分析自变量与因变量的关系，一般因变量都是问题求解的那个量。</li><li>递推问题的第二步是推导递推公式，而容斥原理的思想，对于这一步的求解，十分重要。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>递推</tag>
        <tag>兔子繁殖</tag>
      </tags>
  </entry>
  <entry>
    <title>栈与单调栈：最大矩形面积</title>
    <url>/2020/06/07/geekbang-column-stack-and-monotonic-stack-maximum-rectangular-area/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>假设有一面木板墙，每块木板的宽度都是 1，你现在想在木板墙上，沿着平行于地面的方向，切割出一块矩形区域。问题来了，如果给出了每一块木板的高度，那么如何切出面积最大的矩形区域？矩形木板墙如下图所示：</p><p><img src="/2020/06/07/geekbang-column-stack-and-monotonic-stack-maximum-rectangular-area/mubanqiang.jpg" alt></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>图中有 7 块木板，每块木板的高度分别为：2、1、4、5、1、3、3。经过尝试，我们发现最大矩形就是红色阴影部分所示，也就是切割了高度为 4 和 5 两块木板，形成了一个高度为 4，宽度为 2 的矩形区域，这个最大面积为 8。</p><p>结论：<strong>切下来的最大的矩形，一定是以最大矩形所在区域最短那块木板作为其高度值。</strong></p><p>因此，可以枚举每一块木板，每次都以当前木板作为高度，就是把当前这块木板，当成是切出来的矩形区域中的最矮的木板，然后向左边和右边分别做延伸，切出此时的最大矩形区域。当把所有木板都试过一遍后，我们在所有枚举结果中比较出最大值，这个最大值就是我们要求的最大矩形面积。如果木板的个数为 n，那这种做法的时间复杂度接近于 O(n2)。</p><p>任务要求：将这个时间复杂度降低到 O(n)。</p><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><h3 id="栈：维护一种完全包含关系的结构"><a href="#栈：维护一种完全包含关系的结构" class="headerlink" title="栈：维护一种完全包含关系的结构"></a>栈：维护一种完全包含关系的结构</h3><p>栈就是一种后进先出的结构。</p><p><img src="/2020/06/07/geekbang-column-stack-and-monotonic-stack-maximum-rectangular-area/stack.jpg" alt></p><p>图中所示，入栈顺序分别是 蓝、绿、红，那么出栈顺序就一定是红、绿、蓝。图中每一个颜色的方块上标注的数字，就是每一个方块入栈及出栈的顺序。</p><p>从示意图中，我们还可以观察到一个有趣的事情，在顺序上而言，红色方块被绿色方块包裹着，绿色方块被蓝色方块包裹着。这种结构，像是程序的调用过程，如果把蓝色方块，看成是主函数的话，那么绿色方块就是主函数中调用的一个函数 A，红色方块就是 A 函数中调用的另外一个函数 B，三个函数调用的顺序是主函数、函数 A、函数 B。<br>而它们的执行结束顺序恰恰是相反的，首先是 函数 B 结束，然后是 函数 A 结束，最后是主函数结束。</p><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p><img src="/2020/06/07/geekbang-column-stack-and-monotonic-stack-maximum-rectangular-area/dandiaozhan.jpg" alt></p><p>如果说单调队列是维护区间最值的高效结构，单调栈就是维护最近大于或小于关系的高效结构。</p><h3 id="最大矩形面积"><a href="#最大矩形面积" class="headerlink" title="最大矩形面积"></a>最大矩形面积</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a, b) ((a) &gt; (b) ？ (a) : (b))</span></span><br><span class="line"><span class="keyword">int</span> s[MAX_N + <span class="number">5</span>], top;</span><br><span class="line"><span class="keyword">int</span> l[MAX_N + <span class="number">5</span>], r[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_matrix_area</span><span class="params">(<span class="keyword">int</span> *h, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    h[<span class="number">0</span>] = h[n + <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    top = <span class="number">-1</span>, s[++top] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 找到每一块木板，左边第一块比其矮的木板编号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">0</span> &amp;&amp; h[s[top]] &gt;= h[i]) --top;</span><br><span class="line">        l[i] = s[top];</span><br><span class="line">        s[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到每一块木板，右边第一块比其矮的木板编号</span></span><br><span class="line">    top = <span class="number">-1</span>, s[++top] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">0</span> &amp;&amp; h[s[top]] &gt;= h[i]) --top;</span><br><span class="line">        r[i] = s[top];</span><br><span class="line">        s[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在所有木板中，找到面积最大的矩形</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans = max(ans, (r[i] - l[r] - <span class="number">1</span>) * h[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：代码中假设木板的编号是从 1 到 n 的，然后，在数组的 0 位 及 n + 1 位分别加入两块高度为 -1 的虚拟木板，这是边界控制的一种技巧。也就是说，在每块木板向左搜索的时候，最远也就搜索到 0 号位就停止了，向右搜索的时候呢，最远搜索到 n + 1 位也就停止了。</p><p><strong>通过加入虚拟木板，代码中就少了相关的边界条件判断，这是一种很实用的技巧。</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>单调栈是用来维护最近大于或小于关系的数据结构。</li><li>单调栈就是堵住出口的单调队列，所以其时间复杂度与单调队列一致，平均到每个处理元素上，都是 O(1) 的时间复杂度。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>龙潭水乡半日游</title>
    <url>/2020/06/07/long-tan-shui-xiang-half-a-day-trip/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><p>今天看了天气，不是很热，和女朋友计划去龙潭水乡玩一玩。</p><p>坐车大概花了一个半小时，因为是快速公交，时间上节约了大概半小时。</p><p>到达指定地点后，哇，人很少，很有江南水乡的气息，和小学语文课本上见到的一样呢。</p><p>到处都是桥，路面凹凸不平，水面上的荷花很好看，景区内也有穿着汉服拍照的小哥哥小姐姐。</p><p>我和她选择了一些人比较少的地方取景，摆姿势，不得不说，自己私底下看了看讲拍摄的文章，还是很有用，女朋友夸我拍照技术也进步了，哈哈。(可想而知以前在拍照上打击的有多惨～～～)</p><p>溜达了一圈，不知是不是疫情的缘故，这里好多商家都只有店名，但房子内都已搬空，慢悠悠的走在街道上，迎面吹来的微风，看着波澜不惊的水面，心也归于平静，暂时忘却工作上的烦恼。</p><p>晚上回家，买了两斤小龙虾和自制的鸡腿抓饭当做晚饭，感谢又度过了一个轻松愉快的周末。</p><p><img src="/2020/06/07/long-tan-shui-xiang-half-a-day-trip/ltsx.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>旅行游记</category>
      </categories>
      <tags>
        <tag>龙潭水乡</tag>
        <tag>旅游</tag>
        <tag>散步</tag>
      </tags>
  </entry>
  <entry>
    <title>队列与单调队列：滑动区间最大值</title>
    <url>/2020/06/06/geekbang-column-queues-and-monotonous-queues-maximum-sliding-interval/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>滑动区间最大值，就是指在固定区间长度的前提下，在一个序列上，从前到后滑动这个区间窗口，每次窗口内部的最大值，就组成了滑动区间最大值。</p><p>例如，给你如下包含 8 个数字的序列，区间长度设置为 3：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[6 4 2] 10 3 8 5 9 -&gt; 6</span><br><span class="line">6 [4 2 10] 3 8 5 9 -&gt; 10</span><br><span class="line">6 4 [2 10 3] 8 5 9 -&gt; 10</span><br><span class="line">6 4 2 [10 3 8] 5 9 -&gt; 10</span><br><span class="line">6 4 2 10 [3 8 5] 9 -&gt; 8</span><br><span class="line">6 4 2 10 3 [8 5 9] -&gt; 9</span><br></pre></td></tr></table></figure><p>滑动区间从数字 6 开始出发，每次向右移动一个数字，同时把左边的一个数字丢出去，保持区间长度为 3，最后移动到数字 9 停止。可以看到，这个序列共包含 8 个数字，所以最后形成的滑动区间最大值共有 6 个，依次是 6、10、10、10、8、9。</p><p>常规解法：采用 O(nm) 的算法来完成，n 是区间长度，m 是窗口长度，就是枚举区间的终止位置，每次扫描区间内部，获得最大值。</p><p><strong>要求解法：时间复杂度降低到 O(n)。</strong></p><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><h3 id="初识队列"><a href="#初识队列" class="headerlink" title="初识队列"></a>初识队列</h3><p>先到先得，先入先出，每个元素都是从队列尾部入队，在头部被处理完后再出队。如下图所示：</p><p><img src="/2020/06/06/geekbang-column-queues-and-monotonous-queues-maximum-sliding-interval/queues.jpg" alt></p><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>单调队列的作用，就是用来维护在队列处理顺序中的区间最大值。维护的就是区间长度为 3 时候的最大值。当一个新的元素入队的时候，它会把其前面违反单调性的元素，都从队列中踢掉，最终将一直维护着一个最大值。</p><h3 id="滑动区间最大值"><a href="#滑动区间最大值" class="headerlink" title="滑动区间最大值"></a>滑动区间最大值</h3><p>本身就是求区间最大值的，所以也符合了单调队列应用的场景：维护在队列处理顺序中的区间最大值。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000</span></span><br><span class="line"><span class="keyword">int</span> q[MAX_N + <span class="number">5</span>], head, tail;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interval_max_number</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    head = tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// a[i] 入队，将违反单调性的从队列 q 中踢出</span></span><br><span class="line">        <span class="keyword">while</span> (head &lt; tail &amp;&amp; a[q[tail - <span class="number">1</span>]] &lt; a[i]) tail--;</span><br><span class="line">        q[tail++] = i; <span class="comment">// i 入队</span></span><br><span class="line">        <span class="comment">// 判断队列头部元素是否出了窗口范围</span></span><br><span class="line">        <span class="keyword">if</span> (i - m == q[head]) head++;</span><br><span class="line">        <span class="comment">// 输出区间内最大值</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= m) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"interval(%d, %d)"</span>, i - m + <span class="number">1</span>, i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" = %d\n"</span>, a[q[head]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数内部，依次处理数组中的每个元素，每次处理相应元素的时候，涉及到两个过程：</p><ul><li>第一个过程，是将当前元素入队。在入队之前，将队列尾部违反单调性的元素都从队列中踢出，这个就是第 7 行 while 过程的作用，之后就是将编号 i 入队即可。这里注意，单调队列里面，存储的是 a 数组的下标，而不是 a 数组的值。其实存储了下标，我们就可以索引到值，而在上一节二分查找的课里面，我们也见识过了，要是存储了值，想要反向索引下标是比较困难的。</li><li>第二个过程，就是判断单调队列头部的元素是否超出了窗口范围，也就是前面我们例子中你的学长毕业的过程，如果元素下标已经超出了窗口范围，就将队列头部元素出队。</li></ul><p>这样就可以保证，我们每次输出的，就都是滑动窗口内部的区间最大值了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>单调队列应用的场景：就是维护队列处理顺序中的区间最大值。</li><li>定义一种性质，并且维护这种性质。单调队列，维护的就是单调性。</li><li>单调队列处理单个元素的平均时间复杂度为什么是 O(1) 的。假设我们要处理 n 个元素，从整体上来看，每个元素会入队列 1 次，出队列最多也是 1 次，那么 n 个元素的总操作次数不会超过 2×n 次，平均到一个元素上就是 2 次，也就是常数次，记作 O(1) 时间复杂度。由此得知，处理 n 个元素的总时间复杂度，就是 O(n)。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>单调队列</tag>
        <tag>滑动区间</tag>
      </tags>
  </entry>
  <entry>
    <title>iPad上改变百度网盘播放速度的方法</title>
    <url>/2020/06/06/how-to-use-ipad-baiduyundisk-control-video-play-speed/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><p>百度网盘上的视频无法变速，我将分享一种我自认为最快解决的办法。</p><h2 id="步骤一：添加快捷指令"><a href="#步骤一：添加快捷指令" class="headerlink" title="步骤一：添加快捷指令"></a>步骤一：添加快捷指令</h2><p>打开<code>iPad</code>上的快捷指令；<br>选中<code>共享表单快捷指令</code>；<br>点击<code>更改视频速度</code>；<br>拉到最下面点击<code>添加快捷指令</code>。</p><h2 id="步骤二：Safari浏览器"><a href="#步骤二：Safari浏览器" class="headerlink" title="步骤二：Safari浏览器"></a>步骤二：Safari浏览器</h2><p>打开Safari浏览器，登录百度网盘，选中一个视频播放；<br>点击右上角有一个<strong>向上箭头</strong>的图标；<br>拉到下面有一个<code>更改视频速度</code>的选项；<br>选择可以接受的视频播放速度，完成。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.zhihu.com/question/65320947/answer/649400591" target="_blank" rel="noopener">iPad 百度网盘视频如何加速播放？</a><br><a href="https://www.bilibili.com/video/BV11K4y1C7S3?from=search&seid=16526850915632720540" target="_blank" rel="noopener">你的ipad还在用百度网盘和Alook看视频吗，教你免费的自定义倍速播放！</a></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Play-iPad</category>
      </categories>
      <tags>
        <tag>iPad</tag>
        <tag>百度</tag>
        <tag>网盘</tag>
        <tag>速度</tag>
      </tags>
  </entry>
  <entry>
    <title>重新认识数据结构：链表结构和思维</title>
    <url>/2020/06/03/geekbang-column-linked-list-structure-and-thinking/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>首先，我们定义一种数字名称，叫做“快乐数”。所谓快乐数就是经过有限次变换以后，等于 1 的数字。这个变换规则，给出一个非 1 的数字 a ，把它的位数拎出来，求各个位数的平方和，得到一个数字 b，如果数字 b 不是 1，那就对数字 b 的每一位数再做平方和，得到数字 c……经过不停的变换，确定最后能否得到 1。</p><p>例如，一开始的数字是 19，经过变换规则 12+92=82，得到数字 82；因为不是 1 ，所以接着做变换，就是 82+22=68，再做一次变换 62+82=100，最后一次做变换 12+02+02=1，得到了 1 以后，停止。</p><p>注：<a href="https://leetcode-cn.com/problems/happy-number/" target="_blank" rel="noopener">此题LeetCode链接</a></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul><li>首先，我们知道，整型表示的最大值是 231−1，大约是 20 亿左右。</li><li>例如，从 19 开始，依次得到的是：82、68、100、1 这些数字。也就是说，从一个数字开始，按照快乐数的计算规则，会得到一串数字序列。这其中就蕴含着链表重要的结构思维：<strong>从当前节点，唯一映射到下一个节点。快乐数序列中的数字，就是链表中的节点，如果当前数字确定了，下一个数字也就是确定了的，就像数字 19，下一个肯定是数字 82，这种映射规则，就是链表节点之间的指向关系。</strong></li><li>思维映射：所谓快乐数序列，最终的目标是能到 1，这个数字 1，其实就可以看成是链表中的空地址。</li><li>在整型范围内解决快乐数问题的话，1999999999 这个数字，按照各位平方和来进行计算，得到的下一个数字应该是 (9∗9^2+1)=730————&gt;这个快乐数链表中，节点数量绝对不会超过 731 个。一个不超过 731 个节点的链表，还总也走不到末尾，说明这个链表中有环。</li><li>因此，<strong>判断一个数字是否是快乐数，等价于判断链表中是否有环。</strong></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hasCycle</span><span class="params">(struct Node *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// p 是慢指针，q 是快指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">p</span> = <span class="title">head</span>, *<span class="title">q</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="comment">// 每次循环，p 走1步，q 走2步</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != q &amp;&amp; q); </span><br><span class="line">    <span class="keyword">return</span> p == q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="链表的操作"><a href="#链表的操作" class="headerlink" title="链表的操作"></a>链表的操作</h3><p>有如下函数接口定义：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct Node *<span class="title">erase</span><span class="params">(struct Node *head, <span class="keyword">int</span> ind)</span></span>;</span><br></pre></td></tr></table></figure><p>请你参照链表插入操作，实现一个链表节点删除的操作，删除函数传入两个参数，分别代表指向链表头结点的指针变量 head，以及要删除的节点位置 ind，返回值代表删除节点以后的链表头结点地址。</p><p>代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct Node *<span class="title">erase</span><span class="params">(strcut Node *head, <span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">ret</span>, *<span class="title">p</span> = &amp;<span class="title">ret</span>, *<span class="title">q</span>;</span></span><br><span class="line">    ret.next = head;</span><br><span class="line">    <span class="keyword">while</span> (ind--) p = p-&gt;next;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> ret.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/06/03/geekbang-column-linked-list-structure-and-thinking/linklist.jpg" alt></p><h3 id="如何求解环的长度，如上图，环的长度就是5"><a href="#如何求解环的长度，如上图，环的长度就是5" class="headerlink" title="如何求解环的长度，如上图，环的长度就是5"></a>如何求解环的长度，如上图，环的长度就是5</h3><p>如果链表中有环，那么采用快慢指针的方法，两个指针一定会在环中相遇。此时，可以让其中一个指针不动，另外一个指针再沿着环走一圈，直到两个指针再次相遇，这样，就能得到环的长度了。</p><h3 id="如何找到环的起点，如上图，3号点就是环的起点"><a href="#如何找到环的起点，如上图，3号点就是环的起点" class="headerlink" title="如何找到环的起点，如上图，3号点就是环的起点"></a>如何找到环的起点，如上图，3号点就是环的起点</h3><p>首先，假设从链表起始点到环的起点距离为 x，那么当快慢指针中的慢指针 p 刚刚走到环的起始点位置的时候，q 指针应该在环内部距离环起始点 x 的位置上，如图所示：</p><p><img src="/2020/06/03/geekbang-column-linked-list-structure-and-thinking/linklist2.jpg" alt></p><p>图中，q 指针距离环起始点 x 步，q 指针沿着链表向前走 y 步，就又可以到达环的起始点位置，如图所示 x + y 等于环长。也就是说，q 指针想要遇到 p 指针，就必须要追上 y 步的距离，又因为 p 指针每次走 1 步，q 指针每轮走 2 步，所以 q 指针每轮追上 1 步，也就是说，从此刻开始，当 q 指针追上 p 指针的时候，p 指针正好向前走了 y 步，如图所示：</p><p><img src="/2020/06/03/geekbang-column-linked-list-structure-and-thinking/linklist3.jpg" alt></p><p>此时，你会发现 p 点在环中走了 y 步以后，p 和 q 相遇了，也就意味着 p 点再走 x 步就到环的起始点了。而恰巧，从链表头结点开始到环的起始点也是 x 步，所以此时只需要让 p 站在相遇点，q 指针回到链表的起始点，然后两个指针以相同的速度，一起往后走，直到二者再次相遇的时候，相遇点就是环的起始点了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>数据结构 = 结构定义 + 结构操作，这个等式说明了我们学习数据结构的方法顺序。</li><li>单向链表节点中，存在数据域和指针域，指针域控制了链表的结构，一般不会根据应用场景的变化而变化，而数据域是根据应用场景的需求而设计的。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找：提升程序的查找效率</title>
    <url>/2020/06/03/geekbang-column-binary-search-improve-the-search-efficiency-of-the-program/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>假设你手上有 n 段长度不等的绳子，你现在想将这些绳子进行裁剪，裁剪出 k 条长度相等的绳子，注意，只能剪断绳子，不能拼接绳子。问题就是，你能得到的这 k 段绳子的最长长度是多长？</p><p><img src="/2020/06/03/geekbang-column-binary-search-improve-the-search-efficiency-of-the-program/shenzi.jpg" alt></p><p>如图所示，如果你手中有 3 条绳子，分别是 4 米、6 米 和 5 米，想要切出等长的 4 段，你会发现，每段最长就是 3 米。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul><li><p>采用枚举法，就是先尝试能不能切出至少 4 段的 1 米长绳子，如果可以的话，再去尝试每段长度 2 米是否可行，依次尝试下去，直到尝试不下去为止。最后一次尝试可行的长度，就是每段绳子的最长长度了。（效率太低，放弃。）</p></li><li><p>采用二分法。</p></li></ul><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="二分法示例代码"><a href="#二分法示例代码" class="headerlink" title="二分法示例代码"></a>二分法示例代码</h3><p>中心思想：<strong>不管如何调整区间，都要保证待查找数字，总是落在我们的由 L 和 R 标记的查找区间内部。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//入参：有序数组 arr，数组长度 n 和待查找数字 x</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;  <span class="comment">//查找区间不为空</span></span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>; <span class="comment">//l 和 r 的值，计算得到一个中间位置的下标 mid 值     </span></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == x) <span class="keyword">return</span> mid;  <span class="comment">//比较 mid 位置的值与 x 的大小关系，从而确定区间调整策略。</span></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; x) r = mid - <span class="number">1</span>;  <span class="comment">//如果 arr[mid] 大于 x，说明 x 值在区间的前半段，那么 mid 及 mid 位置以后的值，就不在下一次查找的范围之内了，我们就把区间的尾部位置 r 向前移动，移动到 mid - 1 位。</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;  <span class="comment">//arr[mid] 小于 x 时候的调整策略与之类似</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h3><ul><li>将每一段绳子的长度 x，与能切出来的绳子段数之间，看成一个映射关系，用函数 f(x) = y 来表示，代表每一段长度为 x 的情况下，最多能切出来 y 段绳子。</li><li>f 函数是一个单调函数，随着每一段长度的增加，能切出来的段数 y 是在减少的，而对于我们来说，就是要确定 y = k 时的 x 的最大值。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPS 1e-7  <span class="comment">//EPS 是一个宏，就是我们要控制的精度，一般控制在 10^−7 范围，两个值相差不到 10−7 的时候，我们就认为这两个浮点值相等。</span></span></span><br><span class="line"><span class="keyword">double</span> l[<span class="number">100</span>], n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入每一段的长度 x，返回最多能切多少段</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//变量 n 记录的是原始绳子的数量，l 数组记录的是每一段原始绳子的长度</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cnt += (<span class="keyword">int</span>)<span class="built_in">floor</span>(l[i] / x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">double</span> *l, <span class="keyword">double</span> *r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r - l &lt;= EPS) <span class="keyword">return</span> r;  <span class="comment">//递归程序的边界条件，是当 r - l 小于等于一个极小值的时候，就终止递归</span></span><br><span class="line">    <span class="keyword">double</span> mid = (l + r) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (f(mid) &lt; k) <span class="keyword">return</span> bs(l, mid, k);</span><br><span class="line">    <span class="keyword">return</span> bs(mid, r, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>二分算法框架，是求解具有单调性问题的利器。</li><li>二分算法，通常用来求解那些 f(x) = y 问题中，给定 y，求解 x 的问题。</li><li>数组和函数在思维层面，没有什么本质差别。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>算法</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>编译带OpenGL转场特技的FFmpeg</title>
    <url>/2020/06/01/build-add-gl-transition-ffmpeg/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="why"><a href="#why" class="headerlink" title="why"></a>why</h2><p>FFmpeg现成的版本里没有带<code>gl transition</code>转场特技，所以需要专门编译。</p><h2 id="step-1-clone-ffmpeg"><a href="#step-1-clone-ffmpeg" class="headerlink" title="step 1:clone ffmpeg"></a>step 1:clone ffmpeg</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://git.ffmpeg.org/ffmpeg.git ffmpeg</span><br></pre></td></tr></table></figure><p>（过程会有些漫长）</p><h2 id="step-2-x264-编译"><a href="#step-2-x264-编译" class="headerlink" title="step 2:x264 编译"></a>step 2:x264 编译</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure --enable-shared --enable-static --disable-asm  </span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h2 id="step-3-给ffmpeg打上补丁"><a href="#step-3-给ffmpeg打上补丁" class="headerlink" title="step 3:给ffmpeg打上补丁"></a>step 3:给ffmpeg打上补丁</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.将vf_gltransition.c拷贝到ffmpeg/libavfilter/</span><br><span class="line">2.在ffmpeg里面大上diff补丁，</span><br><span class="line">git apply ~/ffmpeg-gl-transition/ffmpeg.diff</span><br><span class="line">但是，也可以手动大补丁，只需要在/libavfilter/Makefile和/libavfilter/allfilters.c两个文件添加两行代码</span><br><span class="line">--- a/libavfilter/Makefile</span><br><span class="line">+++ b/libavfilter/Makefile</span><br><span class="line">@@ -367,6 +367,7 @@ OBJS-$(CONFIG_YADIF_FILTER)                  += vf_yadif.o</span><br><span class="line"> OBJS-$(CONFIG_ZMQ_FILTER)                    += f_zmq.o</span><br><span class="line"> OBJS-$(CONFIG_ZOOMPAN_FILTER)                += vf_zoompan.o</span><br><span class="line"> OBJS-$(CONFIG_ZSCALE_FILTER)                 += vf_zscale.o</span><br><span class="line">+OBJS-$(CONFIG_GLTRANSITION_FILTER)           += vf_gltransition.o</span><br><span class="line"></span><br><span class="line"> OBJS-$(CONFIG_ALLRGB_FILTER)                 += vsrc_testsrc.o</span><br><span class="line"> OBJS-$(CONFIG_ALLYUV_FILTER)                 += vsrc_testsrc.o</span><br><span class="line"> -----------------------------------------------------------</span><br><span class="line"> --- a/libavfilter/allfilters.c</span><br><span class="line">+++ b/libavfilter/allfilters.c</span><br><span class="line">@@ -357,6 +357,7 @@ extern AVFilter ff_vf_yadif;</span><br><span class="line"> extern AVFilter ff_vf_zmq;</span><br><span class="line"> extern AVFilter ff_vf_zoompan;</span><br><span class="line"> extern AVFilter ff_vf_zscale;</span><br><span class="line">+extern AVFilter ff_vf_gltransition;</span><br><span class="line"></span><br><span class="line"> extern AVFilter ff_vsrc_allrgb;</span><br><span class="line"> extern AVFilter ff_vsrc_allyuv;</span><br></pre></td></tr></table></figure><h2 id="step-4-添加依赖项"><a href="#step-4-添加依赖项" class="headerlink" title="step 4:添加依赖项"></a>step 4:添加依赖项</h2><h3 id="Ubuntu系统"><a href="#Ubuntu系统" class="headerlink" title="Ubuntu系统"></a>Ubuntu系统</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get -y install gcc g++ make xorg-dev pkg-config \</span><br><span class="line">                       libglew2.0 libglew-dev libglfw3-dev \</span><br><span class="line">                       nasm yasm libx264-dev libx265-dev libvpx-dev libglu1-mesa-dev \</span><br><span class="line">                       libmp3lame-dev libopus-dev libfdk-aac-dev</span><br></pre></td></tr></table></figure><p>如果运行命令失败，就一个个单独下。</p><h4 id="disable-EGL"><a href="#disable-EGL" class="headerlink" title="disable EGL"></a>disable EGL</h4><p>注释掉<code>define GL_TRANSITION_USING_EGL</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -v &quot;define GL_TRANSITION_USING_EGL&quot; /build/ffmpeg-gl-transition/vf_gltransition.c &gt; ffmpeg/libavfilter/vf_gltransition.c</span><br></pre></td></tr></table></figure><h2 id="step-5-编译ffmpeg"><a href="#step-5-编译ffmpeg" class="headerlink" title="step 5:编译ffmpeg"></a>step 5:编译ffmpeg</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ffmpeg; ./configure --enable-libx264 --enable-libx265 --enable-libvpx  --enable-libfdk-aac --enable-libmp3lame --enable-libopus --enable-nonfree --enable-gpl --enable-opengl --enable-filter=gltransition --extra-libs=&apos;-lGLEW -lglfw -ldl&apos;</span><br><span class="line"></span><br><span class="line">cd ffmpeg; make -j</span><br><span class="line">cd ffmpeg; make install</span><br></pre></td></tr></table></figure><p>编译结束后，执行<code>./ffmpeg</code>看到有<code>--extra-libs=&#39;-lGLEW -lglfw -ldl&#39;</code>表示编译成功。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ./ffmpeg</span><br><span class="line">ffmpeg version N-98018-gdd76226 Copyright (c) 2000-2020 the FFmpeg developers</span><br><span class="line">  built with gcc 5.4.0 (Ubuntu 5.4.0-6ubuntu1~16.04.12) 20160609</span><br><span class="line">  configuration: --enable-libx264 --enable-libx265 --enable-libvpx --enable-libfdk-aac --enable-libmp3lame --enable-libopus --enable-nonfree --enable-gpl --enable-opengl --enable-filter=gltransition --extra-libs=&apos;-lGLEW -lglfw -ldl&apos;</span><br><span class="line">  libavutil      56. 49.100 / 56. 49.100</span><br><span class="line">  libavcodec     58. 90.100 / 58. 90.100</span><br><span class="line">  libavformat    58. 44.100 / 58. 44.100</span><br><span class="line">  libavdevice    58.  9.103 / 58.  9.103</span><br><span class="line">  libavfilter     7. 84.100 /  7. 84.100</span><br><span class="line">  libswscale      5.  6.101 /  5.  6.101</span><br><span class="line">  libswresample   3.  6.100 /  3.  6.100</span><br><span class="line">  libpostproc    55.  6.100 / 55.  6.100</span><br><span class="line">Hyper fast Audio and Video encoder</span><br><span class="line">usage: ffmpeg [options] [[infile options] -i infile]... &#123;[outfile options] outfile&#125;...</span><br><span class="line"></span><br><span class="line">Use -h to get full help or, even better, run &apos;man ffmpeg&apos;</span><br></pre></td></tr></table></figure><h2 id="step-6-无窗口的时候我们可能还需要-with-glfw"><a href="#step-6-无窗口的时候我们可能还需要-with-glfw" class="headerlink" title="step 6:无窗口的时候我们可能还需要 with glfw"></a>step 6:无窗口的时候我们可能还需要 with glfw</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get -y install xvfb</span><br></pre></td></tr></table></figure><h2 id="step-7-测试"><a href="#step-7-测试" class="headerlink" title="step 7:测试"></a>step 7:测试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ffmpeg-gl-transition</span><br><span class="line">ln -s /usr/local/bin/ffmpeg .</span><br><span class="line">cd ffmpeg-gl-transition</span><br><span class="line">xvfb-run -s &apos;+iglx -screen 0 1920x1080x24&apos; bash concat.sh</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/transitive-bullshit/ffmpeg-gl-transition" target="_blank" rel="noopener">Github_ffmpeg-gl-transition</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>FFmpeg学习</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
        <tag>OpenGL</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构：大整数实战，提升 Shift-And 算法能力</title>
    <url>/2020/05/31/geekbang-column-data-structure-big-data-action-improve-Shift-And-algo-ability/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>如果给你一个文本串和模式串，让你查找文本串中是否包含模式串，你用程序怎么完成？</p><h3 id="字符串匹配问题"><a href="#字符串匹配问题" class="headerlink" title="字符串匹配问题"></a>字符串匹配问题</h3><p>在一个大的字符串里面，查找是否包含另外一个较小的字符串。</p><p><img src="/2020/05/31/geekbang-column-data-structure-big-data-action-improve-Shift-And-algo-ability/stringpipei.jpg" alt></p><h3 id="暴力法解决"><a href="#暴力法解决" class="headerlink" title="暴力法解决"></a>暴力法解决</h3><p>用模式串的首字母依次和文本串中的每一位对齐，每次对齐以后，看看所对应区域是否匹配，如果匹配就说明文本串包含模式串。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴力匹配算法程序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bruce_force</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *text, <span class="keyword">const</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历文本串每一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; text[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从文本串的第 i 位开始与模式串进行匹配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; p[j]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text[i + j] == p[j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 当代码到了这里，说明某一位不匹配</span></span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度是 O(nm)，其中，n 是文本串的长度，m 是模式串的长度。<br>如果文本串长度是 10，模式串长度是 3，那么这个程序差不多要计算 30 次，外层循环 10 次，内层循环每次循环 3 次。</p><p>效率比较差，放弃。</p><h2 id="Shift-And-算法"><a href="#Shift-And-算法" class="headerlink" title="Shift-And 算法"></a>Shift-And 算法</h2><p>基本流程：首先做信息的转换，然后利用位运算，完成单模匹配问题。</p><h3 id="Shift-And-中的信息转换"><a href="#Shift-And-中的信息转换" class="headerlink" title="Shift-And 中的信息转换"></a>Shift-And 中的信息转换</h3><p><img src="/2020/05/31/geekbang-column-data-structure-big-data-action-improve-Shift-And-algo-ability/bianma.jpg" alt></p><h3 id="利用位运算做匹配"><a href="#利用位运算做匹配" class="headerlink" title="利用位运算做匹配"></a>利用位运算做匹配</h3><p><img src="/2020/05/31/geekbang-column-data-structure-big-data-action-improve-Shift-And-algo-ability/pipei.jpg" alt></p><p>我们假设模式串的长度是 m ，code(str[i]) 代表了文本串第 i 位字符的编码，整个匹配过程，从前往后，依次处理文本串的每一位，处理到第 i 位的时候，就是用第 i 位字符的编码（code（str[i])），与 p 左移 1 位并或上 1 以后的值（p&lt;&lt; 1 | 1），做“按位与”运算，把得到的值赋给 p 变量。最终，当 p 的二进制表示的第 m 位为 1 时，说明匹配成功了。</p><p>示例，当模式串为 cdd，文本串为 acdd 时候的匹配流程：</p><p><img src="/2020/05/31/geekbang-column-data-structure-big-data-action-improve-Shift-And-algo-ability/shili.jpg" alt></p><h3 id="p-公式的理解与推导"><a href="#p-公式的理解与推导" class="headerlink" title="p 公式的理解与推导"></a>p 公式的理解与推导</h3><p><img src="/2020/05/31/geekbang-column-data-structure-big-data-action-improve-Shift-And-algo-ability/p.jpg" alt></p><p>其中 pm​ 代表 p 的二进制表示的第 m 位为 1，pm−1​ 表示 p 的二进制表示的第 m-1 位为 1。因为只有第 m-1 位为 1，才可能左移 1 位以后的结果第 m 位为 1。</p><h3 id="实现Shift-And-算法"><a href="#实现Shift-And-算法" class="headerlink" title="实现Shift-And 算法"></a>实现Shift-And 算法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shift_and</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *p_str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> code[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;, m = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始化每一个字符的编码</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; p_str[i]; i++, m++) &#123;</span><br><span class="line">        code[p_str[i]] |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        p = (p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &amp; code[str[i]];</span><br><span class="line">        <span class="comment">// 如果 p 所对应的模式串最高位为1，代表匹配成功</span></span><br><span class="line">        <span class="keyword">if</span> (p &amp; (<span class="number">1</span> &lt;&lt; (m - <span class="number">1</span>))) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>该算法只用了两次循环，一次循环是遍历模式串，生成编码 code 信息，第二次循环是遍历文本串 str，循环迭代得到 p 变量的值，直到 p 变量的第 m 位为 1 时，就代表匹配成功。</li><li>时间复杂度就是 O(n + m) 。意味着，同样是文本串 10000 的长度，模式串 1000 长度，Shift-And 算法，是暴力匹配算法效率的 1000 倍！</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>等价信息表示对于解决问题很重要。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构：突破基本类型的限制，存储更大的整数</title>
    <url>/2020/05/31/geekbang-column-data-structure-break-through-the-limitation-of-basic-types-and-store-larger-integers/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>请你实现一个程序，输出 2 的 1000 次方的结果是多少。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul><li>C 语言中给我们提供的 int 类型，肯定是无法完成这个任务的，因为它表示不了这么大的数字。</li><li>用 long long 类型来进行解决，但long long 是 64 位整型，也就是占 64 个 2 进制位，它顶多能表示 2 的 64 次方减 1 的结果，相对于 2 的 1000 次方来说，小太多了。</li><li>用double类型进行解决，但存在一个严重的问题，就是 double 是有精度损失的。<br>（double 的表示精度，一般来说是有效数字 15 位，就是一个数字，由左向右，从第一个不为零的数字起，向后 15 位都是准确的。因此 double 类型实际上也没有办法，准确表示 2 的 1000 次方的计算结果。）</li></ul><p>那该怎么办呢？</p><h2 id="编码解决"><a href="#编码解决" class="headerlink" title="编码解决"></a>编码解决</h2><h3 id="大整数表示法"><a href="#大整数表示法" class="headerlink" title="大整数表示法"></a>大整数表示法</h3><p><img src="/2020/05/31/geekbang-column-data-structure-break-through-the-limitation-of-basic-types-and-store-larger-integers/dazhengshu.jpg" alt></p><p>这种表示法中，使用数组的第 0 位存储数字的位数，因为 3526 有 4 位，所以数组的第 0 位就设置成了 4 这个值。接下来，数组从第 1 位到第 4 位记录的就是原数字 3526。</p><p>注意：这个数字是好像是倒着放置的，数字的最高位，也放在数组的最高位中。</p><h3 id="如何计算大整数加法"><a href="#如何计算大整数加法" class="headerlink" title="如何计算大整数加法"></a>如何计算大整数加法</h3><p>计算 445 + 9667：</p><p><img src="/2020/05/31/geekbang-column-data-structure-break-through-the-limitation-of-basic-types-and-store-larger-integers/dazhengshujiafa.jpg" alt></p><p>首先我们用大整数表示法，分别表示 445 和 9667 这两个数字；然后以位数最长的那个大整数，作为计算结果大整数的基础位数，445 和 9667 按位相加，得到一个 4 位的结果大整数，4 位分别是，9、10、10、12；最后我们再依次处理进位，就得到了底下那一行的结果：10112。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个交换两个变量值的宏 swap</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123; \</span></span><br><span class="line">    __typeof(a) <span class="keyword">_t</span> = a; \</span><br><span class="line">    a = b, b = <span class="keyword">_t</span>; \</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现大整数加法 a + b 的结果，存放在 c 中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">plus_big_integer</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 让 a 指向位数较长的那个数字</span></span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]) swap(a, b);</span><br><span class="line">    <span class="comment">// 大整数 c 的位数以 a 的位数为基准</span></span><br><span class="line">    c[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 循环模拟按位做加法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= b[<span class="number">0</span>]) c[i] = a[i] + b[i];      </span><br><span class="line">        <span class="keyword">else</span> c[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理每一位的进位过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c[i] &lt; <span class="number">10</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 判断是不是最高位产生了进位</span></span><br><span class="line">        <span class="comment">// 如果是最高位产生进位，就进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (i == c[<span class="number">0</span>]) c[++c[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">        c[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>要计算 2 的 1000 次方的结果，就是要计算 1000 次乘法，最终的结果由于数值太大，我们肯定要使用大整数表示法了，所以要想理解这个计算过程，我们还是得回到大整数表示法本身，所对应的数学模型理解上。</p><p><img src="/2020/05/31/geekbang-column-data-structure-break-through-the-limitation-of-basic-types-and-store-larger-integers/dazhengshushiyi.jpg" alt></p><p>如上图所示，我们把大整数表示法中，每一个数字所对应的位权写出来，那么数组中所存储 3、5、2、6 的大整数信息，其实等价于下面的那一行数学公式，即 3∗10^3+5∗10^2+2∗10^1+6∗10^0。</p><p>我们对 3526 这个大整数乘以 2，其实等价于对下面那个数学式子乘以 2，就可以得到如下结果：</p><p><img src="/2020/05/31/geekbang-column-data-structure-break-through-the-limitation-of-basic-types-and-store-larger-integers/dazhengshushiyi2.jpg" alt></p><p>对某个大整数乘 2 的操作，其实，可以看成是对这个大整数的每一位分别乘以 2 的操作，然后再仿照大整数加法的过程，依次处理进位即可。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 num 数组初始化成大整数表示的 1</span></span><br><span class="line"><span class="comment">// 作用就是做累乘变量</span></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">400</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算 100 次 2 的 10 次方相乘的结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 对大整数的每一位乘以 2 的 10 次方</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= num[<span class="number">0</span>]; j++) num[j] *= <span class="number">1024</span>;      </span><br><span class="line">        <span class="comment">// 处理进位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= num[<span class="number">0</span>]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[j] &lt; <span class="number">10</span>) <span class="keyword">continue</span>;          </span><br><span class="line">            <span class="keyword">if</span> (j == num[<span class="number">0</span>]) num[++num[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">            num[j + <span class="number">1</span>] += num[j] / <span class="number">10</span>;</span><br><span class="line">            num[j] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出大整数</span></span><br><span class="line">    <span class="comment">// 由于大整数是倒着存的，所以输出的时候倒着遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num[<span class="number">0</span>]; i &gt;= <span class="number">1</span>; --i) <span class="built_in">printf</span>(<span class="string">"%d"</span>, num[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出</span></span><br><span class="line"><span class="comment"> * 10715086071862673209484250490600018105614048117055336074437503883703510511249361224931983788156958581275946729175531468251871452856923140435984577574698574803934567774824230985421074605062371141877954182153046474983581941267398767559165543946077062914571196477686542167660429831652624386837205668069376/</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>在大整数的表示法中，数字是从右到左，倒着存放在数组中的。</li><li>大整数的表示法，体现的是数据结构对于程序设计的作用。</li><li>大整数的加法和乘法过程，体现的则是算法对于程序设计的作用。</li><li><strong>算法的底层是数学。</strong></li><li>如果是计算流程不合理，我们需要改进算法；如果是数据表示受限，我们需要求助于数据结构。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>大整数表示法</tag>
        <tag>高精度表示法</tag>
      </tags>
  </entry>
  <entry>
    <title>框架思维：用筛法求解其他积性函数</title>
    <url>/2020/05/31/geekbang-column-frame-thinking-solve-other-productive-fuctions-by-sieve-method/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>求出 10000 以内所有数字的因数和。</p><p>可能已经想好的方法：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">10005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 循环遍历 1 到 10000 的所有数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 用 j 循环枚举数字 i 可能的因数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="comment">// 当 i%j 不等于 0 时，说明 j 不是 i 的因数</span></span><br><span class="line">            <span class="keyword">if</span> (i % j) <span class="keyword">continue</span>;</span><br><span class="line">            sum[i] += j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init_sum();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效率较低，所以弃了。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="数论积性函数"><a href="#数论积性函数" class="headerlink" title="数论积性函数"></a>数论积性函数</h3><p>所谓数论积性函数，首先，是作用在正整数范围的函数，也就是说函数 f(x) = y 中的 x 均是正整数。其次，是数论积性函数的一个最重要的性质，就是如果 n 和 m 互质，那么 f(n*m) = f(n) * f(m) 。</p><p><img src="/2020/05/31/geekbang-column-frame-thinking-solve-other-productive-fuctions-by-sieve-method/shulun.jpg" alt></p><h3 id="因数个数函数"><a href="#因数个数函数" class="headerlink" title="因数个数函数"></a>因数个数函数</h3><p>因数个数：就不难理解了，它指的是一个数字因数的数量。例如，数字 6，有 1、2、3、6 这 4 个因数，因数个数就是 4。</p><h3 id="素数筛框架"><a href="#素数筛框架" class="headerlink" title="素数筛框架"></a>素数筛框架</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000</span></span><br><span class="line"><span class="keyword">int</span> prime[MAX_N + <span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_prime</span><span class="params">()</span> </span>&#123;  <span class="comment">//初始化 prime 数组信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= MAX_N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prime[i]) <span class="keyword">continue</span>;  <span class="comment">//prime[i] 中记录的是数字 i 中最小的素因子</span></span><br><span class="line">        <span class="comment">// 素数中最小的素因子是其本身</span></span><br><span class="line">        prime[i] = i;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= MAX_N; j += i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prime[j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 如果 j 没有被标记过，就标记成 i</span></span><br><span class="line">            prime[j] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prime[i] == <span class="number">0</span>) prime[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000</span></span><br><span class="line"><span class="keyword">int</span> prime[MAX_N + <span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> g_cnt[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_g_cnt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 的因数数量就是 1 个</span></span><br><span class="line">    g_cnt[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = i, cnt = <span class="number">0</span>, p = prime[i];</span><br><span class="line">        <span class="comment">// 得到数字 n 中，包含 cnt 个最小素因子 p</span></span><br><span class="line">        <span class="keyword">while</span> (n % p == <span class="number">0</span>) &#123;</span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">            n /= p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时数字 n 和最小素数 p 部分，就是互素的</span></span><br><span class="line">        g_cnt[i] = g_cnt[n] * (cnt + <span class="number">1</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>所谓代码框架，就是要活学活用。</li><li>在真正的工作中，你所做的事情，大多是在多种代码框架之间做选择及组合拼装，每个算法代码只会解决遇到的一部分问题。而你在使用这些算法代码的时候，往往不能照搬照用，反而要做一些适应性的改变，这些都是“框架思维”中所重视的。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>拉勾直播_90分钟带你玩转BAT算法面试_吃相难看</title>
    <url>/2020/05/26/lagou-live-90min-play-BAT-algo-interview/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="直播内容"><a href="#直播内容" class="headerlink" title="直播内容"></a>直播内容</h2><ul><li><del>1，为什么算法是大厂面试的必备项？</del></li><li><del>2，大厂高频算法面试题剖析</del></li><li><del>3，剖析大厂青睐的必备技能</del></li><li>4，想成为高薪Java工程师，该怎么办？</li></ul><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>麻烦用点心吧，123一晃而过，4才是重点——推销课程。</p><p>这样的直播，不听也罢。</p><p>在此建议各位，如果遇到这种免费直播，听听就好，别太认真，有些直播已推销为主，另外也需要认清自己，以及是否真的需要报班来学习，千万别被洗脑！</p><p>写以此文，记录这糟糕、吃相难看的直播。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>直播分享</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>算法</tag>
        <tag>BAT</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-287-find-the-duplicate-number | 寻找重复数</title>
    <url>/2020/05/26/Leetcode-287-find-the-duplicate-number/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">find-the-duplicate-number</a></p><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><ul><li>建立一个key为int，value为int的map；</li><li>第一遍<code>for range</code>循环遍历<code>nums</code>数组，将<code>nums</code>数组里的元素出现的次数记录进<code>map</code>中；</li><li>第二遍<code>for range</code>循环遍历<code>map</code>，将value不为1的num取出返回，即为重复数。</li></ul><p>这个解法需要用两次<code>for</code>循环，效率不高，下面我考虑用第二种解法。</p><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><ul><li>建立一个key为int，value为bool类型的map；</li><li>一遍<code>for range</code>循环遍历<code>nums</code>数组，如果这个<code>num</code>第一次出现，就将其value置为true，否则直接返回这个<code>num</code>，因为value为true代表这个<code>num</code>已经出现过一次了，第二次再遍历到它时，即为重复数。</li></ul><p>go代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> numsmap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> _,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> !numsmap[num] &#123;</span><br><span class="line">            <span class="comment">//只出现一次</span></span><br><span class="line">            numsmap[num] = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>map</tag>
        <tag>循环</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title>框架思维：将素数筛算法写成框架算法</title>
    <url>/2020/05/24/geekbang-column-frame-thinking-write-the-prime-sieve-algo-as-a-frame-algo/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>求 1 万以内所有素数的和。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="素数筛算法介绍"><a href="#素数筛算法介绍" class="headerlink" title="素数筛算法介绍"></a>素数筛算法介绍</h3><p>所谓素数筛，是将其产出的信息存储在一个标记数组中，数组的第 i 位，标记的是 i 这个数字是否是合数的信息。如果 i 这个数字是合数，数组下标为 i 的位置就被标记成为 1，如果 i 不是合数，则数组下标为 i 的位置就是 0。素数筛就是通过一套算法流程，产生一个这样的数组。</p><p>算法流程：<br><img src="/2020/05/24/geekbang-column-frame-thinking-write-the-prime-sieve-algo-as-a-frame-algo/sushu-algo.jpg" alt></p><h3 id="素数筛代码框架"><a href="#素数筛代码框架" class="headerlink" title="素数筛代码框架"></a>素数筛代码框架</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[<span class="number">10005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 素数筛的标记过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= <span class="number">10000</span>; i++) &#123;  <span class="comment">//从 2 开始遍历到根号 10000，也就是 100。</span></span><br><span class="line">        <span class="comment">//i &lt;= sqrt(10000) == i * i &lt;= 10000</span></span><br><span class="line">        <span class="comment">//这种改变是有好处的，会在代码运行速度上做提升，毕竟开方运算是很慢的，远远没有单独做一个乘法操作要快。</span></span><br><span class="line">        <span class="keyword">if</span> (prime[i]) <span class="keyword">continue</span>;  <span class="comment">//判断 i 这个数字是否被标记过的，如果被标记过，就说明是合数，就不执行后续操作。</span></span><br><span class="line">        <span class="comment">// 用 j 枚举所有素数 i 的倍数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= <span class="number">10000</span>; j += i) &#123;</span><br><span class="line">            prime[j] = <span class="number">1</span>; <span class="comment">// 将 j 标记为合数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000</span></span><br><span class="line"><span class="keyword">int</span> prime[MAX_N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化素数表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     prime[<span class="number">0</span>] = prime[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= MAX_N; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (prime[i]) <span class="keyword">continue</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= MAX_N; j += i) &#123;</span><br><span class="line">             prime[j] = <span class="number">1</span>; <span class="comment">// 将 j 标记为合数</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init_prime();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line">        sum += i * (<span class="number">1</span> - prime[i]); <span class="comment">// 素数累加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：5736396</span></span><br></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1，因子分解程序正确性证明"><a href="#1，因子分解程序正确性证明" class="headerlink" title="1，因子分解程序正确性证明"></a>1，因子分解程序正确性证明</h3><blockquote><p>所谓的素因子分解，就是把一个整数，表示成为若干个素数相乘的形式，并且我们可以轻松的证明，这种只由素数表示的分解表示法，对于某个特定整数 N 来说，一定是唯一的。<br>例如，67689 这个数字就可以分解为：3 * 3 * 3 * 23 * 109 = 67689，其中 3、23、109 都是素数。</p></blockquote><p>下面呢，有一段素因子分解的程序：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个素因子，并且在中间输出 * 乘号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_num</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> *flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*flag == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">" * "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, num);</span><br><span class="line">    *flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i = <span class="number">2</span>, flag = <span class="number">0</span>, raw_n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    raw_n = n;</span><br><span class="line">    <span class="comment">// 循环终止条件，循环到 n 的平方根结束</span></span><br><span class="line">    <span class="keyword">while</span> (i * i &lt;= n) &#123;</span><br><span class="line">        <span class="comment">//①：只要 n 可以被 i 整除，就认为 i 是 n 的一个素因子</span></span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            print_num(i, &amp;flag);</span><br><span class="line">            n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//②：如果最后 n 不等于 1，就说明 n 是最后一个素数</span></span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">1</span>) print_num(n, &amp;flag);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" = %d\n"</span>, raw_n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试证明：</p><ul><li><p>1，第 18 行代码中，只要 n 可以被 i 整除，i 就一定是素数，为什么？<br>假设 i 可以被 n 整除，但 i 不是素数，由算术基本定理可知，一个非素数的数字 N，一定可以分解为几个小于 N 的素数乘积的形式。我们不妨假设 i=p1​×p2​，这里 p1​ 和 p2​ 均为素数，如果变量 n 可以被 i 整除，那么 n 也一定可以被小于 i 的素数 p1​ 整除。而根据程序的运行流程，n 中已经不可能存在小于 i 的因子了，所以 p1​ 不具备存在的条件，故原假设不成立，i 是素数。</p></li><li><p>2，第 25 行代码中，为什么只要 n 不等于 1，n 就一定是素数呢？<br>在 while 循环处理过程中，数字 n 中已经不可能存在小于等于 i 的所有的因子了，又因为此时 i 是大于根号 n 的一个值，也就是说，在小于等于根号 n 范围内，找不到数字 n 的非 1 因子，而能够满足这种性质的数字，一定是素数。</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>想把具体“算法”升华成“算法思维”，首先要习惯性地总结算法的“框架思维”。</li><li>素数筛是用素数去标记掉这个素数所有的倍数。</li><li>清楚地知道素数筛在执行过程中，每一行的性质。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>框架</tag>
        <tag>素数</tag>
        <tag>合数</tag>
      </tags>
  </entry>
  <entry>
    <title>程序设计原则：把计算过程交给计算机</title>
    <url>/2020/05/24/geekbang-column-give-the-calculation-process-to-the-computer/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>求出 1000 以内所有 3 或 5 倍数的数字的和。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="一份合格的程序实现"><a href="#一份合格的程序实现" class="headerlink" title="一份合格的程序实现"></a>一份合格的程序实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1000</span>; i++) &#123;  <span class="comment">//循环遍历 1000 以内的所有整数</span></span><br><span class="line">        sum += i * (i % <span class="number">3</span> == <span class="number">0</span> || i % <span class="number">5</span> == <span class="number">0</span>);  <span class="comment">//把 3 或 5 的倍数累加到变量 sum 中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum);  <span class="comment">//最后输出 sum 变量的值，就是 1000 以内，所有 3 或 5 的倍数和。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提升计算效率"><a href="#提升计算效率" class="headerlink" title="提升计算效率"></a>提升计算效率</h3><p>利用等差数列求和公式：<br><img src="/2020/05/24/geekbang-column-give-the-calculation-process-to-the-computer/gongshi.jpg" alt></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum3 = (<span class="number">3</span> + <span class="number">999</span> / <span class="number">3</span> * <span class="number">3</span>) * (<span class="number">999</span> / <span class="number">3</span>) / <span class="number">2</span>;  <span class="comment">//1000 以内所有 3 的倍数的和 sum3</span></span><br><span class="line">    <span class="keyword">int</span> sum5 = (<span class="number">5</span> + <span class="number">999</span> / <span class="number">5</span> * <span class="number">5</span>) * (<span class="number">999</span> / <span class="number">5</span>) / <span class="number">2</span>;  <span class="comment">//1000 以内所有 5 的倍数的和 sum5</span></span><br><span class="line">    <span class="keyword">int</span> sum15 = (<span class="number">15</span> + <span class="number">999</span> / <span class="number">15</span> * <span class="number">15</span>) * (<span class="number">999</span> / <span class="number">15</span>) / <span class="number">2</span>; <span class="comment">//1000 以内所有 15 的倍数的和 sum15</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum3 + sum5 - sum15);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1，和的平方减平方和"><a href="#1，和的平方减平方和" class="headerlink" title="1，和的平方减平方和"></a>1，和的平方减平方和</h3><blockquote><ol><li>请编写一个程序，计算 100 以内自然数“和的平方”与“平方和”的差。</li><li>能否通过查阅资料，推导得到等差数列的平方和公式呢？</li></ol></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hepingfang</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> + n) * (<span class="number">1</span> + n) * n / <span class="number">4</span> + n * (n * n - <span class="number">1</span>) / <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pingfanghe</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> + n) * (<span class="number">1</span> + n) * n / <span class="number">4</span> + n * (n * n - <span class="number">1</span>) / <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算 100 以内自然数“和的平方”与“平方和”的差</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d - %d = %d\n"</span>,hepingfang(n),pingfanghe(n),hepingfang(n)-pingfanghe(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>具体的计算过程，计算机比你更擅长，所以请把具体的计算过程，留给计算机。</li><li>编写程序，其实是在描述和规定计算过程，而描述的方式不同，效率也不同。</li><li>不同的效率过程，就是我们所谓的不同的算法过程，记住：算法很重要。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>数字</tag>
        <tag>数列</tag>
      </tags>
  </entry>
  <entry>
    <title>数学归纳法：搞定循环与递归的钥匙</title>
    <url>/2020/05/24/geekbang-column-math-induction-the-key-to-loop-and-recursion/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>实现一个可变循环层数的程序。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>我们可以一开始假设，有一个函数，是实现 5 层循环打印的程序，那么它会循环 n 次，每次调用一个实现 4 层循环打印的程序。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码框架</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_loop</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//代表 k 层循环的程序，然后循环 n 次，每次调用一个 k - 1 层循环的程序。</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 打印一行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        print_loop(k - <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完善程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">100</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">入参：</span></span><br><span class="line"><span class="comment">total_k，代表了一共有多少层循环，这个参数是为了方便我们最后确定循环输出的上界</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_loop</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> total_k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = total_k; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != total_k) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        arr[k] = i;</span><br><span class="line">        print_loop(k - <span class="number">1</span>, n, total_k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, fib(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段程序中，fib 函数是求菲波那契数列第 n 项值的函数。菲波那契数列的定义如下：<br><img src="/2020/05/24/geekbang-column-math-induction-the-key-to-loop-and-recursion/fib.jpg" alt><br>根据如上内容，你需要完成两个小的思考题：</p><h3 id="1，请将上述菲波那契数列求解的程序从递归程序，改成循环程序。"><a href="#1，请将上述菲波那契数列求解的程序从递归程序，改成循环程序。" class="headerlink" title="1，请将上述菲波那契数列求解的程序从递归程序，改成循环程序。"></a>1，请将上述菲波那契数列求解的程序从递归程序，改成循环程序。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归写法</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if (n == 1 || n == 2) return 1; // 终止条件 -- 数学归纳法step1</span></span><br><span class="line"><span class="comment">        return fib(n-1) + fib(n-2); // 处理过程 -- 数学归纳法step2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环写法</span></span><br><span class="line">    <span class="keyword">int</span> f1 = <span class="number">1</span>, f2 = <span class="number">1</span>, f3;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        f3 = f1 + f2;</span><br><span class="line">        f1 = f2;</span><br><span class="line">        f2 = f3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2，请将上述递归程序的代码和数学归纳法中的步骤做一一对应。"><a href="#2，请将上述递归程序的代码和数学归纳法中的步骤做一一对应。" class="headerlink" title="2，请将上述递归程序的代码和数学归纳法中的步骤做一一对应。"></a>2，请将上述递归程序的代码和数学归纳法中的步骤做一一对应。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//数学归纳法中所谓的 k0​ 成立，这一步保证了，fib 函数计算的第 1 项 和 第 2 项的斐波那契函数值一定是正确的。</span></span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);  <span class="comment">//数学归纳法中的第二步，假设 ki​ 成立，证明 ki+1​ 也成立。</span></span><br><span class="line">    <span class="comment">//最后结论，这个fib 递归函数设计是正确的。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, fib(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>数学归纳法中重要的两部分，一是要边界条件成立，二是证明转移过程成立。</li><li>程序设计最重要的是正确性，递归函数的正确性可以利用数学归纳法来保证。</li><li>递归程序设计中的重要的两部分：边界条件和处理过程。所谓边界条件，就是当递归函数中的参数等于多少的时候，可以直接返回的条件。处理过程呢，就是设计程序过程，处理递归调用的返回结果，根据递归调用的返回结果，得到本函数的结果。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>循环</tag>
        <tag>递归</tag>
        <tag>数学</tag>
        <tag>归纳</tag>
      </tags>
  </entry>
  <entry>
    <title>预处理命令：让编译器帮你写代码</title>
    <url>/2020/05/23/geekbang-column-Pre-processing-cmd-let-the-compiler-write-the-code-for-you/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>请你实现一个打印“漂亮日志格式”的方法。</p><p>首先我们先说“日志”的作用，程序中的“日志”，通常是指在程序运行过程中，输出的一些与程序当前状态或者数据相关的一些信息。这些信息，可以帮助程序开发人员做调试，帮助运营人员做数据分析，帮助管理人员分析日活等等。总而言之，一份合理的日志信息，是非常有价值的数据。而我们今天呢，接触一种最简单的日志形式，就是程序运行过程中的调试信息。</p><p>请你实现一个参数形式和 printf 函数一样的 log 方法，用法如代码所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">    func(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会看到上述代码中，有一个和 printf 名字不一样可用法完全一样的方法叫做 log，而这个 log 的输出结果，和 printf 可不一样。</p><p>具体如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = 123</span><br><span class="line">[main, 10] a = 123</span><br><span class="line">[func, 4] a = 123</span><br></pre></td></tr></table></figure><p>你会看到 log 的方法，虽然和 printf 函数的用法一致，可在输出内容中，log 方法的输出明显比 printf 函数的输出要多了一些信息。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>如何定义一个支持可变参数的log宏：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> log(frm, args...) <span class="comment">// 假装这里有内容，后续展开讲解</span></span></span><br></pre></td></tr></table></figure><p>所以可以将 log 方法的使用方式与 printf 类似了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> log(frm, args...) printf(frm, args)</span></span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> log(frm, args...) &#123; \</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%s : %d] "</span>,__func__,__LINE__); \</span><br><span class="line">    <span class="built_in">printf</span>(frm, ##args); \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//"##"的作用是对token进行连接，这里的args就是token,如果token为空，那么不进行连接，所以允许省略可变参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//[main : 11] hello world</span></span><br></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1，没有-Bug-的-MAX-宏"><a href="#1，没有-Bug-的-MAX-宏" class="headerlink" title="1，没有 Bug 的 MAX 宏"></a>1，没有 Bug 的 MAX 宏</h3><blockquote><p>请你完善下面代码中的 MAX 宏，MAX 宏的作用，就是接受两个元素，选择出两个元素中的最大值。<br>完善以后的 MAX 宏，输出需要与如下给出的输出样例一致，注意，只能修改 MAX 宏的定义内容，不可以修改主函数中的内容。</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P(item) printf(<span class="meta-string">"%s = %d\n"</span>, #item, item);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) <span class="comment">// TODO</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line">    P(MAX(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    P(<span class="number">5</span> + MAX(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    P(MAX(<span class="number">2</span>, MAX(<span class="number">3</span>, <span class="number">4</span>)));</span><br><span class="line">    P(MAX(<span class="number">2</span>, <span class="number">3</span> &gt; <span class="number">4</span> ? <span class="number">3</span> : <span class="number">4</span>));</span><br><span class="line">    P(MAX(a++, <span class="number">5</span>));</span><br><span class="line">    P(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果参考：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">MAX(2, 3) = 3</span></span><br><span class="line"><span class="comment">5 + MAX(2, 3) = 8</span></span><br><span class="line"><span class="comment">MAX(2, MAX(3, 4)) = 4</span></span><br><span class="line"><span class="comment">MAX(2, 3 &gt; 4 ? 3 : 4) = 4</span></span><br><span class="line"><span class="comment">MAX(a++, 5) = 6</span></span><br><span class="line"><span class="comment">a = 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>实现（思考过程是重点）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) (&#123; \</span></span><br><span class="line">    __typeof(a) __a = (a), __b = (b); \</span><br><span class="line">    __a &gt; __b ? __a : __b; \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>C 语言的程序编译是一套过程，中间你必须搞懂的有：预处理阶段，编译阶段和链接阶段。</li><li>程序最终的功能，是由“待编译源码”决定的，而“待编译源码”是由各种各样的预处理命令决定的。</li><li>预处理命令之所以被称为“黑魔法”，是因为编译器会根据预处理命令改变你的源代码，这个过程，神秘而具有力量，功能强大。</li><li>代码中反斜杠的后面，不能出现任何其他内容。</li><li>宏定义只占用一行代码，为了增强宏定义的代码可读性，我们可以采用在行尾加反斜杠的技巧，来使得上下两行代码，变成编译器眼中的一行代码。</li><li>宏的作用，就是替换，要想理解最终的代码行为，必须从宏替换以后的代码入手分析。</li><li>条件编译相当于一种预处理阶段的代码剪裁技巧。</li><li>编译器预设的宏，有标准的，也有非标准的，非标准的代码会影响其可移植性。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>预处理</tag>
        <tag>宏定义</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手实现低配版 scanf 函数</title>
    <url>/2020/05/23/geekbang-column-DIY-scanf-function-by-yourself/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>仿照 scanf 函数，实现一个低配版的 my_scanf 函数。这个函数的功能，简单来说就是将一个字符串信息转换成整型数字，能够完成这个任务，你会更深刻的理解 scanf 函数，更深刻的理解参数设计。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个基础功能</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">98</span>;</span><br><span class="line">my_scanf(<span class="string">"12345"</span>, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, n); <span class="comment">// 输出 12345，而不是 98</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个基础功能</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">98</span>, m = <span class="number">0</span>;</span><br><span class="line">my_scanf(<span class="string">"123 45"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"n = %d m = %d"</span>, n, m); <span class="comment">// 输出 n = 123 m = 45</span></span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_scanf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> *ret)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, flag = <span class="number">0</span>;  <span class="comment">//定义存放转换结果的 num 变量，用来标记正负数的flag 变量。0 代表正数，1 代表负数。</span></span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'-'</span>) str += <span class="number">1</span>, flag = <span class="number">1</span>; <span class="comment">//判断字符串中的第一位是不是字符 ‘-’，如果是字符 ‘-’，就将 flag 标记为 1，并且把 str 字符指针所指的位置，向后跳动一位，因为 ‘-’ 后面就是要转换的第一个数字字符了。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        num = num * <span class="number">10</span> + (str[i] - <span class="string">'0'</span>);  <span class="comment">//遍历字符串剩余的每一位，每次将当前字符所代表的数字，放到 num 数字的末尾。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) num = -num;  <span class="comment">//如果是负数，数字前需要加-</span></span><br><span class="line">    *ret = num;  <span class="comment">//把 num 中的值拷贝到 ret 所指向的存储区中，也就是主函数中的 n 变量的内存区中。</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1000</span>];  <span class="comment">//定义字符数组 str</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">65</span>;  <span class="comment">//定义整型变量 n</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);  <span class="comment">//读入一个字符串，将其保存在字符数组中</span></span><br><span class="line">    my_scanf(str, &amp;n);  <span class="comment">//使用 my_scanf 函数将字符数组中的字符串信息，转换成为整型信息存储在 n 中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n = %d\n"</span>, n);  <span class="comment">//使用 printf 函数输出 n 的值，加以确认</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>函数的作用，是做功能封装，以便在程序其他地方复用相关功能。</li><li>函数的参数传递过程，就是“实参”给“形参”赋值的过程，“实参”与“形参”之间互相独立，互不影响。</li><li>在函数参数设计中，一定要分清楚，传入参数和传出参数在功能上的差别。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>scanf</tag>
      </tags>
  </entry>
  <entry>
    <title>指针系列_指针变量也是变量</title>
    <url>/2020/05/23/geekbang-column-pointer-variables-are-also-variables/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>假设有如下结构体数组，请看如下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125; a[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>请用尽可能多的形式，替换下面代码中 &amp;a[1].x 的部分，使得代码效果不变：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> *<span class="title">p</span> = <span class="title">a</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p"</span>, &amp;a[<span class="number">1</span>].x);</span><br></pre></td></tr></table></figure><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="方法一，间接引用"><a href="#方法一，间接引用" class="headerlink" title="方法一，间接引用"></a>方法一，间接引用</h3><p>减号大于号（-&gt;），组合起来，叫做“间接引用”运算符，作用可以和“直接引用”运算符对比。</p><p>例如：a 是一个结构体变量，a 中有一个字段叫做 x，由 a 去找到 x，这个过程比较直接，我们就用 a.x 来表示。可如果 p 是一个指针，指向 a 变量，如果要是由 p 去找到 x，这个过程就是个间接的过程，所以我们就使用 p-&gt;x。<br>简单来说，就是：<strong>是结构体变量引用字段，就直接引用，如果是指针想引用字段，就是间接引用。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125; a[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> *<span class="title">p</span> = <span class="title">a</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p"</span>, &amp;((a + <span class="number">1</span>)-&gt;x));  <span class="comment">//用a+1定位到第二个结构体元素的首地址，然后间接引用x字段，最后再对 x 字段取地址，那么得到的和原任务中所输出的地址是一样的。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0x55e3c8fa0028</span></span><br></pre></td></tr></table></figure><h3 id="方法二，巧妙使用指针类型"><a href="#方法二，巧妙使用指针类型" class="headerlink" title="方法二，巧妙使用指针类型"></a>方法二，巧妙使用指针类型</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125; a[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> *<span class="title">p</span> = <span class="title">a</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p"</span>, &amp;(a[<span class="number">0</span>].y) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0x55e3c8fa0028</span></span><br></pre></td></tr></table></figure><p>利用地址类型这个知识点，先定位到 a[0] 元素中 y 字段的首地址，然后对 y 字段取地址，这个时候，由于 y 字段是整型，所以取到的地址类型就是整型地址，之后再对这个整型地址执行 +1 操作，得到的也是 a[1].x 的首地址。</p><p><img src="/2020/05/23/geekbang-column-pointer-variables-are-also-variables/address.jpg" alt="a数组内存结构示意图"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>可以通过 C 语言里面的工具来描述这种类型的特点，这个可以用来描述和定义新类型的工具，就叫做：结构体。</li><li>对于某个结构体类型而言，其存储单元大小，等于它当中占用空间最大的基础类型所占用的字节数量。</li><li>结构体的字段在内存中存储的顺序，是按照结构体定义时的顺序排布的，而且当本存储单元不够安放的时候，就从下个存储单元的头部开始安放。</li><li>指针是变量，指针是一种用来存储地址的变量。</li><li>指针的类型，决定了指针取值时所取的字节数量。</li><li>指针的类型，决定了指针加减法过程中，所跨越的字节数量。</li><li>无论是什么类型的指针，大小都相等，因为地址信息是统一规格的。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>变量</tag>
        <tag>结构体</tag>
        <tag>地址</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串_printf 的高级用法</title>
    <url>/2020/05/23/geekbang-column-strings-advanced-usage-of-printf/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>Q:printf 函数在输出浮点型数据的时候，如何保留位数呢？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2lf"</span>, <span class="number">3.1415926</span>);</span><br><span class="line"><span class="comment">//输出：3.14</span></span><br></pre></td></tr></table></figure><p>A:%lf 是 double 双精度浮点型输出的格式占位符，<strong>当我们想要保留小数点后两位的时候，只需要在 % 和 lf 中间加上 .2 即可</strong>，2 写在 .(点) 的后面代表小数点后 2 位。</p><p>实现一个能够保留小数点后 n 位的程序，这里的 n 是我们程序读入的一个变量。<br>例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入1：3.1415926 2</span><br><span class="line">输出1：3.14</span><br><span class="line"></span><br><span class="line">输入2：3.1415926 3</span><br><span class="line">输出3:3.142</span><br></pre></td></tr></table></figure><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>第一种：用<code>switch case</code>语句做</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> num;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf%d"</span>, &amp;num, &amp;n);</span><br><span class="line">    <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">"%.1lf\n"</span>, num); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, num); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, num); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">"%.4lf\n"</span>, num); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">"%.5lf\n"</span>, num); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如何优化呢？？？</p><p>第二种：printf 函数的第一个参数不就是个字符串，既然是字符串信息，那我只需要在 printf 语言前，拼接合适的字符串信息传给 printf 函数即可。</p><p>例如，要求保留 1 位小数的时候，我就拼接出来 “%.1lf” 字符串信息，要求保留 2 位小数的时候，就拼接处理出 “%.2lf”字符串信息即可。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> num;  <span class="comment">//定义一个浮点型变量 num</span></span><br><span class="line">    <span class="keyword">int</span> n;  <span class="comment">//定义一个整型变量 n</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];  <span class="comment">//定义一个字符数组 str</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf%d"</span>, &amp;num, &amp;n);</span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">"%%.%dlf\n"</span>, n); <span class="comment">// %% 代表输出一个 %</span></span><br><span class="line">    <span class="built_in">printf</span>(str, num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1，体验利器"><a href="#1，体验利器" class="headerlink" title="1，体验利器"></a>1，体验利器</h3><blockquote><p>刚刚在上面，介绍了 sprintf 和 sscanf 两个字符串处理的利器工具，那么就请使用 sprintf 函数实现 strlen、strcpy、strcat 函数的功能，注意哦，只允许使用 sprintf 函数，模仿如上三个函数的功能。</p></blockquote><p>实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">1000</span>], str2[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, str1, str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str1 = %s\tstr2 = %s\n"</span>, str1, str2);</span><br><span class="line">    <span class="built_in">sprintf</span>(str1, <span class="string">"%s"</span>, str1);   <span class="comment">// strlen(str1)，输出str1 字符串中的字符数量</span></span><br><span class="line">    <span class="comment">//printf("strlen= %s\n",str1);</span></span><br><span class="line">    <span class="built_in">sprintf</span>(str1, <span class="string">"%s"</span>, str2);   <span class="comment">// strcpy(str1, str2)，把 str2 的内容复制到了 str1 中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str1 = %s\tstr2 = %s\n"</span>, str1, str2);</span><br><span class="line">    <span class="built_in">sprintf</span>(str1, <span class="string">"%s%s"</span>, str1, str2);   <span class="comment">// strcat(str1, str2)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str1 = %s\tstr2 = %s\n"</span>, str1, str2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2，优美的遍历技巧"><a href="#2，优美的遍历技巧" class="headerlink" title="2，优美的遍历技巧"></a>2，优美的遍历技巧</h3><blockquote><p>介绍完了字符串的相关知识以后，请思考如下问题，如何在不计算字符串长度的情况下，遍历字符串的每一位呢？<br>程序设计要求是，读入一个字符串，然后在不计算字符串长度的情况下，输出字符串中的每一个字符，每个字符占一行。其中所谓计算字符串长度的方法，包括但不限于 strlen，sprintf，先行 for 循环遍历统计等。</p></blockquote><p>实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1000</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    循环的结束条件：</span></span><br><span class="line"><span class="comment">    任何信息在底层都是二进制存储的，那么其余字符均为非零值，也就是代表条件成立。</span></span><br><span class="line"><span class="comment">    只有一个字符的值是零值，就是我们之前所说的字符串中的最后一个特殊的，看不见的字符，\0 字符，</span></span><br><span class="line"><span class="comment">    这个字符所对应的整型值就是 0，也就是我们所谓的假值。那么这个循环，就会一直循环到字符串的最后一位，才会停止。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>具体结果就是值，明确知道等于多少的就是值。存储这些值的地方，就是变量，就是在程序中用来指代某片存储空间的名称，值就是存储空间里面的具体内容。</li><li>字符串信息可以存储在字符数组中，字符数组就是“变量”的概念，字符串就是“值”的概念。</li><li>sscanf 和 sprintf 函数，本质上在做的是以字符串为中间值，做各种数据类型之间的转换。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
  </entry>
  <entry>
    <title>数组：一秒钟，定义 1000 个变量</title>
    <url>/2020/05/23/geekbang-column-array-one-second-define-1000-variables/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>程序中读入一个整数 n，假设 n 不会大于 1000，请输出 1 到 n 的每一个数字二进制表示中的 1 的个数。</p><p>当 n 等于 7 的时候，我们把 1 到 7 的每个数字的二进制表示罗列出来，会得到下表所示内容：</p><p><img src="/2020/05/23/geekbang-column-array-one-second-define-1000-variables/array1.jpg" alt="到7的二进制表示"></p><p>根据表中的内容，如果你的程序编写成功的话，程序应该分别输出 1、1、2、1、2、2、3，这些输出内容分别代表每个数字二进制表示中 1 的数量。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果我们用一个数组 f 记录相应数字二进制表示中 1 的数量，那么 f[i] 就代表 i 这个数字二进制表示中 1 的数量，从而我们可以推导得到 f[i] = f[i &amp; (i - 1)] + 1，也就是说 i 比 i &amp; (i - 1) 这个数字的二进制表示中的 1 的数量要多一个，这样我们通过一步计算就得到 f[i] 的结果。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);  <span class="comment">//读入一个整数n，代表要求解的范围</span></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  <span class="comment">//循环n次</span></span><br><span class="line">        f[i] = f[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;  <span class="comment">//每一次通过递推公式f[i] = f[i &amp; (i - 1)] + 1 计算得到 f[i] 的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后输出 1 到 n 中每个数字二进制表示中 1 的个数。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">1 1 2 1 2 2 3 1 2 2 3 2 3 3 4 1 2 2 3 2 3 3 4 2 3 3 4 3 4 4 5 1 2 2 3 2 3 3 4 2 3 3 4 3 4 4 5 2 3 3 4 3 4 4 5 3 4 4 5 4 5 5 6 1 2 2 3 2 3 3 4 2 3 3 4 3 4 4 5 2 3 3 4 3 4 4 5 3 4 4 5 4 5 5 6 2 3 3 4 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1，去掉倍数"><a href="#1，去掉倍数" class="headerlink" title="1，去掉倍数"></a>1，去掉倍数</h3><blockquote><p>设计一个去掉倍数的程序，要求如下：<br>首先读入两个数字 n 和 m，n 的大小不会超过 10，m 的大小都不会超过 10000；<br>接下来读入 n 个各不相同的正整数，输出 1 到 m 中，有哪些数字无法被这 n 个正整数中任意的一个整除。</p></blockquote><p>例子</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">3 12</span><br><span class="line">4 5 6</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">1 2 3 7 9 11</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> check[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//使用一个 check 数组作为标记，check[i] 等于 0，代表 i 这个数字不是 n 个数字中的任何一个数字的倍数。check[i] 等于 1，代表 i 这个数字能够被 n 个数字中的某个数字整除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, num;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);  <span class="comment">//首先读入 n 个数字中的某一个，存储在 num 变量中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = num; j &lt;= m; j += num) &#123;</span><br><span class="line">            check[j] = <span class="number">1</span>;  <span class="comment">//循环 m 以内所有 num 的倍数，把每个数字的 check 值标记为 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);  <span class="comment">//最后我们循环把 1 到 m 中没有被标记的数字输出，就是符合题目要求的所有数字。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>使用数组，可以很方便的定义出一组变量存储空间，数组下标从 0 开始。</li><li>数据的最基本存储单位是字节，每一个字节都有一个独一无二的地址。</li><li>一个变量占用若干个字节，第一个字节的地址，是这个变量的首地址，称为：变量地址。</li><li>字节是存储数据的最基本单位，比特是表示信息的最基本单位。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>字节</tag>
        <tag>比特</tag>
      </tags>
  </entry>
  <entry>
    <title>随机函数：随机实验真的可以算 π 值吗</title>
    <url>/2020/05/22/geekbang-column-random-function/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>圆周率 π 对你来说肯定不是一个陌生的概念，它指的是圆的周长与直径的比值。在古代，数学家们为了计算 π 的精确值想尽方法，可能穷尽一生也不过精确到小数点后几位而已。但到了现在，你可能不相信，只要你知道 π 的定义，就可以利用编程轻易计算出 π 的值。那究竟怎么做到呢？</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="rand用法"><a href="#rand用法" class="headerlink" title="rand用法"></a>rand用法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, rand() % <span class="number">1000</span>); <span class="comment">// 永远输出固定值</span></span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, rand() % <span class="number">1000</span>); <span class="comment">// 每次运行都不同</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在第 6 行代码里，我们虽然使用了 rand() 函数，可每次运行都将输出同样的值，这是因为我们没有设置随机种子，每次运行时 rand() 函数所记录的起始值都相同，所以每次运行输出的随机值也都相同。</p></li><li><p>第 8 行代码中，由于我们根据程序运行时的当前时间设置了随机种子，每次运行程序，第 8 行都将输出不同的值。事实上，如果你在 srand() 函数里面设置一个固定值，每次运行程序，结果也都将是一样的。</p></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//循环每一次，让计算机帮我们做一次实验</span></span><br><span class="line">        <span class="keyword">double</span> x = <span class="number">1.0</span> * rand() / RAND_MAX;  <span class="comment">//rand() 随机函数，返回值的范围是[0, RAND_MAX]，通过该表达式计算，我们就得到了一个[0.0, 1.0] 之间的随机值了。</span></span><br><span class="line">        <span class="keyword">double</span> y = <span class="number">1.0</span> * rand() / RAND_MAX;</span><br><span class="line">        <span class="keyword">if</span> (x * x + y * y &lt;= <span class="number">1.0</span>) m += <span class="number">1</span>;  <span class="comment">//判断一下随机选择的点，是否在圆内部；如果在，我们就记录一次</span></span><br><span class="line">        n += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, <span class="number">4.0</span> * m / n); <span class="comment">//最后用落在圆里的次数比上总实验次数再乘以 4，就得到了 π 的近似值。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">3.141664</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1，设计迷你随机函数"><a href="#1，设计迷你随机函数" class="headerlink" title="1，设计迷你随机函数"></a>1，设计迷你随机函数</h3><blockquote><p>设计一个循环过程，循环 100 次，以不太明显的规律输出 1～100 中的每个数字。<br>要求 1：规律尽量不明显。<br>要求 2：只能使用循环和最基本的运算，不允许超前使用数组。</p></blockquote><p>例如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 5 15 45 34  1  3  9 27 81 41</span><br><span class="line">22 66 97 89 65 94 80 38 13 39</span><br><span class="line">16 48 43 28 84 50 49 46 37 10</span><br><span class="line">30 90 68  2  6 18 54 61 82 44</span><br><span class="line">31 93 77 29 87 59 76 26 78 32</span><br><span class="line">96 86 56 67100 98 92 74 20 60</span><br><span class="line">79 35  4 12 36  7 21 63 88 62</span><br><span class="line">85 53 58 73 17 51 52 55 64 91</span><br><span class="line">71 11 33 99 95 83 47 40 19 57</span><br><span class="line">70  8 24 72 14 42 25 75 23 69</span><br></pre></td></tr></table></figure><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%2d "</span>, n);</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">10</span> == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);  <span class="comment">//十个一列</span></span><br><span class="line">        n = (n * <span class="number">3</span>) % <span class="number">101</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程序的灵魂在算法，算法的灵魂在数学。</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>学习<code>rand</code>用法。</li><li>计算机中都是伪随机函数，也就是说，下一次的随机值，跟本次的随机值是相关的。</li><li>使用<code>srand</code>函数设置随机种子，也就是设置伪随机过程中的第一个起始点的位置。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>随机</tag>
        <tag>π</tag>
      </tags>
  </entry>
  <entry>
    <title>判断与循环_给程序加上处理逻辑</title>
    <url>/2020/05/21/geekbang-column-judge-and-loop-add-processing-logic-to-your-program/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>如果我给你一个由年月日组成的日期，再给你一个数字 X，你能否准确地让程序输出 X 天后的日期呢？<br>例如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1989 11 20</span><br><span class="line">20</span><br><span class="line">1989 12 10</span><br></pre></td></tr></table></figure><p>数据中给出了 1989 年 11 月 20 日这个日期，然后问你 20 天后的日期是多少，你的程序应该输出 1989 年 12 月 10 日。特别需要注意的是，在这个任务中，你需要考虑到闰年中 2 月份的特殊性，闰年的 2 月有 29 天。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>首先需要有一个循环，循环每一次，让计算机帮我们计算一次下一天的日期。</li><li>每次在计算下一天日期的过程中，先让日子加1，判断是否跨月，如果跨过了一个月份，就让日子从1开始，让月份加1，再判断是否跨年，如果跨年了，就让月份从1开始，年份加1。</li><li>注意2月份的月份天数的计算方法。<br>闰年的判断方法，满足其一即可：能被4整除，但不能被100整除；能被400整除。因此代码逻辑应该是这样<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || year % <span class="number">400</span> == <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y, m, d, X; <span class="comment">// 定义存储 年月日 和 X 的变量</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;y, &amp;m, &amp;d); <span class="comment">// 读入年月日</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;X); <span class="comment">// 读入 X 值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; X; i++) &#123; <span class="comment">// 循环 X 次，每次向后推一天</span></span><br><span class="line">        d += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span> (m) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:            </span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>:&#123; <span class="comment">// 第一部分逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (d &gt; <span class="number">31</span>) d = <span class="number">1</span>, m += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (m == <span class="number">13</span>) m = <span class="number">1</span>, y += <span class="number">1</span>;</span><br><span class="line">            &#125;; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:            </span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">11</span>: &#123; <span class="comment">// 第二部分逻辑 </span></span><br><span class="line">                <span class="keyword">if</span> (d &gt; <span class="number">30</span>) d = <span class="number">1</span>, m += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123; <span class="comment">// 第三部分逻辑</span></span><br><span class="line">                <span class="keyword">if</span> ((y % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">100</span> != <span class="number">0</span>) || y % <span class="number">400</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (d &gt; <span class="number">29</span>) d = <span class="number">1</span>, m += <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d &gt; <span class="number">28</span>) &#123;</span><br><span class="line">                    d = <span class="number">1</span>, m += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, y, m, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1，打印乘法表"><a href="#1，打印乘法表" class="headerlink" title="1，打印乘法表"></a>1，打印乘法表</h3><blockquote><p>使用循环和条件判断，打印一个格式优美的 66 乘法表<br>要求 1：输出内容及样式参照下面给出的样例<br>要求 2：每两列之间用 \t 字符进行分隔，行尾无多余 \t 字符</p></blockquote><p>例子</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1*1=1</span><br><span class="line">1*2=2  2*2=4</span><br><span class="line">1*3=3  2*3=6  3*3=9</span><br><span class="line">1*4=4  2*4=8  3*4=12  4*4=16</span><br><span class="line">1*5=5  2*5=10  3*5=15  4*5=20  5*5=25</span><br><span class="line">1*6=6  2*6=12  3*6=18  4*6=24  5*6=30  6*6=36</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;  <span class="comment">//外层循环控制行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;  <span class="comment">//内层循环控制每一行的列数</span></span><br><span class="line">            <span class="comment">//第 i 行应该有 i 列，所以内层循环是从 1 循环到 i 为止。</span></span><br><span class="line">            j == <span class="number">1</span> || <span class="built_in">printf</span>(<span class="string">"\t"</span>);  <span class="comment">//如果左边条件不满足，就不会执行右边的的代码，所以：第一列前面不会多输出一个 \t 字符。而其他的情况呢，均会执行 printf("\t") 代码        </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d * %d = %d"</span>, j, i, i * j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>循环</tag>
        <tag>判断</tag>
        <tag>switch语句</tag>
      </tags>
  </entry>
  <entry>
    <title>时间的价值</title>
    <url>/2020/05/21/the-value-of-time/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><p>今天，收到一位学弟发来的消息，他收到了北京字节的<code>offer</code>，薪资五位数，本科应届毕业生，看了他发的薪资，讲真我酸了/(ㄒoㄒ)/~~</p><p>让我不禁想起上个月顿悟出的一件事：<strong>时间的价值，到底怎么体现时间的价值呢？</strong></p><p>我记得，我刚毕业入职一家公司，做图形学方面的研发，有一次下班，和我的导师并肩走向地铁站时，我说我多么喜欢这一份工作，他很好奇的问我：你真的喜欢做这个吗？别这么早下定论，至少我到现在还没有找到我喜欢做什么。</p><p>也许只是他随口一说，但此时此景，他的话又放佛在我耳边清晰的回响起来：你真的喜欢做这个吗…</p><p>在后面持续至少20个月的工作生涯里，我兴奋过，厌倦过，苦恼过，迷茫过，直到上个月我才突然顿悟出来：喜欢与不喜欢，无非就是觉得自己是否能体现其存在的价值，如果在他人眼来这份职业（或者是你正在做的事情）价值为0，但我自己却非常感兴趣，那它就是无价的；如果只是用来谋生，那么唯有<code>money</code>，才是检验你过的是否有价值的一个衡量标准。</p><p>最后，希望我可以早日找到————让自己不惜一切也要拼命守护的东西。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>时间</tag>
        <tag>价值</tag>
        <tag>人生</tag>
        <tag>守护</tag>
      </tags>
  </entry>
  <entry>
    <title>教你输出彩色的文字</title>
    <url>/2020/05/19/geekbang-column-teach-you-to-output-colored-text/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>学到如何设计一个读入字符串，并且按照字符串信息中规定的颜色，输出相应颜色文本内容的方法程序。<br>例如当我们：</p><ul><li>输入：red:color content， 输出红色的：color content</li><li>输入：blue:color content，输出蓝色的：color content</li><li>输入：yellow:color content，输出黄色的：color content</li></ul><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>输入输出很好设计，关键是<strong>如何让字体显示不同的颜色呢</strong></p><p>转义字符</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：\033[属性代码&#123;;属性代码...&#125;m输出内容\033[0m</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\033[1;4;33mhello color\033[0m"</span>);  <span class="comment">//输入高亮黄色带下划线的 hello color</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>0 代表关闭所有属性</li><li>1 代表高亮 / 粗体</li><li>4 代表下划线</li><li>33 代表黄色</li></ul><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1，位数输出"><a href="#1，位数输出" class="headerlink" title="1，位数输出"></a>1，位数输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计算一个输入整数的十进制表示的位数？</span><br><span class="line">条件 1：允许有多余输出的情况下，怎么实现？</span><br><span class="line">条件 2：只允许输出数字位数的时候，又该怎么实现？</span><br><span class="line">请单纯考虑使用 printf 一族函数方法实现。</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" has %d digits\n"</span>, <span class="built_in">printf</span>(<span class="string">"%d"</span>, n)); <span class="comment">// 有多余输出</span></span><br><span class="line">    <span class="keyword">char</span> output[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">sprintf</span>(output, <span class="string">"%d"</span>, n);  <span class="comment">//sprintf 也是 printf 一族函数中的一员，它的返回值与 printf 含义相同</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret); <span class="comment">// 无多余输出</span></span><br><span class="line">    <span class="comment">//return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2，读入一行字符串"><a href="#2，读入一行字符串" class="headerlink" title="2，读入一行字符串"></a>2，读入一行字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请大家自行实现一个读入一行字符串，并且输出相关内容的程序，思考如下：</span><br><span class="line">条件 1：如果字符串中没有空格，怎么实现？</span><br><span class="line">条件 2：如果字符串中有空格，又该怎么实现？</span><br><span class="line">请单纯考虑用 scanf 一族函数方法实现。</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//[]代表了一个集合，用来控制 %s 在读入过程中可以读入的字符集合的</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%[^\n]s"</span>, str);  <span class="comment">//只要不是换行符，就可以继续读入</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="部分颜色代码"><a href="#部分颜色代码" class="headerlink" title="部分颜色代码"></a>部分颜色代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字背景颜色: 40--49                字颜色: 30--39</span><br><span class="line">40: 黑                           30: 黑</span><br><span class="line">41: 红                           31: 红</span><br><span class="line">42: 绿                           32: 绿</span><br><span class="line">43: 黄                           33: 黄</span><br><span class="line">44: 蓝                           34: 蓝</span><br><span class="line">45: 紫                           35: 紫</span><br><span class="line">46: 深绿                         36: 深绿</span><br><span class="line">47：白色                         37：白色</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>此文记录我复习和巩固C语言基础的开端，后面会发布一系列学习笔记，加油！</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>文字</tag>
        <tag>C语言</tag>
        <tag>输入</tag>
        <tag>输出</tag>
      </tags>
  </entry>
  <entry>
    <title>兴隆湖半日游</title>
    <url>/2020/05/16/xing-long-hu-half-a-day-trip/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><p>今天和女朋友计划去兴隆湖游玩。</p><p>由于住的地方比较远，倒两趟公交，所以吃过午饭就准备出发了。</p><p>到达目的地后，第一感受是这里人真少，空气很清新，我俩在湖边慢悠悠的散着步，看着有小朋友们玩滑板，还有小姐姐在练舞蹈。</p><p>期间女朋友突然肚子饿了，去一家超市买辣条，明明上面标着是3元/袋，店家说要4.5元，女朋友二话不说就扫码付款，我提出的疑惑后，店家连声说抱歉，给我女朋友退了1.5元。所以以后遇到困惑还是需要提出质疑的哦。</p><p>兴隆湖逛完了，又把旁边的鹿溪河生态区逛了逛，不得不说，安安静静的坐在椅子上，听着鸟叫的声音也是一种享受呢。</p><p>晚上到家准备买些菜，毕竟领了成都的4张线下消费劵。买了很多的菜和水果，女朋友想吃烧烤，于是在一家路边摊点烧烤，md没有问老板烤串的价格，等选完了付款告诉我说是83元，我去，我让他再算一遍，他给我说荤的是6元，素的是2元，有些是3元的，加了一遍又是83元，行吧，我是觉得平时再怎么点也不会超过50的，算理亏了，店家的数学应该还过得去，只能暗自表示下次一定别再来吃了。</p><p>就这样，结束了一天的行程。远离了喧嚣，人与人之间的勾心斗角，这样的感觉真好。</p><p><img src="/2020/05/16/xing-long-hu-half-a-day-trip/jing1.jpg" alt></p><p><img src="/2020/05/16/xing-long-hu-half-a-day-trip/jing2.jpg" alt></p><p><img src="/2020/05/16/xing-long-hu-half-a-day-trip/jing3.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>旅行游记</category>
      </categories>
      <tags>
        <tag>旅行</tag>
        <tag>游记</tag>
        <tag>烧烤</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言的优点和缺点</title>
    <url>/2020/05/10/go-language-advantages-and-disadvantages/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><p>1，性能</p></li><li><p>2，语言性能很重要</p></li><li><p>3，发者效率&amp;不要过于创新</p></li><li><p>4，并发性&amp;通道</p></li><li><p>5，快速的编译时间</p></li><li><p>6，打造团队的能力</p></li><li><p>7，强大的生态系统</p></li><li><p>8，GOFMT，强制代码格式</p></li><li><p>9，gRPC 和 Protocol Buffers</p></li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li><p>1，缺少框架</p></li><li><p>2，错误处理</p></li><li><p>3，软件包管理</p></li></ul><h2 id="个人使用感受"><a href="#个人使用感受" class="headerlink" title="个人使用感受"></a>个人使用感受</h2><p>个人觉得<code>Go</code>语言在做后端并发时非常方便，起一个<code>go func()</code>即可。缺点的话，目前（2020.5月之前）只遇到过<code>Go</code>因垃圾回收而引起的<code>CPU</code>占满的<code>Bug</code>。<br><code>Go</code>有<code>C</code>语言的指针和<code>Python</code>语法的优雅，写起来很舒服，同时也有强大的调试工具<code>Delve</code>。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://studygolang.com/articles/12907" target="_blank" rel="noopener">Go 语言的优点，缺点和令人厌恶的设计</a></li><li><a href="https://www.sohu.com/a/220085058_657921" target="_blank" rel="noopener">Go 在 TiDB 的实践</a></li><li><a href="https://developer.51cto.com/art/201710/555200.htm" target="_blank" rel="noopener">Go语言的9大优势和3大缺点</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>开发</tag>
        <tag>优点</tag>
        <tag>缺点</tag>
      </tags>
  </entry>
  <entry>
    <title>后浪</title>
    <url>/2020/05/04/back-rise/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><p>这是最好的时代，这是最坏的时代；这是智慧的时代，这是愚蠢的时代；这是信仰的时期，这是怀疑的时期；这是光明的季节，这是黑暗的季节；这是希望之春，这是失望之冬；人们面前有着各样事物，人们面前一无所有；人们正在直登天堂，人们正在直下地狱。</p><p>今天看了<a href="https://www.bilibili.com/video/BV1FV411d7u7?spm_id_from=333.851.b_696e7465726e6174696f6e616c486561646572.16" target="_blank" rel="noopener">bilibili献给新一代的演讲《后浪》</a>，让我感慨万分，脑海中想到了《双城记》的开头——<strong>这是最好的时代，这是最坏的时代</strong>。</p><h2 id="最好的时代"><a href="#最好的时代" class="headerlink" title="最好的时代"></a>最好的时代</h2><ul><li>信息量呈几何倍数的增长，我不出门也可以知晓天下事。</li><li>教育开始大众化，有<code>中国MOOC</code>，<code>网易云课堂</code>，<code>慕课网</code>等等在线学习网站，可以尽情学习我想学习的一切。</li><li>交通便利化，记得我大学时期给我父母抱怨上大学要坐13个小时的火车的时候，他们会说他从陕西坐到新疆，从北疆到南疆至少七天以上。而现在我可以坐飞机、动车、高铁、火车、大巴等交通工具去往我想去的地方，再也不局限于一座城市。</li><li>交友多元化，不再满足身边的一个小圈子，我可以活跃在各种论坛、网站、QQ微信群上，和其他大学的网友一起打比赛，请教问题。</li><li>大数据人工智能时代，许多事情由程序就可以帮你做最优的选择，比如外卖拼团，比如规划旅游路线。</li></ul><h2 id="最坏的时代"><a href="#最坏的时代" class="headerlink" title="最坏的时代"></a>最坏的时代</h2><p>目前好像还没有感受到，唯一记得最近的谈话是我亲戚对我说：“现在的年轻人，压力太大了。”</p><p>嗯…好像是这样。但是也得分情况，如果是我自己想去追寻的事情，再累也是身体累，而对于我极力反感的事情，我的心就已经很累了。</p><h2 id="心里有火，眼里有光"><a href="#心里有火，眼里有光" class="headerlink" title="心里有火，眼里有光"></a>心里有火，眼里有光</h2><p><strong>不用活着他们想象中的样子，他们这一代人的想象力不足以想象我们的未来。</strong>我觉得这句话说的很棒，越长大，就越发现和父母会产生隔阂，比如想去旅行，想去看看外面多姿多彩的世界。</p><p>犹记得我大一暑假，想去一趟高原当一回支教的志愿者，和父母沟通了快两个月才同意；大二暑假，我有一天回来突然对父母说“我想出去看看”，父母说“可以啊，坐公交去那个南湖，儿童乐园去看看”，我说“我想坐火车去其他城市”，于是和父母沟通了半个多月，最终才同意了我这场说走就走的旅行；大四暑假，我还在家没待够两天，就坐飞机去成都面试，拿<code>offer</code>，入职新公司。</p><p>是什么带给了我改变现状的行动，我想了很久，也复盘了当时我的心情，我想就是<strong>好奇心+勇气</strong>。</p><p>我今年刚过完24岁生日，看着自己在陌生城市逐渐稳固的步伐，账户上不多不少的存款，以及自己健康的体魄和仍然茂盛的头发（嘿嘿，据说程序员都爱这样说），这些都是我可以立马做出改变的资本。</p><p>未来，还会有无限可能。</p><p>奔涌吧，后浪。</p><h2 id="2020-5-21更新"><a href="#2020-5-21更新" class="headerlink" title="2020-5-21更新"></a>2020-5-21更新</h2><p>细品</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">麻：“师爷，您给翻译翻译，什么叫后浪，翻译翻译，什么，叫后浪”</span><br><span class="line"></span><br><span class="line">汤：“这还用翻译，年轻人嘛，新一代，都说了......”</span><br><span class="line"></span><br><span class="line">麻：“我让你翻译给我听，什么叫后浪！”</span><br><span class="line"></span><br><span class="line">汤：：“不用翻译，就是后浪啊，热爱生活嘛......”</span><br><span class="line"></span><br><span class="line">黄：“难道你听不懂什么叫后浪？”</span><br><span class="line"></span><br><span class="line">麻：“我就想让你翻译翻译，什么，叫后浪！！！”</span><br><span class="line"></span><br><span class="line">汤：“后浪嘛！”</span><br><span class="line"></span><br><span class="line">麻：“翻译出来给我听，什么TM的叫后浪！什么TM的叫TM的后浪！”</span><br><span class="line"></span><br><span class="line">汤：“什么TM的叫后浪啊？”黄：“后浪就是新一代青年，可以选择玩单反，开跑车，玩跳伞，在欧洲旅游拍vlog，明白了吗？”</span><br><span class="line"></span><br><span class="line">汤：“这就是后浪呀！”</span><br><span class="line"></span><br><span class="line">麻：“翻译翻译”</span><br><span class="line"></span><br><span class="line">汤，黄：“.....？？？”</span><br><span class="line"></span><br><span class="line">麻：“翻译翻译！”</span><br><span class="line"></span><br><span class="line">汤：“后浪，就是前浪的儿子和女儿！”</span><br><span class="line"></span><br><span class="line">麻：“噢，大哥这TM是后浪啊。”</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul><li><a href="https://www.zhihu.com/question/392359306" target="_blank" rel="noopener">如何评价 B 站 2020 年五四青年节宣传短片《后浪》？</a></li></ul><p><img src="/2020/05/04/back-rise/back-rise.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下使用gcc调试c语言程序</title>
    <url>/2020/05/03/linux-gcc-debug-c-program/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>看到一些用<code>C语言</code>写的数据结构的程序，很不错，想用<code>gcc</code>调试一下程序，增进记忆，本文记录学习和使用<code>gcc</code>调试<code>C程序</code>的过程。</p><h2 id="使用gcc"><a href="#使用gcc" class="headerlink" title="使用gcc"></a>使用gcc</h2><h3 id="1，生成可调试程序test"><a href="#1，生成可调试程序test" class="headerlink" title="1，生成可调试程序test"></a>1，生成可调试程序test</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o test -g BinarySortTree.c</span><br></pre></td></tr></table></figure><h3 id="2，gdb开始调试"><a href="#2，gdb开始调试" class="headerlink" title="2，gdb开始调试"></a>2，gdb开始调试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb test</span><br></pre></td></tr></table></figure><h3 id="3，设置断点"><a href="#3，设置断点" class="headerlink" title="3，设置断点"></a>3，设置断点</h3><p>这里可以设置行数，或者函数名</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">break 118</span><br></pre></td></tr></table></figure><h3 id="4，运行程序"><a href="#4，运行程序" class="headerlink" title="4，运行程序"></a>4，运行程序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">run</span><br></pre></td></tr></table></figure><h3 id="5，调试"><a href="#5，调试" class="headerlink" title="5，调试"></a>5，调试</h3><ul><li>n，一行一行的执行</li><li>c，continue-执行到下一个断点处</li><li>print,打印出变量信息</li></ul><h3 id="6，退出调试"><a href="#6，退出调试" class="headerlink" title="6，退出调试"></a>6，退出调试</h3><p>quit</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在<code>gdb</code>中如果遇到困惑，可以输入<code>help</code>获取相关帮助信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List of classes of commands:</span><br><span class="line"></span><br><span class="line">aliases -- Aliases of other commands</span><br><span class="line">breakpoints -- Making program stop at certain points</span><br><span class="line">data -- Examining data</span><br><span class="line">files -- Specifying and examining files</span><br><span class="line">internals -- Maintenance commands</span><br><span class="line">obscure -- Obscure features</span><br><span class="line">running -- Running the program</span><br><span class="line">stack -- Examining the stack</span><br><span class="line">status -- Status inquiries</span><br><span class="line">support -- Support facilities</span><br><span class="line">tracepoints -- Tracing of program execution without stopping the program</span><br><span class="line">user-defined -- User-defined commands</span><br><span class="line"></span><br><span class="line">Type &quot;help&quot; followed by a class name for a list of commands in that class.</span><br><span class="line">Type &quot;help all&quot; for the list of all commands.</span><br><span class="line">Type &quot;help&quot; followed by command name for full documentation.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.</span><br><span class="line">Command name abbreviations are allowed if unambiguous.</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文简单记录了使用<code>gdb</code>的常用命令，个人比较喜欢这种用命令行的方式去调试程序，当然也可以去<code>VSCode</code>等软件去做。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>C语言学习</category>
      </categories>
      <tags>
        <tag>Debug</tag>
        <tag>gcc</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang中Slice和Array有何不同</title>
    <url>/2020/04/17/interview-golang-slice-and-array-difference/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="《Go-Program-Language》定义"><a href="#《Go-Program-Language》定义" class="headerlink" title="《Go Program Language》定义"></a>《Go Program Language》定义</h3><p>数组是一个由固定长度的特定类型元素组成的序列， 一个数组可以由零个或多个元素组成。<br>因为数组的长度是固定的， 因此在Go语言中<strong>很少直接使用数组</strong>。</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ul><li>默认情况下， 数组的每个元素都被初始化为元素类型对应的零值， 对于数字类型来说就是0。</li></ul><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><h3 id="《Go-program-language》定义"><a href="#《Go-program-language》定义" class="headerlink" title="《Go program language》定义"></a>《Go program language》定义</h3><p>Slice（ 切片） 代表变长的序列， 序列中每个元素都有相同的类型。 一个slice类型一般写作[]T， 其中T代表slice中元素的类型； slice的语法和数组很像， 只是没有固定长度而已。</p><h3 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h3><ul><li>内置的append函数用于向slice追加元素。<br>（注意：append函数对于理解slice底层是如何工作的非常重要，此问题后面再详细阐述。）</li></ul><h2 id="Difference"><a href="#Difference" class="headerlink" title="Difference"></a>Difference</h2><h3 id="Go-program-language》"><a href="#Go-program-language》" class="headerlink" title="Go program language》"></a>Go program language》</h3><p>数组和slice之间有着紧密的联系。<br>一个slice是一个轻量级的数据结构， 提供了访问数组子序列（ 或者全部） 元素的功能， 而且slice的底层确实引用一个数组对象。 一个slice由三个部分构成： <strong>指针、 长度和容量</strong>。 指针指向第一个slice元素对应的底层数组元素的地址， 要注意的是slice的第一个元素并不一定就是数组的第一个元素。 长度对应slice中元素的数目； 长度不能超过容量， 容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。</p><h2 id="个人小结"><a href="#个人小结" class="headerlink" title="个人小结"></a>个人小结</h2><ul><li>平时开发中对<code>Slice</code>用的较多，因为<code>Slice</code>可以自动扩容；</li><li>slice由三个部分构成： <strong>指针、 长度和容量</strong>。</li><li>array由两个部分构成： <strong>指针、长度</strong>。</li><li>内置的append函数是针对<code>slice</code>操作的。</li><li><code>slice</code>需要用内置的<code>make</code>函数创建。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>数组</tag>
        <tag>Golang</tag>
        <tag>切片</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器输入www.baidu.com为什么能渲染出百度页面</title>
    <url>/2020/04/17/interview-enter-www-baidu-com-why-can-render-baidu-page/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><p>注：此问题涉及计算机网络的深度和广度，内容较多，本文将陆续将相关信息整理出来。</p><p>有好的资源或回答欢迎留言。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>主要分两部分，网络通信和页面渲染。</p><h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><h4 id="1，在浏览器中输入www-baidu-com"><a href="#1，在浏览器中输入www-baidu-com" class="headerlink" title="1，在浏览器中输入www.baidu.com"></a>1，在浏览器中输入<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></h4><h4 id="2，应用层DNS解析域名"><a href="#2，应用层DNS解析域名" class="headerlink" title="2，应用层DNS解析域名"></a>2，应用层DNS解析域名</h4><h4 id="3，应用层客户端发送HTTP请求"><a href="#3，应用层客户端发送HTTP请求" class="headerlink" title="3，应用层客户端发送HTTP请求"></a>3，应用层客户端发送HTTP请求</h4><h4 id="4，传输层TCP传输报文"><a href="#4，传输层TCP传输报文" class="headerlink" title="4，传输层TCP传输报文"></a>4，传输层TCP传输报文</h4><h4 id="5，网络层IP协议查询MAC地址"><a href="#5，网络层IP协议查询MAC地址" class="headerlink" title="5，网络层IP协议查询MAC地址"></a>5，网络层IP协议查询MAC地址</h4><h4 id="6，数据到达数据链路层"><a href="#6，数据到达数据链路层" class="headerlink" title="6，数据到达数据链路层"></a>6，数据到达数据链路层</h4><h4 id="7，服务器接收数据"><a href="#7，服务器接收数据" class="headerlink" title="7，服务器接收数据"></a>7，服务器接收数据</h4><h4 id="8，服务器响应请求"><a href="#8，服务器响应请求" class="headerlink" title="8，服务器响应请求"></a>8，服务器响应请求</h4><h4 id="9，服务器返回相应文件"><a href="#9，服务器返回相应文件" class="headerlink" title="9，服务器返回相应文件"></a>9，服务器返回相应文件</h4><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/jeffleo/article/details/77151646" target="_blank" rel="noopener">从输入URL到浏览器显示页面发生了什么</a></li><li><a href="https://blog.csdn.net/qq_16681169/article/details/50866290" target="_blank" rel="noopener">在浏览器中输入www.baidu.com后执行的全部过程</a></li><li><a href="https://blog.csdn.net/yaotengjian/article/details/80457774" target="_blank" rel="noopener">【网络】 输入www.baidu.com后的过程详解</a></li><li>《网络是怎样连接的》</li><li><a href="https://segmentfault.com/a/1190000002611809" target="_blank" rel="noopener">从输入 URL 到页面加载完成发生了什么事</a></li><li><a href="https://div.io/topic/457" target="_blank" rel="noopener">从输入 URL 到页面加载完成的过程中都发生了什么事情？</a></li><li><a href="https://www.cnblogs.com/xianyulaodi/p/6547807.html" target="_blank" rel="noopener">【原】老生常谈-从输入url到页面展示到底发生了什么</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>面试</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>场景题_从A服务获取用户id，从B服务获取用户信息</title>
    <url>/2020/04/16/interview-use-A-get-userid-and-use-B-get-userinfo/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有这样一个场景，需要你从A服务中获取多个用户id，然后根据用户id请求B服务获取用户信息，如何用<code>Golang</code>的<code>channel</code>和协程来实现？</p><h2 id="问题思考和实现"><a href="#问题思考和实现" class="headerlink" title="问题思考和实现"></a>问题思考和实现</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>由于从A服务中获取的是一个数组形式的用户id，所以我可以考虑从A服务获取用户id后，再用<code>for range</code>循环遍历每一个用户id，给每个用户建立一个通道，开个协程请求B服务获取用户信息，再通过通道传回来。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> userinfo UserInfo</span><br><span class="line"></span><br><span class="line"><span class="comment">//1，请求A服务获取用户id</span></span><br><span class="line">userids := GetAserver()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2，请求B服务获取用户信息</span></span><br><span class="line"><span class="keyword">for</span> _,userid := <span class="keyword">range</span> userids &#123;</span><br><span class="line">    userid_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> userinfo)</span><br><span class="line">    <span class="keyword">go</span> GetBserver(userid_chan,userid)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> info := &lt;- userid_chan:</span><br><span class="line">                <span class="keyword">return</span> info</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ul><li>每个用户新建一个<code>channel</code>，很浪费</li><li>数据量大了，这样做很不好</li></ul><h3 id="方法二-待完善"><a href="#方法二-待完善" class="headerlink" title="方法二(待完善)"></a>方法二(待完善)</h3><p>建立2个<code>channel</code>和2个协程 一个协程用来获取用户id数组g1，一个协程服务负责请求B服务获取用户信息g2, g1通过<code>channel</code>给g2，然后g2将请求到的用户信息再通过<code>channel</code>反馈回去。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> userinfo UserInfo</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> g1()</span><br><span class="line"><span class="keyword">go</span> g2()</span><br><span class="line"></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> userinfo)</span><br><span class="line"></span><br><span class="line"><span class="comment">//g1通过`channel`给g2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三-待完善"><a href="#方法三-待完善" class="headerlink" title="方法三(待完善)"></a>方法三(待完善)</h3><p><strong>核心思路是，A服务的携程不能阻塞，尽量并发等待B的数据。</strong><br>A要新建一个go用来接收B发过来的数据，A的ID可以直接用chan发送到B，B用一个单独的chan一次一个的方式发送结构体到新建的go，新建的go可以打包发给A，或者直接转发给A，所有数据接收完成后，新建的go退出；<br>ID可以一次批量发送，结构体可以用chan，一次一个的处理，也可以打包批次处理，这个可以看需求。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> userinfo UserInfo</span><br></pre></td></tr></table></figure><h2 id="问题复盘"><a href="#问题复盘" class="headerlink" title="问题复盘"></a>问题复盘</h2><ul><li>这个问题的核心是：你如何才能并发处理异步请求，特别是大当量数据的情况。</li><li>并发考虑做个消息队列。</li></ul><h2 id="特别感谢"><a href="#特别感谢" class="headerlink" title="特别感谢"></a>特别感谢</h2><p>特别感谢<code>Go项目实战</code>群里的三位大佬提供的思路：@star,@J,@钢之镇魂曲</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>服务</tag>
        <tag>并发</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>左耳听风，右耳聆心</title>
    <url>/2020/03/31/happy-24-birthday-listening-wind-and-heart/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><p>我步入丛林 因为我希望活得随意 我希望活得深刻 吸取生命所有的精华 把非生命的一切都击溃 以免我在弥留之际 发现自己从未真正活过。</p><p>今天是我大学毕业之后过的第二个生日，是的，过了今天，我就24岁了。</p><p>突然发现我坚持了七年写日记的习惯，在毕业后竟然断更了。</p><p>每天得过且过，忘记了昨天，也看不清未来。</p><h4 id="我的写作之路"><a href="#我的写作之路" class="headerlink" title="我的写作之路"></a>我的写作之路</h4><p>我记忆中记得最开始练习写作，是小时候的语文考试，每次考试要写超过300字的作文，这让我很苦恼，为什么是300字，100字也挺好的啊。</p><p>于是不停的看书，积累好词好句，然后在考试的时候，数着格子，计算着我要写多少字就可以达到及格的要求，很苦恼。</p><p>上了初中，喜欢上了写小说，尤其是科幻小说，只可惜这些不能为我的作文加分，于是开始到处抄作文，然后套用到模板中，只是当我写完了文章，我连我自己写的是什么都不知道。</p><p>直到上了高三，上补习班的老师，一位幽默风趣的男老师，据说是自治区语文命题组成员，告诉我们要用八个自然段，准备了十几个材料模型，教我们如何套模板，并告知我们，应试作文可以造假，反正也查不出来，关键是你要往出题者的意图上去靠….哦，原来这就是“写作”啊。</p><p>直到读了大学，没有了那么多条条框框的束缚，我才发觉，写作竟然是如此有趣，当你内心思绪紊乱，同时有多个想法冒出的时候，可以通过写作，将这些点串成线，线在汇聚成面，放佛在织一张很大的网。</p><p>我仍记得，在我大二那年，我在学习了单片机C语言和汇编知识后，要做一个课程设计出来，于是我查资料，做测试，请教同学，写了十几页演算纸，最后我在想，把它记录下来吧，扔掉怪可惜的。于是在实验室里，从下午两点到晚上七点半，一直在捋逻辑，然后写在博客上，发布出去。多年之后，发现那篇文章用搜索引擎搜出来排名第一，令我感到意外的同时又感到惊喜。</p><p>从那时开始，我将自己学习的收获，以及对生活的感悟记录下来，大学毕业时写下了三百多篇文章，只是没想到无心插柳的举动，竟为我后续面试求职和人脉拓展起到了关键作用。</p><h4 id="起风了"><a href="#起风了" class="headerlink" title="起风了"></a>起风了</h4><p>有位好朋友说，好习惯一定不能断，不然再试着找回来就很困难了。</p><p>我们面临的诱惑太多，如果说在学校面临的是学习和爱情，那么工作后除了学习、爱情，还有工作，人际沟通，经济，生存等，太多太多太多需要自己去注意的地方，在不经意间分散着自己的时间和精力。</p><p>所以，请让自己的时间变得有价值起来，这句话也是我前两个月顿悟出来的。</p><p>也许有人会说你变得冷漠无情了，那就让他说去吧，对你有影响吗？</p><p>有一位朋友说，我有时太在意别人的看法，却忘记了最终的目的，太着急了，以至于乱的方寸，错误频出，实则是降低了效率，所以，请把步调放慢一些。</p><p>很感谢他这么坦诚的说出我的问题，我曾反思过为什么会这样，而追根溯源就是和习惯有关，和曾经的环境有关。</p><p>所以，试着放慢步伐，把每一步都踩扎实，才不会在风中摇摆不定，找不到出口。</p><h4 id="象牙塔与现实的脱节"><a href="#象牙塔与现实的脱节" class="headerlink" title="象牙塔与现实的脱节"></a>象牙塔与现实的脱节</h4><p>曾经在学校读书的时候，遇到过3-5年的开发大佬，也有工作10年以上的架构师，他们都感慨一句“读书真好”，直到现在我才明白这四个字所蕴含的情感。</p><p>在学校，老师教导我们要善良，要乐于助人，却没有告诉我们善良的后果是什么；<br>在学校，老师教导我们要诚实守信，但遇到现实你敢这样做吗；<br>在学校，有问题可以找老师，找同学，而现实中全靠自己解决；<br>…</p><p>今年一月初，晚上我行走在四川大学江安校区内，走在校园的林荫小道上，看着背着书包往返于图书馆的学生们，放佛也找到了自己曾经的身影。</p><h4 id="曾经不代表现在"><a href="#曾经不代表现在" class="headerlink" title="曾经不代表现在"></a>曾经不代表现在</h4><p>工作最大的收获就在于，只要功夫下到位，潜力也是可以被激发出来的。</p><p>那些曾经自认为不擅长的技能，在经过刻意练习和实践后也能够熟练掌握。</p><p>曾经我最害怕在人多的地方骑自行车，现在已经成为一名骑行路程接近3000公里的老骑手；曾经我自认为没有写程序的天赋，然而我也通过看别人代码，自己动手刷了leetcode 200道以上的算法题；曾经我以为写<code>Linux Shell</code>脚本很难，然而我因为项目需要只用了一下午就可以掌握；曾经我遇到<code>Bug</code>心跳就会加速，然而经过两个重量级项目的历练，我熟练掌握了排查问题的流程；曾经我喜欢单干，然而我现在发现和大佬进行技术交流有时也会加深我的记忆和理解…</p><h4 id="左耳听风，右耳聆心"><a href="#左耳听风，右耳聆心" class="headerlink" title="左耳听风，右耳聆心"></a>左耳听风，右耳聆心</h4><p>我的创作时间一般喜欢选定在晚上，尤其是接近零点的时候，这时放佛给我一种进入新的一天的仪式感，同时也是因为万籁俱寂，可以聆听自己内心深处，最真实的感受。</p><p>写作，就是把我在这个世界上听到的，看到的，想到的，品到的，悟到的，记录下来，留给需要的人看，如果能对你们产生一些触动，那么对于我写作的价值也就达到了。</p><p>人生的意义是什么？我到现在都无法下结论。但我至少能这么说：我知道，在我离世时闭上了双眼，却敞开了心灵。</p><p>念，祝你24岁生日快乐！^_^</p><pre><code>念
2020年3月31日凌晨一点
于成都</code></pre><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>生日快乐</category>
      </categories>
      <tags>
        <tag>生日祝福</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker学习和命令的使用</title>
    <url>/2020/03/18/docker-study-and-use/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="为什么要用Docker"><a href="#为什么要用Docker" class="headerlink" title="为什么要用Docker"></a>为什么要用Docker</h2><p>在做软件服务时，有些程序对环境要求极其苛刻，比如必须把<code>C++</code>的库都安装好，且放到指定位置才行，这样就会对测试和运维人员造成极大的工作负担，因此我们利用<code>Docker</code>的<strong>一键编译，到处运行</strong>的特点，给自己的服务创建一个镜像，然后开启一个容器，将端口号和路径映射出来。</p><h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><h3 id="查询本机存在的镜像"><a href="#查询本机存在的镜像" class="headerlink" title="查询本机存在的镜像"></a>查询本机存在的镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h3 id="查询本机中所有创建的容器"><a href="#查询本机中所有创建的容器" class="headerlink" title="查询本机中所有创建的容器"></a>查询本机中所有创建的容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><h3 id="查询正在运行的容器"><a href="#查询正在运行的容器" class="headerlink" title="查询正在运行的容器"></a>查询正在运行的容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><h3 id="创建一个容器并进入这个容器"><a href="#创建一个容器并进入这个容器" class="headerlink" title="创建一个容器并进入这个容器"></a>创建一个容器并进入这个容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it -p 20002:20002 -v /data/:/data/ 47aae5c9b731  /usr/start.sh</span><br></pre></td></tr></table></figure><ul><li>run: 创建一个容器，并让它跑起来</li><li>-it: 进入这个容器</li><li>-d: 后台运行这个容器</li><li>-p: 映射端口号</li><li>-v: 映射路径</li><li>/usr/start.sh: 运行容器后默认执行的脚本文件</li></ul><h3 id="启动一个容器"><a href="#启动一个容器" class="headerlink" title="启动一个容器"></a>启动一个容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker start 容器id</span><br></pre></td></tr></table></figure><h3 id="进入一个正在运行的容器"><a href="#进入一个正在运行的容器" class="headerlink" title="进入一个正在运行的容器"></a>进入一个正在运行的容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器id bash</span><br></pre></td></tr></table></figure><h3 id="停止正在运行的容器"><a href="#停止正在运行的容器" class="headerlink" title="停止正在运行的容器"></a>停止正在运行的容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop 容器id</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.dockerinfo.net/document" target="_blank" rel="noopener">Docker中文文档</a></li><li><a href="https://docs.docker.com" target="_blank" rel="noopener">Docker Documentation</a></li><li><a href="https://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">菜鸟教程_Docker 教程</a></li><li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">阮一峰_Docker 入门教程</a></li></ul><p>(待更新)</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Docker学习</category>
      </categories>
      <tags>
        <tag>容器</tag>
        <tag>Docker</tag>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>极客Live-大厂面试那些问题，平时真的不会用到吗</title>
    <url>/2020/03/17/geekbang-live-interview-problem-to-solve-work/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="直播简介"><a href="#直播简介" class="headerlink" title="直播简介"></a>直播简介</h2><p>直播老师：李玥-京东资深架构师</p><p>你将获得：</p><ul><li>1，大厂面试题考点</li><li>2，如何在平时工作中积累自己的核心能力</li><li>3，面试题和实际工作的交集与并集</li></ul><h2 id="直播笔记"><a href="#直播笔记" class="headerlink" title="直播笔记"></a>直播笔记</h2><h3 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h3><p>你能走多远，取决于你填坑的能力有多大。</p><h3 id="关于简历"><a href="#关于简历" class="headerlink" title="关于简历"></a>关于简历</h3><p>简历可以适当夸大，比如精通xx，熟练yy,zz.</p><h3 id="高并发与海量数据"><a href="#高并发与海量数据" class="headerlink" title="高并发与海量数据"></a>高并发与海量数据</h3><p>小厂：单机，人肉，低可用</p><p>大厂：分布式，自动化，高可用</p><h3 id="大厂面试套路"><a href="#大厂面试套路" class="headerlink" title="大厂面试套路"></a>大厂面试套路</h3><ul><li><p>项目经历</p></li><li><p>基础知识</p></li><li><p>智力测验</p></li><li><p>目标职位需要的技术知识<br>可以看看MQ;分布式;</p></li><li><p>高并发和海量数据</p></li></ul><ul><li><p>知识的深度和广度</p></li><li><p>对前沿技术的了解</p></li></ul><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ul><li><p>如果有十年以上经验，要面试大厂，建议看看顶级学术期刊的最新最前沿的论文；</p></li><li><p>用<code>google</code>搜索</p></li><li><p>仔细看开源项目的文档</p></li><li><p>架构师是个<code>title</code>，平时还需要写代码；但有些公司的架构师相当于技术顾问</p></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>直播分享</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>直播</tag>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>最怕常年不联系的朋友突然的关心</title>
    <url>/2020/02/22/most-afraid-of-strange-friends-studdenly-care/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><p>最近有件事让我既喜又悲，那就是常年不联系的朋友，对我突然的关心。</p><h2 id="大学好友lss"><a href="#大学好友lss" class="headerlink" title="大学好友lss"></a>大学好友lss</h2><p>过年没事看到lss的朋友圈，说他在乌鲁木齐的公司晋升了高级主管，我很开心，于是找他闲聊了几句。</p><p>然后就问我“兄弟，办信用卡不”，我说不办，立马用哈哈缓解尴尬的气氛，还不死心的说一句“帮我问问身边的呗，有需要可以联系我”。</p><p>我回了句好吧之后，立马结束了聊天。</p><h2 id="高中同学djx"><a href="#高中同学djx" class="headerlink" title="高中同学djx"></a>高中同学djx</h2><p>高一是一个班的同学，文静，好学，前些天突然QQ联系我做过小游戏没，要给客户群活跃气氛用，我就帮她想办法，然后加上微信后开始步入正题“微信上绑工行卡没”，一句话放佛让我懂了她主动联系我的真实目的。</p><p>我立马拒绝绑卡，我觉得没必要，她仍然坚持说帮个忙嘛，我没理，就这样在尬聊中结束了。</p><h2 id="办卡的目的"><a href="#办卡的目的" class="headerlink" title="办卡的目的"></a>办卡的目的</h2><p>随后我咨询了在四大会计师事务所之一工作的朋友，为什么会有这么多办卡的？她解释道：办信用卡就和花呗的原理一样，只不过逾期了要给银行交利息，至于为什么有办卡的，估计是银行员工有指标要拉人。</p><h2 id="铁心"><a href="#铁心" class="headerlink" title="铁心"></a>铁心</h2><p>还是应了那句话：最怕常年不联系的人突然的关心。</p><p>记得上大学那会，一到寒暑假宿舍群安静的要命，突然一位舍友问我一句“在吗”，我猜测应该是找我有事，或者借钱，于是故意等过了八个小时后才回复他，最后也印证了我的猜想。</p><p>也记得在大三暑假那会，我在北京去找中农的好友玩，在一家商场碰到一位美女在推销英语课程，说是帮个忙嘛，她只是为了完成指标，我心一软就答应了，写下自己的联系方式，结果从那天开始到此后的一年时间内，总是接到来自上海、北京、杭州的推销电话，我真是感到无语。</p><p>因此，以后再遇到这种类似的情况，不管当年交情有多么的深厚，不好意思，从此我们是陌路。</p><p>我有时也在问自己，这样是不是太铁石心肠了？——是吗，也许吧。但没办法，社会就是这个样子，你要为了完成指标而四处充当销售，用当年的友情去变现自己的业绩，但我也是有自己的底线，不容逾越！</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>朋友</tag>
        <tag>利益</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-lcof-05-ti-huan-kong-ge | 替换空格</title>
    <url>/2020/02/13/Leetcode-lcof-05-ti-huan-kong-ge/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">面试题05.替换空格</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="使用Go-strings包"><a href="#使用Go-strings包" class="headerlink" title="使用Go strings包"></a>使用Go strings包</h3><p>替换字符串，直接用<code>strings.Replace</code>解决。<br>第一个参数为源字符串，第二个参数表示被替换的部分，第三个参数表示最终被替换成的值，第四个参数表示替换的次数，-1表示不限制次数。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">replaceSpace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> strings.Replace(s, <span class="string">" "</span>, <span class="string">"%20"</span>, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode-剑指offer题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>lcof</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-189-rotate-array | 旋转数组</title>
    <url>/2020/02/13/Leetcode-189-rotate-array/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href>leetcode中国</a></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="方法一，暴力求解"><a href="#方法一，暴力求解" class="headerlink" title="方法一，暴力求解"></a>方法一，暴力求解</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="comment">//暴力解决</span></span><br><span class="line">    <span class="keyword">var</span> temp,previous <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;k;i++ &#123;</span><br><span class="line">        previous = nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(nums);j++ &#123;</span><br><span class="line">            temp = nums[j]</span><br><span class="line">            nums[j] = previous</span><br><span class="line">            previous = temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二，使用额外的数组"><a href="#方法二，使用额外的数组" class="headerlink" title="方法二，使用额外的数组"></a>方法二，使用额外的数组</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="comment">//使用额外的数组</span></span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">        a[(i+k) % <span class="built_in">len</span>(nums)] = nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">        nums[i] = a[i]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-387-first-unique-character-in-a-string | 字符串中的第一个唯一字符</title>
    <url>/2020/02/11/Leetcode-387-first-unique-character-in-a-string/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">leetcode中国</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>1，建立一个字符为<code>key</code>，出现次数为<code>int</code>类型的<code>map</code>；<br>2，第一次循环，记录字符串中每个字符出现的次数；<br>3，第二次循环，找出<code>index</code>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstUniqChar</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// build hash map : character and how often it appears</span></span><br><span class="line">    cmap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(s);i++ &#123;</span><br><span class="line">        c := s[i]</span><br><span class="line">        cmap[c] = cmap[c] + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the index</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(s);i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> cmap[s[i]] == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>哈希表</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-242-valid-anagram | 有效的字母异位词</title>
    <url>/2020/02/07/Leetcode-242-valid-anagram/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">leetcode中国</a></p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAnagram</span><span class="params">(s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    countmap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint8</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		countmap[s[i]]++</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(t); i++ &#123;</span><br><span class="line">        countmap[t[i]]--</span><br><span class="line">        <span class="keyword">if</span> countmap[t[i]] &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>字符串比较</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-283-move-zeroes | 移动零</title>
    <url>/2020/02/07/Leetcode-283-move-zeroes/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">leetcode中国</a></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moveZeroes</span><span class="params">(nums []<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    index := <span class="number">0</span></span><br><span class="line">    <span class="comment">//1，先将非0的数排到数组前面</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> v != <span class="number">0</span> &#123;</span><br><span class="line">            nums[index] = v</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2，再排是0的数到nums数组后面</span></span><br><span class="line">    <span class="keyword">for</span> i:=index;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">        nums[i] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>循环</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-412-fizz-buzz | Fizz Buzz</title>
    <url>/2020/02/02/Leetcode-412-fizz-buzz/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/fizz-buzz/" target="_blank" rel="noopener">leetcode中国</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>按照题目要求的一步步写，读取<code>n</code>的值，然后开始一个<code>for</code>循环在里面一个个判断满足的结果，注意要先将<code>既是3又是5的倍数</code>这一条件进行优先判断。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fizzBuzz</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> re []<span class="keyword">string</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=n;i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> (i%<span class="number">3</span> == <span class="number">0</span> &amp;&amp; i%<span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            re = <span class="built_in">append</span>(re,<span class="string">"FizzBuzz"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i%<span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            re = <span class="built_in">append</span>(re,<span class="string">"Buzz"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i%<span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            re = <span class="built_in">append</span>(re,<span class="string">"Fizz"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            re = <span class="built_in">append</span>(re,strconv.Itoa(i))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>循环</tag>
      </tags>
  </entry>
  <entry>
    <title>极客时间直播_王争_前Google工程师的算法学习与面试经验分享</title>
    <url>/2020/01/09/geekbang-live-wangzheng-algo-interview/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="嘉宾"><a href="#嘉宾" class="headerlink" title="嘉宾"></a>嘉宾</h2><p>王争，前<code>Google</code>工程师</p><h2 id="直播大纲"><a href="#直播大纲" class="headerlink" title="直播大纲"></a>直播大纲</h2><ul><li>1，掌握数据结构和算法的方法；</li><li>2，判定掌握数据结构和算法的标准；</li><li>3，应对算法面试的一些技巧分享。</li></ul><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="学习算法的目的"><a href="#学习算法的目的" class="headerlink" title="学习算法的目的"></a>学习算法的目的</h3><ul><li>1，用于工作</li><li>2，应付面试</li><li>3，潜移默化的提高逻辑思维能力，提高编码能力</li></ul><h3 id="应付面试"><a href="#应付面试" class="headerlink" title="应付面试"></a>应付面试</h3><ul><li>1，看一些优秀的算法专栏</li><li>2，刷<code>leetcode</code></li></ul><h3 id="算法面试到底考察候选人什么？"><a href="#算法面试到底考察候选人什么？" class="headerlink" title="算法面试到底考察候选人什么？"></a>算法面试到底考察候选人什么？</h3><ul><li>1，逻辑思维能力</li><li>2，编写复杂代码的能力</li><li>3，基本数据结构和算法的掌握</li><li>4，时间空间复杂度分析的能力，代码的性能分析能力</li><li>5，编写Bug，free代码的能力</li><li>6，代码是否整洁，是否符合编码规范</li></ul><h2 id="应对算法面试多一些小技巧"><a href="#应对算法面试多一些小技巧" class="headerlink" title="应对算法面试多一些小技巧"></a>应对算法面试多一些小技巧</h2><ul><li><p>1，多搜面经，知己知彼</p></li><li><p>2，练习白板编程<br>在面试前，你要在纸上多练习一下，能够做到脑袋里想好算法之后，能一气呵成的写出代码。</p></li><li><p>3，尽量保证代码没有bug<br>测试要考虑正确情况，错误情况和边界情况。</p></li><li><p>4，尽量保证代码规范<br>在纸上写完之后，如果看着太乱，建议再迅速的抄写一遍。</p></li><li><p>5，要有时间意识<br>对于一些简单算法题目，面试官还会考察你是否能快速写出代码。</p></li><li><p>6，先用最简单的方法解决<br>拿到一道算法题后，先想最简单的解决方法，说给面试官听，然后再进行优化。<br>这样做的目的是一方面是缓和自己的紧张情绪，另一方面可能要闷头想很久，面试官很难知道你的进度，也没法做指导。</p></li></ul><h2 id="算法面试书籍推荐"><a href="#算法面试书籍推荐" class="headerlink" title="算法面试书籍推荐"></a>算法面试书籍推荐</h2><p>个人整理的一些适合准备算法面试时看的书籍，欢迎补充</p><ul><li>《程序员面试金典（第6版）》</li><li>《编程之美》</li><li>《剑指offer》</li><li>《程序员代码面试指南：IT名企算法与数据结构题目最优解》</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>直播学习</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>直播</tag>
        <tag>算法</tag>
        <tag>极客邦</tag>
      </tags>
  </entry>
  <entry>
    <title>我的老师们</title>
    <url>/2020/01/01/my-teachers/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><p>从小学，中学到大学，我遇到过许多各式各样的老师，此文写于我遇到的老师，以及从他们身上学习到的东西。</p><h2 id="小学"><a href="#小学" class="headerlink" title="小学"></a>小学</h2><p>小学的老师没什么印象，只记得我小学三年级时，肚子疼的走不动路，然后班主任就在冬天一步一步把我背回了家，当时让我的父母很感动，然后老师嘱咐了我父母几句，就冒着风雪又走回了学校。</p><p>小学五年级的时候，数学老师要做一个观摩课，需要用到乒乓球，问谁家有，而我天真的以为我父母是开店的，这些都有，于是就说我有，明天给你带来。然而回家后我爸说乒乓球卖完了，然后我就忘记这件事了，结果第二天中午我父亲给我带饭时，老师气汹汹的问我为什么没有带乒乓球过来，眼睛瞪得贼大，吓坏了我，只见我父亲小心翼翼的说“孩子也是作业多，忘记了，老师您是下午有课吧，我中午去买”。于是下午我父亲带着买好的乒乓球，才让老师的课继续讲了下去。</p><p>这件事，让我明白了<strong>既然许诺要做的事，就一定要做到，即使做不到，也要提前告知对方。</strong></p><p>（然而，我事后觉得这位数学老师小题大做，全程我就没看你从箱子里取出乒乓球，唉…总之，最后这些乒乓球有些是我在打乒乓球时打烂的。）</p><h2 id="中学"><a href="#中学" class="headerlink" title="中学"></a>中学</h2><p>初中的班主任，性格还好，很年轻，教我们思想品德课。</p><p>记得初一时，太顽皮，经常被老师叫到办公室去谈话，然而第一次月考，我竟然考到了全班第二，把我给开心坏了，然而老师告诉我，你高兴什么，你全年级才排第30名。我当时心想，天呐，我竟然排这么高的名次，但表面上还得装作惋惜的样子。</p><p>初中还有个语文老师，个子比较矮，上课只口述，很少写板书，问其原因，说是粉笔灰对身体有害，可笑，既然知道有害，你为什么要选择来当老师呢？</p><p>高中的班主任是个语文老师，有次她让我们对一个诗人的情感进行扩写，我扩写到停不住笔变成想象了，结果把这份作业上交了，次日中午全班的作业都发了，唯独我的没有发，我以为老师要当众表扬我，结果等我坐到座位上，老师把昨天要求扩写的作业像废纸一样扔到了我面前，并说我要基于事实扩写，我受够了被要求，想掌握一次主动权，于是说出了“老师，请不要扼杀我的才华”。这句话很奏效，直接把老师怼回去了，然而，她后面直接当着全班的面批评我，让我无地自容。</p><p>后来高二分班，我被分配进了一个男老师的班级。</p><p>而我这个班主任，我觉得很有商业头脑，我的女同桌告诉我，这个老师利用寒暑假在自己的客厅搭了一个小教室，让20个左右的学生挤进家里补物理课，一个寒假下来赚好几万，而我有次在班里去问他物理题，他爱理不理的样子让我很生气，于是我后来有物理上的问题，直接跑到高一带我物理的张老师那里去问了。</p><h2 id="大学"><a href="#大学" class="headerlink" title="大学"></a>大学</h2><p>大学碰到过各式各样的老师，对以下几个老师印象极为深刻</p><ul><li><p>班主任<code>S</code>：很感谢他大学四年的指导，虽然我很反感他上课老讲他在长安大学怎么怎么样，毕业后在北京怎么怎么样（遇到这种情况我一般私底下看小说或算法书），但我至今记得他大二时给我说<strong>不要把眼光局限在学校里，多向优秀的人去学习</strong>，以及大三时告诫我<strong>想要在这个世界生存下来，先适应这个世界的生存法则，再寻求转机</strong>。毕业前也感谢他私底下给我签了请假条上的字，让我赶上了大城市校招的末班车。</p></li><li><p>编译原理老师<code>L</code>：这个老师是我大学学院里最讨厌的老师之一，没有本事，却天天上课吹牛逼，有时还要和我做算法竞赛交易，例如指导老师报他的名字，到时得奖了给我奖励100元，呵呵，谁稀罕你那点钱，于是我果断拒了。</p></li><li><p>学院的一位副教授<code>G</code>：这位老师是我另外讨厌的一个人，虽然没有和他正面接触过，但那大大的脸上镶着一双小小的眼睛令我印象深刻，他会在其他学院的计算机基础课上吹牛说写程序的人是多么多么牛逼，你们这些文科生是进不来的，我当时听到我朋友说这些话我就想骂一句 放屁，他（指<code>G</code>）算什么东西，有什么资格评价你们学文科的！后来又听说班级聚餐时逼迫那些女生喝酒，我就对他的厌恶又加深的一分。他带队<code>acm</code>去参加比赛，为了多捞点学校的钱，把学生的毕设答辩全不当一回事。</p></li><li><p>学院数据结构老师<code>W</code>：这位老师印象深刻的一幕是，上了一节数据结构课，念<code>PPT</code>，后来为了嘚瑟自己写一个单链表删除的程序，结果硬是卡了大半节课还没找到<code>bug</code>，最后被我身边一位高中打信息学奥赛的湖南朋友分分钟解决。大三时看他因为贪污学校公款被举报，登上了学校的首页，我很高兴。</p></li></ul><h2 id="社会"><a href="#社会" class="headerlink" title="社会"></a>社会</h2><p>进入了社会，我发现我进入了另外一种学校，这里的许多人都是我的老师，有毕业刚进入公司带我做项目的导师，有我敬佩的同事，以及<code>leader</code>。</p><p>我想，未来我还会在这所社会学校中学到更多的东西。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>往事如风</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>老师</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业18个月，我终于在这座城市活了下来</title>
    <url>/2019/12/30/graduate-18-months-i-finally-survived-in-the-city/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2019年12月19日，星期四，我在成都，写下了这句话，距离的毕业后的第一天入职，已经过去了整整十八个月。现在，我终于敢说，我在这座城市活了下来。</p><p>犹记得，大学还有半年就毕业时，经历了考研失败的我，在考虑去哪座城市发展时，高中好友涛说，来成都嘛，找工作可以先住我家，于是，我跟父母说明情况后，就来到了成都。</p><p>在这里，我逐渐学会了如何独立成长，如何与自己独处，如何照顾自己，以及如何与他人协作。</p><p>从大一到大四，可能唯一的遗憾就是没有去实习过。</p><p>寒假时间短，冬天基本就是在家，或者出去看看那似曾相识的街道，在雪地里和妹妹打雪仗。</p><p>犹记得，最快乐最有意义的时光都是在暑假度过————支教，远途旅行，以及在家准备考研。</p><p>毕业后的18个月，失去父母庇护的我，学习着如何写简历，投简历，面试，以及签下了我的第一份劳务合同，第一个月拿到了试用期的薪资，那一刻我放佛觉得我长大了，不再需要问父母要生活费，可以自己自给自足。</p><h2 id="亲爱的小孩，今天有没有哭"><a href="#亲爱的小孩，今天有没有哭" class="headerlink" title="亲爱的小孩，今天有没有哭"></a>亲爱的小孩，今天有没有哭</h2><h3 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h3><p>毕业后最大的收获，就在于适应了职场生存的法则。</p><p>犹记得，刚入职的时候，第一次用<code>Go</code>写一个定时删除服务，涉及了大量的文件处理，设计模式和并发等知识点，当我写完后，我感觉很有成就感，后来，当这个服务产品化后，出现了一个内存泄露的问题，我又用性能分析工具层层剖析，解决了它。</p><p>但我知道这只是小试牛刀，接着我有接手了一个核心调度的项目，然而这个项目给我的打击太大，比如逻辑很复杂，导致和产品对需求的时候，都不敢保证这个需求什么时候能做出来；又比如当整个系统出来了问题时，会把所有的<code>Bug</code>都指派给我，然后我就挨个去打断点，看日志去排查；又比如有一次，因为需求太多，做不完，每天被<code>leader</code>和其他同事催着赶进度时，我只能偷偷跑到卫生间去哭上五分钟，然后擦干眼泪继续做。</p><p>为什么我对这两件事这么记忆尤新呢，因为它让我看到了一个程序员工作的缩影：提需求——编码——测试——改<code>Bug</code>——新的需求…周而复始。</p><p>在工作中，我也总结了一些研发和改<code>Bug</code>的经验</p><ul><li>1，和产品经理沟通是双向的，当他/她提出一个需求时，最好是根据自己的理解把他/她的话再复述一遍，以确认是否信息一致，当然最好写在文档里，后面可以防止产品频繁变需求（虽然这个愿望有些微小）；</li><li>2，编码时，最好理清逻辑，在脑海中画好逻辑时序图，接着写代码就会轻松许多；</li><li>3，最好在容易出错，以及频繁赋值的地方打上日志，后期出现<code>Bug</code>时好及时有效地定位问题；</li><li>4，如果出现<code>Bug</code>了，最好在已经出现<code>Bug</code>的机器上再复现一遍，当然也可以在本地搭一个完整的测试环境，这样最好；</li><li>5，运用性能分析工具，解决完<code>Bug</code>后，最好详细将<code>Bug</code>出现的原因和解决过程个最终结果记录下来，方便以后自己查阅；</li><li>6，将自己的研发时间定在25-35分钟一块，中间最好不要被别人打断；</li><li>7，学会使用搜索引擎，尽量用<code>Google</code>和<code>Bing</code>，将问题切换成英文描述，搜出来的文章质量会高一些；</li><li>8，是你的问题，及时承担，不是你的问题，找到证据后迅速甩锅。</li></ul><p>以上是我个人在写程序的经验小结。</p><h3 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h3><ul><li>1，自己做的饭真好吃</li></ul><p>2019年最大的感受就是学会了做饭。</p><p>自己买了电磁炉，照着网上的步骤开始学会炒素菜，炒荤菜。接着依葫芦画瓢，不断调整酱油、盐、鸡精的比例，味道和颜色也好了许多。</p><p>我想今年过年家里又多了个做饭的帮手。</p><ul><li>2，一觉睡到自然醒的感觉真爽</li></ul><p>项目不忙的时候，六点半下班，回去看看书，玩玩手机，十一点前关灯睡觉，早上一觉睡到自然醒，再看看表，八点多，没事，还来得及。</p><p>这段<code>一觉睡到自然醒</code>的时光，让我又找回了睡觉的乐趣，同时对<code>996</code>的厌恶又加深了一些。</p><ul><li>3，睡前水乳护肤很舒服</li></ul><p>从大学买的一套曼秀雷敦，到18年毕业时买的高夫男士全套，再到今年的百雀羚，我逐渐学会了护肤这一技能。</p><p>先用清水洗一遍脸，再涂上洗面奶清一遍，再用爽肤水，护肤乳，后面还可以用面霜，眼霜除皱纹，上班时还可以抹一层隔离霜，每次护理完，感觉脸像生命一样在自由的呼吸，很清爽。</p><h3 id="在这座城市，哭过，笑过"><a href="#在这座城市，哭过，笑过" class="headerlink" title="在这座城市，哭过，笑过"></a>在这座城市，哭过，笑过</h3><p>在一座陌生的城市，给我最大的感触就是，一切都只能靠自己。</p><p>找房子，你需要现场去验房，签合同；找工作，需要自己投简历，面试，签劳动合同；工作完成不了，你需要自己加班赶进度。</p><p>折磨你，也在成就你。</p><p>谢谢你，让我变得更坚强。</p><h2 id="要感谢的人"><a href="#要感谢的人" class="headerlink" title="要感谢的人"></a>要感谢的人</h2><ul><li>感谢我的父母对我只身前往陌生城市的支持；</li><li>感谢我的女友，教会为如何护肤，告诫我不要一到周末就想着外面吃，要自己买菜做饭；</li><li>感谢我在成都结识的好友，在知道我要面试时，分享了他宝贵的面试经验并整理成文档分享给我；</li><li>感谢我在健身房结识的一位好友，一起健身，劳逸结合，在健身中释放一天的压力；</li><li>感谢我在游戏公司时结识的一位前辈，他教会我把眼界放长远一些；</li><li>感谢我在公司部门内刚入职时带我的导师，教会我如何设计程序，分享他的所见所闻和工作经验；</li></ul><p>谢谢你们的帮助，让我在这一年内学会了许多技能，它们是我在这黑暗森林中得以生存的资本。</p><h2 id="文章链接"><a href="#文章链接" class="headerlink" title="文章链接"></a>文章链接</h2><ul><li><a href="https://octopuslian.github.io/2019/03/28/first-work-project-havest/">第一次做项目学到的技术之外的东西</a></li><li><a href="https://octopuslian.github.io/2019/05/31/a-project-deadline-note/">记一次项目演示前赶deadline的经历</a></li></ul><p><img src="/2019/12/30/graduate-18-months-i-finally-survived-in-the-city/live.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>我那些奇葩的舍友们</title>
    <url>/2019/12/27/weird-roommates/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><p>前几天做了一个梦，梦见我的舍友了，而我的第一反应，就是想打他们。</p><p>为什么想打，因为那是我曾压抑许久的潜意识。</p><p>我的本科大学在一座十八线的小城市里，记得第一天入学报到，学姐说计算机专业的宿舍已经满员了，于是把我分配到和通信专业的一个宿舍，结果就开始了我的噩梦之旅。</p><p>宿舍虽然是六人间，但加上我总共只有五个人，分别是舍友M，舍友H，舍友C和舍友W。</p><p>大一和大二都还好，真正感到无语的情景是从大三开始。（也许大二就开始了，但我忘记了）</p><p>记得有这几件事情触动了我。</p><h4 id="舍友C宿舍抽烟"><a href="#舍友C宿舍抽烟" class="headerlink" title="舍友C宿舍抽烟"></a>舍友C宿舍抽烟</h4><p>有次我重感冒，感冒到感觉嗓子冒烟，吃了药，中午在床上午休，舍友C边看剧边抽烟，我呛到实在忍不住，温柔的对他说一声“我感冒了，麻烦别抽烟了好吗？”，结果他当做没听见继续抽。</p><h4 id="舍友M的猥琐"><a href="#舍友M的猥琐" class="headerlink" title="舍友M的猥琐"></a>舍友M的猥琐</h4><p>舍友M戴着眼镜，看着挺斯文的，但是在他那斯文的外表下，我却看到了一颗猥琐的心。</p><p>为什么会这样说，因为他每天晚上，都会无缘无故的给我们讲一些黄色笑话，有些“语言”都是我无法理解的，结果他却无缘无故的笑起来，关键是还总拿我举例，有时还语言攻击其他专业的一些女生。</p><p>对这样的人，我只能呵呵。</p><h4 id="满口脏话，瘦骨如柴的H"><a href="#满口脏话，瘦骨如柴的H" class="headerlink" title="满口脏话，瘦骨如柴的H"></a>满口脏话，瘦骨如柴的H</h4><p>舍友H在我看来是重朋友友情的，然而，我很反感他打英雄联盟时的满口脏话，有时甚至不打了专门停下来和别人对骂，我在想至于吗，不就是个游戏吗，大不了不玩了呗。</p><p>大四谈恋爱了，一天到晚电话没完没了了，白天就算了，你TMD晚上凌晨三点还在和女朋友堡电话粥，你还让我们睡觉吗？哦不对，不是我们，是我，因为其他三个还没有入睡，于是，我只能用耳塞，或者放BBC让自己催眠。</p><p>最令我感到愤怒的是舍友H有次打游戏塔让敌方推了，于是就拿我撒气，问我为什么凳子摆在他那，不好意思，凳子只是摆在我上床休息时的梯子那，于是就开始各种言语攻击，我当时真有拿起凳子朝他后脑勺砸下去的打算，但是我忍住了，我不能因为这样一个人渣断送我的前程，我想到时候我父母一定会很伤心。</p><h4 id="自卑自大贪小便宜的W"><a href="#自卑自大贪小便宜的W" class="headerlink" title="自卑自大贪小便宜的W"></a>自卑自大贪小便宜的W</h4><p>同样，舍友W也是一个重情义的人，而且很聪明，期末考试不光能令自己通过，而且还能给另外三个舍友拿下助攻。</p><p>然而，令我感到惊悚的一点就是，你非常自卑，为什么这么说，因为有次舍友们在谈论大城市有多么多么好的时候，我就是在大城市长大的，而我只是阐述我觉得大城市也没那么好，我还是比较向往乡村…然而当我的话还没有说完时，你就从床上坐起来恶狠狠的看着我说“咋了，农村人咋了？！” 我很懵逼锕。</p><p>不管你能不能看到这段话，至少这是我压抑在心里的话，不好意思，我没有瞧不起农村。</p><p>同样的情节也发生在舍友M身上，又是舍友们在谈论初高中住宿，我说我好羡慕你们啊，初高中住宿，我初高中都是住家里，大学才住宿，从你们身上学到了好多生活常识，而舍友M，你是TMD脑回路有问题吗，莫名其妙的对我说了句“咋了，你以为就你是家养的，我们就是散养的是吧”。</p><p>而最让我感到无语的是，在我临近毕业准备去成都工作时，你说了一句“出去记得好好做人…”，我当时听到这句话，真想一巴掌扇烂你的嘴，你有什么资格说这句话？？？就因为你比我大一岁？</p><h4 id="What-a-Fuck"><a href="#What-a-Fuck" class="headerlink" title="What a Fuck !"></a>What a Fuck !</h4><p>从那以后，我谨言慎行，少说话，早上起来，去吃早饭，然后去图书馆或者实验室学习，晚上等图书馆或教学楼关门的时候出来，回宿舍洗漱完就睡觉。</p><p>然而好景不长，记得我有次参加算法竞赛拿了省一，要去北京参赛，回来后已经过去了十二天，舍友M、H和W一致叫我把宿舍的桶装水连换两次，我问其原因，他们说上周你去北京参赛了，所以那桶水你改换，我说我这十二天没有喝一口水吧，不好意思我不换；然后舍友M说你去北京参赛这段时间宿舍停了一天电，是我们其余四人垫付的，你也应该交，我说停电那一天我在外面，我没有用过一丝电，我不叫；然后他又说你每天早晨八点起床开灯，晚上十一点半回来用灯，这电费应该交，我TM快无语了，宿舍每个月免费使用36度电，难道我每天早晨起床用半小时电，晚上回来用半小时电，这点电一个月就能超过6度？ 于是舍友M不说话了，然后舍友C回来问我们在吵什么，听完缘由后，他说了句这钱本来就不该他（指我）掏啊，我心想终于有个明事理的人了，结果舍友C下一句话对我说，你要是实在掏不起那点钱，我就帮你掏吧….我TM掏不起那点钱，我只是不想被你们无缘无故欺负罢了！</p><p>后来我把这件事和我家人说起，他们很诧异，怎么会有如此不要脸的人，然后父亲就告诉说实在不行就掏了吧，家里不欠这点钱，我苦笑说了句，这不是钱不钱的事情，如果我掏了这个钱，后面会不会还有其他奇葩的需求需要我交钱。</p><p>后来，我和舍友关系决裂，他们聚餐从不叫我（反正从大学进来到毕业，也就只在刚开始一起吃过一次），说起吃饭，有次说好一块出去吃饭，舍友H手贱开了一句英雄联盟，然后舍友C也开了一局，结果等舍友H打完了准备去吃饭，舍友H还没打完，见状舍友C又重开了一局，等舍友C打完第一局后见舍友H又开了第二局，于是舍友C又开了第二局，我在想，你们能不能动点脑子啊，吃完饭回来开N局都没事，于是，说好的六点去吃饭，一直拖到八点，去他妈的聚餐，老子自己去吃了。</p><p>每每想起你们这些人的行为，我就想作呕，我是怎样和你们一块度过了四年，哦不，其实准确的说是三年半，因为中间有一个多学期搬到别的宿舍去住了，因为，<strong>我实在受不了了！！！</strong></p><p>考研究生的时候，各种讽刺挖苦，等我混好了，又是各种巴结。</p><p>在临近毕业还有两个月，奇葩的学校突发奇想要大家都换宿舍，真是无语。</p><p>舍友C边哭边给辅导员说不想搬到隔壁宿舍，因为隔壁宿舍太臭了，怕染上味道找不到女朋友，于是自告奋勇地说我和舍友W愿意换到那个宿舍，我于是私底下问了舍友W愿意换宿舍？他一句草泥马老子什么时候说要换，让我知道舍友C在说谎。</p><p>后来我把舍友C给辅导员求情这一段告诉了舍友W，H，M，他们都很愤怒，说是同一个屋檐下住了快四年，最后为了利益只顾自己，于是大家把舍友C孤立了起来，舍友W还说瞎了狗眼以前还帮舍友C作弊，传答案，舍友M还说舍友C天天趁你们不在的时候，私底下骂你们呢。</p><p>（顺便我想告诉舍友C，你当时在床上肚子疼的下不了床，周围人都不理你的样子，真是狼狈！）</p><p>其实，这些我都知道，从舍友C的眼神中我就可以看出来，只是，我不想惹事，所以一直忍，因为我相信这件事是包不住的。就像：</p><ul><li>舍友H曾经在宿舍里单独和我说舍友C和舍友M的自私，洗发水用完了自己不买，全用他的，真是受够了；</li><li>舍友W和我在去图书馆的路上说宿舍没一个好东西，都是自私的；</li><li>舍友C一天到晚嘴碎天天评论别人，骂舍友H像个女人，骂舍友W像个娘炮泡，不够男人（请问怎么算男人，难道满嘴脏话黄段子就是man吗？），骂舍友M最讨厌的人之一。</li></ul><p>这些“单独的谈话”我都知道，我只是不说罢了。</p><p>以前舍友M还说，我发现你从进来到现在，好像从来没有一次给我们请过客哎，我也是无语，给你们吃水果，给你们买烤鸭，你们都TMD忘记了吗？？？</p><p>我过生日那天，我自己买了瓜子水果和蛋糕，只是希望你们能陪我过一个19岁的生日，舍友C和舍友H一直在打游戏，达到十二点半熄灯了才来过生日，舍友M就跟蔫了一样摊在床上不下来。————这是我过的最差的一次生日，18岁的前的每一个生日，我都和我的家人快乐的度过，但在宿舍，我只有感到寒心与无助！！！</p><p>每次受委屈后，我都和家人打电话，边哭边打，想着早点毕业离开这该死的地方。</p><p>2018年5月底，当我拍完班级毕业照后，我第二天就申请了离校，离开了这个我再也不会来的地方，我用四年的经历，告诫我的父母，<strong>环境真的很重要！！！</strong></p><p>当我离开校园，踏上回家的旅程时，那一刻，我的心是自由的。</p><p>愿我能依旧保持自由的心。</p><h3 id="最后要说的话"><a href="#最后要说的话" class="headerlink" title="最后要说的话"></a>最后要说的话</h3><p>这篇文章的感受，是我长久压抑在自己内心深处的感受，现在写完感觉释然了好多。</p><p>我不知道在读这篇文章的你，有没有遇到类似文中的<code>W,H,C,M</code>这样的人，如果没有遇到，那么你很幸运，生活质量又高了一分。</p><p>很感谢那些安慰开导过我的朋友（尤其是学法律的朋友），我从小到成年从来没有过这样如此一再挑战我心理和尊严底线的经历，我曾多少次想要张开獠牙，挣开道德的约束，拿起身边最尖锐的东西，用力戳破这四周的虚伪和愤怒，但是最后一丝理智告诉我一定要忍耐，因为我这一凳子下去，可能一辈子就毁了。</p><blockquote><p>最后我想对<code>W,H,C,M</code>说，倘若我们还能相遇，倘若你还是那么冥顽不顾，那么你绝对绝对绝对不会有在学校那么好的运气了。<br>（但愿我们不要再相遇。）</p></blockquote><p><img src="/2019/12/27/weird-roommates/free.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>往事如风</category>
      </categories>
      <tags>
        <tag>奇葩</tag>
        <tag>愤怒</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-2-add-two-numbers | 两数相加</title>
    <url>/2019/12/23/Leetcode-2-add-two-numbers/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">leetcode中国</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="comment">//先考虑特殊情况</span></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sum := l1.Val + l2.Val</span><br><span class="line">    nextNode := addTwoNumbers(l1.Next, l2.Next)</span><br><span class="line">    <span class="keyword">if</span> sum &lt; <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;ListNode&#123; Val: sum, Next: nextNode &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tempNode := &amp;ListNode&#123;</span><br><span class="line">            Val: <span class="number">1</span>,</span><br><span class="line">            Next: <span class="literal">nil</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &amp;ListNode&#123;</span><br><span class="line">            Val: sum - <span class="number">10</span>,</span><br><span class="line">            Next: addTwoNumbers(nextNode, tempNode),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-292-nim-game | Nim 游戏</title>
    <url>/2019/12/19/Leetcode-292-nim-game/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/nim-game/" target="_blank" rel="noopener">leetcode中国</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>只要不被4整除就行。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canWinNim</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (n % <span class="number">4</span> != <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>合理分析问题，做数学归纳，有时候可以化繁为简，一眼洞穿题目的本质！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://leetcode-cn.com/problems/nim-game/solution/nimyou-xi-by-leetcode/" target="_blank" rel="noopener">leetcdoe官方解答</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数学归纳</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-557-reverse-words-in-a-string-iii | 反转字符串中的单词 III</title>
    <url>/2019/12/19/Leetcode-557-reverse-words-in-a-string-iii/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="noopener">leetcode中国</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>1，先将字符串分解成数组</li><li>2，使用<code>for range</code>循环取出数组中的元素，并执行反转字符串的操作</li><li>3，将反转后的字符串<code>append</code>进一个新的<code>string</code>类型的数组</li><li>4，循环遍历这个新的<code>string</code>类型的数组，拼接成一个字符串，返回最终结果</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseWords</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	ss := strings.Fields(s)</span><br><span class="line">	<span class="keyword">var</span> results []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> _, str := <span class="keyword">range</span> ss &#123;</span><br><span class="line">		<span class="keyword">var</span> shift_str []<span class="keyword">byte</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">			shift_str = <span class="built_in">append</span>(shift_str, str[<span class="built_in">len</span>(str)-i<span class="number">-1</span>])</span><br><span class="line">		&#125;</span><br><span class="line">		results = <span class="built_in">append</span>(results, <span class="keyword">string</span>(shift_str))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	re := <span class="string">""</span></span><br><span class="line">	<span class="keyword">for</span> index, value := <span class="keyword">range</span> results &#123;</span><br><span class="line">		<span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">			re = re + value</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			re = re + <span class="string">" "</span> + value</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> re</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，此方案不是最优解，后期再更新优化后的解法，目前只为快速解决题目。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>字符串</tag>
        <tag>反转</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-70-climbing-stairs | 爬楼梯</title>
    <url>/2019/12/17/Leetcode-70-climbing-stairs/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">leetcode中国</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>第一层：0+1=1种<br>第二层：1+1=2种<br>第三层：2+1=3种<br>第四层：3+2=5种<br>第五层：5+3=8种<br>第六层：8+5=13种<br>…</p><p>得出结论：<strong>第<code>x</code>层爬楼梯的方法数量=第<code>x-1</code>层种+第<code>x-2</code>层种</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="comment">//小于2，直接返回值</span></span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FirstNum := <span class="number">1</span></span><br><span class="line">    SecondNum := <span class="number">2</span></span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">3</span>;i&lt;=n;i++ &#123;</span><br><span class="line">        result = FirstNum + SecondNum  <span class="comment">//当前层 = 倒数第一层 + 倒数第二层</span></span><br><span class="line">        FirstNum = SecondNum</span><br><span class="line">        SecondNum = result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-9-palindrome-number | 回文数</title>
    <url>/2019/12/16/Leetcode-9-palindrome-number/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">leetcode中国</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="第一种解法"><a href="#第一种解法" class="headerlink" title="第一种解法"></a>第一种解法</h3><ul><li>1，先将<code>x</code>转为字符串类型，这样好根据下标来判断是否为回文数；</li><li>2，声明<code>i</code>和<code>j</code>两个<code>int</code>型变量，其中<code>i</code>在字符串<code>x</code>的最左边，<code>j</code>在字符串<code>x</code>的最右边，<code>i</code>从左往右开始递增，<code>j</code>从右往左开始递减，每次当<code>i</code>递增和<code>j</code>递减一次后，判断<code>i</code>和<code>j</code>下标所对应的元素是否相等，如果不相等，说明不是回文数，返回<code>false</code>，否则最终返回<code>true</code>。</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	x_str := strconv.Itoa(x) <span class="comment">// 整型转换为字符串</span></span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(x_str)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">		<span class="comment">//i从左开始，j从右开始，i递增，j递减，逐个判断下标i和j对应的数字是否相等</span></span><br><span class="line">		<span class="keyword">if</span> x_str[i] != x_str[j] &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://leetcode-cn.com/problems/palindrome-number/solution/dong-hua-hui-wen-shu-de-san-chong-jie-fa-fa-jie-ch/" target="_blank" rel="noopener">动画：回文数的三种解法 | 法解种三的数文回：画动</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回文数</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-136-single-number | 只出现一次的数字</title>
    <url>/2019/12/15/Leetcode-136-single-number/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">leetcode中国</a></li><li><a href="https://leetcode.com/problems/single-number/" target="_blank" rel="noopener">leetcode</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>第一步，新建一个<code>map</code>，用一个<code>for</code>循环，记录<code>nums</code>数组中出现的元素和次数，如果重复出现，<code>value</code>置为2，出现一次置为1；</li><li>第二步，再用一个<code>for</code>循环，遍历这个新建<code>map</code>，判断<code>value</code>为是否1，如果为1，就把<code>value</code>为1对应的<code>key</code>返回即可。</li></ul><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    numsmap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> numsmap[v] != <span class="number">0</span> &#123;</span><br><span class="line">            numsmap[v] = <span class="number">2</span>  <span class="comment">//有重复，value为2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            numsmap[v] = <span class="number">1</span>  <span class="comment">//无重复，value为1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> numsmap &#123;</span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">1</span> &#123;</span><br><span class="line">            result = k  <span class="comment">//返回那个只出现一次的数字</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-344-reverse-string | 反转字符串</title>
    <url>/2019/12/12/Leetcode-344-reverse-string/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">leetcode中国</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一步，使用<code>for</code>循环，将数组<code>s</code>里的最后一位<code>append</code>进新数组<code>result</code>，以此类推<br>第二步，将新数组<code>result</code>里的值复制到数组s即可</p><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseString</span><span class="params">(s []<span class="keyword">byte</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(s);i++&#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result,s[<span class="built_in">len</span>(s)-i<span class="number">-1</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> result &#123;</span><br><span class="line">        s[k] = v</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-78-subsets | 子集</title>
    <url>/2019/12/12/Leetcode-78-subsets/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">leetcode中国</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//复制数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copySlice</span><span class="params">(src []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	temp := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, i := <span class="keyword">range</span> src &#123;</span><br><span class="line">		temp = <span class="built_in">append</span>(temp, i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	result = <span class="built_in">append</span>(result, []<span class="keyword">int</span>&#123;&#125;) <span class="comment">//第一步 包含空集</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        length := <span class="built_in">len</span>(result)</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; length; j++ &#123;</span><br><span class="line">			<span class="comment">//设定两个下标元素,从0开始遍历nums的值</span></span><br><span class="line">			<span class="comment">//里层复制数组,接着append进去下标为j的值组成nums的一个子集,再append进result数组</span></span><br><span class="line">			result = <span class="built_in">append</span>(result, <span class="built_in">append</span>(copySlice(result[j]), nums[i]))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>代码直接写成<code>for j := 0; j &lt; length; j++</code>会超出内存限制，我在本地虚拟机上运行时，会卡爆电脑，原因正在找。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-26-remove-duplicates-from-sorted-array | 删除排序数组中的重复项</title>
    <url>/2019/12/12/Leetcode-26-remove-duplicates-from-sorted-array/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">leetcode中国</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用<code>for</code>循环从数组<code>nums</code>末尾的最后一个数字开始遍历，让数组<code>nums</code>末尾最后一个数字与末尾最后倒数第二个数字做比较，如果后一个等于前一个，则从数组中删除后一个元素，直到遍历完成，返回新数组的长度。</p><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="built_in">len</span>(nums)<span class="number">-1</span>;i&gt;<span class="number">0</span>;i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">            nums = <span class="built_in">append</span>(nums[:i],nums[i+<span class="number">1</span>:]...)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-53-maximum-subarray | 最大子序和</title>
    <url>/2019/12/10/Leetcode-53-maximum-subarray/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/maximum-subarray" target="_blank" rel="noopener">leetcode中文</a><br><a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">leetcode</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="暴力解"><a href="#暴力解" class="headerlink" title="暴力解"></a>暴力解</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">//一个临时值，和一个最大值</span></span><br><span class="line">    temp,max := <span class="number">0</span>,nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp + nums[i]) &gt; nums[i] &#123;</span><br><span class="line">            temp = temp + nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> temp &gt; max &#123;</span><br><span class="line">            max = temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max  <span class="comment">//返回最大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">//dp解法</span></span><br><span class="line">    <span class="keyword">var</span> dp = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    max := nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="comment">//做判断</span></span><br><span class="line">        <span class="keyword">if</span> (dp[i - <span class="number">1</span>] + nums[i]) &gt; nums[i] &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> dp[i] &gt; max &#123;</span><br><span class="line">            max = dp[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/golangban-dong-tai-gui-hua-fu-sha-gua-ban-si-lu-sh/" target="_blank" rel="noopener">golang版动态规划，附傻瓜版思路（傻瓜也能看懂）</a></li><li><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/golangjie-fa-si-lu-by-iphpt/" target="_blank" rel="noopener">Golang解法+思路</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>暴力求解</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-7-reverse-integer | 整数反转</title>
    <url>/2019/12/08/Leetcode-7-reverse-integer/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">leetcode中国</a></li><li><a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">leetcode</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>需要解决两个问题</p><ul><li>1，排除为0的情况</li><li>2，反转数字</li></ul><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//考虑x为负数的情况</span></span><br><span class="line">        <span class="keyword">return</span> -reverse(-x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> re <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> x != <span class="number">0</span> &#123;</span><br><span class="line">        re = re*<span class="number">10</span> + x%<span class="number">10</span></span><br><span class="line">        x = x/<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> re &lt; <span class="number">0x7fffffff</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> re</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-217-contains-duplicate | 存在重复元素</title>
    <url>/2019/12/07/Leetcode-217-contains-duplicate/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/contains-duplicate" target="_blank" rel="noopener">leetcode中国</a><br><a href="https://leetcode.com/problems/contains-duplicate/" target="_blank" rel="noopener">leetcode</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先考虑到特殊情况，<strong>nums数组元素为0和1，直接返回false</strong><br>设置计数变量<code>count</code>，将第一次遍历数组得到的元素与第二次遍历数组得到的元素做判断，如果两数相等，就将<code>count</code>加1，在结束循环后对<code>count</code>做判断，<code>count</code>值不等于0返回<code>true</code>，否则返回<code>false</code>。</p><p>这里尤其需要注意，第一次遍历数组的下标一定比第二次遍历出的数组元素下标大，举个例子：<br>输入<code>[1,2,3,1]</code>，判断这个数组里有没有重复元素，第一次遍历<code>nums[0]</code>得到1，那么第二次遍历时肯定不能从<code>nums[0]</code>开始，必须从<code>nums[1]</code>开始往后累加，不然在同一个数组中，将下标相等的两个元素做比较，肯定相等，从而AC不通过。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">containsDuplicate</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> || <span class="built_in">len</span>(nums) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">//考虑nums特殊情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i+<span class="number">1</span>;j&lt;<span class="built_in">len</span>(nums);j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[j] &#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> count != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附录，踩坑记录"><a href="#附录，踩坑记录" class="headerlink" title="附录，踩坑记录"></a>附录，踩坑记录</h2><h3 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h3><p>创建一个<code>shift</code>数组，第一步先遍历<code>nums</code>数组，将每次遍历取出的<code>num</code>与<code>shift</code>数组里的值做判断，如果相等就代表重复，<code>count</code>增1，最后在循环结束后，对<code>count</code>做判断，如果不等于1，返回<code>true</code>，否则返回<code>false</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一版</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">containsDuplicate</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> shift []<span class="keyword">int</span></span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(shift) == <span class="number">0</span> &#123;</span><br><span class="line">            shift = <span class="built_in">append</span>(shift,num)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> _,s := <span class="keyword">range</span> shift &#123;</span><br><span class="line">                <span class="keyword">if</span> s == num &#123;</span><br><span class="line">                    count++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            shift = <span class="built_in">append</span>(shift,num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> count != <span class="number">1</span> &amp;&amp; count != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第一版存在的问题"><a href="#第一版存在的问题" class="headerlink" title="第一版存在的问题"></a>第一版存在的问题</h4><ul><li>为什么要复制数组，直接用原来的<code>nums</code>数组做<code>range</code>不可以吗？</li><li><code>append</code>数组有问题</li><li>没有考虑<code>nums</code>数组元素为1和0两种特殊情况</li><li>判断条件只需满足<code>count != 0</code>即可</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>暴力求解</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-122-best-time-to-buy-and-sell-stock-ii | 买卖股票的最佳时机II</title>
    <url>/2019/12/06/Leetcode-122-best-time-to-buy-and-sell-stock-ii/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">买卖股票的最佳时机 II</a></li><li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. Best Time to Buy and Sell Stock II</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于没有规定交易次数，所以可以遍历<code>prices</code>数组。<br>如果后一个比前一个大，做差，并累积利润，最后返回结果。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    maxProfit := <span class="number">0</span>  <span class="comment">//最大利润</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(prices)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i+<span class="number">1</span>] &gt; prices[i] &#123;</span><br><span class="line">            <span class="comment">//如果后一笔比前一笔数额大，做减法，累积利润</span></span><br><span class="line">            maxProfit = maxProfit + prices[i+<span class="number">1</span>] - prices[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-121-best-time-to-buy-and-sell-stock | 买卖股票的最佳时机</title>
    <url>/2019/12/05/Leetcode-121-best-time-to-buy-and-sell-stock/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">原题链接</a><br><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">中文原题链接</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>1，暴力求解，直接求出买入和买出的最大值返回即可。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>方法一：暴力法求解</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    maxProfit := <span class="number">0</span>  <span class="comment">//最大利润</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(prices); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[j] - prices[i] &gt; maxProfit) &#123;</span><br><span class="line">                maxProfit = prices[j] - prices[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>暴力求解</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵导读_《微积分入门》_第七天_柯西判别法</title>
    <url>/2019/11/23/turing-read-introduce-to-calculus-day7/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="知识点概览"><a href="#知识点概览" class="headerlink" title="知识点概览"></a>知识点概览</h2><p>本节定理的证明十分精彩，几乎把前面所学到的知识的板块，集训似的演练一遍。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>（位置在书本的第十八面，定理1.13）</p><p><img src="/2019/11/23/turing-read-introduce-to-calculus-day7/1.jpg" alt></p><p><img src="/2019/11/23/turing-read-introduce-to-calculus-day7/2.jpg" alt></p><p><img src="/2019/11/23/turing-read-introduce-to-calculus-day7/3.jpg" alt></p><p><img src="/2019/11/23/turing-read-introduce-to-calculus-day7/4.jpg" alt></p><p><img src="/2019/11/23/turing-read-introduce-to-calculus-day7/5.jpg" alt></p><h3 id="证明α是数列极限"><a href="#证明α是数列极限" class="headerlink" title="证明α是数列极限"></a>证明α是数列极限</h3><p><img src="/2019/11/23/turing-read-introduce-to-calculus-day7/6.jpg" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>从定义上认真理解到位，很重要。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://wikipedia.hk.wjbk.site/wiki/%E6%9F%AF%E8%A5%BF%E5%88%A4%E5%88%A5%E6%B3%95" target="_blank" rel="noopener">维基百科_柯西判别法</a></li></ul><p><img src="/2019/11/23/turing-read-introduce-to-calculus-day7/day7.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>数学学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>TURING</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵导读_《微积分入门》_第六天_数列极限的基本概念</title>
    <url>/2019/11/22/turing-read-introduce-to-calculus-day6/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="/2019/11/22/turing-read-introduce-to-calculus-day6/9.jpg" alt></p><p><img src="/2019/11/22/turing-read-introduce-to-calculus-day6/8.jpg" alt></p><p><img src="/2019/11/22/turing-read-introduce-to-calculus-day6/7.jpg" alt></p><p><img src="/2019/11/22/turing-read-introduce-to-calculus-day6/6.jpg" alt></p><p>4，不收敛数列</p><h3 id="论证定理1-2"><a href="#论证定理1-2" class="headerlink" title="论证定理1.2"></a>论证定理1.2</h3><p><img src="/2019/11/22/turing-read-introduce-to-calculus-day6/4.jpg" alt></p><h3 id="充分性的证明"><a href="#充分性的证明" class="headerlink" title="充分性的证明"></a>充分性的证明</h3><p><img src="/2019/11/22/turing-read-introduce-to-calculus-day6/1.jpg" alt></p><p><img src="/2019/11/22/turing-read-introduce-to-calculus-day6/10.jpg" alt></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://wikipedia.hk.wjbk.site/wiki/%E6%95%B0%E5%88%97" target="_blank" rel="noopener">维基百科_数列</a></li><li><a href="https://wikipedia.hk.wjbk.site/wiki/%E6%9E%81%E9%99%90" target="_blank" rel="noopener">维基百科_极限</a></li></ul><p><img src="/2019/11/22/turing-read-introduce-to-calculus-day6/day6.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>数学学习</category>
      </categories>
      <tags>
        <tag>数列</tag>
        <tag>数学</tag>
        <tag>TURING</tag>
        <tag>极限</tag>
        <tag>证明</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵导读_《微积分入门》_第五天_实数的加法</title>
    <url>/2019/11/21/turing-read-introduce-to-calculus-day5/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="知识点概览"><a href="#知识点概览" class="headerlink" title="知识点概览"></a>知识点概览</h2><ul><li>证明实数的加法</li></ul><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>向量，既有大小，又有方向，具有平行四边形法则的量。</p><p><img src="/2019/11/21/turing-read-introduce-to-calculus-day5/6.jpg" alt></p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><ul><li>1，为什么不把S看成a/2，t看成b/2？</li></ul><p>s+t = (a+b)/2 则当a,b大于0时，(a+b)/2 &lt; (a+b)成立</p><p>若a,b &lt;0，则(a+b) &gt; (a+b)，不可取</p><p><img src="/2019/11/21/turing-read-introduce-to-calculus-day5/5.jpg" alt></p><p><img src="/2019/11/21/turing-read-introduce-to-calculus-day5/4.jpg" alt></p><h3 id="证明实数的加法"><a href="#证明实数的加法" class="headerlink" title="证明实数的加法"></a>证明实数的加法</h3><p><img src="/2019/11/21/turing-read-introduce-to-calculus-day5/3.jpg" alt></p><p><img src="/2019/11/21/turing-read-introduce-to-calculus-day5/2.jpg" alt></p><h3 id="证明定理1-11"><a href="#证明定理1-11" class="headerlink" title="证明定理1.11"></a>证明定理1.11</h3><p><img src="/2019/11/21/turing-read-introduce-to-calculus-day5/dingli1-11.jpg" alt></p><p>举例</p><p>绝对值：在数轴上，代表一个数的点，与原点的距离，叫做这个数的<strong>绝对值</strong>，记作|α|。<br>那么|α|=|α-0|。</p><p><img src="/2019/11/21/turing-read-introduce-to-calculus-day5/test.jpg" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>此节难度适中，主要需掌握证明实数加法的原理和思想。</p><p>（反复阅读，不停思考）</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://wikipedia.hk.wjbk.site/wiki/%E5%90%91%E9%87%8F" target="_blank" rel="noopener">维基百科_向量</a></li><li><a href="https://wikipedia.hk.wjbk.site/baike-%E5%8A%A0%E6%B3%95" target="_blank" rel="noopener">维基百科_加法</a></li><li><a href="https://wikipedia.hk.wjbk.site/wiki/%E7%BB%9D%E5%AF%B9%E5%80%BC" target="_blank" rel="noopener">维基百科_绝对值</a></li></ul><p><img src="/2019/11/21/turing-read-introduce-to-calculus-day5/day5.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>数学学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>TURING</tag>
        <tag>实数</tag>
        <tag>加法</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵导读_《微积分入门》_第四天_实数的定义（下）</title>
    <url>/2019/11/20/turing-read-introduce-to-calculus-day4/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="知识点概览"><a href="#知识点概览" class="headerlink" title="知识点概览"></a>知识点概览</h2><ul><li>无理数性质的论证</li><li>实数的连续性</li></ul><h2 id="实数的连续性"><a href="#实数的连续性" class="headerlink" title="实数的连续性"></a>实数的连续性</h2><p><img src="/2019/11/20/turing-read-introduce-to-calculus-day4/shishulianxu1.jpg" alt></p><p><img src="/2019/11/20/turing-read-introduce-to-calculus-day4/shishulianxu2.jpg" alt></p><h2 id="定理1-6"><a href="#定理1-6" class="headerlink" title="定理1.6"></a>定理1.6</h2><p><img src="/2019/11/20/turing-read-introduce-to-calculus-day4/test1.jpg" alt></p><p><img src="/2019/11/20/turing-read-introduce-to-calculus-day4/test2.jpg" alt></p><p><img src="/2019/11/20/turing-read-introduce-to-calculus-day4/test3.jpg" alt></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li><p>存在 = 至少有一个。</p></li><li><p>《微积分入门》第十面要精读，熟读。</p></li><li><p>抽屉原理：三个球放两个抽屉，如果每个抽屉都要放的话，至少一个抽屉会放两个球。</p></li><li><p>弧度制</p></li></ul><p><img src="/2019/11/20/turing-read-introduce-to-calculus-day4/hudu.jpg" alt></p><h4 id="疑惑，为什么已经有角度制了，还要增加弧度制？"><a href="#疑惑，为什么已经有角度制了，还要增加弧度制？" class="headerlink" title="疑惑，为什么已经有角度制了，还要增加弧度制？"></a>疑惑，为什么已经有角度制了，还要增加弧度制？</h4><p>角度制存在两种进制：1，在度、分、秒间，是60进制；2，在度以上，秒以下为10进制。<br>在描述连续变化角的角度的时候是非常繁琐的，所以建议用<code>弧度制</code>。</p><p>弧度制本质就是长度，可以用实数表示，而实数具有连续性。<br>弧长 除以 半径长，把单位约掉后它就是一个纯数量，而且只有一个10进制。</p><h4 id="数学魅力，什么都没有，即拥有整个世界？！"><a href="#数学魅力，什么都没有，即拥有整个世界？！" class="headerlink" title="数学魅力，什么都没有，即拥有整个世界？！"></a>数学魅力，什么都没有，即拥有整个世界？！</h4><p><img src="/2019/11/20/turing-read-introduce-to-calculus-day4/world.jpg" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本次学习定理1.4，1.5和1.6的证明，需要细细品味；</p><p>了解了弧度制、角度制和抽梯原理。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://wikipedia.hk.wjbk.site/baike-%E9%B4%BF%E5%B7%A2%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">维基百科_鴿巢原理</a></li><li><a href="https://wikipedia.hk.wjbk.site/baike-%E5%BC%A7%E5%BA%A6" target="_blank" rel="noopener">维基百科_弧度</a></li></ul><p><img src="/2019/11/20/turing-read-introduce-to-calculus-day4/day4.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>数学学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>TURING</tag>
        <tag>实数</tag>
        <tag>定理证明</tag>
        <tag>无理数</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵导读_《微积分入门》_第三天_实数的定义（上）</title>
    <url>/2019/11/19/turing-read-introduce-to-calculus-day3/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="知识点概览"><a href="#知识点概览" class="headerlink" title="知识点概览"></a>知识点概览</h2><ul><li>集合知识在分析学中应用的最初步尝试；</li><li>反证法的应用；</li><li>形式逻辑学。</li></ul><h2 id="证明定理1-1"><a href="#证明定理1-1" class="headerlink" title="证明定理1.1"></a>证明定理1.1</h2><p><img src="/2019/11/19/turing-read-introduce-to-calculus-day3/dingli1-1-z1.jpg" alt></p><p><img src="/2019/11/19/turing-read-introduce-to-calculus-day3/dingli1-1-z2.jpg" alt></p><h2 id="证明定理1-3"><a href="#证明定理1-3" class="headerlink" title="证明定理1.3"></a>证明定理1.3</h2><p><img src="/2019/11/19/turing-read-introduce-to-calculus-day3/dingli1-3-z1.jpg" alt></p><p><img src="/2019/11/19/turing-read-introduce-to-calculus-day3/dingli1-3-z2.jpg" alt></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li><p>课后两点告诫：1，认真，反复阅读课文；2，以智商和毅力的极限去积极思考问题。</p></li><li><p>定理1.2的证明方法，在 人教版数学必修一A第七面。</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>此节主要讲解了有关实数的几个重要的定理证明，有难度，需要反复阅读，反复领悟。</p><p><img src="/2019/11/19/turing-read-introduce-to-calculus-day3/day3.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>数学学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>TURING</tag>
        <tag>实数</tag>
        <tag>定理证明</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵导读_《微积分入门》_第二天_第一章实数_第一节序言</title>
    <url>/2019/11/18/turing-read-introduce-to-calculus-day2/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>集合的基本知识的具体应用；</li><li>映射的初步知识；</li><li>有理数的基本性质；</li><li>无穷等比数列求和的方法；</li><li>有理数的局限性</li></ul><h2 id="无穷等比数列求和的方法"><a href="#无穷等比数列求和的方法" class="headerlink" title="无穷等比数列求和的方法"></a>无穷等比数列求和的方法</h2><p>公比$q = a_n / a_n-1$</p><p>求和 $S_n = a_1 + a_1<em>q^2 + a_1</em>q^3 + … + a_n*q^n-1$ (1)式</p><p>两边同时乘以<code>q</code>，q<em>S_n = a_1</em>q^2 + a_1<em>q^3 + … + a_n</em>q^n-1 + a_n*q^n$ (2)式</p><p>令(2)式 - (1)式： q<em>S_n - Sn = a_1*q^n - a_1<br>S_n</em>(q-1) = a_1<em>(q^n - 1)<br>S_n = a_1</em>(q^n - 1) / q - 1</p><p>当 n -&gt; 无穷大 ，q^n -&gt; 0， S_n ≈ a_1*(0-1)/q - 1<br>S_n ≈ a_1 / 1- q</p><p><img src="/2019/11/18/turing-read-introduce-to-calculus-day2/bi.jpg" alt></p><h3 id="关于pai"><a href="#关于pai" class="headerlink" title="关于pai"></a>关于pai</h3><p>3 &lt; pai &lt;3 + 1<br>3 + 0.1 &lt; pai &lt; 3 + 0.2<br>3 + 0.1 + 0.04 &lt; pai &lt; 3 + 0.1 + 0.05<br>.<br>.<br>.<br>不足近似数列 &lt; pai &lt; 过剩近似数列</p><p><img src="/2019/11/18/turing-read-introduce-to-calculus-day2/pai.jpg" alt></p><h3 id="区间套理论"><a href="#区间套理论" class="headerlink" title="区间套理论"></a>区间套理论</h3><p>用两个端点都是有理数的区间，去一层套一层，直至到极限的情况下，定义出一个实数。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>数轴是规定了原点，正方向和单位长度的直线</p><p>不是有理数的实数是无理数。</p><p>有限小数的补集 -&gt; 无限小数</p><p>循环小数都是有理数</p><h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><ul><li><p>本节收获了等比数列求和的推导过程（记得上高中那会这个公式可以出一道大题和一道选择或填空题）；</p></li><li><p>对有理数和有理直线的定义。</p></li><li><p>数的范围，就像下面这张图</p></li></ul><p><img src="/2019/11/18/turing-read-introduce-to-calculus-day2/youli.jpg" alt></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://wikipedia.hk.wjbk.site/wiki/%E6%97%A0%E7%90%86%E6%95%B0" target="_blank" rel="noopener">维基百科_無理數</a></li><li><a href="https://wikipedia.hk.wjbk.site/baike-%E6%9C%89%E7%90%86%E6%95%B0" target="_blank" rel="noopener">维基百科_有理数</a></li></ul><p><img src="/2019/11/18/turing-read-introduce-to-calculus-day2/day2.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>数学学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>TURING</tag>
        <tag>实数</tag>
        <tag>有理数</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵导读_《微积分入门》_第一天_集合与函数的基本性质</title>
    <url>/2019/11/16/turing-read-introduce-to-calculus-day1/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="知识点总览"><a href="#知识点总览" class="headerlink" title="知识点总览"></a>知识点总览</h2><ul><li>1，集合的基本概念；</li><li>2，交集、并集、补集、全集、子集、空集；</li><li>3，函数的基本概念；</li><li>4，映射与函数。</li></ul><h2 id="集合的基本概念"><a href="#集合的基本概念" class="headerlink" title="集合的基本概念"></a>集合的基本概念</h2><p>由确定的研究对象构成的总体叫做<strong>集合</strong>，集合的作用是归集（或归纳）与界定。</p><p>集合的性质：<br>1，元素的确定性；<br>2，元素的互异性；<br>3，元素的无序性；-&gt; 暗示可以排序也可以不排序</p><p>共同特征，归集的条件，门槛</p><p>E = { x∈Z | x=2k+1 k∈Z }</p><ul><li>x 表示这个集合中的元素一般形式，它表示的形式为整数集</li><li>| 起分界作用</li><li>{} 起界定作用</li></ul><h2 id="交集、并集、补集、全集、子集、空集；"><a href="#交集、并集、补集、全集、子集、空集；" class="headerlink" title="交集、并集、补集、全集、子集、空集；"></a>交集、并集、补集、全集、子集、空集；</h2><p>任意元素a∈集合A，都有元素a∈集合B，那么集合A是集合B的子集；</p><p>任意集合A中的元素a 属于 集合B，且 任意集合B中的元素b 属于 集合A，那么集合A等于集合B（元素绝对相等）；</p><p>集合的基数 / 集合的势 ：一个集合中包含元素的个数。</p><p>例如，A = {1,2,3}，那么集合A的势为 |A| = 3。</p><p>空集：不含有任何元素的集合叫做<strong>空集</strong>，表示 A ≠ ∅；∅ = {} = {x| x≠x}</p><p><img src="/2019/11/16/turing-read-introduce-to-calculus-day1/kongji.jpg" alt></p><h3 id="反证法"><a href="#反证法" class="headerlink" title="反证法"></a>反证法</h3><p>证明：空集是任何集合的子集，是任何非空集合的真子集。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设 A是任意一个集合</span><br><span class="line">假设 ∅ 不是 集合A的子集</span><br><span class="line">那么至少有一个元素a∈∅，且a∉集合A</span><br><span class="line">不可能，因为空集中是不含任何元素的，所以假设不成立，因此证明了：</span><br><span class="line"></span><br><span class="line">空集是任何集合的子集，是任何非空集合的真子集。</span><br></pre></td></tr></table></figure><h3 id="一个例子了解交集、并集和补集"><a href="#一个例子了解交集、并集和补集" class="headerlink" title="一个例子了解交集、并集和补集"></a>一个例子了解交集、并集和补集</h3><p>假设集合A表示会唱歌的同学，集合B表示会跳舞的同学，那么</p><p>交集：既会唱歌又会跳舞，A∩B；</p><h3 id="笛卡尔积-直积"><a href="#笛卡尔积-直积" class="headerlink" title="笛卡尔积(直积)"></a>笛卡尔积(直积)</h3><p>A={1,2,3}，B={a,b,c}<br>AxB={(a,b)| a∈A,b∈B}，构成一个有序的元素对-&gt;AxB的元素<br>AxB={(1,a)(1,b)(1,c)(2,a)(2,b)(2,c)(3,a)(3,b)(3,c)}</p><p>BxA={(a,1)(a,2)(a,3)(b,1)(b,2)(b,3)(c,1)(c,2)(c,3)}</p><p>所以通常情况下 AxB ≠ BxA</p><p>所以笛卡尔积不满足交换律。</p><h4 id="它有什么用？"><a href="#它有什么用？" class="headerlink" title="它有什么用？"></a>它有什么用？</h4><p>假设一个食堂提供主食A={馒头，包子，米饭，面条}<br>假设一个食堂提供饮料B={可乐，豆浆，奶茶，果汁}<br>假设一个食堂提供甜点C={土豆泥，冰淇淋，苹果派，蛋挞}</p><p>假设一个学生必须吃一种主食，一种饮料，一种甜点，所以</p><p>AxBxC = {(a,b,c)| a∈A,b∈B,c∈C}</p><p>|A|=4 * |B|=4 * |C|=4 -&gt; 64种吃法</p><h2 id="函数与映射"><a href="#函数与映射" class="headerlink" title="函数与映射"></a>函数与映射</h2><p>函数在数学中为两不为空集的集合间的一种对应关系：输入值集合中的每项元素皆能对应​​唯一一项输出值集合中的元素。<br><img src="/2019/11/16/turing-read-introduce-to-calculus-day1/func1.jpg" alt></p><p><img src="/2019/11/16/turing-read-introduce-to-calculus-day1/func2.jpg" alt></p><p>注：映射的范围包含于函数。</p><p>假设 y = f(x),x∈A<br>在集合A中任意一个元素x都与集合B中的f(x)一一对应</p><p><img src="/2019/11/16/turing-read-introduce-to-calculus-day1/func3.jpg" alt></p><p>{(x,y)∈RxR|y=f(x),x∈A} ——函数图像的集合表示法。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="集合中的符号"><a href="#集合中的符号" class="headerlink" title="集合中的符号"></a>集合中的符号</h3><p>Q-有理数集，Z-整数集，N-自然数集，R-实数集</p><p>通常大写拉丁字母表示集合，小写拉丁字母表示元素</p><p>集合相等的定义 -&gt; 元素必须绝对相等；</p><p>任意—表示所有</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节课是图灵导读01期《微积分入门》的第一节课，主要重温了集合，函数、映射这些基础知识。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://stevenshi.me/2017/06/26/hexo-insert-formula/" target="_blank" rel="noopener">hexo中插入数学公式</a></li><li><a href="https://wikipedia.hk.wjbk.site/baike-%E7%AC%9B%E5%8D%A1%E5%84%BF%E7%A7%AF" target="_blank" rel="noopener">维基百科_笛卡儿积</a></li><li><a href="https://wikipedia.hk.wjbk.site/wiki/%E9%9B%86%E5%90%88" target="_blank" rel="noopener">维基百科_集合</a></li><li><a href="https://wikipedia.hk.wjbk.site/wiki/%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">维基百科_函数</a></li><li><a href="https://wikipedia.hk.wjbk.site/wiki/%E6%98%A0%E5%B0%84" target="_blank" rel="noopener">维基百科_映射</a></li></ul><p><img src="/2019/11/16/turing-read-introduce-to-calculus-day1/day1.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>数学学习</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>数学</tag>
        <tag>TURING</tag>
        <tag>集合</tag>
        <tag>映射</tag>
      </tags>
  </entry>
  <entry>
    <title>世界又少了一个单纯善良的人</title>
    <url>/2019/11/14/the-world-has-lost-a-simple-and-kind-human/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>前天女朋友回来告诉我，说她在下班途中碰到一个马来西亚的华人，来成都出差，在问路，于是她和那位华人多聊了几句，昨天回来后闷闷不乐，还流眼泪，我再三询问原因，她才告诉我说被骗了，自己怎么这么傻…被骗的过程我就不赘述了，网上搜关键字<strong>买烟骗局</strong>。</p><p>而我写下这篇文章，一是阐述这样的一种骗局，二是感慨，世界上又少了一位单纯善良的人。</p><h2 id="善良有错吗？"><a href="#善良有错吗？" class="headerlink" title="善良有错吗？"></a>善良有错吗？</h2><p>我记得，从小学，初中，高中这十二年的教育中，无论是从语文书，还是思想品德书上，都告诉我们要做一个正直善良的人，要孝敬父母，尊老爱幼，朋友有难要伸出援手，遇到困难学会忍受，相信雨过天晴这样大篇章的废话套话。</p><p>但是，要做到这些的前提，就是你要有资本。</p><p>在这个星球上生活了二十三年，有一些本来需要遗忘又不经意回想的瞬间，让我不得不在此时此景下记录下来，例如</p><ul><li>上高中时，在乌鲁木齐坐公交，碰到一个老头(这么称呼说明我并不尊重他)投了币，径直走向一个上面坐着小孩的座位，把他拉了起来，自己坐了下去，给老人让座没有错，但请对自己鲁莽的动作说一声抱歉，因为你确实吓到那位小孩了；</li><li>去上大学，坐十三个小时的火车，想上卫生间，在门口排队时，有些大人不顾其他人的感受，直接插队；</li><li>在大学里，帮助某些人，明明主动权在自己手上，却偏偏别人以为这是你必须帮我的义务(真是可笑)；</li><li>晚上休息时，舍友外放看直播，我吵得睡不着，但当我练习吹口琴时旁边人就不耐烦，那一刻，我有了脑子一热砍人的想法；</li><li>上大三时一位老师直接和我谈一笔和算法竞赛有关的交易，无奈我很讨厌他，委婉的拒绝了，结果那门科目我就挂了(当时我预测我的卷面分至少在80分以上)，原来，老师没有那么神圣，他们也是人，也有自己的七情六欲;</li><li>去济南玩时，一天内碰到两个乞讨者，追着我叫我给他and她一点钱；</li><li>大学毕业，独自去一座城市生活，在软件园遇到一个女子，问我借20元坐地铁，说明天给我，转账后第二天微信被拉黑；</li></ul><p>所以，善良有错吗？</p><p>善良没有错，但是你要有资本，有承受贡献善良后的风险。</p><p>如果没有资本，即使被所谓的社会道德谴责，我也会无动于衷。</p><p>由于女朋友被骗的金额够不到2000，不构成诈骗罪，所以到公安局只是立案，不会调查，具体进展我会及时更新，而我只能在下班时在诈骗地点附近转悠，期待都找到骗女友钱的骗子，如果真能找到，我一定要给上一拳头，顺便补上几脚。</p><p><strong>我可以一直保持善良，在心里立一尊佛，但是当佛倒了，我就会变成魔。</strong></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.zhihu.com/question/278929215/answer/404243094" target="_blank" rel="noopener">知乎_被骗买两条中华烟？</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>社会</tag>
        <tag>骗局</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04环境安装FFmpeg</title>
    <url>/2019/11/13/ubuntu1804-ffmpeg-install/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><p>学习视音频技术，要了解<code>FFmpeg</code>，本文将介绍在<code>Linux</code>下安装官方<code>FFmpeg</code>的步骤。</p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p>使用<code>Git</code>下载</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/FFmpeg/FFmpeg</span><br></pre></td></tr></table></figure><h3 id="使用configure命令"><a href="#使用configure命令" class="headerlink" title="使用configure命令"></a>使用configure命令</h3><ul><li>先下载<code>yasm</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install yasm    //这儿需要先安装yasm,否则configure会报错</span><br></pre></td></tr></table></figure><ul><li>使用<code>configure</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure --prefix=./ffmpeg_install</span><br></pre></td></tr></table></figure><p>注：<code>--prefix=./ffmpeg_install</code>的作用是将新编译的<code>FFmpeg</code>放入这个目录下，没有这一项将默认安装执行<code>configure</code>命令的位置。</p><ul><li>使用<code>make</code>命令</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line"></span><br><span class="line">或 make j8  //指定系统用8核来运行</span><br></pre></td></tr></table></figure><ul><li>使用<code>make install</code>命令完成安装</li></ul><p>进入<code>ffmpeg_install</code>的<code>bin</code>目录下，运行<code>FFmpeg</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ./ffmpeg_install/bin</span><br><span class="line">$ ./ffmpeg</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/qq_31186123/article/details/81180918" target="_blank" rel="noopener">ubuntu 编译安装ffmpeg</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>FFmpeg学习</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
        <tag>Ubuntu</tag>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title>如何释放压力</title>
    <url>/2019/11/11/how-to-reduce-pressure/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="压力来源"><a href="#压力来源" class="headerlink" title="压力来源"></a>压力来源</h2><p>我个人觉得压力的渠道主要有这些：</p><ul><li><p>单调，日复一日的生活，没有新鲜感；</p></li><li><p>对未来的迷茫</p></li><li><p>焦虑(知识，未来)</p></li><li><p>生理期</p></li></ul><h2 id="减压方式"><a href="#减压方式" class="headerlink" title="减压方式"></a>减压方式</h2><p>人是一种群体性动物，所以每天和周围人说说话也是释放压力的一种方式，然而有些时候节奏过快，而像类似程序员这种天天和机器打交道的职业，可能时间久了连一句语序正确的话都说不出了，或者说出的话都是间隔相同，带分号(;)隔开？亦或是进行并发同时阐述多种话语？hhh调皮一下。</p><h3 id="写日记"><a href="#写日记" class="headerlink" title="写日记"></a>写日记</h3><p>这是我坚持了(3+4+1.5)八年半的习惯，不得不说这是我首选的宣泄方式，从高中对某个女孩的暗恋，到大学对这教育体制的不满又无能为力的心情，以及毕业顺利拿到<code>offer</code>的喜悦，记录着我心智成长的艰辛过程。</p><h3 id="慢跑"><a href="#慢跑" class="headerlink" title="慢跑"></a>慢跑</h3><p>很怀念大学时期每晚在操场跑步的时光，从图书馆自习出来后，戴上无线耳机去操场慢跑3-5圈，然后回宿舍泡热水脚洗漱睡觉，第二天又精神饱满的去学习。</p><h3 id="瑜伽"><a href="#瑜伽" class="headerlink" title="瑜伽"></a>瑜伽</h3><p>有段时间加班严重，回到家就想躺在床上，背部及其难受，无意间在<code>keep</code>上发现一个长达16分钟的睡前舒缓瑜伽课程，于是跟着视频练习起来，效果很满意。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>打电话、看书、睡觉、打游戏？？？</p><p>部门老哥推荐的一本<a href="ps://book.douban.com/subject/26590889/" target="_blank" rel="noopener">《情绪急救》</a></p><h3 id="关于焦虑"><a href="#关于焦虑" class="headerlink" title="关于焦虑"></a>关于焦虑</h3><p>周末看完了阮一峰老师写的书《未来世界的幸存者》，让我不自在的又焦虑了起来，技术迭代太快，我怕我跟不上时代的节奏，称为了淘汰者。</p><p>可是，这又有什么办法呢？人的生命如此渺小，如沧海一粟，实在难以想象一千年后的技术水平会是什么样子。</p><p>最后以我很喜欢的一句话结尾</p><p><strong>吾生也有涯，而知也无涯。以有涯随无涯，殆已！已而为知者，殆而已矣！为善无近名，为恶无近刑，缘督以为经，可以保身，可以全生，可以养亲，可以尽年</strong></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>压力</tag>
        <tag>健康</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04环境下安装Java</title>
    <url>/2019/11/10/ubuntu1804-install-java/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="安装java"><a href="#安装java" class="headerlink" title="安装java"></a>安装java</h2><p>在Ubuntu系统上安装以下两个软件：</p><ul><li>Java运行时环境Java Runtime Environment（JRE）</li><li>Java开发工具包Java Development Kit（JDK）</li></ul><p>命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装jre</span><br><span class="line">sudo apt install default-jre</span><br><span class="line"></span><br><span class="line">安装jdk</span><br><span class="line">sudo apt install default-jdk</span><br></pre></td></tr></table></figure><h2 id="第一个Java程序"><a href="#第一个Java程序" class="headerlink" title="第一个Java程序"></a>第一个Java程序</h2><p>创建一个<code>test.java</code>的文件</p><p>在这个文件里写入以下代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存文件并关闭</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过Java编译器编译第一个程序</span><br><span class="line">javac test.java</span><br><span class="line"></span><br><span class="line">编译java源代码</span><br><span class="line">java test</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/freeking101/article/details/80522586" target="_blank" rel="noopener">Ubuntu18.04安装和配置 Java JDK 和 JRE，并卸载自带OpenJDK</a></li><li><a href="https://www.linuxidc.com/Linux/2018-10/155020.htm" target="_blank" rel="noopener">在Ubuntu终端中运行第一个Java程序</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Ubuntu</tag>
        <tag>安装</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>演示结束后的开心与喜悦</title>
    <url>/2019/11/10/happy-after-ai-demo-show/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="昆明大学演示"><a href="#昆明大学演示" class="headerlink" title="昆明大学演示"></a>昆明大学演示</h2><p>十月中下旬，突然被<code>leader</code>安排去做一个和<code>FFmpeg</code>相关的重组视音频片段的服务，说是项目演示用。</p><p>于是我快速搭建好服务器的框架，接着开始不断的构造和测试<code>FFmpeg</code>命令(不得不说<code>FFmpeg</code>确实是视音频领域的”瑞士军刀”)，经过一番波折后(加了两天班)，服务跑了起来，和<code>python</code>程序联调一下午+一晚上后，10月底昆明大学演示上通过，很开心。</p><h2 id="领导演示"><a href="#领导演示" class="headerlink" title="领导演示"></a>领导演示</h2><p>进入十一月后，又来了新的演示，印象最深的是有一天心情实在不好，下班时以为没什么问题了，于是就回家了，结果刚到家部门同事打电话通知我回公司改<code>bug</code>，虽然心里不太乐意，但还是回去了，然后发觉是配置文件出的问题，程序没问题。后面两天的演示也是一切顺利。</p><h2 id="周末游天府芙蓉园"><a href="#周末游天府芙蓉园" class="headerlink" title="周末游天府芙蓉园"></a>周末游天府芙蓉园</h2><p>周末去天府芙蓉园逛了一圈，持续的输出，早出晚归，让我似乎忘记了沐浴在阳光中是一种什么样的感觉。</p><p>犹记得我高一第一次接触编程时，将一堆字母输入在屏幕上，然后点击<code>run</code>后屏幕打出<code>hello world</code>的兴奋感，不知道现在从事研发后，兴趣和责任，哪个更重一些呢？</p><p><a href="./sunshine.png"></a></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
        <tag>项目</tag>
        <tag>人工智能</tag>
        <tag>收录</tag>
        <tag>服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang操作Redis数据库小结</title>
    <url>/2019/11/03/golang-redis-op/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>十月中旬要做出一个和<code>Redis</code>相关的服务，在此记录<code>Golang</code>操作<code>Redis</code>的笔记。</p><h2 id="Golang操作Redis"><a href="#Golang操作Redis" class="headerlink" title="Golang操作Redis"></a>Golang操作Redis</h2><p>(内容还在更新中…)</p><h3 id="使用redisgo包"><a href="#使用redisgo包" class="headerlink" title="使用redisgo包"></a>使用redisgo包</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/garyburd/redigo/redis"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c, err := redis.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:6379"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"Connect to redis error"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//写入值</span></span><br><span class="line">	_, err = c.Do(<span class="string">"SET"</span>, <span class="string">"username"</span>, <span class="string">"nick"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"redis set failed:"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读取key对应的value值</span></span><br><span class="line">	username, err := redis.String(c.Do(<span class="string">"GET"</span>, <span class="string">"username"</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"redis get failed:"</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Get username %v \n"</span>, username)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从右往左，存一个名字为mylist的列表</span></span><br><span class="line">	_, err = c.Do(<span class="string">"lpush"</span>, <span class="string">"mylist"</span>, <span class="string">"ofo"</span>, <span class="string">"mobike"</span>, <span class="string">"foo"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"redis lpush failed"</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从左往右，给一个名字为mylist的列表存值</span></span><br><span class="line">	_, err = c.Do(<span class="string">"rpush"</span>, <span class="string">"mylist"</span>, <span class="string">"bluegogo"</span>, <span class="string">"xiaolan"</span>, <span class="string">"xiaoming"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"redis rpush failed"</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取这个列表的长度</span></span><br><span class="line">	num, err := c.Do(<span class="string">"llen"</span>, <span class="string">"mylist"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"mylist get len err"</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"mylist's len is "</span>, num)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取mylist列表下表从0到10的值</span></span><br><span class="line">	values, err := redis.Values(c.Do(<span class="string">"lrange"</span>, <span class="string">"mylist"</span>, <span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"lrange err"</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"mylist is:"</span>)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">		fmt.Printf(<span class="string">" %s "</span>, v.([]<span class="keyword">byte</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	_, err = c.Do(<span class="string">"ltrim"</span>, <span class="string">"mylist"</span>, <span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"ltrim error"</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		values, err = redis.Values(c.Do(<span class="string">"lrange"</span>, <span class="string">"mylist"</span>, <span class="number">0</span>, <span class="number">4</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"ltrim failed:"</span>, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">"ltrim mylist is:"</span>)</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"%s "</span>, v.([]<span class="keyword">byte</span>))</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	val, err := c.Do(<span class="string">"lindex"</span>, <span class="string">"mylist"</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"lindex error:"</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"lindex get result :%s\n"</span>, val)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = c.Do(<span class="string">"rpoplpush"</span>, <span class="string">"mylist"</span>, <span class="string">"mybike"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"rpoplpush failed:"</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		values, err = redis.Values(c.Do(<span class="string">"lrange"</span>, <span class="string">"mylist"</span>, <span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"lrange failed:"</span>, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"rpoplpush %s\n"</span>, v.([]<span class="keyword">byte</span>))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		values, err = redis.Values(c.Do(<span class="string">"lrange"</span>, <span class="string">"mybike"</span>, <span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"lrange failed:"</span>, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">			<span class="comment">//fmt.Println(string(v.([]byte)))</span></span><br><span class="line">			fmt.Printf(<span class="string">"rpoplpush %s\n"</span>, v.([]<span class="keyword">byte</span>))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = c.Do(<span class="string">"lset"</span>, <span class="string">"mylist"</span>, <span class="number">2</span>, <span class="string">"mysql"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"lset error:"</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	val, err = c.Do(<span class="string">"lindex"</span>, <span class="string">"mylist"</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"lset error:"</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"lset get result:%s\n"</span>, val)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = c.Do(<span class="string">"lrem"</span>, <span class="string">"mylist"</span>, <span class="number">1</span>, <span class="string">"mysql"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"lrem error"</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		values, err = redis.Values(c.Do(<span class="string">"lrange"</span>, <span class="string">"mylist"</span>, <span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"ltrim failed:"</span>, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"lrem mylist: %s"</span>, v.([]<span class="keyword">byte</span>))</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = c.Do(<span class="string">"lpop"</span>, <span class="string">"mylist"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"lpop failed:"</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		values, err = redis.Values(c.Do(<span class="string">"lrange"</span>, <span class="string">"mylist"</span>, <span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"lpop failed:"</span>, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">"lpop mylist :"</span>)</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"lpop mylist %s"</span>, v.([]<span class="keyword">byte</span>))</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = c.Do(<span class="string">"rpop"</span>, <span class="string">"mylist"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"rpop failed"</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		values, err = redis.Values(c.Do(<span class="string">"lrange"</span>, <span class="string">"mylist"</span>, <span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"rpop failed:"</span>, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">"rpop mylist :"</span>)</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">			<span class="comment">//fmt.Println(string(v.([]byte)))</span></span><br><span class="line">			fmt.Printf(<span class="string">"lpop mylist %s"</span>, v.([]<span class="keyword">byte</span>))</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res, err := c.Do(<span class="string">"blpop"</span>, <span class="string">"mylist"</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"blpop error"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"blpop from mylist get:%s\n"</span>, res)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res, err = c.Do(<span class="string">"blpop"</span>, <span class="string">"tmpbike"</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"blpop time out"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"blpop from tmpbike get:"</span>, res)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res, err = c.Do(<span class="string">"brpop"</span>, <span class="string">"tmpbike"</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"brpop error"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"brpop from tmpbike get :%s\n"</span>, res)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res, err = c.Do(<span class="string">"brpop"</span>, <span class="string">"mybike"</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"brpop time out"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"brpop from mybike get:%s "</span>, res)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">菜鸟教程_Redis教程</a></li><li><a href="https://www.jianshu.com/p/89ca34b84101" target="_blank" rel="noopener">Golang操作redis指南</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业16个月的面经整理以及思考</title>
    <url>/2019/10/21/interview-think-and-life/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在写这篇文章之前，先简单介绍要自己的情况。</p><p>2018年6月计算机专业本科毕业，放弃了学校的校招，只身前往成都市求职。</p><p>在经历了两周的投简历，经历了笔试，面试，被培训机构忽悠，外包公司等，最终入职了一家上市游戏公司，三个月后辞职去了一家互联网公司做图形图像视音频算法，本文将记录我毕业工作这16个月的感悟和经验。</p><p>注：以下将以采访的形式分享自己的观点。</p><h2 id="为什么会选择放弃校招？"><a href="#为什么会选择放弃校招？" class="headerlink" title="为什么会选择放弃校招？"></a>为什么会选择放弃校招？</h2><p>因为我是在新疆上的大学，而我认为那里的互联网还是有些落后，技术这东西更新迭代非常快，之前也在学校面过海康威视的技术支持和一家央企的<code>Java</code>开发，虽然个人感觉难度不大(只要不挂科，毕业拿到双证，户口在新疆，笔试面试这些很水)，但我最终还是选择放弃并在毕业时坐飞机来成都。</p><h2 id="第一次一个人去一座陌生的城市，心里是什么样的感觉，在求职路上有没有遇到什么困难？"><a href="#第一次一个人去一座陌生的城市，心里是什么样的感觉，在求职路上有没有遇到什么困难？" class="headerlink" title="第一次一个人去一座陌生的城市，心里是什么样的感觉，在求职路上有没有遇到什么困难？"></a>第一次一个人去一座陌生的城市，心里是什么样的感觉，在求职路上有没有遇到什么困难？</h2><p>先说下内心的感受，刚开始我父母是不同意我去一座陌生的城市的，觉得待在乌鲁木齐也挺好的啊，后来我和他们耐心沟通后，并承诺待不下去就回来，他们才放过。</p><p>一个人刚来成都时，借宿在朋友家，她白天上班，我就在拉勾、智联招聘、<code>Boss</code>直聘上不断地投简历，只要是和我大学学的东西稍微沾边的。过了段时间，电话就打来了，基本上是确认本人在成都市，顺利毕业拿到双证的就安排面试，于是，我开始了我社招的正式面试：</p><ul><li><p>第一家是游戏公司<code>Unity</code>岗，在我刚准备第二天去该公司面试时，负责人在微信上说了句：我们公司是包培训的，培训半年包就业，月薪在<code>xx-yy</code>k以上，于是我断定这是一家游戏公司，放弃；</p></li><li><p>第二家是一家北京做人工智能的公司找人工智能实习生，开头带个“欣”字，结果过去之后大门口一张闪闪发光的优秀培训机构映入眼帘，接着我被叫去一个小房间，开始给我讲<code>python</code>多么多么好，你看那些川大电科研究生毕业都找不到工作还不是来我这培训(不好意思，请不要把小概率事件扩大)，我无动于衷，并拒绝了培训，放弃；</p></li><li><p>第三家是外包，说主要接美团，腾讯，华为的外包，加班多但是成长快，但我不想去，原因就不说了，放弃；</p></li><li><p>第四家是一家做音乐的公司，招的<code>Java</code>开发，我大学总共写的<code>Java</code>不超过20行，于是硬着头皮去面试，数据结构那些答的还好，被问到<code>Java</code>虚拟机我主动要求停止面试，放弃；</p></li><li><p>第五家是一家创业游戏公司，先让我做了一些<code>C#</code>笔试题，接着问我能不能接受<code>996</code>和<code>9910</code>加班，我说考虑下，于是也没有了下文；</p></li><li><p>第六家是一家上市游戏公司，经历了<code>HR面-技术面-HR面-Boss-面</code>后，顺利拿到<code>offer</code>，面试经验已整理到下面的参考链接中。</p></li></ul><p>列举了这些面试经历后，我只是想阐述当你校招或刚毕业面临社招时，当你已经失去了<code>应届大学毕业生</code>这个保护伞后，你会遇到各式各样的面试，所以请诸位擦亮眼睛，多问几个为什么。</p><h2 id="第一份工作感觉如何，为什么辞职？"><a href="#第一份工作感觉如何，为什么辞职？" class="headerlink" title="第一份工作感觉如何，为什么辞职？"></a>第一份工作感觉如何，为什么辞职？</h2><h3 id="第一印象"><a href="#第一印象" class="headerlink" title="第一印象"></a>第一印象</h3><p>第一份做游戏研发方面的工作，很兴奋，对研发游戏的每一个步骤都充满了好奇，例如服务端，客户端，策划，美术等。</p><p>大牛很多，给我推荐参考书籍，项目代码质量很高，和在学校写的课设毕设天壤之别。</p><p>活动福利多，比如一些游戏开发大赛，也有幸去厦门参考了一次<code>Game Pith Time</code>。</p><h3 id="So，为什么辞职"><a href="#So，为什么辞职" class="headerlink" title="So，为什么辞职"></a>So，为什么辞职</h3><p>详见参考文章链接<code>离职，新的开始</code>，在此不赘述。</p><h2 id="辞职后做了什么？"><a href="#辞职后做了什么？" class="headerlink" title="辞职后做了什么？"></a>辞职后做了什么？</h2><p>离职后在家躺了三天，然后开始在牛客网上刷题，再投简历，因为之前已经有了一定的工作经验，因此遇到培训机构的概率降低了。之后收到了一家做视音频的发来的面试邀请，约定了面试时间后就去面试，三场面试很快通过拿了<code>offer</code>。</p><h2 id="有什么面试经验想要分享吗？"><a href="#有什么面试经验想要分享吗？" class="headerlink" title="有什么面试经验想要分享吗？"></a>有什么面试经验想要分享吗？</h2><p>面试经验在下面的链接中会详细阐述，在此分享下个人感受</p><ul><li><p>1，个人认为开发/研发面试时，能力:面试发挥 = 7:3，为什么这样说，因为面试是可以突击来的，而能力是突击不来的，即使突击成功，接下来的3-6个月的试用期负责人有足够的时间了解你；</p></li><li><p>2，保持好奇，追根究底，务实基础；</p></li><li><p>3，可以去听一些师哥师姐的面试经验，如果条件允许最好面对面交谈；</p></li><li><p>4，时刻知道自己需要什么，还差什么，如何实现；</p></li><li><p>5，建议不要总沉迷技术书籍，适当接触一些哲学，有助于培养自己的思辨能力，因为在当你入职研发岗时，能力又是其次，最重要的是要弄清楚产品的需求。</p></li></ul><h2 id="最后还有想说的吗？"><a href="#最后还有想说的吗？" class="headerlink" title="最后还有想说的吗？"></a>最后还有想说的吗？</h2><p>转眼间已经工作了16个月，其实有时候还会梦见在学校悠哉的生活，5元的饭菜，800/一年的宿舍，以及一瓶水，一把椅子，一台电脑坐一天，晚上在操场上慢跑的生活，然后早餐的闹铃又会把这一切打破。</p><p>现在在完成需求的同时，及时利用碎片时间去看一些书籍或视频，在星球里看一看大佬们分享的职场经验，再结合自己的实际情况加以学习利用。</p><p>我们的路还很长，所以如果遇到简历被刷，面试被拒，也不要灰心。</p><p>祝求职顺利！</p><h2 id="参考文章链接"><a href="#参考文章链接" class="headerlink" title="参考文章链接"></a>参考文章链接</h2><ul><li><a href="https://www.jianshu.com/p/df2ea79b027c" target="_blank" rel="noopener">心酸，又是一家培训机构</a></li><li><a href="https://www.ituring.com.cn/article/506666" target="_blank" rel="noopener">应届毕业生求职经验分享</a></li><li><a href="https://www.cnblogs.com/OctoptusLian/p/9157266.html" target="_blank" rel="noopener">飞鱼科技游戏开发岗面试经验</a></li><li><a href="https://www.cnblogs.com/OctoptusLian/p/9634250.html" target="_blank" rel="noopener">离职，新的开始</a></li><li><a href="https://www.cnblogs.com/OctoptusLian/p/9797313.html" target="_blank" rel="noopener">华栖云科技图形图像视音频算法岗面试经验</a></li><li><a href="https://octopuslian.github.io/2019/04/07/about-996-i-want-to-say/">关于996，我想说</a></li></ul><p>(注意，此文已发布早牛客网上，点击<a href="https://www.nowcoder.com/discuss/321386" target="_blank" rel="noopener">链接</a>)</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>生活</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>博客尘埃落定</title>
    <url>/2019/10/13/blog-decision/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="开端"><a href="#开端" class="headerlink" title="开端"></a>开端</h2><p>2019年1月停更博客园，到现在为止已经接近十个月了。</p><p>在此期间试过<code>冰水鉴心</code>给我推荐的<code>hexo</code>，<code>ghost</code>这些风格的博客，最终从经济和简约的角度，选择了<code>hexo</code>。感谢他的热心帮助和答疑。</p><p>在搭建博客的过程，我发现前端真是很有意思，也许是给我带来的持续反馈机制吧。所以后面不光要关注后端和底层，可以适当去学习下前端的知识。</p><p>目前博客风格已尘埃落定，以后计划所有的学习收获和感想都优先发布在这里。</p><p>明天又是崭新的一天，坚持。</p><h3 id="2019年10月18日更新"><a href="#2019年10月18日更新" class="headerlink" title="2019年10月18日更新"></a>2019年10月18日更新</h3><p>感谢@枫林无归提供的<code>hexo-plugin-gitalk</code>插件。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>乐山一日游</title>
    <url>/2019/09/15/travel-le-shan-one-day/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="启程准备"><a href="#启程准备" class="headerlink" title="启程准备"></a>启程准备</h2><p>启程时间：9月15日早上，从成都到乐山坐高铁只需要50分钟。<br>所需物品：手机，钱包（身份证，零钱，车票），充电宝，充电线，雨伞，水杯，零食</p><h2 id="开始旅行"><a href="#开始旅行" class="headerlink" title="开始旅行"></a>开始旅行</h2><p>到乐山站后，先导航去芳芳家翘脚牛肉店吃午饭，然而到那时正好到了饭点，门口排起了长队，我预估到我至少要两个小时以上，于是放弃，买了个烧饼吃，接着前往下一个小吃街。</p><a id="more"></a><p>然而去了下一个小吃街，甜皮鸭店门口排起了长队，我看甜皮鸭以斤算价（一斤最便宜要30元），基本是按一只起卖，女朋友说太腻了，不排了，于是去四方豆腐店（排了三十多人）和小豆海棠（排了八个人），结果也排起了队，放弃。最后去了一家豆腐脑店，店了一碗牛肉粉，一晚牛肉豆腐脑，一碗水果冰粉，很好吃。</p><p>接下来坐车去乐山大佛，比较坑的是，乐山大佛的售票处离乐山大佛入口有一公里远，所以下次去的话，建议到乐山大佛入口处买票，成人价80元/人。<br>进了乐山大佛入口后，先是一个大大的佛字映入眼帘，接着就是爬台阶，如果要听讲解的话，可以请个导游，或者扫旁边的二维码花10元买个语音讲解。爬了半个多小时到达山上，看大了乐山大佛的头，不得不说，场景确实让人震撼，不过更让我震撼的是许多人排队去走栈道，不知道是去干嘛，据说是近距离欣赏大佛，无奈我又选择了放弃。逛了一会，然后下山去吃晚饭。</p><p>坐公交抵达另一处小吃街，比较出名的是叶婆婆和黄鸡肉两家钵钵鸡店，但是门口排着队，我换了一家档次也算不错的在吃，期间也品尝了下烧麦，个人觉得就是饺子的缩小版。吃了六分饱后，去了张公桥小吃街，买了酥肉咔饼（感觉就是肉夹馍），叶儿粑，味道不错。</p><p>吃完这些已经是晚上八点，于是我和女朋友坐公交赶去乐山站坐回成都的高铁。结果在公交车上人太多，我转了个身发现一位老大爷从我后面快速把手缩了回去，我猜测可能是人太多把他手卡住了吧，但我觉得不对劲，把书包翻过来正手拿着，结果发现我书包被拉开了半个口，接着刚好到站了那位缩手回去的老大爷也下车了，我检查了下包内的东西，没有少。</p><h2 id="旅行收获"><a href="#旅行收获" class="headerlink" title="旅行收获"></a>旅行收获</h2><ul><li>超过半小时需要步行到达的地方，最好选择共享单车或公交。</li><li>去看景点时如果不想请导游可以下个语音讲解。</li><li>防人之心不可无。</li><li>学会拍照很重要。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>旅行游记</category>
      </categories>
      <tags>
        <tag>旅游</tag>
        <tag>开心</tag>
        <tag>美食</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04升级Go版本</title>
    <url>/2019/08/15/ubuntu1804-update-go-version/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>因为我本机系统上的Go版本是<code>10.4</code>的，不支持<code>Go Module</code>，想升级到最新的<code>go12.7</code>。</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="1，先下载最新的源码文件"><a href="#1，先下载最新的源码文件" class="headerlink" title="1，先下载最新的源码文件"></a>1，先下载最新的源码文件</h3><p>上<a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a>下载自己需要的源码文件，我需要的是<code>go1.12.7.linux-amd64.tar.gz</code>。</p><h3 id="2，解压"><a href="#2，解压" class="headerlink" title="2，解压"></a>2，解压</h3><p>执行命令<code>tar -C /usr/local -zxvf go1.12.7.linux-amd64.tar.gz</code>,会覆盖到原先的<code>go</code>目录。</p><h3 id="3，复制可执行文件"><a href="#3，复制可执行文件" class="headerlink" title="3，复制可执行文件"></a>3，复制可执行文件</h3><p>如果不是第一次安装，需要将<code>/usr/local/go/bin</code>目录下的文件复制到<code>/usr/bin</code>下。</p><h3 id="4，检查环境配置"><a href="#4，检查环境配置" class="headerlink" title="4，检查环境配置"></a>4，检查环境配置</h3><p>打开<code>/etc/profile</code>文件检查环境配置参数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=$HOME/code/go</span><br><span class="line">PATH=$PATH:$GOROOT/bin:$GOPATH/bin</span><br></pre></td></tr></table></figure><p>命令<code>source /etc/profile</code>使环境生效。</p><h3 id="5，检查版本号"><a href="#5，检查版本号" class="headerlink" title="5，检查版本号"></a>5，检查版本号</h3><p>执行<code>go version</code>命令，输出版本号为<code>go version go1.12.7 linux/amd64</code></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，Ubuntu18.04下完成Go版本升级。<br>后面如果版本有更新，可照此方法再升级一遍。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Linux</tag>
        <tag>升级</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言调试工具-Dlv使用</title>
    <url>/2019/07/28/go-dlv-tool-use/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./dlv debug</span><br></pre></td></tr></table></figure><h3 id="打断点"><a href="#打断点" class="headerlink" title="打断点"></a>打断点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b 文件名.go:行号 或 函数名</span><br></pre></td></tr></table></figure><h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c(continue)</span><br></pre></td></tr></table></figure><p>重启</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">r(restart)</span><br></pre></td></tr></table></figure><h3 id="下一行"><a href="#下一行" class="headerlink" title="下一行"></a>下一行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n (next)</span><br></pre></td></tr></table></figure><h3 id="进入函数"><a href="#进入函数" class="headerlink" title="进入函数"></a>进入函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s (step)</span><br></pre></td></tr></table></figure><h3 id="退出函数"><a href="#退出函数" class="headerlink" title="退出函数"></a>退出函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stepout</span><br></pre></td></tr></table></figure><h3 id="查看堆栈"><a href="#查看堆栈" class="headerlink" title="查看堆栈"></a>查看堆栈</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bt</span><br></pre></td></tr></table></figure><h3 id="查看打了断点的列表"><a href="#查看打了断点的列表" class="headerlink" title="查看打了断点的列表"></a>查看打了断点的列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bp (breakpoints)</span><br></pre></td></tr></table></figure><h3 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clear 断点号</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>delve</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Go vendor应用</title>
    <url>/2019/07/10/go-vendor-application/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="为什么要用它"><a href="#为什么要用它" class="headerlink" title="为什么要用它"></a>为什么要用它</h2><p>控制包的依赖，例如一个项目引用的是A包1.0版本后编译成功，结果几个月后A包tag号升到了2.3，而我们平时用<code>go get</code>命令是直接从<code>master</code>分支下引入的，因此可能会造成引入了同样的包，但编译不通过的问题。<br>而如果这个项目中存在<code>vendor</code>文件夹，<code>go</code>项目编译时就会优先编译<code>vendor</code>文件夹里的包。</p><h2 id="问题还原"><a href="#问题还原" class="headerlink" title="问题还原"></a>问题还原</h2><p>今天编译一个用<code>Go</code>写的语音识别服务的项目，缺失的A包用<code>go get</code>命令获取了，但编译后显示<code>xxx function not defined</code>，而我查了这个<code>xxx</code>函数是A包声明好的，这是什么原因呢。<br>原因就在于<strong>版本不匹配</strong>。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="简单直接的方法"><a href="#简单直接的方法" class="headerlink" title="简单直接的方法"></a>简单直接的方法</h3><p>在该项目下新建一个<code>vendor</code>文件夹，假如这个包是引入<code>github</code>上的，就在这下面建立基于<code>github</code>的路径，像这样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── 20hours</span><br><span class="line">│   ├── 20hours</span><br><span class="line">│   ├── demo.txt</span><br><span class="line">│   ├── file.png</span><br><span class="line">│   └── main.go</span><br><span class="line">├── testgo</span><br><span class="line">├── test.go</span><br><span class="line">└── vendor</span><br><span class="line">    └── github.com</span><br><span class="line">        └── name</span><br><span class="line">            └── A</span><br></pre></td></tr></table></figure><p>获取包的指定版本号仓库文件，可以用命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone v版本号 httpurl  </span><br><span class="line"></span><br><span class="line">举例:获取版本号为1.4.1的go-socket.io包  </span><br><span class="line">git clone v1.4.1 https://github.com/googollee/go-socket.io</span><br></pre></td></tr></table></figure><h3 id="推荐的方法，使用dep构建"><a href="#推荐的方法，使用dep构建" class="headerlink" title="推荐的方法，使用dep构建"></a>推荐的方法，使用dep构建</h3><p>网上教程很多，在此不做赘述</p><ul><li><a href="https://golang.github.io/dep/docs/introduction.html" target="_blank" rel="noopener">dep官方文档</a></li><li><a href="https://godoc.org/github.com/golang/dep/cmd/dep" target="_blank" rel="noopener">dep_Godoc</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>vendor</tag>
      </tags>
  </entry>
  <entry>
    <title>炒菜心得小结</title>
    <url>/2019/07/06/cokking-feeling/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><p>女友工作了，于是开始商议在家自己做饭，顺便把第二天中午的也做好，带到公司去吃。<br>本文记录这段时间做饭炒菜的收获。<br>炒菜心得</p><p>炒菜前需要把菜洗干净，然后把菜和肉切薄。<br>接着进入炒菜步骤：</p><pre><code>首先，热锅冷油：先把锅烧热，再倒入冷油。
如果是肉，先倒肉，接着赶紧翻炒，防止粘锅。
肉翻的差不多后，倒入切好的蒜，可以入味和杀菌。
倒入料酒，去腥味。
倒入老抽酱油（凉菜用生抽）。
其次倒入不容易煮熟的菜，例如青椒，进行翻炒。
再倒入容易熟的菜进行翻炒。
洒盐。
快熟的时候关火，洒鸡精，然后用余温翻炒。</code></pre><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>如果闻到糊味，就倒一些凉水。</li><li>炒肉前可以加入料酒和酱油搅拌均匀放置。</li><li>炒肉时可以放入适量的豆瓣酱。</li></ul><h2 id="小试牛刀-自制冒菜"><a href="#小试牛刀-自制冒菜" class="headerlink" title="小试牛刀_自制冒菜"></a>小试牛刀_自制冒菜</h2><pre><code>1，买一个冒菜底料（和火锅底料类似）
2，准备食材</code></pre><p>素菜：鱼豆腐，娃娃菜，金针菇，海带，土豆片，土豆粉，火腿肠<br>荤菜：鸡胸肉，牛肉丸子，蟹棒，虾饺，毛肚，千层肚，午餐肉</p><pre><code>3，洗菜
4，切菜，切肉
5，烧水，煮沸
6，先倒入荤菜
7，再倒入素菜
8，煮熟，关火，试吃</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>认真做好一件事，真的很开心！</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>厨艺学习</category>
      </categories>
      <tags>
        <tag>炒菜</tag>
        <tag>学习</tag>
        <tag>系统</tag>
        <tag>youtube</tag>
      </tags>
  </entry>
  <entry>
    <title>流媒体收录流程</title>
    <url>/2019/07/06/stream-media-collection-process/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>因为工作相关，所以写篇文章记录下这整体的业务流程。</p><h2 id="收录"><a href="#收录" class="headerlink" title="收录"></a>收录</h2><h3 id="文字简述"><a href="#文字简述" class="headerlink" title="文字简述"></a>文字简述</h3><p>收录，简单来说就是将视频流保存成视频文件，比如后缀名为mp4,flv,ts等。那么需要哪些模块呢</p><ul><li>前端：展示给用户看的，同时将用户点击的请求数据发送给后端做处理；</li><li>数据中转服务：在前端传给调度服务的数据格式可能会有误，所以中间要经过这个服务，对数据进行加工（一般是<code>json</code>封装）后发送给对方；</li><li>调度服务：负责所有数据库表的创建，记录的添加，修改，删除的操作；将要收录的源流分发给空闲的收录服务器；如果源流的码率较高，需要用转码服务器转成低码文件后收录；</li><li>源流和设备信息检测服务：检测源流的状态是否异常，如果异常就反馈给前端；检测设备的<code>CPU</code>，物理存储，内存的使用占比情况；</li><li>收录服务：开始收录时，由调度服务发给收录服务一个信号，收录服务开始工作，如果不需要收录了，也是由调度服务发给收录服务一个信号，收录服务停止工作；</li><li>转码服务：如果源流的码率过高，例如有8000k，而用户那边的网速又很差，这样会导致视频收录下来播放给用户会显得很卡，影响用户体验，因此需要经过转码服务将高码率的源流转成低码率后，再由收录服务进行收录；</li><li>迁移服务：收录下来后，其他模块可能也会需要，这时需要做迁移。</li><li>适配服务：如果添加的流类型是收录服务器不支持的，需要通过适配服务转换成收录服务支持的，再进行收录。</li><li>定时删除服务：收录的视频文件过多，极其占用物理存储资源，所以需要定时删除。这个定时删除服务就是做这样的事情。</li></ul><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="/2019/07/06/stream-media-collection-process/streamsystem_o.png" alt></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>最开始做这个我不知道是干嘛用的，直到部门老哥给我讲了下<code>Youtube</code>的视频播放过程，让我看到当你的网速不好时，为了保证视频的流畅，画质会差一些，等你网速好了画质再变得高清点。<br>而我这个原理和它类似。<br>注意，收录服务器和转码服务器在图示为了简洁只画了一台，实际上现场要部署很多台。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>流媒体学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>系统</tag>
        <tag>youtube</tag>
        <tag>视音频</tag>
        <tag>收录</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-448-Find All Numbers Disappeared in an Array | 找到所有数组中消失的数字</title>
    <url>/2019/07/01/Leetcode-448-Find-All-Numbers-Disappeared-in-an-Array/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">Find All Numbers Disappeared in an Array</a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>题目意思是找出1～n(n是指数组的长度)内没有出现的数。例如[4,3,2,7,8,2,3,1]里1~8没有出现的数有5,6，所以输出就是[5,6]。</p><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDisappearedNumbers</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)  <span class="comment">//获取数组的长度</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>;i &lt; n;i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> nums[i]<span class="number">-1</span> != i &amp;&amp; nums[i] != nums[nums[i]<span class="number">-1</span>] &#123;</span><br><span class="line">			nums[i],nums[nums[i]<span class="number">-1</span>] = nums[nums[i]<span class="number">-1</span>],nums[i]  <span class="comment">//交换位置</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ans := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>;i &lt; n;i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i]<span class="number">-1</span> != i &#123;</span><br><span class="line">			ans = <span class="built_in">append</span>(ans,i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-88-Merge Sorted Array | 合并两个有序数组</title>
    <url>/2019/07/01/Leetcode-88-Merge-Sorted-Array/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.com/problems/merge-sorted-array/" target="_blank" rel="noopener">merge-sorted-array</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums1 []<span class="keyword">int</span>, m <span class="keyword">int</span>, nums2 []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">	nums := <span class="built_in">make</span>([]<span class="keyword">int</span>,n+m)  <span class="comment">//创建一个混合数组，长度是nums1和nums2的和</span></span><br><span class="line">	<span class="comment">//三个变量i，j，k，分别指向nums1，nums2，和混合数组的末尾</span></span><br><span class="line">	<span class="keyword">for</span> i,j,k := <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>;i &lt; m || j &lt; n;k++ &#123;</span><br><span class="line">		<span class="keyword">if</span> i &lt; m &amp;&amp; j &lt; n &#123;</span><br><span class="line">			<span class="keyword">if</span> nums1[i] &lt; nums2[j] &#123;</span><br><span class="line">				nums[k] = nums1[i]</span><br><span class="line">				i++</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				nums[k] = nums2[j]</span><br><span class="line">				j++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> i &lt; m &#123;</span><br><span class="line">			nums[k] = nums1[i]</span><br><span class="line">			i++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			nums[k] = nums2[j]</span><br><span class="line">			j++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">copy</span>(nums1,nums)  <span class="comment">//把nums的数拷贝到nums1里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg常用命令整理</title>
    <url>/2019/07/01/ffmpeg-command-finish/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="检测源流信息"><a href="#检测源流信息" class="headerlink" title="检测源流信息"></a>检测源流信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i 源流地址</span><br></pre></td></tr></table></figure><h2 id="推流"><a href="#推流" class="headerlink" title="推流"></a>推流</h2><h3 id="把A-MP4和B-mp4打包进同一个ts流，并推到本机的10003端口"><a href="#把A-MP4和B-mp4打包进同一个ts流，并推到本机的10003端口" class="headerlink" title="把A.MP4和B.mp4打包进同一个ts流，并推到本机的10003端口"></a>把A.MP4和B.mp4打包进同一个ts流，并推到本机的10003端口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -re -i A.mp4  -re -i B.mp4  -map 0:0 -map 0:1 -map 1:0 -map 1:1  -program program_num=1:title=videoA:st=0:st=1 -program program_num=3:title=videoB:st=2:st=3 -c copy -f mpegts udp://localhost:10003</span><br></pre></td></tr></table></figure><p>以此类推</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">推一路流</span><br><span class="line">ffmpeg -re -i A.mp4 -map 0:0 -map 0:1 -program program_num=1:title=videoA:st=0:st=1  -f mpegts udp://localhost:10003</span><br><span class="line"></span><br><span class="line">推三路流</span><br><span class="line">ffmpeg -re -i shenzhen.ts  -re -i guangdong.ts -re -i girl.mp4  -map 0:0 -map 0:1 -map 1:0 -map 1:1 -map 0:0 -map 0:1 -program program_num=1:title=videoA:st=0:st=1 -program program_num=3:title=videoB:st=2:st=3 -program program_num=5:title=videoXXX:st=4:st=5 -f mpegts udp://localhost:10003</span><br></pre></td></tr></table></figure><p>循环推一路流，不做编码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -re -stream_loop -1 -i aaa.xx -c copy -f mpegts udp://localhost:10003</span><br></pre></td></tr></table></figure><h3 id="命令参数解释"><a href="#命令参数解释" class="headerlink" title="命令参数解释"></a>命令参数解释</h3><ul><li>re:realtime 推的速度，按当前帧率推</li><li>map 0:0 第一个流的视频</li><li>map 0:1 第一个流的音频</li><li>map 1:0 第二个流的视频</li><li>map 1:1 第二个流的音频</li><li>program_num=1:title=videoA:st=0:st=1 0,1合成一个视频videoA</li><li>program program_num=3:title=videoB:st=2:st=3 2,3合成一个视频videoB</li><li>-stream_loop 循环推流</li><li>-c copy 将视频中压缩的数据复制</li><li>-c:v libh264 将视频流强制转换为h264编码</li></ul><h2 id="查看流中的program信息"><a href="#查看流中的program信息" class="headerlink" title="查看流中的program信息"></a>查看流中的program信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffprobe -show_programs -print_format json -timeout 5000000 -i udp://localhost:10003</span><br></pre></td></tr></table></figure><ul><li>注意:这个命令有返回值，<code>0</code>表示执行成功，<code>1</code>表示失败。</li></ul><h2 id="将流中的program-1和program-3分别截取5s钟的时间，生成了两个文件"><a href="#将流中的program-1和program-3分别截取5s钟的时间，生成了两个文件" class="headerlink" title="将流中的program 1和program 3分别截取5s钟的时间，生成了两个文件"></a>将流中的program 1和program 3分别截取5s钟的时间，生成了两个文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -timeout 5000000 -i udp://localhost:10003  -t 0:0:5  -map p:1 -c copy  1.mp4 -t 0:0:5 -map p:3 -c copy 3.mp4</span><br></pre></td></tr></table></figure><ul><li>注意。此时推的是复合流。</li></ul><h2 id="对视频流抽帧"><a href="#对视频流抽帧" class="headerlink" title="对视频流抽帧"></a>对视频流抽帧</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i 源流地址 -vframes 1 -vf scale=90:51 图片存放路径</span><br></pre></td></tr></table></figure><h2 id="重复推流"><a href="#重复推流" class="headerlink" title="重复推流"></a>重复推流</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -re -stream_loop -1 -i aaa.xx -c copy -f mpegts udp://localhost:10003</span><br><span class="line"></span><br><span class="line">./ffmpeg -re  -i -stream_loop -1 startslient.mp3  -c:a aac -f flv rtmp://123.56.17.184/live/znn</span><br></pre></td></tr></table></figure><h2 id="将流保存成文件"><a href="#将流保存成文件" class="headerlink" title="将流保存成文件"></a>将流保存成文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i 流地址 -c copy 文件名</span><br><span class="line"></span><br><span class="line">例如:</span><br><span class="line">ffmpeg -i udp://localhost:10003 -c copy test.ts</span><br></pre></td></tr></table></figure><h2 id="检测源流中是否有静音"><a href="#检测源流中是否有静音" class="headerlink" title="检测源流中是否有静音"></a>检测源流中是否有静音</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i silence.mp3 -af silencedetect=noise=0.0001 -f null -</span><br><span class="line">(默认音频中如果有2秒是静音，就认为是有静音的)</span><br><span class="line"></span><br><span class="line">持续让ffmpeg检测音频5秒</span><br><span class="line">ffmpeg -i silence.mp3 -af silencedetect=noise=0.0001 -t 0:0:5 -f null -</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>FFmpeg学习</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
        <tag>视音频</tag>
      </tags>
  </entry>
  <entry>
    <title>Go test单元测试小技巧</title>
    <url>/2019/06/30/golang-test-tips/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>周五在做<code>go test</code>测试时，碰到个问题，我要对一个<code>xxx</code>函数写测试样例，然而它的首字母是小写的，没有导出，单元测试过不去，而这个<code>xxx</code>函数外面还有一个<code>YYY</code>函数首字母是大写的，但要经过很长的逻辑才能到<code>xxx</code>函数。这时我又要完成对<code>xxx</code>函数进行测试，又不想经过<code>YYY</code>函数走逻辑，该怎么办呢？</p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>首先，绝对不能做的事：</p><ul><li>将<code>xxx</code>函数改为首字母大写的<code>Xxx</code>函数<br>原因：很多地方都在调这个函数，你改了这一处只满足你这次的测试，那其他基本业务流程也就崩了。</li></ul><p>我目前是在<code>test</code>文件夹里新建了一个<code>xxx_test.go</code>测试文件，样子长这样</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Testxxx</span><span class="params">(t testing.T)</span></span>&#123;</span><br><span class="line">    control.XXX()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>xxx</code>函数是在<code>control</code>包里，因此我要在<code>control</code>包下建一个<code>export.go</code>文件</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> control</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> XXX = xxx</span><br></pre></td></tr></table></figure><p>然后执行<code>go test</code>命令，它会遍历<code>control</code>包下的所有文件，这时<code>export.go</code>文件 里的<code>var XXX = xxx</code>就起到了一个桥梁作用。</p><p>这时测试的时候就不需要再经过<code>YYY</code>的逻辑走到<code>xxx</code>函数里面。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://studygolang.com/topics/9332" target="_blank" rel="noopener">付费用户「每日一学」2019-06-14：你应该知道的单元测试小技巧</a></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
        <tag>技巧</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go test单元测试小技巧</title>
    <url>/2019/06/30/go-test-tips/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>周五在做<code>go test</code>测试时，碰到个问题，我要对一个<code>xxx</code>函数写测试样例，然而它的首字母是小写的，没有导出，单元测试过不去，而这个<code>xxx</code>函数外面还有一个<code>YYY</code>函数首字母是大写的，但要经过很长的逻辑才能到<code>xxx</code>函数。这时我又要完成对<code>xxx</code>函数进行测试，又不想经过<code>YYY</code>函数走逻辑，该怎么办呢？</p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>首先，绝对不能做的事：</p><ul><li>将<code>xxx</code>函数改为首字母大写的<code>Xxx</code>函数<br>原因：很多地方都在调这个函数，你改了这一处只满足你这次的测试，那其他基本业务流程也就崩了。</li></ul><p>我目前是在<code>test</code>文件夹里新建了一个<code>xxx_test.go</code>测试文件，样子长这样</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Testxxx</span><span class="params">(t testing.T)</span></span>&#123;</span><br><span class="line">    control.XXX()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>xxx</code>函数是在<code>control</code>包里，因此我要在<code>control</code>包下建一个<code>export.go</code>文件</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> control</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> XXX = xxx</span><br></pre></td></tr></table></figure><p>然后执行<code>go test</code>命令，它会遍历<code>control</code>包下的所有文件，这时<code>export.go</code>文件 里的<code>var XXX = xxx</code>就起到了一个桥梁作用。</p><p>这时测试的时候就不需要再经过<code>YYY</code>的逻辑走到<code>xxx</code>函数里面。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://studygolang.com/topics/9332" target="_blank" rel="noopener">付费用户「每日一学」2019-06-14：你应该知道的单元测试小技巧</a></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>单元测试</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Git更改远程推送的仓库地址</title>
    <url>/2019/06/29/git-change-push-remote-rep/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>本地代码推送到远程仓库地址时，有时地址会发生变更，所以需要更改，<code>git</code>命令如下</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="查看远程仓库地址"><a href="#查看远程仓库地址" class="headerlink" title="查看远程仓库地址"></a>查看远程仓库地址</h3><figure class="highlight plain"><figcaption><span>remote -v```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 添加远程仓库链接  </span><br><span class="line"></span><br><span class="line">```git remote add 远程仓库链接</span><br></pre></td></tr></table></figure><p>所以当年<code>push</code>代码的时候，是<code>git push -u 链接名 分支名</code></p><h3 id="更改远程仓库链接名"><a href="#更改远程仓库链接名" class="headerlink" title="更改远程仓库链接名"></a>更改远程仓库链接名</h3><figure class="highlight plain"><figcaption><span>remote rename 老链接名 新链接名```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 删除远程链接仓库链接名</span><br><span class="line"></span><br><span class="line">```git remote remove 链接名</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Git学习</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>push</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员10x工作法</title>
    <url>/2019/06/23/programmer-10x-work/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul><li>01：面对问题时，用思考框架问问自己，现状、目标和路径。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Where are we?（我们现在在哪？）</span><br><span class="line">Where are we going?（我们要到哪儿去？）</span><br><span class="line">How can we get there?（我们如何到达那里？）</span><br></pre></td></tr></table></figure></li><li>02：遇到事情，倒着想。</li><li>03：在做任何事之前，先定义完成的标准。</li><li>04：在做任何需求或任务之前，先定好验收标准。</li><li>05：尽早提交代码去集成。</li><li>06：默认所有需求都不做，直到弄清楚为什么要做这件事。</li><li>07：扩大自己工作的上下文，别把自己局限在一个“程序员”的角色上。</li><li>08：在动手做一件事之前，先推演一番。</li><li>09：问一下自己，我的工作是不是可以用数字衡量。</li><li>10：设计你的迭代0清单，给自己的项目做体检。</li><li>11：动手做一个工作之前，请先对它进行任务分解。</li><li>12：多写单元测试。</li><li>13：我们应该编写可测的代码。</li><li>14：将任务拆小，越小越好。</li><li>15：按照完整实现一个需求的顺序去安排分解出来的任务。</li><li>16：要想写好测试，就要写简单的测试。</li><li>17：想要管理好需求，先把需求拆小。</li><li>18：尽量做最重要的事。</li><li>19：做好产品开发，最可行的方式是采用 MVP（最小可行产品）。</li><li>20：通过沟通反馈，不断升级自己的编解码能力。</li><li>21：用业务的语言写代码。</li><li>22：多面对面沟通，少开会。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我昨天做了什么？  </span><br><span class="line">我今天打算做什么？  </span><br><span class="line">我在过程中遇到了什么问题，需要请求帮助。</span><br></pre></td></tr></table></figure></li><li>23：多尝试用可视化的方式进行沟通。</li><li>24：做好持续集成的关键在于，快速反馈。</li><li>25：定期复盘，找准问题根因，不断改善。</li><li>26：多走近用户。</li><li>27：事情往前做，有问题尽早暴露。</li><li>28：多输出，让知识更有结构。</li><li>29：请谨慎地将工作自动化。</li><li>30：将你的工作过程自动化。</li><li>31：有体系地学习运维知识。</li><li>32：将部署纳入开发的考量。</li><li>33：将验收测试自动化。</li><li>34：把函数写短。</li><li>35：构建好你的领域模型。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">万维钢有期节目里提到芯片设计时讲到了分层以及模型的概念。分层或模型，实质是因为人的认知能力有</span><br><span class="line">限不得已而为之的。学习计算机，我们都知道晶体管，即便早就忘了它的原理。实际上晶体管涉及非常深</span><br><span class="line">奥的物理学知识，这是绝大多数人一辈子都不需要了解的物理学。抛开复杂艰深的物理学，晶体管的本质</span><br><span class="line">却很简单，它就是一个包含通和不通两个状态的开关，这就是它构建的模型。</span><br><span class="line">在开关的模型基础之上，信息论的创立者香农用一篇硕士论文构建了逻辑门这层。他证明了可以用最简单</span><br><span class="line">的开关，实现所有逻辑运算。</span><br><span class="line">逻辑运算层次之上，就是我们所知道的CPU模型。再往上，就是我们所熟悉的信息世界</span><br></pre></td></tr></table></figure></li><li>36：用简单技术解决问题，直到问题变复杂。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一方面，有人会因为对业务量级理解不足，盲目低估其他人系统的复杂度；另一方面，也有人会盲目应用技</span><br><span class="line">术，给系统引入不必要的复杂度，让自己陷入泥潭。</span><br><span class="line">作为拥有技术能力的程序员，我们都非常在意个人技术能力的提升，但却对在什么样情形下，什么样的技术</span><br><span class="line">更加适用考虑得不够。采用恰当的技术，解决当前的问题，是每个程序员都应该仔细考虑的问题。</span><br></pre></td></tr></table></figure></li><li>37：学习领域驱动设计。</li><li>38：了解一个项目，从大图景开始。</li><li>39：小步改造遗留系统，不要回到老路上。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">构建测试防护网，保证新老模块功能一致；</span><br><span class="line">分成小块，逐步替换；</span><br><span class="line">构建好领域模型；</span><br><span class="line">寻找行业中关于系统构建的最新理解。</span><br></pre></td></tr></table></figure></li><li>40：在学习区工作和成长。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从目前的发展来看，IT 行业依然是一个非常有前景的行业，但想在这条路上走好，需要我们成为 “T ”型</span><br><span class="line">人才，也就是“一专多能”。一专多能的前提是“一专”，让自己成为某个方面的专家。这个专家要放在行</span><br><span class="line">业的标准去看，这才能降低因为一个公司的波动而造成的影响。</span><br><span class="line">成为行业专家，要向行业的大师学习，给自己定下一个高的目标，然后是脚踏实地，找适合自己的问题去解</span><br><span class="line">决，让自己一直在学习区成长。</span><br></pre></td></tr></table></figure></li></ul><h2 id="答疑解惑"><a href="#答疑解惑" class="headerlink" title="答疑解惑"></a>答疑解惑</h2><h3 id="单元测试做不好，是否会影响到-CI-的效果？"><a href="#单元测试做不好，是否会影响到-CI-的效果？" class="headerlink" title="单元测试做不好，是否会影响到 CI 的效果？"></a>单元测试做不好，是否会影响到 CI 的效果？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CI 作为一个单独的实践，本身是很简单的，但它可以成为提纲挈领的主线，帮助团队不断改善自己</span><br><span class="line">的开发过程。</span><br></pre></td></tr></table></figure><h3 id="老板参加复盘，不敢说真话怎么办？"><a href="#老板参加复盘，不敢说真话怎么办？" class="headerlink" title="老板参加复盘，不敢说真话怎么办？"></a>老板参加复盘，不敢说真话怎么办？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">问题，是改进的前提条件。</span><br></pre></td></tr></table></figure><h3 id="国内的技术信息落后吗？"><a href="#国内的技术信息落后吗？" class="headerlink" title="国内的技术信息落后吗？"></a>国内的技术信息落后吗？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">国内程序员真正落后的不是信息，而是观念。</span><br></pre></td></tr></table></figure><h3 id="如何管理上级？"><a href="#如何管理上级？" class="headerlink" title="如何管理上级？"></a>如何管理上级？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一，管理上级的预期。</span><br><span class="line">第二，帮助上级丰富知识。</span><br><span class="line">第三，说出你的想法。</span><br></pre></td></tr></table></figure><h3 id="面对不了解的技术，我该如何分解任务？"><a href="#面对不了解的技术，我该如何分解任务？" class="headerlink" title="面对不了解的技术，我该如何分解任务？"></a>面对不了解的技术，我该如何分解任务？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先把它变成你熟悉的技术。</span><br></pre></td></tr></table></figure><h3 id="项目时间紧，该怎么办？"><a href="#项目时间紧，该怎么办？" class="headerlink" title="项目时间紧，该怎么办？"></a>项目时间紧，该怎么办？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">混淆了目标与现状。</span><br><span class="line">目标是应该怎么做，现状是我们正在怎么做。我们都知道</span><br><span class="line">现状是什么样的，问题是，你对现状满意吗？如果每个人都对现状是满意的，就不会有人探索更好的做法。</span><br><span class="line">假设现在不忙了，你知道该怎么改进吗？</span><br><span class="line"></span><br><span class="line">自动糊改进：</span><br><span class="line">把测试覆盖率检查加入到工程里，得到现有的测试覆盖率。</span><br><span class="line">将测试覆盖率加入持续集成，设定当前测试覆盖率为初始值。测试覆盖率不达标，不许提交代码。</span><br><span class="line">每周将测试覆盖率调高，比如，5%或10%，直到测试覆盖率达到100%。</span><br></pre></td></tr></table></figure><h3 id="多个功能同时开发，怎么办？"><a href="#多个功能同时开发，怎么办？" class="headerlink" title="多个功能同时开发，怎么办？"></a>多个功能同时开发，怎么办？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在主分支开发模型中，有一些常见的解决多功能并行开发的方法，其中，Feature Toggle 是最常用的一个，</span><br><span class="line">也就是通过开关，决定哪个功能是对外可用的。</span><br></pre></td></tr></table></figure><h3 id="如何在实际工作中推行新观念？"><a href="#如何在实际工作中推行新观念？" class="headerlink" title="如何在实际工作中推行新观念？"></a>如何在实际工作中推行新观念？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">找到愿意和你一起改变的人，做一件具体的事。</span><br></pre></td></tr></table></figure><h3 id="测试怎么写？"><a href="#测试怎么写？" class="headerlink" title="测试怎么写？"></a>测试怎么写？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">关于外部系统的测试，你可以先通过接口隔离开来，然后，通过模拟服务或本地可控的方式进行</span><br><span class="line">测试。</span><br></pre></td></tr></table></figure><h3 id="IntelliJ-IDEA-怎么学？"><a href="#IntelliJ-IDEA-怎么学？" class="headerlink" title="IntelliJ IDEA 怎么学？"></a>IntelliJ IDEA 怎么学？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个工具怎么学？我的经验就是去用。我没有专门学过 IntelliJ IDEA，只是不断地在使用它。</span><br><span class="line">遇到问题就去找相应的解决方案。</span><br><span class="line">也有一些辅助的方法可以帮助我们练习，</span><br><span class="line">比如，我们会给新员工发放 IntelliJ IDEA 的快捷键卡片，写代码休息之余，可以拿来看一下；</span><br><span class="line">再比如，IntelliJ IDEA 有一个插件叫 Key Promoter X，</span><br><span class="line">如果你用鼠标操作，它会给你提示，帮你记住快捷键</span><br></pre></td></tr></table></figure><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li><a href="https://www.infoq.cn/article/function-switch-realize-better-continuous-implementations" target="_blank" rel="noopener">使用功能开关更好地实现持续部署</a></li><li><a href="https://martinfowler.com/articles/feature-toggles.html" target="_blank" rel="noopener">Feature Toggles (aka Feature Flags)</a></li><li><a href="https://www.unixhot.com/page/ops" target="_blank" rel="noopener">运维知识体系</a></li><li><a href="https://www.unixhot.com/page/cache" target="_blank" rel="noopener">Web缓存知识体系</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>工作</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode_977_Squares-of-a-Sorted-Array | 有序数组的平方</title>
    <url>/2019/06/19/LeetCode-977-Squares-of-a-Sorted-Array/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><ul><li><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener">leetcode中国</a></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>此题比较简单，意思就是对数组里的数字进行排序和开平方。代码如下</p><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            A[i] = A[i] * A[i];  <span class="comment">//对数组中每个数都平方</span></span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(A);  <span class="comment">//对数组进行排序</span></span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Python</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span><span class="params">(self, A: <span class="string">'List[int]'</span>)</span> -&gt; 'List[int]':</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> x*x</span><br><span class="line">        <span class="keyword">return</span> sorted(map(f,A))</span><br></pre></td></tr></table></figure><h2 id="开启刷题之路"><a href="#开启刷题之路" class="headerlink" title="开启刷题之路"></a>开启刷题之路</h2><p>加入了大佬创建的刷题圈，目标是一天一道LeetCode算法题，按专题刷，加油！</p><p><img src="/2019/06/19/LeetCode-977-Squares-of-a-Sorted-Array/sky.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode_905_Sort-Array-By-Parity | 按奇偶排序数组</title>
    <url>/2019/06/19/LeetCode-905-Sort-Array-By-Parity/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.com/problems/sort-array-by-parity/?utm_source=LCUS&utm_medium=ip_redirect_q_uns&utm_campaign=transfer2china" target="_blank" rel="noopener">905. Sort Array By Parity</a></p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><ul><li>Python</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArrayByParity</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> A[i] % <span class="number">2</span> &gt; A[j] % <span class="number">2</span>:</span><br><span class="line">                A[i], A[j] = A[j], A[i] <span class="comment">#互换</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> A[i] % <span class="number">2</span> == <span class="number">0</span>: i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> A[j] % <span class="number">2</span> == <span class="number">1</span>: j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure><ul><li>C++</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortArrayByParity(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                swap(A[i--],A[len--]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-485-Max Consecutive Ones | 最大连续1的个数</title>
    <url>/2019/06/17/Leetcode-485-Max-Consecutive-Ones/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.com/problems/max-consecutive-ones/" target="_blank" rel="noopener">Max Consecutive Ones</a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="题目意思"><a href="#题目意思" class="headerlink" title="题目意思"></a>题目意思</h3><p>给定一个二进制数组，计算数组中出现的最大连续1的个数。</p><p>注意：</p><ul><li>输入数组只包含0和1</li><li>数组长度是正整数并且不会超过10000</li></ul><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>遍历数组并对连续的数计数，最终取最大值。</p><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><ul><li><p>错误</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> max <span class="keyword">int</span>  <span class="comment">//声明最大值</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i &lt;= <span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> _,v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[i] = v &#123;</span><br><span class="line">				max++</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				max=<span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>正确1</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	count := <span class="number">1</span></span><br><span class="line">	<span class="comment">//考虑特殊情况</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &amp;&amp; nums[<span class="number">0</span>] == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] == nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[i] == <span class="number">1</span> &#123;</span><br><span class="line">				count++  <span class="comment">//计数</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			count = <span class="number">1</span>  <span class="comment">//没有合适的就置为1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> count &gt; res &#123;</span><br><span class="line">			res = count</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>正确2</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sum, max <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		sum += v</span><br><span class="line">		sum *= v</span><br><span class="line">		<span class="keyword">if</span> sum &gt; max &#123;</span><br><span class="line">			max = sum</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>知识星球Go项目实战爬虫项目总结</title>
    <url>/2019/06/16/zsxq-go-project-action-crawler-summary/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>知识星球<code>Go项目实战</code>的第一个实战项目—&gt;爬虫。<br>本文记录直播内容和相关细节。</p><h2 id="前端相关"><a href="#前端相关" class="headerlink" title="前端相关"></a>前端相关</h2><p>DOM，CSS选择器，jQuery</p><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><ul><li>前端：Bootstrap和jQuery</li><li>后端：Go</li><li>数据库：MySQL</li></ul><h3 id="数据库设计思路"><a href="#数据库设计思路" class="headerlink" title="数据库设计思路"></a>数据库设计思路</h3><ul><li>job_info 表：我们计划抓取猎聘、Boss直聘和拉钩网三个网站的 Go 语言相关职位信息。通过分析三个网站上的职位信息数据，结合咱们的目标，设计了 job_info 表；</li><li>crawl_rule 表：针对 job_info 表的设计，我们希望在网站职位的详情页能够获取到相应信息。因为每个网站页面结构不同，抓取策略也会不一样，因此有了此表；</li><li>auto_crawl_rule 表：crawl_rule 表是针对一个职位详情页的，但我们不可能手动一个页面一个页面抓取，而是希望能够提供一些信息将某个网站上相关职位信息批量抓取。此表用于抓取职位列表信息，进而抓取一个个职位信息；</li></ul><h3 id="数据库设计原则和注意事项-重点"><a href="#数据库设计原则和注意事项-重点" class="headerlink" title="数据库设计原则和注意事项(重点)"></a>数据库设计原则和注意事项(重点)</h3><p>1，字段不允许 NULL 且提供默认值，即 NOT NULL DEFAULT xx；<br>2，选择合适的最小数据类型；<br>3，确保是非负数的字段，加上 unsigned;<br>4，使用 COMMENT 给字段加备注；<br>5，表一般应该有 created_at 字段；<br>6，没特殊情况，请使用 InnoDB 引擎；<br>7，字符编码使用 utf8mb4；<strong>不要用utf8</strong><br>8，VARCHAR 类型的长度值使用 2 的幂次方减1或减2，比如 varchar(127) varchar(255) varchar(510) 因为 510 这个数字（长度）本身需要 2 个字节存储。（也就是长度超过 255 之后，用两个字节存储长度，所以减 2）；<br>9，根据查询条件，建立必要的索引；<br>10，NOT NULL，确保它一定不是NULL；</p><h3 id="项目结构和代码组织"><a href="#项目结构和代码组织" class="headerlink" title="项目结构和代码组织"></a>项目结构和代码组织</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── cmd  //项目入口，主程序</span><br><span class="line">│   └── crawler</span><br><span class="line">│       ├── background.go</span><br><span class="line">│       ├── crawler</span><br><span class="line">│       └── main.go</span><br><span class="line">├── config  //配置信息</span><br><span class="line">│   └── config.yaml</span><br><span class="line">├── dao  //数据访问对象，直接和数据存储打交道</span><br><span class="line">│   ├── auto_crawl_rule.go</span><br><span class="line">│   ├── auto_crawl_rule_test.go</span><br><span class="line">│   ├── crawl_rule.go</span><br><span class="line">│   ├── db.go</span><br><span class="line">│   └── job.go</span><br><span class="line">├── docs  //文档</span><br><span class="line">│   └── db.sql</span><br><span class="line">├── global  //全局信息，初始化</span><br><span class="line">│   ├── app.go</span><br><span class="line">│   ├── error.go</span><br><span class="line">│   └── init.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── http  //</span><br><span class="line">│   ├── controller  //MVC 的 controller</span><br><span class="line">│   │   ├── job_handler.go</span><br><span class="line">│   │   └── job_handler_test.go</span><br><span class="line">│   ├── middleware  //http的中间件</span><br><span class="line">│   │   ├── logger.go</span><br><span class="line">│   │   └── recover.go</span><br><span class="line">│   └── routes.go</span><br><span class="line">├── LICENSE</span><br><span class="line">├── logic  //业务逻辑</span><br><span class="line">│   ├── crawler</span><br><span class="line">│   │   ├── colly.go</span><br><span class="line">│   │   ├── goquery.go</span><br><span class="line">│   │   ├── parser.go</span><br><span class="line">│   │   └── work.go</span><br><span class="line">│   └── job.go</span><br><span class="line">├── model  //映射的结构体</span><br><span class="line">│   ├── auto_crawl_rule.go</span><br><span class="line">│   ├── crawl_rule.go</span><br><span class="line">│   └── job_info.go</span><br><span class="line">├── README.md</span><br><span class="line">├── template  //模板</span><br><span class="line">│   ├── detail.html</span><br><span class="line">│   └── index.html</span><br><span class="line">└── util  //辅助工具</span><br><span class="line">    ├── file.go</span><br><span class="line">    ├── http.go</span><br><span class="line">    ├── int.go</span><br><span class="line">    └── ip.go</span><br></pre></td></tr></table></figure><h3 id="关于配置文件"><a href="#关于配置文件" class="headerlink" title="关于配置文件"></a>关于配置文件</h3><p>1，写死，保底<br>2，通过配置拿到数据，两种形式，读取配置文件和命令行参数传递过来<br>3，读环境变量</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本项目主要熟悉和培养用Go设计项目的框架，同时也把前段时间学习的知识点做了综合运用。下面记录下一些关键信息：</p><ul><li>熟悉<code>go mod</code></li><li>执行数据库语句的代码和数据库语句最好分开来操作</li><li>数据量很大的时候，最好不要随意改变数据表中的字段，不然服务会挂</li><li>项目中还有待完善的部分，例如<code>Colly</code>的实现，结构体转数据表或数据表转结构体，选择分析器的部分</li></ul><h2 id="提问环节"><a href="#提问环节" class="headerlink" title="提问环节"></a>提问环节</h2><p>Q1:cmd下为什么要有crawler文件夹<br>如果cmd下放main.go，编译出来的文件名叫什么？—cmd</p><p>Q2:并发版爬虫？什么时候成分布式的啊<br>抓的太频繁，会被封。</p><p>Q3:測試 controller 會直接對 db 調用，不知道這樣好嗎</p><p>Q4:http 为什么要加 recover ？ 默认没有么</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>爬虫</tag>
        <tag>Go</tag>
        <tag>知识星球</tag>
      </tags>
  </entry>
  <entry>
    <title>Git如何更新fork后的repository</title>
    <url>/2019/06/10/how-to-update-git-fork-repository/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有一个仓库A，我经过<code>fork</code>后变成了仓库B，当仓库A已经有了新提交时，我需要更新仓库B，该怎么办呢？</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>1,首先，检查一下当前的配置，看看当前有没有已经设置了上游，这要使用<code>git remote -v</code>命令。</p><p>2,将原repository设置为自己fork出的repository的上游（upstream）。运用如下的命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git</span><br></pre></td></tr></table></figure><p>3,运行<code>git fetch upstream</code>命令，如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">remote: Enumerating objects: 122, done.</span><br><span class="line">remote: Counting objects: 100% (122/122), done.</span><br><span class="line">remote: Compressing objects: 100% (90/90), done.</span><br><span class="line">remote: Total 97 (delta 40), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (97/97), done.</span><br><span class="line">From https://gitea.com/zsxq/jobs_crawler</span><br><span class="line"> * [new branch]      master     -&gt; upstream/master</span><br></pre></td></tr></table></figure><p>4,<code>git checkout master</code>，这是保证切换到本地的repository的master上，如果本来就在，那么这一步不是必须的。</p><p>5,运行<code>git merge upstream/master</code>命令，将upstream/master上的更新合并到本地的master上，其实就是将第三步中download到.git文件夹下的那些change合并到本地的master中。如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Updating e9540a6..c31fadf</span><br><span class="line">Fast-forward</span><br><span class="line"> README.md                      |   8 +-</span><br><span class="line"> cmd/crawler/background.go      |  42 ++++++++</span><br><span class="line"> cmd/crawler/main.go            |  32 +++---</span><br><span class="line"> config/config.yaml             |  18 +++-</span><br><span class="line"> dao/auto_crawl_rule.go         |  79 +++++++++++++++</span><br><span class="line"> dao/auto_crawl_rule_test.go    |  38 +++++++</span><br><span class="line"> dao/crawl_rule.go              |  44 ++++++++</span><br><span class="line"> dao/db.go                      |  19 ++--</span><br><span class="line"> dao/job.go                     | 101 ++++++++++++++++++-</span><br><span class="line"> docs/db.sql                    |  19 ++--</span><br><span class="line"> global/app.go                  |  77 ++++++++++++++</span><br><span class="line"> global/init.go                 |  35 +++++++</span><br><span class="line"> go.mod                         |   5 +-</span><br><span class="line"> go.sum                         |   3 +</span><br><span class="line"> http/controller/job_handler.go |  79 ++++++++++++++-</span><br><span class="line"> http/middleware/logger.go      |  35 +++++++</span><br><span class="line"> logic/crawler/colly.go         |  46 +++++++++</span><br><span class="line"> logic/crawler/goquery.go       | 221 +++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> logic/crawler/parser.go        |  68 +++++++++++++</span><br><span class="line"> logic/crawler/work.go          |  55 ++++++++++</span><br><span class="line"> logic/job.go                   |  14 ++-</span><br><span class="line"> model/auto_crawl_rule.go       |  31 ++++++</span><br><span class="line"> model/crawl_rule.go            |  26 +++++</span><br><span class="line"> model/job_info.go              |   2 +-</span><br><span class="line"> template/detail.html           |  49 +++++++++</span><br><span class="line"> template/index.html            |  70 +++++++++++++</span><br><span class="line"> util/file.go                   |  18 ++++</span><br><span class="line"> util/http.go                   |  21 ++++</span><br><span class="line"> util/int.go                    |   8 ++</span><br><span class="line"> util/ip.go                     |  37 +++++++</span><br><span class="line"> 30 files changed, 1253 insertions(+), 47 deletions(-)</span><br></pre></td></tr></table></figure><p>这时我在用<code>gitk</code>命令查看<br><img src="/2019/06/10/how-to-update-git-fork-repository/git-fork.png" alt="git-fork"></p><p>6,如果本地没有什么自己独立的更新的话，那么将执行”Fast-forward”的合并。如果本地有自己独立的更新，而又会引起冲突的话，则要解决冲突，再commit.</p><p>关于解决冲突，如果明确所有冲突都是使用upstream/master上的来override自己的，那么可以直接运行如下命令，则无需解决冲突了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge -X theirs upstream/master</span><br></pre></td></tr></table></figure><p>注意，以上步骤结束后，仅仅是本地的fork出的repository和原repository取得了同步，如果想让远程的fork出的repository也同样取得同步，必须再git push上去。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://help.github.com/en/articles/syncing-a-fork" target="_blank" rel="noopener">Syncing a fork</a></li><li><a href="https://help.github.com/en/articles/configuring-a-remote-for-a-fork" target="_blank" rel="noopener">Configuring a remote for a fork</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>Git</tag>
        <tag>fork</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-66-Plus One | 加一</title>
    <url>/2019/06/10/Leetcode-66-Plus-One/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.com/problems/plus-one/" target="_blank" rel="noopener">plus one</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>模拟十进制进位加法</li><li>注意处理有进位的情况</li></ul><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><ul><li><p>解法一</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plusOne</span><span class="params">(digits []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	digitslength := <span class="built_in">len</span>(digits)  <span class="comment">//获取数组长度</span></span><br><span class="line">	<span class="keyword">for</span> i := digitslength - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i-- &#123;</span><br><span class="line">		<span class="keyword">if</span> digits[i] &lt; <span class="number">9</span> &#123;  <span class="comment">//判断数组尾部是否小于9</span></span><br><span class="line">			digits[i]++</span><br><span class="line">			<span class="keyword">return</span> digits</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//有进位的情况</span></span><br><span class="line">		digits[i] = <span class="number">0</span>  <span class="comment">//数组最后一位置为0</span></span><br><span class="line">		res := []<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;  </span><br><span class="line">		res = <span class="built_in">append</span>(res,digits...)</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法二</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plusOne</span><span class="params">(digits []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	digits = <span class="built_in">append</span>(digits,<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(digits) - <span class="number">1</span>;i &gt; <span class="number">0</span>;i-- &#123;</span><br><span class="line">		digits[i] = digits[i] + digits[i<span class="number">-1</span>]</span><br><span class="line">		digits[i<span class="number">-1</span>] = digits[i]/<span class="number">10</span>  <span class="comment">//取除数</span></span><br><span class="line">		digits[i] %= <span class="number">10</span>  <span class="comment">//取余数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> digits[<span class="number">0</span>] == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> digits[<span class="number">1</span>:]</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> digits</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title>文字直播：消息推送系统介绍</title>
    <url>/2019/06/09/text-live-introduction-message-push-system/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>直播内容:主要讨论周洋在360做的消息推送系统，主要分为以下几个部分：</p><ul><li>关于push系统对比与性能指标的讨论~</li><li>消息系统架构介绍</li><li>哪些因素决定了推送系统的效果？</li><li>go语言开发问题与解决方案</li><li>消息系统的运维，测试</li></ul><h2 id="直播开始"><a href="#直播开始" class="headerlink" title="直播开始"></a>直播开始</h2><p>360消息系统更确切的说是长连接push系统，目前服务于360内部50多个产品，开发平台数千款app，也支持部分聊天业务场景，单通道多app复用，支持上行数据，提供接入方不同粒度的上行数据和用户状态回调服务。<br>目前整个系统按不同业务分成9个功能完整的集群，部署在10个idc上（每个集群覆盖不同的idc），实时在线2亿量级.<br>通常情况下，pc，手机，甚至是智能硬件上的360产品的push消息，基本上是从我们系统发出的，期望大家收到的push都是自己关心的… 如果不是，请相信，“我们不生产消息，我们只是消息的搬运工”~<br>很多同行比较关心go语言在实现push系统上的性能问题，单机性能究竟如何，能否和其他语言实现的类似系统做对比么？甚至问如果是创业,第三方云推送平台，推荐哪个?<br>其实各大厂都有类似的push系统，市场上也有类似功能的云服务。包括我们公司早期也有erlang，nodejs实现的类似系统，也一度被公司要求做类似的对比测试。<br>我感觉在讨论对比数据的时候，很难保证大家环境和需求的统一，我只能说下我这里的体会，数据是有的，但这个数据前面估计会有很多定语~</p><h2 id="一些重要指标"><a href="#一些重要指标" class="headerlink" title="一些重要指标"></a>一些重要指标</h2><h3 id="1，单机的连接数指标。"><a href="#1，单机的连接数指标。" class="headerlink" title="1，单机的连接数指标。"></a>1，单机的连接数指标。</h3><p>做过长连接的同行，应该有体会，如果在稳定连接情况下，连接数这个指标，在没有网络吞吐情况下对比，其实意义往往不大，维持连接消耗cpu资源很小，每条连接tcp协议栈会占约4k的内存开销，系统参数调整后，我们单机测试数据，最高也是可以达到单实例300w长连接。<br>但做更高的测试，我个人感觉意义不大。因为实际网络环境下，单实例300w长连接，从理论上算压力就很大：因为实际弱网络环境下，移动客户端的断线率很高，假设每秒有1000分之一的用户断线重连。300w长连接，每秒新建连接达到3w，这同时连入的3w用户，要进行注册，加载离线存储等对内rpc调用，另外300w长连接的用户心跳需要维持,假设心跳300s一次，心跳包每秒需要1w tps。<br>单播和多播数据的转发，广播数据的转发，本身也要响应内部的rpc调用，300w长连接情况下，gc带来的压力，内部接口的响应延迟能否稳定保障。<br>这些集中在一个实例中，可用性是一个挑战。所以线上单实例不会hold很高的长连接,实际情况也要根据接入客户端网络状况来决定。</p><h3 id="2，消息系统的内存使用量指标"><a href="#2，消息系统的内存使用量指标" class="headerlink" title="2，消息系统的内存使用量指标"></a>2，消息系统的内存使用量指标</h3><p>这一点上，使用go语言情况下，由于协程的原因，会有一部分额外开销。但是要做两个推送系统的对比，也有些需要确定问题。<br>比如系统从设计上是否需要全双工（即读写是否需要同时进行）如果半双工，理论上对一个用户的连接只需要使用一个协程即可（这种情况下，对用户的断线检测可能会有延时），如果是全双工，那读/写各一个协程。两种场景内存开销是有区别的.</p><p>另外测试数据的大小往往决定我们对连接上设置的读写buffer是多大，是全局复用的，还是每个连接上独享的，还是动态申请的。另外是否全双工也决定buffer怎么开. 不同的策略，可能在不同情况的测试中表现不一样。</p><h3 id="3，每秒消息下发量"><a href="#3，每秒消息下发量" class="headerlink" title="3，每秒消息下发量"></a>3，每秒消息下发量</h3><p>这一点上，也要看我们对消息到达的QoS级别(回复ack策略区别），另外架构策略，每种策略有其更适用的场景，是纯粹推，还是推拉结合。甚至是否开启了消息日志，日志库的实现机制，缓冲开多大，flush策略,这些都影响整个系统的吞吐量。另外为了HA，增加了内部通信成本，为了避免一些小概率事件，提供闪断补偿策略，这些都要考虑进去。如果所有的都去掉，那就是比较基础库的性能了.</p><p>所以我只能给出大概数据，24核，64G的服务器上，在Qos为message at least，纯粹推的情况，消息体256B<del>1kB情况下，单个实例100w实际用户（200w+）协程，峰值可以达到2</del>5w的QPS…<br>内存可以稳定在25G左右，gc时间在200<del>800ms左右.（还有优化空间） 我们正常线上单实例用户控制在80w以内，单机最多两个实例</del><br>事实上，整个系统在推送的需求上，对高峰的输出不是提速，往往是进行限速，以防push系统瞬时的高吞吐量，转化成对接入方业务服务器的ddos攻击<br>所以对于性能上，我感觉大家可以放心使用，至少在我们这个量级上，经受过考验，go1.5到来后，确实有之前投资又增值了的感觉~<br>下面是对消息系统的大概介绍，之前一些同学可能在gopher china上可以看到分享，这里简单讲解下架构和各个组件功能，额外补充一些当时遗漏的信息：<br>架构图如下，所有的service都 written by golang.<br><img src="/content/images/2019/06/0b8323ed2b40742005a9a6b2010f85b.jpg" alt="0b8323ed2b40742005a9a6b2010f85b"></p><h2 id="几个大概重要组件介绍如下"><a href="#几个大概重要组件介绍如下" class="headerlink" title="几个大概重要组件介绍如下"></a>几个大概重要组件介绍如下</h2><h3 id="dispatcher-service"><a href="#dispatcher-service" class="headerlink" title="dispatcher service"></a>dispatcher service</h3><p>根据客户端请求信息，将应网络和区域的长连接服务器的，一组IP传送给客户端。客户端根据返回的IP，建立长连接，连接Room service.</p><h3 id="room-Service"><a href="#room-Service" class="headerlink" title="room Service"></a>room Service</h3><p>长连接网关，hold用户连接，并将用户注册进register service，本身也做一些接入安全策略、白名单、IP限制等</p><h3 id="coordinator-service"><a href="#coordinator-service" class="headerlink" title="coordinator service"></a>coordinator service</h3><p>用来转发用户的上行数据，包括接入方订阅的用户状态信息的回调，另外做需要协调各个组件的异步操作，比如kick用户操作,需要从register拿出其他用户做异步操作.</p><h3 id="saver-service"><a href="#saver-service" class="headerlink" title="saver service"></a>saver service</h3><p>是存储访问层，承担了对redis和mysql的操作，另外也提供部分业务逻辑相关的内存缓存，比如广播信息的加载可以在saver中进行缓存。另外一些策略，比如客户端sdk由于被恶意或者意外修改，每次加载了消息，不回复ack，那服务端就不会删除消息，消息就会被反复加载，形成死循环，可以通过在saver中做策略和判断。（客户端总是不可信的）</p><h3 id="center-service"><a href="#center-service" class="headerlink" title="center service"></a>center service</h3><p>提供给接入方的内部api服务器，比如单播或者广播接口，状态查询接口等一系列api,包括运维和管理的api.</p><h3 id="举两个常见例子，了解工作机制："><a href="#举两个常见例子，了解工作机制：" class="headerlink" title="举两个常见例子，了解工作机制："></a>举两个常见例子，了解工作机制：</h3><p>比如发一条单播给一个用户，center先请求Register获取这个用户之前注册的连接通道标识、room实例地址，通过room service下发给长连接。<br>Center Service比较重的工作如全网广播，需要把所有的任务分解成一系列的子任务，分发给所有center，然后在所有的子任务里，分别获取在线和离线的所有用户，再批量推到Room Service。通常整个集群在那一瞬间压力很大。<br>deployd/agent service 用于部署管理各个进程，收集各组件的状态和信息,zookeeper和keeper用于整个系统的配置文件管理和简单调度</p><h2 id="关于推送的服务端架构"><a href="#关于推送的服务端架构" class="headerlink" title="关于推送的服务端架构"></a>关于推送的服务端架构</h2><p>常见的推送模型有长轮训拉取，服务端直接推送（360消息系统目前主要是这种），推拉结合（推送只发通知，推送后根据通知去拉取消息）.<br>拉取的方式不说了，现在并不常用了，早期很多是nginx+lua+redis，长轮训，主要问题是开销比较大，时效性也不好, 能做的优化策略不多。<br>直接推送的系统，目前就是360消息系统这种，消息类型是消耗型的，并且对于同一个用户并不允许重复消耗,如果需要多终端重复消耗，需要抽象成不同用户。<br>推的好处是实时性好，开销小，直接将消息下发给客户端，不需要客户端走从接入层到存储层主动拉取.<br>但纯推送模型，有个很大问题，由于系统是异步的，他的时序性无法精确保证。这对于push需求来说是够用的，但如果复用推送系统做im类型通信，可能并不合适。</p><h2 id="这里还有一个常见话题，哪些因素决定推送系统的效果？"><a href="#这里还有一个常见话题，哪些因素决定推送系统的效果？" class="headerlink" title="这里还有一个常见话题，哪些因素决定推送系统的效果？"></a>这里还有一个常见话题，哪些因素决定推送系统的效果？</h2><h3 id="首先是sdk的完善程度"><a href="#首先是sdk的完善程度" class="headerlink" title="首先是sdk的完善程度"></a>首先是sdk的完善程度</h3><p>sdk策略和细节完善度，往往决定了弱网络环境下最终推送质量.</p><p>1.SDK选路策略,最基本的一些策略如下：<br>有些开源服务可能会针对用户hash一个该接入区域的固定ip，实际上在国内环境下不可行，最好分配器（dispatcher）是返回散列的一组，而且端口也要参开，必要时候，客户端告知是retry多组都连不上，返回不同idc的服务器。因为我们会经常检测到一些case，同一地区的不同用户，可能对同一idc内的不同ip连通性都不一样，也出现过同一ip不同端口连通性不同，所以用户的选路策略一定要灵活，策略要足够完善.<br>另外在选路过程中，客户端要对不同网络情况下的长连接ip做缓存，当网络环境切换时候(wifi 2G,3G)，重新请求分配器，缓存不同网络环境的长连接ip.</p><p>2.客户端对于数据心跳和读写超时设置,完善断线检测重连机制<br>针对不同网络环境，或者客户端本身消息的活跃程度，心跳要自适应的进行调整并与服务端协商，来保证链路的连通性。并且在弱网络环境下，除了网络切换（wifi切3G）或者读写出错情况，什么时候重新建立链路也是一个问题。客户端发出的ping包，不同网络下，多久没有得到响应，认为网络出现问题，重新建立链路需要有个权衡。另外对于不同网络环境下，读取不同的消息长度，也要有不同的容忍时间，不能一刀切。好的心跳和读写超时设置，可以让客户端最快的检测到网络问题，重新建立链路，同时在网络抖动情况下也能完成大数据传输。</p><p>3.结合服务端做策略<br>另外系统可能结合服务端做一些特殊的策略，比如我们在选路时候，我们会将同一个用户尽量映射到同一个room service实例上。断线时，客户端尽量对上次连接成功的地址进行重试。主要是方便服务端做闪断情况下策略，会暂存用户闪断时实例上的信息，重新连入的时候，做单实例内的迁移，减少延时与加载开销.</p><p>4.客户端保活策略<br>很多创业公司愿意重新搭建一套push系统，确实不难实现，其实在协议完备情况下（最简单就是客户端不回ack不清数据），服务端会保证消息是不丢的。但问题是为什么在消息有效期内,到达率上不去？<br>往往因为自己app的push service存活能力不高。选用云平台或者大厂的，往往sdk会做一些保活策略，比如和其他app共生，互相唤醒，这也是云平台的push service更有保障原因~ 我相信很多云平台旗下的sdk，多个使用同样sdk的app，为了实现服务存活，是可以互相唤醒和保证活跃的~ 另外现在push sdk本身是单连接，多app复用的，这为sdk实现，增加了新的挑战~</p><p>综上，对我来说，选择推送平台，优先会考虑客户端sdk的完善程度~ 对于服务端，选择条件稍微简单，要求部署接入点（IDC）越要多，配合精细的选路策略，效果越有保证，至于想知道哪些云服务有多少点，这个群里来自各地的小伙伴们，可以合伙测测~</p><p>这个系统在开发过程中遇到挑战和优化策略，给大家看下当年的一张图，在第一版优化方案上线前一天截图~</p><p>可以看到，内存最高占用69G，GC时间单实例最高时候高达3<del>6s.这种情况下，试想一次悲剧的请求，经过了几个正在执行gc的组件，后果必然是超时… gc照成的接入方重试，又加重了系统的负担。遇到这种情况当时整个系统最差情况每隔2，3天就需要重启一次</del></p><p><img src="/content/images/2019/06/2b01512149c092fa9edf1e4023d7ed0.jpg" alt="2b01512149c092fa9edf1e4023d7ed0"></p><p>当时出现问题，现在总结起来，大概以下几点</p><p>1.散落在协程里的I/O，Buffer和对象不复用。<br>当时由于对go的gc效率理解有限，比较奔放，程序里大量short live的协程，对内通信的很多io操作，由于不想阻塞主循环逻辑或者需要及时响应的逻辑，通过单独go协程来实现异步。这回会gc带来很多负担。</p><p>针对这个问题，应尽量控制协程创建，对于长连接这种应用，本身已经有几百万并发协程情况下，很多情况没必要在各个并发协程内部做异步io，因为程序的并行度是有限，理论上做协程内做阻塞操作是没问题。<br>如果有些需要异步执行，比如如果不异步执行，影响对用户心跳或者等待response无法响应，最好通过一个任务池，和一组常驻协程，来消耗，处理结果，通过channel再传回调用方. 使用任务池还有额外的好处，可以对请求进行打包处理，提高吞吐量，并且可以加入控量策略.</p><p>2.网络环境不好引起激增<br>go协程相比较以往高并发程序，如果做不好流控，会引起协程数量激增。早期的时候也会发现，时不时有部分主机内存会远远大于其他服务器，但发现时候，所有主要profiling参数都正常了。<br>后来发现，通信较多系统中，网络抖动阻塞是不可免的(即使是内网)，对外不停accept接受新请求，但执行过程中，由于对内通信阻塞，大量协程被创建，业务协程等待通信结果没有释放，往往瞬时会迎来协程暴涨. 但这些内存在系统稳定后，virt和res都并没能彻底释放，下降后，维持高位。<br>处理这种情况，需要增加一些流控策略，流控策略可以选择在rpc库来做，或者上面说的任务池来做，其实我感觉放在任务池里做更合理些，毕竟rpc通信库可以做读写数据的限流，但它并不清楚具体的限流策略，到底是重试还是日志还是缓存到指定队列。任务池本身就是业务逻辑相关的，它清楚针对不同的接口需要的流控限制策略。</p><p>3.低效和开销大的rpc框架<br>早期rpc通信框架比较简单，对内通信时候使用的也是短连接。这本来短连接开销和性能瓶颈超出我们预期，短连接io效率是低一些，但端口资源够，本身吞吐可以满足需要，用是没问题的，很多分层的系统，也有http短连接对内进行请求的。但早期go版本，这样写程序，在一定量级情况，是支撑不住的。短连接大量临时对象和临时buffer创建，在本已经百万协程的程序中，是无法承受的。所以后续我们对我们的rpc框架作了两次调整。</p><p>第二版的rpc框架，使用了连接池，通过长连接对内进行通信（复用的资源包括client和server的：编解码Buffer、Request/response），大大改善了性能。</p><p>但这种在一次request和response还是占用连接的，如果网络状况ok情况下，这不是问题，足够满足需要了，但试想一个room实例要与后面的数百个的register，coordinator，saver，center，keeper实例进行通信，需要建立大量的常驻连接，每个目标机几十个连接，也有数千个连接被占用。</p><p>非持续抖动时候（持续逗开多少无解），或者有延迟较高的请求时候，如果针对目标ip连接开少了，会有瞬时大量请求阻塞，连接无法得到充分利用。第三版增加了Pipeline操作，Pipeline会带来一些额外的开销，利用tcp的全双特性，以尽量少的连接完成对各个服务集群的rpc调用。</p><p>4.GC时间过长<br>Go的Gc仍旧在持续改善中，大量对象和buffer创建，仍旧会给gc带来很大负担，尤其一个占用了25G左右的程序。之前go team的大咖邮件也告知我们，未来会让使用协程的成本更低，理论上不需要在应用层做更多的策略来缓解gc. （目前最新版本，Go 的 GC 已经有了很大的改进）</p><p>改善方式，一种是多实例的拆分，如果公司没有端口限制，可以很快部署大量实例，减少gc时长，最直接方法。不过对于360来说，外网通常只能使用80和433。因此常规上只能开启两个实例。当然很多人给我建议能否使用SO_REUSEPORT，不过我们内核版本确实比较低，并没有实践过。另外能否模仿nginx，fork多个进程监控同样端口，至少我们目前没有这样做，主要对于我们目前进程管理上，还是独立的运行的，对外监听不同端口程序，还有配套的内部通信和管理端口，实例管理和升级上要做调整。</p><p>解决gc的另两个手段，是内存池和对象池,不过最好做仔细评估和测试，内存池、对象池使用，也需要对于代码可读性与整体效率进行权衡。<br>这种程序一定情况下会降低并行度，因为用池内资源一定要加互斥锁或者原子操作做CAS，通常原子操作实测要更快一些。CAS可以理解为可操作的更细行为粒度的锁（可以做更多CAS策略，放弃运行，防止忙等）。这种方式带来的问题是，程序的可读性会越来越像C语言，每次要malloc，各地方用完后要free，对于对象池free之前要reset，我曾经在应用层尝试做了一个分层次结构的“无锁队列”</p><p>上图左边的数组实际上是一个列表，这个列表按大小将内存分块，然后使用atomic操作进行CAS。但实际要看测试数据了，池技术可以明显减少临时对象和内存的申请和释放，gc时间会减少，但加锁带来的并行度的降低，是否能给一段时间内的整体吞吐量带来提升，要做测试和权衡…</p><p><img src="/content/images/2019/06/d5fb44dcbb01cb30d4820ece2db74fb.jpg" alt="d5fb44dcbb01cb30d4820ece2db74fb"></p><p>在我们消息系统，实际上后续去除了部分这种黑科技，试想在百万个协程里面做自旋操作申请复用的buffer和对象，开销会很大，尤其在协程对线程多对多模型情况下，更依赖于golang本身调度策略，除非我对池增加更多的策略处理，减少忙等，感觉是在把runtime做的事情，在应用层非常不优雅的实现。普遍使用开销理论就大于收益。<br>但对于rpc库或者codec库，任务池内部，这些开定量协程，集中处理数据的区域，可以尝试改造~<br>对于有些固定对象复用，比如固定的心跳包什么的，可以考虑使用全局一些对象，进行复用，针对应用层数据，具体设计对象池，在部分环节去复用，可能比这种无差别的设计一个通用池更能进行效果评估.</p><h2 id="架构迭代和迭代经验"><a href="#架构迭代和迭代经验" class="headerlink" title="架构迭代和迭代经验"></a>架构迭代和迭代经验</h2><p>下面介绍消息系统的架构迭代和一些迭代经验，由于之前在其他地方有过分享，后面的会给出相关链接，下面实际做个简单介绍，感兴趣可以去链接里面看</p><h3 id="架构迭代"><a href="#架构迭代" class="headerlink" title="架构迭代"></a>架构迭代</h3><p>根据业务和集群的拆分，能解决部分灰度部署上线测试，减少点对点通信和广播通信不同产品的相互影响，针对特定的功能做独立的优化.<br>消息系统架构和集群拆分，最基本的是拆分多实例，其次是按照业务类型对资源占用情况分类，按用户接入网络和对idc布点要求分类（目前没有条件，所有的产品都部署到全部idc）</p><p><img src="/content/images/2019/06/3bd38ef89d953b4a38ee82d3883845a.jpg" alt="3bd38ef89d953b4a38ee82d3883845a"></p><h3 id="简要介绍下我们的运维系统"><a href="#简要介绍下我们的运维系统" class="headerlink" title="简要介绍下我们的运维系统"></a>简要介绍下我们的运维系统</h3><p>我们利用Go原生的profiling工具，做了些可视化工作。可以对比多次上线出现的问题，通过压测程序复现部分瓶颈。定位cpu或者内存消耗的瓶颈。</p><p><img src="/content/images/2019/06/9d20e7fc447c0934ede155cd7a1ca5f.jpg" alt="9d20e7fc447c0934ede155cd7a1ca5f"></p><p><img src="/content/images/2019/06/d582183dc3ccbbc15ae6203fcb08762.jpg" alt="d582183dc3ccbbc15ae6203fcb08762"></p><p>另外，我们也可以对基础库代码做内嵌，将RPC库，Redis库，内存池命中数据等，做可视化的展示，统计它的QPS、网络带宽占用、idle与working，各种出错情况。然后再通过各种压测手段，观察优化性能点，上线前后是否有影响。如果一个系统不可评估就无法优化，利用压测评估就会发现一些潜在的问题。</p><p><img src="/content/images/2019/06/fd90a02582647647c1631b71a570164.jpg" alt="fd90a02582647647c1631b71a570164"></p><h3 id="系统的测试"><a href="#系统的测试" class="headerlink" title="系统的测试"></a>系统的测试</h3><p>go语言在并发测试上有独特优势。<br>在功能测试上，系统分成两套，一套是我们针对自己的功能，自己设计并测试，但这样难免会有问题。另一套是公司的自动化测试部门（python实现的<del>）根据我们的功能来测试。双保险</del><br><img src="/content/images/2019/06/c1e3523ce678de3c2a5e0d763b6927a.jpg" alt="c1e3523ce678de3c2a5e0d763b6927a"></p><p>对于压力测试，目前主要针对指定的服务器，选定线上空闲的服务器做长连接压测。然后结合可视化，分析压测过程中的系统状态。但压测早期用的比较多，但实现的统计报表功能和我理想有一定差距。理论上压测完后，可以根据协议版本，汇总每一次压测进程详细数据，业务的QPS数量、每秒钟建立连接数量，极限状态下的cpu和内存消耗，等每一个考核细节。现在只是能看一个大概趋势.对于细微的性能提升，没法评估，我们后续准备结合自己写的中央管理组件keeper，做这个数据收集和展示~</p><p>对于go语言适用的场景。之前在gopher china上，有过我个人的理解和概括：适用于重逻辑的io密集型应用.</p><p>我觉得最近出的golang开源产品都符合这种场景， go写网络并发程序给大家带来的便利，让大家把以往为了降低复杂度，拆解或者分层协作的组件，又组合在了一起。</p><p>比如go的web框架是在做负责并发的webserver和负责业务处理cgi程序，放在了webserver中。新近的一些go写的“智能”代理或者中间件，把很多原先分层控制或者不同功能但类似的子系统，以各种形式组装起来，reborn一个新的中间件或者新产品<del>包括之前百度放出的go-bfe也是把重逻辑和io密集型很好结合的产物</del>（群里有bfe的同学么，求更多资料）</p><p>个人感觉在国内互联网创业公司爆发环境下，大厂的复杂设备，很多将被golang重新打包成适用在一定量级下的“全能”工具箱~<br>以上就是今天的go分享~ 谢谢大家，欢迎提问~</p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>架构设计和概要（ 1小时的分享 文字总结）<br><a href="http://blog.qiniu.com/archives/3720" target="_blank" rel="noopener">http://blog.qiniu.com/archives/3720</a><br>关于基础库实现和性能参数对比表格：<br><a href="http://blog.golang.org/qihoo" target="_blank" rel="noopener">http://blog.golang.org/qihoo</a></p><h2 id="提问环节"><a href="#提问环节" class="headerlink" title="提问环节"></a>提问环节</h2><p>提问：对比kafaka这些消息系统 有什么优点？<br>回答：我们是消息推送系统 指的对客户端的高并发推送的 面对场景不一样</p><p>提问：hadoop生态圈的大数据，算重逻辑和IO密集型应用不？<br>回答：不算 Hadoop主要是计算</p><p>提问：这种推送的方式如何保证消息是有序到达的？<br>回答：如果要保证有序 需要重新设计协议 对消息编号 先存储 后拉取 可以按人存储也可以按订阅关系 目前花椒的im系统 属于这种场景 有机会大家感兴趣可以分享升级版本聊天架构</p><p>提问：golang适不适合写web应用<br>回答：这个可以单独一讲回答 我的建议新的应用 大并发的场景可以考虑 老项目酌情改写替换</p><p>提问：推送的消息会有多级转发吗？还是说客户端直接跟一个server保持长链接就完事了？<br>回答：当流量大到一定程度 可以多级转发 类似cdn架构 目前花椒直播的推送系统支持这种场景 为idc流量做分级转发 普通场景不需要</p><p>提问：极光推送跟这种推送的应用场景就是差不多吧？<br>回答：方案都类似 协议复杂度会不同 比如为了保证一致性采取编号 先存储后发送</p><p>提问：多级之间也是长链接吧<br>回答：多级别只是rpc调用 rpc通常keepalive</p><p>提问：推送系统目前支持什么协议呢？ mqtt？web socket？<br>回答：分传输层和协议层 传输层web socket 没问题 mqtt是一个具体交互协议了 不具备通用可比性</p><p>提问：推送系统里面有用到epoll吗？有没有开源地址？<br>回答：用的golang； go原生就是对epoll封装…目前不开源 安全公司理解下</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>直播学习</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>学习</tag>
        <tag>技术</tag>
        <tag>消息推送</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-1-Two Sum | 两数之和</title>
    <url>/2019/06/09/Leetcode-1-Two-Sum/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">two-sum</a></p><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = [<span class="number">2</span>]<span class="keyword">int</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="built_in">len</span>(nums) - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;  </span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                result[<span class="number">0</span>] = i</span><br><span class="line">                result[<span class="number">1</span>] = j</span><br><span class="line">                <span class="keyword">return</span> result[:]  <span class="comment">//返回结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; numsSize;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; numsSize;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] == target - nums[i])&#123;</span><br><span class="line">                a[<span class="number">0</span>] = i;</span><br><span class="line">                a[<span class="number">1</span>] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>端午安康以及我的高考</title>
    <url>/2019/06/08/duan-wu-and-my-gao-kao/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><p>昨天是中国的传统节日端午节，也是2019年高考的第一天。</p><p>她在端午节前一天下午来到了成都，我们相遇了，是的，相隔三千公里远外长达十个月的异地恋，终于宣告结束了。</p><p>端午节这一天，我们把房子整体收拾了一下，该扔的扔，该买的买，中午吃的冒菜，晚上买了鸭肉，虾尾，酸奶和啤酒庆祝。</p><p>今天是高考第一天，想起2014年我参加高考时，第一场语文作文后半段写的有些急，字都飞了起来；第二场数学填空选择做的很好，后面大题做的糟糕；第三场英语作文写的还可以；第四场理综一般般。后来回学校估分觉得应该能上个一本。</p><p>后来高考成绩公布，与我估分的偏差有些大，但还是能上个二本，然而我不甘心，思考着是复读还是去上大学。后来决定还是去上大学，因为我厌恶了高考那压抑的生活。</p><p>上了大学，遇见了各种各样的人，以及琳琅满目的社团和学生会。在每一次把酒言欢的夜晚，我独自坐在桌前，思考着我未来要走的路。当时的我很长一段时间都在自责与后悔中度过，放佛人生已成定数。</p><p>直到大二下学期，开始尝试打开窗户看外面的世界，开阔新视野的同时让我对自己的遭遇和学校看淡了些。大学毕业后，从事研发，专注于提升实力，前几天还意外被Go语言中文站长拉入了一个Go语言实践和布道者的群，里面的人大部分都是公司内的专家了，我有些激动，因为我从没有想过，我会离大佬们如此接近。未来的路，我想我会更坚定的走下去，因为这是一次他们对我的认可。</p><p>回忆了这么多，其实我想告诉正在准备高考的你，也是告诉那个曾经对未来惶恐不安的自己。人生就像一个长跑，也像一条正弦曲线，刚开始为0，然后你的事业会经历高峰和低谷，到高峰不要骄傲，到低谷不要气馁。</p><p>高考只是一道小山坡，未来的变数还有很多。</p><p>面带微笑，温暖前行。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>感悟</tag>
        <tag>端午</tag>
        <tag>高考</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu设置root账号登录</title>
    <url>/2019/06/04/ubuntu-set-up-root-login/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="这样做的原因"><a href="#这样做的原因" class="headerlink" title="这样做的原因"></a>这样做的原因</h2><p>如果你是用<code>root</code>权限去启动一个服务，而这个服务正在跑时，我又在根据它反馈的信息，对代码做调整，比如打日志，而修改完源代码后，你是无法保存文件的，原因是你用<code>root</code>执行它，而就应该用<code>root</code>权限去修改它，否则你的编辑是无效的，<code>push</code>上去的代码还是原来的。</p><h2 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h2><ul><li><p>使用<code>chown</code>命令修改文件或文件夹的拥有者，具体如下</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chown -R 用户名 文件夹名或文件名</span><br></pre></td></tr></table></figure></li><li><p>使用<code>chmod</code>命令直接开放代码所在目录的所有权限</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chmod -R 777 代码目录</span><br></pre></td></tr></table></figure></li><li><p>设置<code>root</code>账号登录。<br>不过一般<code>root</code>严格只用来管理服务器，只有少数人有该权限，所以在公司内不一定所有人都会有开启<code>root</code>的权限。<br>(在此感谢知识星球Go项目实战里的<code>Hy、per</code>提供的建议)</p></li></ul><h2 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h2><p>1，设置<code>root</code>用户密码</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure><p>（注意：以下步骤必须在<code>root</code>权限下操作）<br>2，修改<code>/root/.profile</code>文件<br>用<code>vim</code>打开该文件内容</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ~/.profile: executed by Bourne-compatible login shells.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$BASH</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [ -f ~/.bashrc ]; <span class="keyword">then</span></span><br><span class="line">    . ~/.bashrc</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">mesg n || <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>将最后一句<code>mesg n || true</code>修改为<code>tty -s&amp;&amp;mesg n || true</code></p><p>2，修改<code>/usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf</code>文件<br>在文件中添加以下内容</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#手动输入登录系统的用户名和密码</span></span><br><span class="line">greeter-show-manual-login=<span class="literal">true</span></span><br><span class="line"><span class="comment">#不允许guest登录</span></span><br><span class="line">all-guest=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>3，修改<code>/etc/pam.d/gdm-autologin</code>文件<br>注释掉</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#auth   required        pam_succeed_if.so user != root quiet_success</span></span><br></pre></td></tr></table></figure><p>4，修改<code>/etc/pam.d/gdm-password</code>文件<br>注释掉</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#auth   required        pam_succeed_if.so user != root quiet_success</span></span><br></pre></td></tr></table></figure><p>5，重新启动<code>ubuntu</code>系统，输入<code>root</code>名和密码登录即可。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>用<code>root</code>账户登录相当于给你重新创建一个新的桌面，所以个人建议是重装系统后就立马设置以<code>root</code>账户登录最佳。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>root</tag>
        <tag>登录</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang并发中的FanIn范式学习</title>
    <url>/2019/06/02/learn-to-golang-fanin/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><p>在学习并发时，对<code>Fanin</code>和<code>Fanout</code>这两个范式印象深刻，特此记录一下学习心得。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>扇出（Fan-out）是一个术语，用于描述启动多个goroutines以处理来自管道的输入的过程，并且扇入（fan-in）是描述将多个结果组合到一个通道中的过程的术语。</p><p>画个图</p><p><img src="/2019/06/02/learn-to-golang-fanin/fanin_o.png" alt="fanin"></p><p><img src="/2019/06/02/learn-to-golang-fanin/fanout_o.png" alt="fanout"></p><p>这样做有什么好处呢，下面来看看源码。</p><h2 id="源码学习"><a href="#源码学习" class="headerlink" title="源码学习"></a>源码学习</h2><p>在<code>concurrent_map.go</code>文件中</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Iter returns an iterator which could be used in a for range loop.</span></span><br><span class="line"><span class="comment">// Deprecated: using IterBuffered() will get a better performence</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m ConcurrentMap)</span> <span class="title">Iter</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">Tuple</span></span> &#123;</span><br><span class="line">	chans := snapshot(m)</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Tuple)</span><br><span class="line">	<span class="keyword">go</span> fanIn(chans, ch)</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanIn</span><span class="params">(chans []<span class="keyword">chan</span> Tuple, out <span class="keyword">chan</span> Tuple)</span></span> &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(<span class="built_in">len</span>(chans))  <span class="comment">//总共要进入的管道数目</span></span><br><span class="line">	<span class="keyword">for</span> _, ch := <span class="keyword">range</span> chans &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span> Tuple)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> t := <span class="keyword">range</span> ch &#123;  <span class="comment">//取出每一个管道内的数据</span></span><br><span class="line">				out &lt;- t  <span class="comment">//将数据发送给管道接收者out</span></span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()  <span class="comment">//每取完一次管道内的数据，管道数目减1</span></span><br><span class="line">		&#125;(ch)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="built_in">close</span>(out)  <span class="comment">//管道内的数据已经取完，关闭管道接收者out</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画图演示下过程<br><img src="/2019/06/02/learn-to-golang-fanin/chan_o.png" alt="chan"></p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul><li><code>sync.WaitGroup</code><br>sync.WaitGroup只有3个方法，Add()，Done()，Wait()。其中Done()是Add(-1)的别名。简单的来说，使用Add()添加计数，Done()减掉一个计数，计数不为0, 阻塞Wait()的运行。<br>因此当计数为0时，也就是要进入的管道数都没有的时候，关闭管道。</li></ul><h2 id="FanIn范式的用途"><a href="#FanIn范式的用途" class="headerlink" title="FanIn范式的用途"></a>FanIn范式的用途</h2><p>在此引用我看到的一段话</p><blockquote><p>管道的一个有趣属性是它的各个阶段相互独立，方便组合。你可以多次重复使用管道的各个阶段。因此，在多个goroutine上重用管道的单个阶段实现并行化，将有助于提高管道的性能。<br>事实上，这种模式被称为扇入扇出。<br>那么在什么情况下适用于这种模式呢？如果出现以下两种情况，你就可以考虑这么干了：<br>不依赖模块之前的计算结果。<br>运行需要很长时间。</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.kancloud.cn/mutouzhang/go/596844" target="_blank" rel="noopener">扇入扇出_Concurrency in Go 中文笔记</a></li><li><a href="https://austburn.me/blog/a-better-fan-in-fan-out-example.html" target="_blank" rel="noopener">Go: A Better Fan-out, Fan-in Example</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>解决方案</tag>
        <tag>并发</tag>
        <tag>范式</tag>
        <tag>FanIn</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次项目演示前赶deadline的经历</title>
    <url>/2019/05/31/a-project-deadline-note/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>给新疆广电做的流媒体收录系统，原定于六月二十日研发完毕，无奈要提前演示，定到了五月底。所以我负责的地方需要抓紧进度。<br>同时下周一要做芒果TV的演示，我这里负责的模块网络端没有跑通。</p><h2 id="紧张"><a href="#紧张" class="headerlink" title="紧张"></a>紧张</h2><p>由于我之前在根据芒果TV的需求修改我负责的流媒体服务，改动较大（确切地说我已经改晕了），已经把最原始的功能都已经无法复现了，导致新疆广电的需求也无法完成。我在想，我该怎么办？</p><h2 id="转机"><a href="#转机" class="headerlink" title="转机"></a>转机</h2><p>在我即将感到绝望的一刻，产品负责人把部门的两位大佬打电话叫来，他看了下我的代码，改删的删，改增的增，在本地跑通后，放到测试环境上跑了一下，看了下日志，修改了几处异常，测试环境就跑通了，新疆广电的演示算是完成了。<br>而芒果TV的需求，涉及把业务流程搞懂再添加业务判断逻辑，和数据的封装和请求的发送，而我的问题就在于不知道这段逻辑代码放在哪里。不过还好最后有老哥带我一步步跟代码，最终把代码放到了正确的位置，测试也跑通了。</p><h2 id="经验教训和感受"><a href="#经验教训和感受" class="headerlink" title="经验教训和感受"></a>经验教训和感受</h2><ul><li>用<code>Go</code>写一个服务，应当首先用<code>curl</code>命令在本地跑通，接着写一个<code>Test</code>测试函数针对核心逻辑就行测试和修改，如果需要依赖其他服务，要么把需要的服务也部署起来，或者用<code>Nginx</code>去模拟<code>Mock</code>它（这个我还不会）。</li><li>越紧急的事情，一定要放宽心，深呼吸两次，不然很容易犯低级错误，比如该打日志的地方没有打，或者数据库查询语句写错，或者是变量名的格式没有写对，或者是<code>curl</code>命令请求时忘记在每一个出现<code>&quot;</code>加<code>\</code>（<code>curl</code>命令请求发<code>json</code>时的格式）。而这些细微的出错，最终都将导致自己，或者陪同的其他研发人员，甚至测试人员白忙活一阵。</li><li>一定要对服务器业务逻辑熟悉，一定要经常打断点去跟代码。</li><li>遇到<code>Panic</code>空指针报错，一定是一些值没有初始化造成的，而我是犯了一个低级错误：没有<code>error</code>，自己在日志中打了个<code>error.Error()</code>导致的，为此我付出了代价，全局搜索了<code>error.Error()</code>字段，把有问题的语句全部改了。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是错误的，一定要注意，直接会抛异常</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(xxx) == <span class="number">0</span> &#123;</span><br><span class="line">    Log.Error(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>遇到想不通的问题，多在存在疑惑的代码片段周围打满日志。</li><li>遇到的每一个<code>bug</code>，详细记录错误发生的原因，以及找到错误解决的方式，还有解决过程，记录完后要及时回看。</li><li>熟练使用<code>git</code>指令，不只满足于<code>add commit push</code>三步，还应该涉及合并，<code>cherry-pick</code>等比较危险的指令，这有益于减少管理代码和发版时瞎忙活的概率。</li><li>相比于研发，测试运维这些人在体力上都比较辛苦，所以建议能自己解决的就少给他们增添麻烦。也许是我看到他们一个电脑开着十几台虚拟机，远程连接里套着远程连接再套着远程连接，周围做前后端和产品都围着他时，才有的感触吧。</li></ul><p>问题警报解除后，同事问我，有没有是在给家乡做贡献的感觉。我说，有那么一点。但我心里更多的是对他们的感激与深深的惭愧，交代给我负责的项目，没有完成，同时也暴露了我的诸多开发上的问题。这些坑，我需要尽快填上。</p><p>希望项目演示一切顺利！</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>成长</tag>
        <tag>演示</tag>
        <tag>感悟</tag>
        <tag>收获</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang中的CPU占满100%及解决方案</title>
    <url>/2019/05/26/golang-cpu-100-solution/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><p>有一个流媒体适配服务，出现了<code>CPU</code>开销很大的问题，一个服务把<code>CPU</code>资源占满了，导致其他服务无法正常工作。<br>下面来详细记录发现<code>bug</code>和解决的流程。</p><h1 id="发现CPU开销很大"><a href="#发现CPU开销很大" class="headerlink" title="发现CPU开销很大"></a>发现CPU开销很大</h1><p>扫描发现，是垃圾回收导致 <code>CPU</code> 使用上升 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time: Mar 22, 2019 at 5:52pm (CST)</span><br><span class="line">Duration: 1mins, Total samples = 1.43mins (142.57%)</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof) tree </span><br><span class="line">Showing nodes accounting for 83.13s, 97.11% of 85.60s total</span><br><span class="line">Dropped 256 nodes (cum &lt;= 0.43s)</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">      flat  flat%   sum%        cum   cum%   calls calls% + context 	 	 </span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">                                            71.36s 99.86% |   runtime.gcDrain</span><br><span class="line">                                             0.10s  0.14% |   runtime.systemstack</span><br><span class="line">    48.56s 56.73% 56.73%     71.46s 83.48%                | runtime.scanobject</span><br><span class="line">                                            11.86s 16.60% |   runtime.heapBitsForObject</span><br><span class="line">                                            11.04s 15.45% |   runtime.greyobject</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">                                            11.86s 99.92% |   runtime.scanobject</span><br><span class="line">    11.87s 13.87% 70.60%     11.87s 13.87%                | runtime.heapBitsForObject</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">                                            11.04s   100% |   runtime.scanobject</span><br><span class="line">    11.02s 12.87% 83.47%     11.04s 12.90%                | runtime.greyobject</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">                                             6.53s 95.05% |   runtime.gosweepone.func1</span><br><span class="line">                                             0.34s  4.95% |   runtime.(*mheap).alloc</span><br><span class="line">     4.34s  5.07% 88.54%      6.87s  8.03%                | runtime.sweepone</span><br><span class="line">                                             2.53s 36.83% |   runtime.(*mspan).sweep</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">                                            74.42s   100% |   runtime.gcBgMarkWorker.func2</span><br><span class="line">     1.97s  2.30% 90.84%     74.42s 86.94%                | runtime.gcDrain</span><br><span class="line">                                            71.36s 95.89% |   runtime.scanobject</span><br><span class="line">                                             0.52s   0.7% |   runtime.pollWork</span><br><span class="line">----------------------------------------------------------+-------------</span><br></pre></td></tr></table></figure><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>之后考虑使用 <code>buffer pool</code>,</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 这里不再分配新的内存，而是从 buffer pool 里面 GET </span></span><br><span class="line">databuf = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">100000</span>)</span><br></pre></td></tr></table></figure><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>参考<a href="https://github.com/libp2p/go-buffer-pool" target="_blank" rel="noopener">go buffer pool</a></p><ul><li><p>先创建一个<code>buffer pool</code></p></li><li><p>在<code>Get</code>它</p></li><li><p>用完再<code>Put</code>回去</p></li><li><p>注意，最好在<code>Get</code>和<code>Put</code>时加锁。</p></li></ul><h1 id="是什么原因导致了CPU开销很大（重点）"><a href="#是什么原因导致了CPU开销很大（重点）" class="headerlink" title="是什么原因导致了CPU开销很大（重点）"></a>是什么原因导致了CPU开销很大（重点）</h1><p>当我们新建了一个有长度变量时，例如100<code>byte</code>的数组，那么它在操作系统内存中是这样展现的</p><p><img src="/2019/05/26/golang-cpu-100-solution/memory.png" alt></p><p>因此，当我们新建一个变量时，操作系统会在自己的运行内存里开辟一块内存给这个变量存数据用。当我们不需要这个数据时，或者说要删除这个变量时，<code>Golang</code>会执行垃圾回收机制。</p><p>然而当<code>Golang</code>在执行垃圾回收时，操作系统会不断对这些有或者没有被引用的变量进行扫描，这中间涉及操作系统的算法，我们不用深究，但是，在执行这种算法时，会占用<code>CPU</code>的资源，如果新开辟的变量和内存过多，就会导致系统不停的检查是否有不需要引用的变量了，从而造成占用<code>CPU</code>资源过多。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>创建一个<code>buffer pool</code></p><p>创建一个大的<code>buffer pool</code>，你需要内存时，向<code>buffer pool</code>获取一下<code>Get</code>，用完不需要时再还回去<code>Put</code>。</p><p><img src="/2019/05/26/golang-cpu-100-solution/bufferpool.png" alt></p><p>这样做的好处是，操作系统每次检查内存时，都只有一个<code>buffer pool</code>在引用，不增不减，于是也就减少<code>CPU</code>资源的消耗了。</p><h2 id="打个比方"><a href="#打个比方" class="headerlink" title="打个比方"></a>打个比方</h2><p>比如说操作系统就是一个土豪，借东西再换回来不收利息。它有一个很大的内存，周围许多人都想找它去借(新声明的变量并初始化)，刚开始借的人只有十几个，后面有上万个，于是它要每天记录谁借了多少内存出去，谁还没有归还，归还的直接从记录上把名字划掉(垃圾回收)。后来操作系统烦了，于是就建了一个很大的内存池，够所有人分批次借，只要借完及时归还就行，而它每次去看这个内存池有没有变小即可，省了不少精力。</p><p>而这个内存池就是<code>go buffer pool</code>的作用。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>建议给<code>Get</code>和<code>Put</code>加锁，防止多个协程同时借阅，造成竞争冒险。<br>这个<code>CPU</code>占满问题涉及<code>Golang</code>的垃圾回收机制，这块是要点，一定要搞明白。</p><h1 id="参考文章和资源"><a href="#参考文章和资源" class="headerlink" title="参考文章和资源"></a>参考文章和资源</h1><ul><li><a href="https://github.com/libp2p/go-buffer-pool" target="_blank" rel="noopener">go buffer pool</a></li><li><a href="http://legendtkl.com/2017/04/28/golang-gc/" target="_blank" rel="noopener">Golang 垃圾回收剖析</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>解决问题记录</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>解决方案</tag>
        <tag>CPU占满</tag>
      </tags>
  </entry>
  <entry>
    <title>吊车尾</title>
    <url>/2019/05/23/in-the-end/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><p>这一周感觉过得好慢，也许是我太压抑了的缘故吧。</p><p>周一，让我做一个新需求，周二，又增加了一个新需求，让我抓紧时间，五月底要上线，然而我周二下午发现这个需求有问题，周三又讨论了一上午定下来要修改的部分。然而就在今天，又说这些不重要了，先把另外一个新需求做了。</p><p>好吧，我认了，毕竟是拿人钱财，替人干活。你说干嘛我干嘛。</p><p>然而，新需求是在老项目的一个逻辑上做的，而我对这块业务不熟悉，于是请教，接着受打击，这已经成为我工作的家常便饭了。</p><p>晚上回家，突然想看火影，看李使用八门遁甲开了五门虐我爱罗最终获得凯老师的认可，看鸣人中忍考试最终用实力证明给宁次看我不是吊车尾，看迈特凯开了死门虐拥有六道能力的斑。</p><p>他们都在坚持不懈的贯彻自己的忍道。</p><p>那我在编程上的忍道又是什么呢？</p><p>我喜欢钻研新东西，喜欢用自己的方式去创新，然而我现在经验不足，只能通过大佬的源代码窥探其中工程设计的奥妙。</p><p>我能力不足，但又不肯认输；我进步缓慢，原来，突然发现自己真的是一无是处，放佛成了部门的吊车尾。</p><p>今天我不知道在内心深处有多少次想过放弃，但我实在不甘心，不跨过这个坎，我怎么成长？！</p><p>只能在深夜再给自己打气，让自己挺住，毕竟，在那些大佬看来，这真的是一件微不足道的挫折罢了。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>挫折</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang中的内存泄露及解决方案</title>
    <url>/2019/05/14/Golang-memory-leak-solution/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><p>工作中记一次碰到内存泄漏的解决过程。</p><h1 id="发现内存泄露"><a href="#发现内存泄露" class="headerlink" title="发现内存泄露"></a>发现内存泄露</h1><p>写的一个定时删除文件的服务，结果无缘无故被系统杀死了。</p><p>于是我设置了参数，每隔30s启动一次。并用<code>dmesg</code>命令查看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1700172.849656] Out of memory: Kill process 1195 (SliceDyson) score 730 or sacrifice child</span><br><span class="line">[1700172.849665] Killed process 1195 (SliceDyson) total-vm:13314968kB, anon-rss:8693980kB, file-rss:116kB</span><br></pre></td></tr></table></figure><p>确定是内存泄露造成的。</p><h1 id="使用pprof分析造成内存泄露的原因"><a href="#使用pprof分析造成内存泄露的原因" class="headerlink" title="使用pprof分析造成内存泄露的原因"></a>使用pprof分析造成内存泄露的原因</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><p><a href="https://golang.org/pkg/runtime/pprof/" target="_blank" rel="noopener">golang pprof 的文档</a> 里面给了一个例子，如何把 <code>pprof</code> 信息输出到文件里面</p></li><li><p><a href="https://www.reddit.com/r/golang/comments/6kv625/my_app_has_memory_leaks_how_to_find_them/" target="_blank" rel="noopener">Reddit 上这篇文章</a>，提到了如何通过对比两次 <code>heap</code> 的结构，来判断到底哪些内存没有释放：</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">One thing you can do is to compare 2 heap pprofs. You can do it like this:</span><br><span class="line"></span><br><span class="line">    Extract a heap profile heap0.pprof</span><br><span class="line"></span><br><span class="line">    Add some load to the application</span><br><span class="line"></span><br><span class="line">    Extract another heap profile heap1.pprof</span><br><span class="line"></span><br><span class="line">    Compare them with go tool pprof -base heap0.pprof &lt;bin&gt; heap1.pprof</span><br><span class="line"></span><br><span class="line">This way you can see exactly what is increasing over time.</span><br></pre></td></tr></table></figure><ul><li><a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="noopener">https://blog.golang.org/profiling-go-programs</a></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>分析生成的<code>.pprof</code>文件</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go tool pprof 120.pprof </span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: Mar 6, 2019 at 9:27pm (CST)</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting for 603.20MB, 99.67% of 605.20MB total</span><br><span class="line">Dropped 1 node (cum &lt;= 3.03MB)</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">  603.20MB 99.67% 99.67%   605.20MB   100%  main.main</span><br><span class="line">         0     0% 99.67%   605.20MB   100%  runtime.main</span><br><span class="line">(pprof) ^C</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ go tool pprof 240.pprof </span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: Mar 6, 2019 at 11:42pm (CST)</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting for 2.81GB, 99.86% of 2.81GB total</span><br><span class="line">Dropped 6 nodes (cum &lt;= 0.01GB)</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    2.81GB 99.86% 99.86%     2.81GB   100%  main.main</span><br><span class="line">         0     0% 99.86%     2.81GB   100%  runtime.main</span><br></pre></td></tr></table></figure><ul><li>分析各个函数的占比情况</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">File: SliceDyson</span><br><span class="line">Type: inuse_objects</span><br><span class="line">Time: Mar 7, 2019 at 2:52pm (CST)</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof) web</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting for 6810, 100% of 6810 total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">      6554 96.24% 96.24%       6554 96.24%  main.GetXMLFiles</span><br><span class="line">       256  3.76%   100%        256  3.76%  vendor/golang_org/x/net/http2/hpack.addDecoderNode</span><br><span class="line">         0     0%   100%        256  3.76%  main.init</span><br><span class="line">         0     0%   100%       6554 96.24%  main.main</span><br><span class="line">         0     0%   100%        256  3.76%  net/http.init</span><br><span class="line">         0     0%   100%       6810   100%  runtime.main</span><br><span class="line">         0     0%   100%        256  3.76%  vendor/golang_org/x/net/http2/hpack.init</span><br><span class="line">         0     0%   100%        256  3.76%  vendor/golang_org/x/net/http2/hpack.init.0</span><br></pre></td></tr></table></figure><p>最后定位到造成内存泄露的原因，是<code>GetXMLFiles</code>函数造成的。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlFilesPath []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> LoopGetXmlFilesPath []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> AllTasks []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> tasks []*Task</span><br><span class="line"><span class="keyword">for</span> _, RootPath := <span class="keyword">range</span> ParseStorageINI(StorageINIPath) &#123;</span><br><span class="line">	xmlFilesPath = GetXMLFiles(RootPath)</span><br><span class="line">	<span class="keyword">for</span> _, xmlFilesPath_str := <span class="keyword">range</span> xmlFilesPath &#123;</span><br><span class="line">		LoopGetXmlFilesPath = <span class="built_in">append</span>(LoopGetXmlFilesPath, xmlFilesPath_str)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>把<code>xmlFilesPath</code>放到<code>for range</code>循环里面声明初始化即可</p><h1 id="是什么原因会导致内存泄露"><a href="#是什么原因会导致内存泄露" class="headerlink" title="是什么原因会导致内存泄露"></a>是什么原因会导致内存泄露</h1><h1 id="什么时候需要垃圾回收-GC"><a href="#什么时候需要垃圾回收-GC" class="headerlink" title="什么时候需要垃圾回收(GC)"></a>什么时候需要垃圾回收(GC)</h1><h1 id="参考文章和资源"><a href="#参考文章和资源" class="headerlink" title="参考文章和资源"></a>参考文章和资源</h1><ul><li><a href="https://stackoverflow.com/questions/48618201/how-to-release-memory-allocated-by-a-slice" target="_blank" rel="noopener">how-to-release-memory-allocated-by-a-slice</a></li><li><a href="https://stackoverflow.com/questions/37382600/cannot-free-memory-once-occupied-by-bytes-buffer" target="_blank" rel="noopener">cannot-free-memory-once-occupied-by-bytes-buffer</a></li><li><a href="http://legendtkl.com/2017/04/28/golang-gc/" target="_blank" rel="noopener">Golang垃圾回收剖析</a></li><li><a href="https://golang.org/pkg/runtime/pprof/" target="_blank" rel="noopener">pprof</a></li><li><a href="https://www.reddit.com/r/golang/comments/6kv625/my_app_has_memory_leaks_how_to_find_them/" target="_blank" rel="noopener">my_app_has_memory_leaks_how_to_find_them</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>解决问题记录</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>解决方案</tag>
        <tag>内存泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang踩坑集中整理</title>
    <url>/2019/05/14/golang-hit-pit-finish/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h1 id="append-x-1-与x-append-x-1-的区别"><a href="#append-x-1-与x-append-x-1-的区别" class="headerlink" title="append(x,1)与x = append(x,1)的区别"></a>append(x,1)与x = append(x,1)的区别</h1><p>今天有同事问我</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x,<span class="number">1</span>)</span><br><span class="line"><span class="comment">//append(x,1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//两者有什么区别</span></span><br></pre></td></tr></table></figure><p>我瞬间懵了，这不很明显吗？</p><p><code>x = append(x,1)</code>是在<code>x</code>的原先基础上增加了一个元素，所以<code>x</code>中元素为5，而<code>append(x,1)</code>没有赋返回值，所以会报错!</p><p>同事说，这不是重点，我是问你<code>append(x,1)</code>后<code>x</code>中的元素有几个。</p><p>于是，我想了下，同时也请教了他人，最终得出答案，<code>x</code>为4。</p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>append(x,1)之后相当于扩容，所以`append 的结果，底层会分配一个新的数组。</p><p>如果我不接收返回值，相当于还是append前，长度没变。<br>那么为什么要这样呢</p><p>此处引用polaris的解释</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">append 是 内置函数，必须要接收它的值。</span><br><span class="line">由此看来 go安全性做的确实好</span><br><span class="line">避免出现失误，没有将错误的append的结果保存</span><br></pre></td></tr></table></figure><p>因此</p><p>在<code>x := make([]int,4,4)</code>后，执行<code>x = append(x,1)</code>，长度为5；执行<code>append(x,1)</code>，长度为4.</p><p>注：可参考GO圣经中的Slice章节下的append用法介绍。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>再见乌鲁木齐，再见新疆</title>
    <url>/2019/05/11/goodbye-urumqi-goodbye-xinjiang/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><p><a href="./plane"></a></p><p>(本文有感于五一，完稿于母亲节)</p><p>5月6号晚，在乌鲁木齐的地窝堡国际机场，坐在飞机上，广播里说着飞机即将起飞，请关闭手机或调整为飞行模式，我知道，我又要和这座城市告别了。</p><p>父亲开车送我去机场的路上，在穿过蜘蛛山隧道时，落日的余晖洒向了这座城市，我看到了这里林立的高楼，和四通八达的街道，以及刚刚亮起来的路灯。</p><p>是的，这是我生活了二十二年的城市。</p><p>它完整的记录了我从孩童成长为工作者的心路历程。</p><p>就让我再穿越回过去，回忆这些转瞬即逝又弥足珍贵的记忆。</p><h1 id="与杨搭城堡"><a href="#与杨搭城堡" class="headerlink" title="与杨搭城堡"></a>与杨搭城堡</h1><p>时间：小学四年级。</p><p>地点：小巷子。</p><p>人物：童年玩伴杨</p><p>结束了一天在学校的学习，作业太少了，提前做完了，就算不会第二天去早点抄，玩耍才是最重要的！</p><p>我约了杨和我一起去沙堆上搭城堡（其实现在看来像是在打洞），我和他挖的正兴奋时，父亲怒气冲冲的过来把我像提小鸡一样提起来，告诫我不要玩沙子，把手弄脏了。</p><p>我给杨递了个眼色，于是给父亲保证再不会碰这个了。</p><p>等父亲走后，我又跑过去和他动工了。忙活到了晚上十点多，终于把城堡搭完了，筷子用断了好几根，脸也脏了，不过还是很开心呢。</p><p>虽然这些艺术品在大人看来一文不值，明天估计就要被毁了，但我知道那时的我看到自己辛苦搭建出来的东西后，充满了成就感。</p><h1 id="新华书店窃读记"><a href="#新华书店窃读记" class="headerlink" title="新华书店窃读记"></a>新华书店窃读记</h1><p>时间：小学五年级</p><p>地点：乌鲁木齐市南门新华书店</p><p>人物：童年玩伴杨</p><p>因为非常喜欢看冒险小虎队系列的侦探书，无奈杨用零花钱买的几本书已经被我看了两遍了，于是我和他计划，周末去书店看。</p><p>于是和父母说了一声后，周末吃过早饭和杨坐着61路公交车去书店，心里默念：今天我要看十本书！</p><p>抵达书店，上二楼后厅，拿书，找空地坐下来，动作一气呵成。</p><p>那一天，我记得是我生命中最充实最开心的时光，因为我把我的意识完全沉浸在侦探的世界里。</p><h1 id="街边小巷你追我打的欢快"><a href="#街边小巷你追我打的欢快" class="headerlink" title="街边小巷你追我打的欢快"></a>街边小巷你追我打的欢快</h1><p>时间：小学六年级</p><p>地点：街头小巷</p><p>人物：一群小屁孩</p><p>作业写完，叫上好朋友，一起去玩捉迷藏，真假孙悟空…反正就是各种跑。</p><p>有时候玩得过头了，十几个小娃娃追着我，我就东躲西藏，他们说抓住我有重赏。</p><p>就这样，间接锻炼了我奔跑的耐力和随机应变的决断力，也收获了一下午的喜悦。</p><h1 id="插卡游戏机街头霸王车轮战"><a href="#插卡游戏机街头霸王车轮战" class="headerlink" title="插卡游戏机街头霸王车轮战"></a>插卡游戏机街头霸王车轮战</h1><p>时间：初一、二年级</p><p>地点：韩家蛋糕盒厂</p><p>人物：韩，杨等游戏高手</p><p>初一认识了韩，因为他家有插卡游戏机，所以我经常跑他家里打游戏。</p><p>还记得当时我最爱玩街头霸王，最喜欢用一个黄头发发冲击波的格斗家和会放电的野兽。为了发出绝招，我把游戏手柄的方向键搓掉了，又把自己的大拇指搓肿了。经常玩到父母上门来找才肯结束。</p><p>除了街头霸王，还有四代魂斗罗，超级赛亚人等。</p><h1 id="地下游戏厅称霸记"><a href="#地下游戏厅称霸记" class="headerlink" title="地下游戏厅称霸记"></a>地下游戏厅称霸记</h1><p>时间：初一</p><p>地点：家对面的地下游戏厅</p><p>人物：游戏爱好者</p><p>家对面开了家游戏厅，里面有台球桌，还有两台PS2，在一个小隔间里还有四五台电脑，于是这里成了我放学和周末的天堂。</p><p>我充分发挥了自己善于钻研和学习的天分，不到两个月，没花一分钱，成了这家游戏厅里的游戏专家，没事给打三国无双的玩家指点一二，或者去和其他人联机CS1.6场场爆头。</p><p>后来因为白玩的次数太多了，被游戏厅老板拉入了黑名单。</p><h1 id="懵懂无知的好感"><a href="#懵懂无知的好感" class="headerlink" title="懵懂无知的好感"></a>懵懂无知的好感</h1><p>时间：初二</p><p>地点：某初中</p><p>人物：a gril</p><p>第一次对一个女孩产生好感应该就是这个时候吧。</p><p>想想也真是奇葩，产生好感那就表现的好一点就是，然而偏偏把自己最坏的一面表现了出来。</p><p>那种抑制不住的脸红和怦怦的心跳声，大概就是初恋的滋味吧，也是我再也回不去的青春。</p><p>虽然我已经记不清她的模样，但也是因为她的出现和离开，让我学会如何去用心喜欢上一个人。</p><h1 id="与赵的原始书信"><a href="#与赵的原始书信" class="headerlink" title="与赵的原始书信"></a>与赵的原始书信</h1><p>时间：初三</p><p>地点：无</p><p>人物：学习的榜样老赵</p><p>面临中考，每当这时候会与相互打气，还记得那时候没有手机，不能登QQ，于是就以最原始的方式保持通信—写信。</p><p>将信写好，装入那种放自动笔芯的圆筒内，然后交给顺路的人帮忙捎带给他，想想也是够机智的。</p><p>这种方式一直持续到高考结束，然后就戛然而止。</p><h1 id="影响我一生的良师益友"><a href="#影响我一生的良师益友" class="headerlink" title="影响我一生的良师益友"></a>影响我一生的良师益友</h1><p>时间：高三</p><p>地点：高中</p><p>人物：张，沈，杨，赵</p><p>高三，多么神圣的阶段，也许你的一分，就能干掉上千人，这是当时最流行的宣传语。</p><p>然而我又何尝不想拼搏努力呢。</p><p>只是，当我把自己想象成一台做题机器时，总会有人帮我找回本来的模样。</p><p>我想起，每当吃午饭的时候，我都会给凡儿和魁拔，讲述我自编的喜剧小说《高考命题组专家的故事》；我会在补习班内和杨还有赵吐槽这该死的高考题；我会咨询张老师是不是我太笨了为什么我一天睡五个小时，做题十个小时还是年级还不进步呢…</p><p>多年后当我再来看这些问题时，会觉得当时的我多么幼稚。</p><h1 id="大学毕业之后才懂"><a href="#大学毕业之后才懂" class="headerlink" title="大学毕业之后才懂"></a>大学毕业之后才懂</h1><ul><li>原来挣钱真的不容易</li><li>保持终生学习的观念，这是一个长跑</li><li>有空常回家看看</li><li>学习靠主动，工作靠自觉</li><li>有些人走着走着就会散了，你可以沉默一时，但不能一直活在这个阴影里</li><li>生命第一，生活第二，工作第三</li></ul><h1 id="再见乌鲁木齐，再见新疆"><a href="#再见乌鲁木齐，再见新疆" class="headerlink" title="再见乌鲁木齐，再见新疆"></a>再见乌鲁木齐，再见新疆</h1><p>这里有我忘不掉的人和景。</p><p>我想起和家人一起去阜康天池坐船看瀑布；一起去吐鲁番欣赏交河故城的荒凉，维吾尔族村寨，坎儿井的避暑好去处，火焰山的金箍棒温度计，葡萄沟的葡萄；一起去天山野生动物园里看狮子老虎大象长颈鹿，去植物园看各种花花草草，去游乐场玩碰碰车、旋转椅子和疯狂老鼠；一起自驾游去昌吉的杜氏旅游村；一起去石人沟骑马，我在湖边行走时右脚踏入沼泽地硬是左腿发力挣脱了出来；</p><p>我感谢家人给予我资金和精神上的鼓励，在我大二暑假时同意让我一个人走出去看看，这一走就是一个多月，走了十三座城市，路上遇到了许多社会上各个阶级的人，使我长了见识；感谢他们一如既往的支持我继续读研和深造，而不是逼着我赶紧就业，虽然最后没有成功考上。</p><p>我会想起和大学同学一起骑行一百二十公里去阿克苏的惊险刺激；和朋友去库车旅行，在沙漠公路上遭遇沙尘暴，方圆能见度不足三米的时候一辆越野车及时出现化解了危机；百里徒步去沙漠路上的艰辛，以及看到屹立不倒的胡杨，放佛沙漠中守护的卫士；</p><p>我会想起和女友夏天去的博斯腾湖，夜晚欣赏那静谧的孔雀河；冬天在公园里散步，差点把自己的耳朵冻掉；</p><p>我会想起和学校同学夏天扔水球，泼水冲凉，冬天打雪仗的开心；和慎在学校内散步，讨论物理化学题；和涛咨询人生困惑；和杨推着购物车在七一酱园，好家乡，友好里面乱逛；和好朋友去火焰山吃自助火锅烧烤，去八音和里唱歌，去人民电影院和和平都会踩点找最合适的场次；高三毕业去南山牧场吃烧烤，骑马。</p><p>仔细梳理，原来我留在这的回忆有这么多。</p><p>五一回家，看着周围熟悉的街道已经拆的差不多了，想想自己以后也是要一年才回一次家，不知明年回来时，这些记忆是否还能记住一半？</p><p>从我决定离开这座城市到一座新城市发展的时候，我知道我以后需要独自面临许多未知的阻碍。我要随机应变适应新的环境。</p><ul><li>我要更加坚强，来应对突如其来的质疑和压力；</li><li>我要更加机警，防止被套路；</li><li>我要更加勇敢，接受新挑战；</li><li>我要更加感恩，记住在这样一个陌生的城市里还愿意帮助我的人；</li><li>我要更加珍惜学习的机会；</li><li>我要学会接纳自己的不足。</li></ul><p>今天，我不认为一年前我放弃校招选择社招离开自己熟悉的环境而感到遗憾，并且我从没有如此神清气爽过，我放佛看到了重生，因为从此以后，我将不受束缚。</p><p><img src="/2019/05/11/goodbye-urumqi-goodbye-xinjiang/bohu" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>乌鲁木齐</tag>
        <tag>新疆</tag>
        <tag>告别</tag>
      </tags>
  </entry>
  <entry>
    <title>我们这一代人面临的知识焦虑</title>
    <url>/2019/04/28/we-face-knowledge-anxiety/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h1 id="为什么要写这样一篇文章"><a href="#为什么要写这样一篇文章" class="headerlink" title="为什么要写这样一篇文章"></a>为什么要写这样一篇文章</h1><p>零点整，和远在三千公里外的女友互道晚安后，继续刷我在极客时间上订阅的关于操作系统的专栏，无意间看到微信群里有人谈到焦虑，我想是时候写一篇文章，来聆听下自己的心声，因为不知道下次又等到什么时候去了。</p><h1 id="我的知识焦虑"><a href="#我的知识焦虑" class="headerlink" title="我的知识焦虑"></a>我的知识焦虑</h1><p>我最开始感到知识焦虑，是在我上大三的时候，当时下载了一个得到app，看到我尊敬的老师在里面建了专栏发文章，于是我咬牙拿出我半个月的伙食费，订阅了为期一年的专栏，于是我坚持早起打开app刷一篇文章，觉得不错还在下面进行留言。</p><p>讲真，我到现在都没有记住里面的内容，只记得当时讲的各种人生经验、理论、方法都很高大上，让我这小白大开眼界。</p><p>后来知识付费不知不觉就流行了起来，从得到app，到知识星球和小专栏，再到极客时间，于是美其名曰充分利用碎片化时间进行学习。</p><h1 id="为什么要知识付费"><a href="#为什么要知识付费" class="headerlink" title="为什么要知识付费"></a>为什么要知识付费</h1><p>说说我为什么会对一些专栏进行付费的原因</p><ul><li>得到某一领域技能的提点，从而提升在某领域的核心竞争力(主因)</li><li>与大佬近距离接触，沟通，不是常说“近朱者赤，近墨者黑”嘛</li><li>拓宽人脉，结识优秀的人</li><li>督促自己主动学习(既然花钱了，肯定想要回本啊)</li></ul><h1 id="那为什么会有知识焦虑呢"><a href="#那为什么会有知识焦虑呢" class="headerlink" title="那为什么会有知识焦虑呢"></a>那为什么会有知识焦虑呢</h1><p>在这里让我想起了木心的一首诗</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">记得早先少年时 大家诚诚恳恳 说一句是一句</span><br><span class="line"></span><br><span class="line">清早上火车站 长街黑暗无行人 卖豆浆的小店冒着热气</span><br><span class="line"></span><br><span class="line">从前的日色变得慢 车、马、邮件都慢 一生只够爱一个人</span><br><span class="line"></span><br><span class="line">从前的锁也好看 钥匙精美有样子 你锁了 人家就懂了</span><br></pre></td></tr></table></figure><p>从前的交通很慢，父母要从陕西到乌鲁木齐，要坐七天七夜的绿皮车；从前的网速邮件很慢，话费很贵，见字如面，惜字如金，只要能半个月写封信或通个电话那头的人就已经心满意足了；从前的人想法很简单，只要学一个技能，能混个饭饱饿不死就行。</p><p>然而那是二十年前的日子，现在是高速信息化时代，一切都在追寻快。</p><p>交通如果慢一点，就着急跺脚；视频通话稍微卡顿，就说网速太差；一个技能还没有吃透，又想着吃另一个，然而精力时间有限。</p><p>我一直在找寻产生知识焦虑的原因，如果让我追本溯源的话，我想，那就是当我们的野心还配不上我们的行动时，现实与理想的落差而造成的。</p><h1 id="IT，一个特殊的行业"><a href="#IT，一个特殊的行业" class="headerlink" title="IT，一个特殊的行业"></a>IT，一个特殊的行业</h1><p>IT，我觉得它与传统行业的差别在于，更新迭代速度非常快，稍微慢一点，你就会感觉到掉队。</p><p>比如新框架替换老框架，就像人体的新城代谢似的。</p><p>所以，在我们入了这个行业的时候，就要抱着终身学习的方向去努力。</p><h1 id="我曾如此焦虑过"><a href="#我曾如此焦虑过" class="headerlink" title="我曾如此焦虑过"></a>我曾如此焦虑过</h1><p>当我早上醒来时，去操场跑步，去食堂吃早饭，在校园的林荫小道上背半小时的新概念，看一会我订阅的专栏的更新，然后去教师上课，这时候视情况而定，如果老师在吹牛逼，就屏蔽掉，同时拿出自己到图书馆借阅的算法书或一些文学小说看；中午午休，下午没课去图书馆或实验室看书刷题写博客；晚饭过后继续做看书学习的循环。</p><p>这样的日子持续了很长时间，因为我不知道未来我会遇到什么样的竞争对手，不知道我遇到的同事是否比我强，如果比我强，拖后腿就难受了。<br>未知是恐惧的，所有的这一切促使我紧张而又焦虑的度过生活的每一天。</p><h1 id="战胜焦虑的过程"><a href="#战胜焦虑的过程" class="headerlink" title="战胜焦虑的过程"></a>战胜焦虑的过程</h1><p>这一切的改变源于一个人的出现。</p><p>直到她的出现我的生活中，让我知道原来学校外还有一些好吃的餐馆，原来秋天学校里通往教学楼的路是如此美丽，原来梨花开的那一刻竟是如此浪漫，原来和喜欢的人安安静静的坐在小水池旁边，一人各抱着半个西瓜啃是如此美好。</p><p>她说：<strong>生命苦短，及时行乐</strong>。</p><h1 id="适当焦虑"><a href="#适当焦虑" class="headerlink" title="适当焦虑"></a>适当焦虑</h1><p>现在的我，有时会因为新出现的需求和<code>bug</code>而忙前忙后，和各个岗位负责人做沟通，但我依旧会挤出晚上宝贵的睡前半小时，静下心来写一写日记，听几首喜欢的音乐。培养着和艺术，音乐，书法方面的爱好。</p><p>焦虑每一个人都会有，我也不例外。也许我们会为了自己道路远方的光而不断奔跑，但请别忘了适当停下来回首自己走过的路，因为那是属于你独一无二，不可替代的曾经。</p><p><img src="/2019/04/28/we-face-knowledge-anxiety/weroad.png" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>焦虑</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>感情这东西</title>
    <url>/2019/04/25/feelings/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><p>今天是2019年4月25日，距离她毕业离校到来成都，还有一个月的时间。</p><p>放佛是越到最后越按捺不住自己的情绪。感情这东西，真是有趣。</p><p>最近情绪不怎么稳定，运维上出现了两个bug已经拖了四天还没有解决，五一回家，想和女友聚一波去耍，无奈新疆太大，从她出学校到见我，还有坐两个小时的班车和十三个小时的火车（速度比较快的）。真是很惆怅。</p><p>我对她说，你要来，我肯定会给你把吃住安排好，带你去看美景，但是我也就在家呆六天，然后就要飞回成都工作。</p><p>感情这东西，真是神奇，长年累月，让两个素不相识的人在一起，成为伴侣，这样的感觉很美妙，然而，当两个人分开时，却要承受分开时思念的痛苦。</p><p>我希望这是我最后一次品尝，不管是不是最后一次，请不要再分开这么长的时间了。</p><p>而我，也绝对绝对绝对不会再让我爱的人离开我，也不会让她再受到半点委屈。</p><p>也许这就是爱情所赋予平凡人的力量吧。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>爱情</tag>
        <tag>毕业</tag>
      </tags>
  </entry>
  <entry>
    <title>Go项目结构设计过程点滴记录</title>
    <url>/2019/04/22/go-project-struct-design-note/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>之前在知识星球里星主让用<code>SMTP</code>协议实现邮件发送功能，看了<code>Max Li</code>的设计，并和他交流了一小时，在此将设计经验记录下来。</p><h1 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h1><p>设计一个项目的结构，有时候就像写文章一样，得分清层级。下面我将把讨论出的设计经验记录下来。</p><ul><li><p>main.go文件，当做项目的入口，里面可以写明版本号，读取配置文件，以及日志的初始化；</p></li><li><p>gomod文件，包管理</p></li><li><p>makefile文件，如果启动程序较多，可以写入makefile文件中，到时运行直接make即可；</p></li><li><p>pkg文件夹，存放项目的主要源代码</p></li><li><p>cmd文件夹，存放项目生成的可执行文件</p></li><li><p>config文件夹，存放配置文件，包含项目的基本配置信息</p></li><li><p>vendor文件夹，将依赖的包放入此目录中</p></li><li><p>util文件夹，项目中所写的小工具，例如进制转换，查错，类型转换，时间转时间戳等放入该文件件</p></li></ul><h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><h2 id="1，设计中难免会出现明文密码显示等相关信息，如何做到保密呢？"><a href="#1，设计中难免会出现明文密码显示等相关信息，如何做到保密呢？" class="headerlink" title="1，设计中难免会出现明文密码显示等相关信息，如何做到保密呢？"></a>1，设计中难免会出现明文密码显示等相关信息，如何做到保密呢？</h2><h2 id="2，如何做到在项目build同时自己更新tag号？"><a href="#2，如何做到在项目build同时自己更新tag号？" class="headerlink" title="2，如何做到在项目build同时自己更新tag号？"></a>2，如何做到在项目build同时自己更新tag号？</h2><p>参考<a href="https://github.com/ahmetb/govvv" target="_blank" rel="noopener">govvv</a></p><h2 id="3，怎样设计出一个框架，支持易扩展可维护呢？"><a href="#3，怎样设计出一个框架，支持易扩展可维护呢？" class="headerlink" title="3，怎样设计出一个框架，支持易扩展可维护呢？"></a>3，怎样设计出一个框架，支持易扩展可维护呢？</h2><p>我能想到的是，<code>web</code>服务设计接口，在接口中添加操作。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://idiomaticgo.com/post/best-practice/server-project-layout/" target="_blank" rel="noopener">Server Project Layout</a></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>写<code>demo</code>的时候，还是忍不住将所有的程序写进一个<code>main</code>函数里，又或者是新建一个<code>server.go</code>文件，然后一股脑的在里面做文章。</p><p>今天早上看星球里的朋友提出了一个问题，我觉得很对，在此摘录如下</p><blockquote><p>提高编程技能是很不容易的，一个人一旦习惯了某种编程思维就很难再突破。就说说我自己，一个业务用一般方法能实现的，我很难再去想到用接口，函数类型，闭包，反射等。虽然业务实现了，但总感觉代码写的很烂，自己看了都恶心。我相信大家一定有同感，教程和视频看了很多，也知道很多概念，但等到自己用的时候，又回到了旧的思维习惯。我觉得老大在布道go时，更应关注这方面的培养，知识的细节和技巧可以慢慢积累，但思维定势不突破，永远也不可能提高。</p></blockquote><p>今天和<code>Max Li</code>的沟通，还有在做项目时不断的以工程思维冲击着以前遗留下来的旧的思维习惯，我只想说，越早做出好的改变，成长的空间的也就越大。</p><p>共勉！</p><p><img src="/2019/04/22/go-project-struct-design-note/road" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>Go</tag>
        <tag>架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>暂时停留</title>
    <url>/2019/04/21/temporary-stay/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><p>前天，也就是星期五，我终于把我负责的流媒体收录系统上的<code>bug</code>和需求都清空了，成功打了<code>tag</code>号。</p><p>可以暂时休息下，思考一下前方的路该如何走？</p><p>有时候很好奇，大家都是24小时的时间，为什么有的人风生水起，有的人碌碌无为呢？</p><p>昨天去现场咨询了一下成都落户，本科以上学历+无房，落的是集体户口。嗯，觉得这块得好好了解下。不然以后再落会比较麻烦。</p><p>接下来要做的事情，似乎还有很多：</p><ul><li><p>流媒体收录关于管道，并发，以及<code>nginx</code>的服务还要细看下；</p></li><li><p>英语流利说的会员到期日还有80天，要抓紧时间了；</p></li><li><p>极客专栏上有关<code>Linux</code>操作系统内核，网络协议和数据库原理的的内容也需要更新；</p></li><li><p>给伶说好的画画，要在她五月底来成都前画完，虽然时间还很充裕，但不能再拖了。</p></li></ul><p>入职半年多，现在才真正感觉是在跟着大家一块做项目。</p><p>加油，努力！</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>远方</tag>
      </tags>
  </entry>
  <entry>
    <title>服务端漫游</title>
    <url>/2019/04/14/server-roam/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><p>注：本文内容源自<code>polaris</code>在知识星球<strong>Go项目实战</strong>中的直播，已获得本人许可。</p><h1 id="第一站：穿梭于Internet"><a href="#第一站：穿梭于Internet" class="headerlink" title="第一站：穿梭于Internet"></a>第一站：穿梭于Internet</h1><p><img src="/2019/04/14/server-roam/internet.png" alt></p><h1 id="第二站：协议"><a href="#第二站：协议" class="headerlink" title="第二站：协议"></a>第二站：协议</h1><p>重点掌握</p><ul><li>TCP/UDP</li><li>HTTP</li></ul><p>常考面试题</p><ul><li>TCP的三次握手过程</li><li>TCP的四次挥手过程</li></ul><h4 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h4><ul><li>《图解http协议》</li><li>《图解TCP协议》</li></ul><p>建议用<code>wireshark</code>抓包软件进行分析。</p><h1 id="第三站：Unix-Linux操作系统"><a href="#第三站：Unix-Linux操作系统" class="headerlink" title="第三站：Unix/Linux操作系统"></a>第三站：Unix/Linux操作系统</h1><p>掌握对<code>Unix/Linux</code>操作系统的常用操作指令操作，例如</p><ul><li><code>shell</code>脚本</li><li><code>vim</code>编辑器的使用</li><li><code>sed</code></li><li><code>awk</code></li></ul><p>多练习，多总结</p><p>网络编程方面需掌握</p><ul><li>Socket、Unix Domain Socket</li><li>进程间通讯</li></ul><h4 id="推荐书籍-1"><a href="#推荐书籍-1" class="headerlink" title="推荐书籍"></a>推荐书籍</h4><ul><li>《UNIX网络编程卷一：套接字》</li><li>《UNIX环境高级编程》</li><li>《Linux/Unix设计思想》</li></ul><h1 id="第四站：Nginx、Apache、Caddy、等Web-Server和核心功能"><a href="#第四站：Nginx、Apache、Caddy、等Web-Server和核心功能" class="headerlink" title="第四站：Nginx、Apache、Caddy、等Web Server和核心功能"></a>第四站：Nginx、Apache、Caddy、等Web Server和核心功能</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><img src="/2019/04/14/server-roam/server.png" alt></p><h2 id="Web-Server核心功能"><a href="#Web-Server核心功能" class="headerlink" title="Web Server核心功能"></a>Web Server核心功能</h2><ul><li>HTTP解析</li><li>HTTPS支持</li><li>虚拟主机(一个端口，多个域名)</li><li>静态资源</li><li>URL重写</li><li>gzip压缩</li><li>作为反向代理，和其他进程常用通讯协议的支持</li></ul><p>推荐学习了解下<code>Caddy</code></p><h1 id="第五站：常用的支持Web开发的语言"><a href="#第五站：常用的支持Web开发的语言" class="headerlink" title="第五站：常用的支持Web开发的语言"></a>第五站：常用的支持Web开发的语言</h1><ul><li>PHP(LAMP、LNMP)</li><li>Java</li><li>Python</li><li>Ruby</li><li>Go</li><li>C#(.NET)</li></ul><p>另外常用的数据结构和算法要有了解</p><h1 id="第六站：数据库"><a href="#第六站：数据库" class="headerlink" title="第六站：数据库"></a>第六站：数据库</h1><ul><li>关系数据库：SQLite,MySQL,Postgresql,SQL Server,Oracle</li><li>NoSQL：Redis,Mongodb,Cassandra,HBase</li><li>缓存：Redis,Memcached</li><li>其他：Go BoltDB,dgraph,CockroachDB</li></ul><p>入门数据库推荐使用<code>MySQL</code></p><h4 id="推荐书籍-2"><a href="#推荐书籍-2" class="headerlink" title="推荐书籍"></a>推荐书籍</h4><ul><li>《高性能MySQL》</li><li>《MySQL技术内幕InnoDB引擎》</li><li>《Redis实战》</li></ul><h1 id="第七站：架构"><a href="#第七站：架构" class="headerlink" title="第七站：架构"></a>第七站：架构</h1><ul><li>高可用，高性能，可扩展</li><li>分布式，CAP理论</li><li>分布式消息队列：Redis,ActiveMQ,RabbitMQ,ZeroMQ,Kafka,MetaMQ,RocketMQ等</li><li>常用的应用场景：异步处理，应用解耦，流量削峰和消息通讯</li><li>微服务</li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>直播后有个答疑环节，我将此次答疑的收货整理如下：</p><h4 id="关于服务端面试"><a href="#关于服务端面试" class="headerlink" title="关于服务端面试"></a>关于服务端面试</h4><p>面试考语言的分量比较小，因为服务端涉及的面比较广，需要学习的东西很多，有时候原理比语言更重要。</p><h4 id="关于承压"><a href="#关于承压" class="headerlink" title="关于承压"></a>关于承压</h4><p>在项目研发过程中，无论是测试还是上线跑，服务端会经常背锅，所以在压力上要及时调整好心态，做好和其他岗位人员的及时有效沟通。</p><h4 id="关于未来发展"><a href="#关于未来发展" class="headerlink" title="关于未来发展"></a>关于未来发展</h4><p>努力去大公司，做一些大项目，最好流量是千万级别以上的。</p><p>学无止境，一起努力！</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>服务端学习</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>数据库</tag>
        <tag>服务端</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>关于996，我想说</title>
    <url>/2019/04/07/about-996-i-want-to-say/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>最近Github上有一个叫<a href="https://github.com/996icu/996.ICU" target="_blank" rel="noopener">996.ICU</a>的项目很火，原因是它公开抵制国内的996工作制，这严重违反了劳动法。工作996，住院ICU。</p><p>于是我身边有朋友问我，996到底是什么意思，那么我先说下我个人的亲身经历吧。</p><h1 id="回忆"><a href="#回忆" class="headerlink" title="回忆"></a>回忆</h1><p>去年六月大学本科毕业后，幸运的入职一家上市游戏公司，从事游戏服务端开发，刚开始对新公司，新工作充满好奇，想着下班回去也没什么事，就多待会，熟悉公司的业务流程。于是在公司内，我算是比较活跃的一类。</p><p>游戏公司与其他互联网公司最大的不同在于，活动非常多，各种节日庆祝，生日庆祝，下午茶，大家其乐融融，嬉戏打闹，品尝美食，氛围很融洽…</p><p>2018年8月，隔壁一工作室出了一款暗黑类手游，IOS端零点开服，于是我看着他们工作室从早忙到深夜，要么服务器崩了，要么数据有误急需修改，有些策划兼当游戏客服，而我看到一小伙子有时还披着被子工作，莫不是凌晨都睡在公司了吧。</p><p>后来，我也要开始加班了，虽然我也并不知道为什么加班，明明可以六点半走的，莫不是为了八点的餐补，还是九点的滴滴打车报销？</p><p>再后来，我经常晚上回来，同租的老哥每次看我拖着疲惫的身子回来，一脸倦容，就知道我又加班了。</p><p>八月底，做了两个梦</p><ul><li>第一个梦是让我两天把《Java编程思想》看完，我被吓醒了；</li><li>第二个梦是半醒中，突然摸到了一双手在我后脑勺处，我吓的大叫了一声，后来才发现是我那双已经被压麻的手，因为太累，躺床上还没有调整好睡姿就已经睡着了。</li></ul><p>八月三十一号，我记得很清楚，那是我离猝死最近的距离…</p><p>那天，我坐在工位前，一直在看服务端主程用<code>Lua</code>语言写的球球大作战源码，虽然看不懂，但我还是坚持把这四千行的代码都过了一遍，吃晚饭的时候一激动，起身起的太快，感到心脏隐隐作痛，头昏脑涨，恍恍惚惚间已经不知道自己在哪里，在干什么。旁边的客户端同事告诉我赶紧休息下，不能再工作了。我想也是。</p><p>在回去的路上，我将我今天的症状对学西医的朋友描述的一遍，他说你这离猝死不远了，得好好休息。</p><p>我慌了，我再也不敢透支身体了！</p><p>九月初，转正答辩，虽然我列举了我这三个月的改变，和完成的事情，但当他们一脸不屑，以及对我提出的问题，我就能猜出我能否通过转正了，虽然我每天都在拼命加班，但产出在他们看来微乎其微，公司不养闲人，于是我光荣的提了离职申请。</p><p>九月十一号，我办好离职手续，出了公司，成了一名工作经验仅只有三个月的社会人士。</p><p>我很想找个没人的地方哭一次，但我知道，塞翁失马，焉知非福。如果这就是我所了解到的游戏生涯，那我的游戏开发的梦也可以就此宣告结束了。</p><h1 id="工作996，生病ICU"><a href="#工作996，生病ICU" class="headerlink" title="工作996，生病ICU"></a>工作996，生病ICU</h1><p>我觉得这个比喻真的很好，说的更直白点，就是有命赚钱，没命花钱。</p><p>曾经我以为996就是累点而已，多学点东西也是极好的。</p><p>现在想想错了。</p><p>996在消耗你的体力的同时，也在消耗你的自由支配时间。在你本应该下班好好玩耍或吃顿美食开始看书学习的时候，你却要在嘈杂的环境下持续输出。可想而知，在精力和体力都枯竭的情况下，怎么能高产出呢？</p><p>然后负责人觉得你每天工作十二个小时，产出还这么低，看来你能力不行嘛，明天可以走人了，我再招一批年轻的实习生进来。</p><p>于是最终吃亏的还是自己。</p><h1 id="关于996，我想说"><a href="#关于996，我想说" class="headerlink" title="关于996，我想说"></a>关于996，我想说</h1><ul><li><p>跟对<code>leader</code>很重要。在我看来，一个好<code>leader</code>可以成为自己学习的榜样。虽然我无法全面定义一个好<code>leader</code>到底是什么样子，但是有一点是可以证明的：就是不会总是在他人面前炫耀自己曾经获得过什么荣誉。毕竟那都是过去的事情，一个人总沉浸在过去，会影响现在以及对未来的判断。</p></li><li><p>对不应该加的班说不。工作重要的一点是能力，另一点就是沟通。对于不是自己负责的任务，及时说明原因，让负责人定夺，而不是一股脑的全都接下。</p></li><li><p>抓紧一切时间去学习，去提升自我。我相信那些大厂年薪过百万的人，即使不加班领导也不会拿他怎样，毕竟这种人是无法短期被替代的，同时掌握着公司内最核心的技术。</p></li><li><p>加班多工资多，加班少工作也低，放佛总不能找到一个完美的选择，那么就请平衡好自己的能力和野心。</p></li><li><p>提升工作效率是关键。比如设立番茄钟，遇到不懂的赶紧问。</p></li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>转眼间我已经工作快十一个月了，有时还会把自己想象是在校大学生。</p><p>从996到955，从睡眠不足到睡到自然醒精神的去上班，我知道我找到了适合自己的工作方式。</p><p>曾经看着红的蓝的绿的共享单车如三条颜色的河流缓缓的流向软件园，中间有分流到xx大厦，xx集团，我曾想过上班的意义是什么？</p><p>直到现在我也没彻底想明白，但我知道，上班绝不是去医院住ICU。</p><p>希望996这样的工作制能成为个例，也希望以后的程序员们可以早点下班。</p><p>Good Luck.</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>工作</tag>
        <tag>感悟</tag>
        <tag>加班</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Golang进行字符串的替换</title>
    <url>/2019/04/07/use-golang-string-replace/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//转换为字符串后追加到字节数组</span></span><br><span class="line">	slice := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	slice = strconv.AppendBool(slice, <span class="literal">true</span>)</span><br><span class="line">	<span class="comment">//第二个数为要追加的数，第三个数为指定10进制方式追加</span></span><br><span class="line">	slice = strconv.AppendInt(slice, <span class="number">1234</span>, <span class="number">10</span>)</span><br><span class="line">	slice = strconv.AppendQuote(slice, <span class="string">"abcgohello"</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"slice = "</span>, <span class="keyword">string</span>(slice))</span><br><span class="line"></span><br><span class="line">	<span class="comment">//其它类型转换为字符串</span></span><br><span class="line">	<span class="keyword">var</span> str <span class="keyword">string</span></span><br><span class="line">	str = strconv.FormatBool(<span class="literal">false</span>)</span><br><span class="line">	fmt.Println(<span class="string">"str = "</span>, str)</span><br><span class="line">	<span class="comment">//'f'指打印格式，以小数形式，-1指小数点位数，64以float64处理</span></span><br><span class="line">	str = strconv.FormatFloat(<span class="number">3.14</span>, <span class="string">'f'</span>, <span class="number">-1</span>, <span class="number">64</span>)</span><br><span class="line">	fmt.Println(<span class="string">"str = "</span>, str)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//整型转字符型</span></span><br><span class="line">	str = strconv.Itoa(<span class="number">6666</span>)</span><br><span class="line">	fmt.Println(<span class="string">"str = "</span>, str)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符串转其它类型</span></span><br><span class="line">	flag, err := strconv.ParseBool(<span class="string">"true"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err = "</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"flag = "</span>, flag)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符串转换为整型</span></span><br><span class="line">	a, _ := strconv.Atoi(<span class="string">"56479"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"a = "</span>, a)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="/2019/04/07/use-golang-string-replace/str.png" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>字符串</tag>
        <tag>替换</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串操作常用函数介绍</title>
    <url>/2019/04/07/golang-string-operation-function/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><ul><li>操作</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//"helloogo"中是否包含"hello"</span></span><br><span class="line">fmt.Println(strings.Contains(<span class="string">"helloogo"</span>, <span class="string">"hello"</span>))</span><br><span class="line">fmt.Println(strings.Contains(<span class="string">"helloogo"</span>, <span class="string">"goe"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//Join组合</span></span><br><span class="line">s := []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>, <span class="string">"hello"</span>, <span class="string">"mike"</span>, <span class="string">"go"</span>&#125;</span><br><span class="line">buf := strings.Join(s, <span class="string">"_"</span>)</span><br><span class="line">fmt.Println(<span class="string">"buf = "</span>, buf)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Index 查找子串所在位置</span></span><br><span class="line">fmt.Println(strings.Index(<span class="string">"abcdhello"</span>, <span class="string">"hello"</span>))</span><br><span class="line">fmt.Println(strings.Index(<span class="string">"abcdhello"</span>, <span class="string">"go"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//Repeat 重复打印</span></span><br><span class="line">buf = strings.Repeat(<span class="string">"go"</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="string">"buf = "</span>, buf)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Split 以指定的分隔符对字符串进行拆分</span></span><br><span class="line">buf = <span class="string">"hello&amp;abc&amp;go&amp;mike&amp;you"</span></span><br><span class="line">s2 := strings.Split(buf, <span class="string">"&amp;"</span>)</span><br><span class="line">fmt.Println(<span class="string">"s2 = "</span>, s2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Trim 去掉两头的字符</span></span><br><span class="line">buf = strings.Trim(<span class="string">"      are you ok    "</span>, <span class="string">" "</span>)</span><br><span class="line">fmt.Println(<span class="string">"buf = "</span>, buf)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Fields 去掉空格，把元素放入切片中</span></span><br><span class="line">s3 := strings.Fields(<span class="string">"    are you ok?    "</span>)</span><br><span class="line"><span class="keyword">for</span> i, data := <span class="keyword">range</span> s3 &#123;</span><br><span class="line">	fmt.Println(i, <span class="string">", "</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">buf =  abc_hello_mike_go</span><br><span class="line">4</span><br><span class="line">-1</span><br><span class="line">buf =  gogogo</span><br><span class="line">s2 =  [hello abc go mike you]</span><br><span class="line">buf =  are you ok</span><br><span class="line">0 ,  are</span><br><span class="line">1 ,  you</span><br><span class="line">2 ,  ok?</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>字符串</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次做项目学到的技术之外的东西</title>
    <url>/2019/03/28/first-work-project-havest/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><p>三月初转正后开始接手公司内的一个有关流媒体收录系统服务器方面的项目，和部门老哥，产品，测试，运维，前端交流，对需求，看bug，学习到了很多编程之外的技能，写篇文章记录下来。</p><h2 id="接手新项目"><a href="#接手新项目" class="headerlink" title="接手新项目"></a>接手新项目</h2><ul><li>把完整的接口说明文档，配置文件拿到手，大致先过一遍</li><li>学会打断点，代码不是文章，不能从头读到尾，除非是一个文件只有一个<code>main</code>函数从头跟到尾</li><li>有不懂就赶紧问，时间不等人！</li><li>大部分时间都是把逻辑理清楚，代码只是分分钟的事情。</li></ul><h2 id="与产品沟通"><a href="#与产品沟通" class="headerlink" title="与产品沟通"></a>与产品沟通</h2><ul><li>大部分产品是不写代码的，所以不要和他/她扯到程序内部的实现上，否则他/她会很懵逼</li><li>遇到需求完成不了或觉得有问题，应尽早提出来</li></ul><h2 id="与其他部门的沟通"><a href="#与其他部门的沟通" class="headerlink" title="与其他部门的沟通"></a>与其他部门的沟通</h2><ul><li>其实在做编码设计的时候，我的时间不是整块的，有时候会被测试，运维临时打断去处理bug</li><li>学会把时间整片化，例如25-30分钟做一件事情，如果中间被要求去解决<code>bug</code>，咨询他能否等10分钟</li><li>每次解决完一个<code>bug</code>，把问题和解决过程描述清楚，记录在<code>wiki</code>上，方便自己和其他相关人员以后查看</li><li>学会看日志，通过日志分析问题的所在</li></ul><h2 id="排查bug的基本流程"><a href="#排查bug的基本流程" class="headerlink" title="排查bug的基本流程"></a>排查bug的基本流程</h2><p>当运维、测试那里出现问题需要你来解决时，解决流程是这样的:</p><ul><li>先看配置文件是否正确，也许是模式<code>model</code>选错，也许是路径没有配置正确;</li><li>再看日志记录;(所以前提是自己要在关键模块打详细日志描述，方便排查问题)</li><li>然后再看版本号是否正确;</li><li>最后再将问题在本机复现，用<code>dlv</code>或<code>gdb</code>打断点调试找出问题;</li><li>当问题解决后，一定记得在<code>wiki</code>里做好相应的记录，原因有二，帮助自己整理和回顾项目中的业务流程，当另外的运维或测试碰到类似的问题时，直接让它看<code>wiki</code>记录就可以，自己可以专心干其他的事情。</li></ul><p>加油！这将是我正式开发和维护的第一个<code>Golang</code>语言的项目！</p><p><img src="/2019/03/28/first-work-project-havest/beautiful.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>成长</tag>
        <tag>感悟</tag>
        <tag>学习</tag>
        <tag>沟通</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>一点进展</title>
    <url>/2019/03/25/a-little-progress/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><p>今天部门老大问我项目进展怎样，我说有点慢，一个需求正在测试，还有四个需求没有开始实施。（我为什么要这么诚实？！）</p><p>中午和同事出去吃饭，他建议我先把接口列出来，然后把每一步要做的注释写出来，再将注释翻译成代码。</p><p>散步快结束时，董说你已经过了让我们告诉你如何做的阶段，现在只能是自己去探索，而我们告诉你是<code>true</code>或<code>false</code>。</p><p>当我听到这句话的时候，我竟然心中油然升起一种莫名其妙的喜悦。</p><p>是的，我已经转正了，已经离开学校九个多月了，应该学会独立解决问题和培养随机应变的能力。</p><p>企业不是学校，没有责任和义务告诉你每一步该怎么做。</p><p>谢谢给我指导的部门老哥们。</p><p>是我自己太矫情了，一直沉溺在学校的幻想中，不愿意走出来。</p><p>今天终于解决了第一个需求，不知明天能不能把第二个需求做完。</p><p>坚持，并学会改变。</p><p><img src="/2019/03/25/a-little-progress/smile.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>进步</tag>
      </tags>
  </entry>
  <entry>
    <title>一点小挫折</title>
    <url>/2019/03/23/some-setbacks/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><p>终于迎来了最难受的时期，流媒体收录服务，逻辑很杂，但不难，就是tmd理不清楚。</p><p>下周五要发版，现在东西搞定不了，该如何是好？</p><p>父母说，遇到困难就去解决，不要逃避，他们也说，这个东西以后就交给我来负责了！</p><p>可是，我真的能扛起这个重任吗？我反复问自己。</p><p>明天还有一天的时间，我想重新用dlv调试把每个流程弄懂。</p><p>希望可以来得及！</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>挫折</tag>
      </tags>
  </entry>
  <entry>
    <title>痛并成长着</title>
    <url>/2019/03/18/pain-and-growth/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><p>三月，对我来说是一个特殊的月份，特殊在:</p><ul><li>转正通过，开始接手公司项目;</li><li>月底我将23岁，每当这个时候，我都会感到莫名其妙的沉默寡言。</li></ul><p>上一周感觉过得很艰难，很充实，因为自己不会的很多，得一个个去补。</p><p>杨说叫我把B站上的20小时快速入门Go语言课程从新再系统学习一遍，虽然我觉得之前都接触过，但我还是欣然接受。现在课程已经过半，让我真正意识到，忘记自己曾经以为对的东西，推到重来，反而会有新的收获，也许这就是温故而知新吧。</p><p>这周很荣幸加入了Go语言中文网创始人创办的知识星球，与无闻，轩辕刃这些大佬一起学习Go语言，探究底层的本质。</p><p>技术文章我仍旧会继续坚持写下去，但我会逐渐摒弃数量，追求质量。</p><p>上周六和一位朋友去看漫展，然后去逛街，疯玩了一天，身心放松了下来，很是开心，让我忘却了工作上的烦恼。</p><p>我一直坚信，天将降大任于斯人也，必先苦其心智，饿其筋骨，劳其体肤…</p><p>加油!扛过去，胜利就在前方。</p><p><img src="/2019/03/18/pain-and-growth/whale.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>感悟</tag>
        <tag>挫折</tag>
      </tags>
  </entry>
  <entry>
    <title>转正才是工作的开始</title>
    <url>/2019/03/04/positive-is-work-begin/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><p>转正通过，也算是对我这六个月的一次认可吧。</p><p>然后有一老哥的流媒体服务相关的项目移交给我负责了，还有视音频编码，放佛之前是在过家家，现在才是正式工作的开始。</p><p>加油，机遇与挑战并存！</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>开始</tag>
        <tag>转正</tag>
      </tags>
  </entry>
  <entry>
    <title>对Go语言interface的理解</title>
    <url>/2019/03/03/golang-interface-understand/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h1 id="什么是interface"><a href="#什么是interface" class="headerlink" title="什么是interface"></a>什么是interface</h1><p>interface是一组method（方法）的组合，我们通过interface来定义对象的一组行为。</p><h1 id="interface类型"><a href="#interface类型" class="headerlink" title="interface类型"></a>interface类型</h1><p>interface类型定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口。<br>（如果给鸭子模型定义划水的方法，当我再新建立一个鸟的对象，让它实现划水的方法，这时我可以认为鸟也是鸭子）</p><p>一个例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段Human</span></span><br><span class="line">    school <span class="keyword">string</span></span><br><span class="line">    loan <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段Human</span></span><br><span class="line">    company <span class="keyword">string</span></span><br><span class="line">    money <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Human对象实现Sayhi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Hi, I am %s you can call me on %s\n"</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Human对象实现Sing方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">Sing</span><span class="params">(lyrics <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"La la, la la la, la la la la la..."</span>, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Human对象实现Guzzle方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">Guzzle</span><span class="params">(beerStein <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Guzzle Guzzle Guzzle..."</span>, beerStein)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Employee重载Human的Sayhi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Hi, I am %s, I work at %s. Call me on %s\n"</span>, e.name,</span><br><span class="line">        e.company, e.phone) <span class="comment">//此句可以分成多行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Student实现BorrowMoney方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">BorrowMoney</span><span class="params">(amount <span class="keyword">float32</span>)</span></span> &#123;</span><br><span class="line">    s.loan += amount <span class="comment">// (again and again and...)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Employee实现SpendSalary方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">SpendSalary</span><span class="params">(amount <span class="keyword">float32</span>)</span></span> &#123;</span><br><span class="line">    e.money -= amount <span class="comment">// More vodka please!!! Get me through the day!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义interface</span></span><br><span class="line"><span class="keyword">type</span> Men <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(lyrics <span class="keyword">string</span>)</span><br><span class="line">    Guzzle(beerStein <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> YoungChap <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(song <span class="keyword">string</span>)</span><br><span class="line">    BorrowMoney(amount <span class="keyword">float32</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ElderlyGent <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(song <span class="keyword">string</span>)</span><br><span class="line">    SpendSalary(amount <span class="keyword">float32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以知道</p><ul><li>interface可以被任意对象调用和实现。</li><li>一个对象可以实现任意多个interface。</li></ul><p>形象的比喻：每个物种都是一个类，我们给这个类定义一系列的行为，例如给鸟类定义可以飞行的行为，给狗定义可以“汪汪”的声音，给人类定义可以说话可以跑步的行为，那么当你和我都实现了说话和跑步的行为，你我都属于人类，你和我都实现了飞行的行为，你我都属于鸟类，以此类推。这么做的意义在于，实现代码的高度使用。</p><h1 id="思考：errors-这个-package-里面的-errors-New-到底是做什么的？"><a href="#思考：errors-这个-package-里面的-errors-New-到底是做什么的？" class="headerlink" title="思考：errors 这个 package 里面的 errors.New 到底是做什么的？"></a>思考：errors 这个 package 里面的 errors.New 到底是做什么的？</h1><p><code>errors</code>包实现了创建错误值的函数。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>使用字符串创建一个错误,可以类比fmt包的Errorf方法，差不多可以认为是New(fmt.Sprintf(…))。</p><p>例子</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(request <span class="keyword">string</span>)</span> <span class="params">(response <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> request == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="comment">//调用errors.New函数时传入一个由字符串代表的错误信息，它会返回</span></span><br><span class="line">		<span class="comment">//给我们一个包含了这个错误信息的error类型值。该值的静态类型是error</span></span><br><span class="line">		err = errors.New(<span class="string">"empty content"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	response = fmt.Sprintf(<span class="string">"echo: %s"</span>, request)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是返回一个自己定义的错误。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://golang.org/pkg/errors/" target="_blank" rel="noopener">gopkg-errors</a></p><p><a href="https://golang.org/src/errors/errors.go?s=293:320#L1" target="_blank" rel="noopener">New的实现</a></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>interface</tag>
      </tags>
  </entry>
  <entry>
    <title>开始学习一项新技术</title>
    <url>/2019/02/27/start-learn-new-technology/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><p>今天部门老哥说，周五会开始做一个新东西，会用到<code>Docker</code>，叫我先下载下来，后面要用。</p><p><code>Docker</code>这东西有段时间听过，是个容器，把应用放在里面跑，还是<code>Golang</code>的开源项目，对此我一直很好奇它和虚拟机相比究竟优点在哪里？</p><p>现在终于要开始接触它了！</p><p>加油，这两天先把手上的<code>flv</code>时移推进一下进度。</p><p><img src="/2019/02/27/start-learn-new-technology/docker.png" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Docker</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Go文件操作大全</title>
    <url>/2019/02/25/go-file-operation-finish/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h1 id="Go文件操作大全"><a href="#Go文件操作大全" class="headerlink" title="Go文件操作大全"></a>Go文件操作大全</h1><h2 id="1，介绍"><a href="#1，介绍" class="headerlink" title="1，介绍"></a>1，介绍</h2><h3 id="1-1-万物皆文件"><a href="#1-1-万物皆文件" class="headerlink" title="1.1 万物皆文件"></a>1.1 万物皆文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">One of the fundamental aspects of UNIX is that everything is a file. We don&apos;t necessarily know what the file descriptor maps to, that is abstracted by the operating system&apos;s device drivers. The operating system provides us an interface to the device in the form of a file.</span><br><span class="line"></span><br><span class="line">The reader and writer interfaces in Go are similar abstractions. We simply read and write bytes, without the need to understand where or how the reader gets its data or where the writer is sending the data. Look in /dev to find available devices. Some will require elevated privileges to access.</span><br></pre></td></tr></table></figure><p>在此引用刘超老师专栏里写的话</p><h4 id="Linux一切皆文件"><a href="#Linux一切皆文件" class="headerlink" title="Linux一切皆文件"></a>Linux一切皆文件</h4><ul><li>启动一个进程，需要一个程序文件，这是一个二进制文件</li><li>启动的时候，要加载一些配置文件，例如yml、properties等，这是配置文件；启动之后会打印一些日志，如果写到硬盘上，也是文本文件；如果我想把日志打印到交互控制台上，在命令行上打印出来，这是一个标准输出的stdout文件</li><li>这个进程的输出可以作为另一个进程的输入，这种方式称为管道，它也是一个文件</li><li>进程可以通过网络和其他进程进行通信，建立的Socket，也是一个文件</li><li>进程需要访问外部设备，设备也是一个文件</li><li>文件都被存储在文件夹里面，文件夹也是一个文件</li><li>进程运行起来，要想看到进程运行的情况，会在/proc下面有对应的进程号，也是一系列的文件</li></ul><h2 id="2，基本操作"><a href="#2，基本操作" class="headerlink" title="2，基本操作"></a>2，基本操作</h2><h3 id="2-1-创建空文件"><a href="#2-1-创建空文件" class="headerlink" title="2.1 创建空文件"></a>2.1 创建空文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    newFile *os.File</span><br><span class="line">    err     error</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    newFile, err = os.Create(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(newFile)</span><br><span class="line">    newFile.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-缩短文件"><a href="#2-2-缩短文件" class="headerlink" title="2.2 缩短文件"></a>2.2 缩短文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 裁剪一个文件到100个字节。</span></span><br><span class="line">    <span class="comment">// 如果文件本来就少于100个字节，则文件中原始内容得以保留，剩余的字节以null字节填充。</span></span><br><span class="line">    <span class="comment">// 如果文件本来超过100个字节，则超过的字节会被抛弃。</span></span><br><span class="line">    <span class="comment">// 这样我们总是得到精确的100个字节的文件。</span></span><br><span class="line">    <span class="comment">// 传入0则会清空文件。</span></span><br><span class="line">    err := os.Truncate(<span class="string">"test.txt"</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-获取文件信息"><a href="#2-3-获取文件信息" class="headerlink" title="2.3 获取文件信息"></a>2.3 获取文件信息</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    fileInfo os.FileInfo</span><br><span class="line">    err      error</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果文件不存在，则返回错误</span></span><br><span class="line">    fileInfo, err = os.Stat(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"File name:"</span>, fileInfo.Name())</span><br><span class="line">    fmt.Println(<span class="string">"Size in bytes:"</span>, fileInfo.Size())</span><br><span class="line">    fmt.Println(<span class="string">"Permissions:"</span>, fileInfo.Mode())</span><br><span class="line">    fmt.Println(<span class="string">"Last modified:"</span>, fileInfo.ModTime())</span><br><span class="line">    fmt.Println(<span class="string">"Is Directory: "</span>, fileInfo.IsDir())</span><br><span class="line">    fmt.Printf(<span class="string">"System interface type: %T\n"</span>, fileInfo.Sys())</span><br><span class="line">    fmt.Printf(<span class="string">"System info: %+v\n\n"</span>, fileInfo.Sys())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-重命名和移动文件"><a href="#2-4-重命名和移动文件" class="headerlink" title="2.4 重命名和移动文件"></a>2.4 重命名和移动文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    originalPath := <span class="string">"test.txt"</span></span><br><span class="line">    newPath := <span class="string">"test2.txt"</span></span><br><span class="line">    err := os.Rename(originalPath, newPath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-删除一个文件"><a href="#2-5-删除一个文件" class="headerlink" title="2.5 删除一个文件"></a>2.5 删除一个文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := os.Remove(<span class="string">"test.txt"</span>)  <span class="comment">//Remove 移除</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-打开和关闭文件"><a href="#2-6-打开和关闭文件" class="headerlink" title="2.6 打开和关闭文件"></a>2.6 打开和关闭文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 简单地以只读的方式打开。下面的例子会介绍读写的例子。</span></span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">    <span class="comment">// OpenFile提供更多的选项。</span></span><br><span class="line">    <span class="comment">// 最后一个参数是权限模式permission mode</span></span><br><span class="line">    <span class="comment">// 第二个是打开时的属性    </span></span><br><span class="line">    file, err = os.OpenFile(<span class="string">"test.txt"</span>, os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">    <span class="comment">// 下面的属性可以单独使用，也可以组合使用。</span></span><br><span class="line">    <span class="comment">// 组合使用时可以使用 OR 操作设置 OpenFile的第二个参数，例如：</span></span><br><span class="line">    <span class="comment">// os.O_CREATE|os.O_APPEND</span></span><br><span class="line">    <span class="comment">// 或者 os.O_CREATE|os.O_TRUNC|os.O_WRONLY</span></span><br><span class="line">    <span class="comment">// os.O_RDONLY // 只读</span></span><br><span class="line">    <span class="comment">// os.O_WRONLY // 只写</span></span><br><span class="line">    <span class="comment">// os.O_RDWR // 读和写</span></span><br><span class="line">    <span class="comment">// os.O_APPEND // 往文件末尾添加（Append）</span></span><br><span class="line">    <span class="comment">// os.O_CREATE // 如果文件不存在时则先创建这个文件</span></span><br><span class="line">    <span class="comment">// os.O_TRUNC // 文件打开时裁剪文件</span></span><br><span class="line">    <span class="comment">// os.O_EXCL // 和O_CREATE一起使用，文件不能存在</span></span><br><span class="line">    <span class="comment">// os.O_SYNC // 以同步I/O的方式打开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-判断这个文件是否存在"><a href="#2-7-判断这个文件是否存在" class="headerlink" title="2.7 判断这个文件是否存在"></a>2.7 判断这个文件是否存在</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    fileInfo *os.FileInfo</span><br><span class="line">    err      error</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 文件不存在则返回error</span></span><br><span class="line">    fileInfo, err := os.Stat(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line">            log.Fatal(<span class="string">"File does not exist."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">"File does exist. File information:"</span>)</span><br><span class="line">    log.Println(fileInfo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8-检查读写权限"><a href="#2-8-检查读写权限" class="headerlink" title="2.8 检查读写权限"></a>2.8 检查读写权限</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这个例子测试写权限，如果没有写权限则返回error。</span></span><br><span class="line">    <span class="comment">// 注意文件不存在也会返回error，需要检查error的信息来获取到底是哪个错误导致。</span></span><br><span class="line">    file, err := os.OpenFile(<span class="string">"test.txt"</span>, os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> os.IsPermission(err) &#123;</span><br><span class="line">            log.Println(<span class="string">"Error: Write permission denied."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">    <span class="comment">// 测试读权限</span></span><br><span class="line">    file, err = os.OpenFile(<span class="string">"test.txt"</span>, os.O_RDONLY, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> os.IsPermission(err) &#123;</span><br><span class="line">            log.Println(<span class="string">"Error: Read permission denied."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-9-改变权限、拥有者、时间戳"><a href="#2-9-改变权限、拥有者、时间戳" class="headerlink" title="2.9 改变权限、拥有者、时间戳"></a>2.9 改变权限、拥有者、时间戳</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用Linux风格改变文件权限</span></span><br><span class="line">    err := os.Chmod(<span class="string">"test.txt"</span>, <span class="number">0777</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改变文件所有者</span></span><br><span class="line">    err = os.Chown(<span class="string">"test.txt"</span>, os.Getuid(), os.Getgid())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改变时间戳</span></span><br><span class="line">    twoDaysFromNow := time.Now().Add(<span class="number">48</span> * time.Hour)</span><br><span class="line">    lastAccessTime := twoDaysFromNow</span><br><span class="line">    lastModifyTime := twoDaysFromNow</span><br><span class="line">    err = os.Chtimes(<span class="string">"test.txt"</span>, lastAccessTime, lastModifyTime)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-10-硬链接和软链接"><a href="#2-10-硬链接和软链接" class="headerlink" title="2.10 硬链接和软链接"></a>2.10 硬链接和软链接</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个硬链接。</span></span><br><span class="line">    <span class="comment">// 创建后同一个文件内容会有两个文件名，改变一个文件的内容会影响另一个。</span></span><br><span class="line">    <span class="comment">// 删除和重命名不会影响另一个。</span></span><br><span class="line">    err := os.Link(<span class="string">"original.txt"</span>, <span class="string">"original_also.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"creating sym"</span>)</span><br><span class="line">    <span class="comment">// Create a symlink</span></span><br><span class="line">    err = os.Symlink(<span class="string">"original.txt"</span>, <span class="string">"original_sym.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Lstat返回一个文件的信息，但是当文件是一个软链接时，它返回软链接的信息，而不是引用的文件的信息。</span></span><br><span class="line">    <span class="comment">// Symlink在Windows中不工作。</span></span><br><span class="line">    fileInfo, err := os.Lstat(<span class="string">"original_sym.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Link info: %+v"</span>, fileInfo)</span><br><span class="line">    <span class="comment">//改变软链接的拥有者不会影响原始文件。</span></span><br><span class="line">    err = os.Lchown(<span class="string">"original_sym.txt"</span>, os.Getuid(), os.Getgid())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3，读写"><a href="#3，读写" class="headerlink" title="3，读写"></a>3，读写</h2><h3 id="3-1-复制文件"><a href="#3-1-复制文件" class="headerlink" title="3.1 复制文件"></a>3.1 复制文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打开原始文件</span></span><br><span class="line">    originalFile, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> originalFile.Close()</span><br><span class="line">    <span class="comment">// 创建新的文件作为目标文件</span></span><br><span class="line">    newFile, err := os.Create(<span class="string">"test_copy.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> newFile.Close()</span><br><span class="line">    <span class="comment">// 从源中复制字节到目标文件</span></span><br><span class="line">    bytesWritten, err := io.Copy(newFile, originalFile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Copied %d bytes."</span>, bytesWritten)</span><br><span class="line">    <span class="comment">// 将文件内容flush到硬盘中</span></span><br><span class="line">    err = newFile.Sync()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-跳转到文件指定位置（Seek）"><a href="#3-2-跳转到文件指定位置（Seek）" class="headerlink" title="3.2 跳转到文件指定位置（Seek）"></a>3.2 跳转到文件指定位置（Seek）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, _ := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="comment">// 偏离位置，可以是正数也可以是负数</span></span><br><span class="line">    <span class="keyword">var</span> offset <span class="keyword">int64</span> = <span class="number">5</span></span><br><span class="line">    <span class="comment">// 用来计算offset的初始位置</span></span><br><span class="line">    <span class="comment">// 0 = 文件开始位置</span></span><br><span class="line">    <span class="comment">// 1 = 当前位置</span></span><br><span class="line">    <span class="comment">// 2 = 文件结尾处</span></span><br><span class="line">    <span class="keyword">var</span> whence <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">    newPosition, err := file.Seek(offset, whence)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Just moved to 5:"</span>, newPosition)</span><br><span class="line">    <span class="comment">// 从当前位置回退两个字节</span></span><br><span class="line">    newPosition, err = file.Seek(<span class="number">-2</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Just moved back two:"</span>, newPosition)</span><br><span class="line">    <span class="comment">// 使用下面的技巧得到当前的位置</span></span><br><span class="line">    currentPosition, err := file.Seek(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    fmt.Println(<span class="string">"Current position:"</span>, currentPosition)</span><br><span class="line">    <span class="comment">// 转到文件开始处</span></span><br><span class="line">    newPosition, err = file.Seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Position after seeking 0,0:"</span>, newPosition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-写文件"><a href="#3-3-写文件" class="headerlink" title="3.3 写文件"></a>3.3 写文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 可写方式打开文件</span></span><br><span class="line">    file, err := os.OpenFile(</span><br><span class="line">        <span class="string">"test.txt"</span>,</span><br><span class="line">        os.O_WRONLY|os.O_TRUNC|os.O_CREATE,</span><br><span class="line">        <span class="number">0666</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="comment">// 写字节到文件中</span></span><br><span class="line">    byteSlice := []<span class="keyword">byte</span>(<span class="string">"Bytes!\n"</span>)</span><br><span class="line">    bytesWritten, err := file.Write(byteSlice)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Wrote %d bytes.\n"</span>, bytesWritten)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-快写文件"><a href="#3-4-快写文件" class="headerlink" title="3.4 快写文件"></a>3.4 快写文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := ioutil.WriteFile(<span class="string">"test.txt"</span>, []<span class="keyword">byte</span>(<span class="string">"Hi\n"</span>), <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-使用缓存写"><a href="#3-5-使用缓存写" class="headerlink" title="3.5 使用缓存写"></a>3.5 使用缓存写</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打开文件，只写</span></span><br><span class="line">    file, err := os.OpenFile(<span class="string">"test.txt"</span>, os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="comment">// 为这个文件创建buffered writer</span></span><br><span class="line">    bufferedWriter := bufio.NewWriter(file)</span><br><span class="line">    <span class="comment">// 写字节到buffer</span></span><br><span class="line">    bytesWritten, err := bufferedWriter.Write(</span><br><span class="line">        []<span class="keyword">byte</span>&#123;<span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>&#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Bytes written: %d\n"</span>, bytesWritten)</span><br><span class="line">    <span class="comment">// 写字符串到buffer</span></span><br><span class="line">    <span class="comment">// 也可以使用 WriteRune() 和 WriteByte()   </span></span><br><span class="line">    bytesWritten, err = bufferedWriter.WriteString(</span><br><span class="line">        <span class="string">"Buffered string\n"</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Bytes written: %d\n"</span>, bytesWritten)</span><br><span class="line">    <span class="comment">// 检查缓存中的字节数</span></span><br><span class="line">    unflushedBufferSize := bufferedWriter.Buffered()</span><br><span class="line">    log.Printf(<span class="string">"Bytes buffered: %d\n"</span>, unflushedBufferSize)</span><br><span class="line">    <span class="comment">// 还有多少字节可用（未使用的缓存大小）</span></span><br><span class="line">    bytesAvailable := bufferedWriter.Available()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Available buffer: %d\n"</span>, bytesAvailable)</span><br><span class="line">    <span class="comment">// 写内存buffer到硬盘</span></span><br><span class="line">    bufferedWriter.Flush()</span><br><span class="line">    <span class="comment">// 丢弃还没有flush的缓存的内容，清除错误并把它的输出传给参数中的writer</span></span><br><span class="line">    <span class="comment">// 当你想将缓存传给另外一个writer时有用</span></span><br><span class="line">    bufferedWriter.Reset(bufferedWriter)</span><br><span class="line">    bytesAvailable = bufferedWriter.Available()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Available buffer: %d\n"</span>, bytesAvailable)</span><br><span class="line">    <span class="comment">// 重新设置缓存的大小。</span></span><br><span class="line">    <span class="comment">// 第一个参数是缓存应该输出到哪里，这个例子中我们使用相同的writer。</span></span><br><span class="line">    <span class="comment">// 如果我们设置的新的大小小于第一个参数writer的缓存大小， 比如10，我们不会得到一个10字节大小的缓存，</span></span><br><span class="line">    <span class="comment">// 而是writer的原始大小的缓存，默认是4096。</span></span><br><span class="line">    <span class="comment">// 它的功能主要还是为了扩容。</span></span><br><span class="line">    bufferedWriter = bufio.NewWriterSize(</span><br><span class="line">        bufferedWriter,</span><br><span class="line">        <span class="number">8000</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// resize后检查缓存的大小</span></span><br><span class="line">    bytesAvailable = bufferedWriter.Available()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Available buffer: %d\n"</span>, bytesAvailable)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-读取最多N个字节"><a href="#3-6-读取最多N个字节" class="headerlink" title="3.6 读取最多N个字节"></a>3.6 读取最多N个字节</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打开文件，只读</span></span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="comment">// 从文件中读取len(b)字节的文件。</span></span><br><span class="line">    <span class="comment">// 返回0字节意味着读取到文件尾了</span></span><br><span class="line">    <span class="comment">// 读取到文件会返回io.EOF的error</span></span><br><span class="line">    byteSlice := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">16</span>)</span><br><span class="line">    bytesRead, err := file.Read(byteSlice)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Number of bytes read: %d\n"</span>, bytesRead)</span><br><span class="line">    log.Printf(<span class="string">"Data read: %s\n"</span>, byteSlice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-读取正好N个字节"><a href="#3-7-读取正好N个字节" class="headerlink" title="3.7 读取正好N个字节"></a>3.7 读取正好N个字节</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Open file for reading</span></span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// file.Read()可以读取一个小文件到大的byte slice中，</span></span><br><span class="line">    <span class="comment">// 但是io.ReadFull()在文件的字节数小于byte slice字节数的时候会返回错误</span></span><br><span class="line">    byteSlice := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">2</span>)</span><br><span class="line">    numBytesRead, err := io.ReadFull(file, byteSlice)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Number of bytes read: %d\n"</span>, numBytesRead)</span><br><span class="line">    log.Printf(<span class="string">"Data read: %s\n"</span>, byteSlice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-读取至少N个字节"><a href="#3-8-读取至少N个字节" class="headerlink" title="3.8 读取至少N个字节"></a>3.8 读取至少N个字节</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打开文件，只读</span></span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    byteSlice := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">512</span>)</span><br><span class="line">    minBytes := <span class="number">8</span></span><br><span class="line">    <span class="comment">// io.ReadAtLeast()在不能得到最小的字节的时候会返回错误，但会把已读的文件保留</span></span><br><span class="line">    numBytesRead, err := io.ReadAtLeast(file, byteSlice, minBytes)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Number of bytes read: %d\n"</span>, numBytesRead)</span><br><span class="line">    log.Printf(<span class="string">"Data read: %s\n"</span>, byteSlice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-9-读取全部字节"><a href="#3-9-读取全部字节" class="headerlink" title="3.9 读取全部字节"></a>3.9 读取全部字节</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Open file for reading</span></span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// os.File.Read(), io.ReadFull(), and</span></span><br><span class="line">    <span class="comment">// io.ReadAtLeast() all work with a fixed</span></span><br><span class="line">    <span class="comment">// byte slice that you make before you read</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ioutil.ReadAll() will read every byte</span></span><br><span class="line">    <span class="comment">// from the reader (in this case a file),</span></span><br><span class="line">    <span class="comment">// and return a slice of unknown slice</span></span><br><span class="line">    data, err := ioutil.ReadAll(file)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"Data as hex: %x\n"</span>, data)</span><br><span class="line">    fmt.Printf(<span class="string">"Data as string: %s\n"</span>, data)</span><br><span class="line">    fmt.Println(<span class="string">"Number of bytes read:"</span>, <span class="built_in">len</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-10-快速读到内存中"><a href="#3-10-快速读到内存中" class="headerlink" title="3.10 快速读到内存中"></a>3.10 快速读到内存中</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 读取文件到byte slice中</span></span><br><span class="line">    data, err := ioutil.ReadFile(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Data read: %s\n"</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-11-使用缓存读"><a href="#3-11-使用缓存读" class="headerlink" title="3.11 使用缓存读"></a>3.11 使用缓存读</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打开文件，创建buffered reader</span></span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    bufferedReader := bufio.NewReader(file)</span><br><span class="line">    <span class="comment">// 得到字节，当前指针不变</span></span><br><span class="line">    byteSlice := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">5</span>)</span><br><span class="line">    byteSlice, err = bufferedReader.Peek(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Peeked at 5 bytes: %s\n"</span>, byteSlice)</span><br><span class="line">    <span class="comment">// 读取，指针同时移动</span></span><br><span class="line">    numBytesRead, err := bufferedReader.Read(byteSlice)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Read %d bytes: %s\n"</span>, numBytesRead, byteSlice)</span><br><span class="line">    <span class="comment">// 读取一个字节, 如果读取不成功会返回Error</span></span><br><span class="line">    myByte, err := bufferedReader.ReadByte()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Read 1 byte: %c\n"</span>, myByte)     </span><br><span class="line">    <span class="comment">// 读取到分隔符，包含分隔符，返回byte slice</span></span><br><span class="line">    dataBytes, err := bufferedReader.ReadBytes(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Read bytes: %s\n"</span>, dataBytes)           </span><br><span class="line">    <span class="comment">// 读取到分隔符，包含分隔符，返回字符串</span></span><br><span class="line">    dataString, err := bufferedReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Read string: %s\n"</span>, dataString)     </span><br><span class="line">    <span class="comment">//这个例子读取了很多行，所以test.txt应该包含多行文本才不至于出错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-12-使用-scanner"><a href="#3-12-使用-scanner" class="headerlink" title="3.12 使用 scanner"></a>3.12 使用 scanner</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// To define your own split function, match this fingerprint</span></span><br><span class="line"><span class="keyword">type</span> SplitFunc <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">Returning</span> <span class="params">(0, <span class="literal">nil</span>, <span class="literal">nil</span>)</span> <span class="title">will</span> <span class="title">tell</span> <span class="title">the</span> <span class="title">scanner</span></span></span><br><span class="line"><span class="function">// <span class="title">to</span> <span class="title">scan</span> <span class="title">again</span>, <span class="title">but</span> <span class="title">with</span> <span class="title">a</span> <span class="title">bigger</span> <span class="title">buffer</span> <span class="title">because</span></span></span><br><span class="line"><span class="function">// <span class="title">it</span> <span class="title">wasn</span>'<span class="title">t</span> <span class="title">enough</span> <span class="title">data</span> <span class="title">to</span> <span class="title">reach</span> <span class="title">the</span> <span class="title">delimiter</span></span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    scanner := bufio.NewScanner(file)</span><br><span class="line">    <span class="comment">// 缺省的分隔函数是bufio.ScanLines,我们这里使用ScanWords。</span></span><br><span class="line">    <span class="comment">// 也可以定制一个SplitFunc类型的分隔函数</span></span><br><span class="line">    scanner.Split(bufio.ScanWords)</span><br><span class="line">    <span class="comment">// scan下一个token.</span></span><br><span class="line">    success := scanner.Scan()</span><br><span class="line">    <span class="keyword">if</span> success == <span class="literal">false</span> &#123;</span><br><span class="line">        <span class="comment">// 出现错误或者EOF是返回Error</span></span><br><span class="line">        err = scanner.Err()</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">"Scan completed and reached EOF"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到数据，Bytes() 或者 Text()</span></span><br><span class="line">    fmt.Println(<span class="string">"First word found:"</span>, scanner.Text())</span><br><span class="line">    <span class="comment">// 再次调用scanner.Scan()发现下一个token</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4，压缩"><a href="#4，压缩" class="headerlink" title="4，压缩"></a>4，压缩</h2><h3 id="4-1-打包文件"><a href="#4-1-打包文件" class="headerlink" title="4.1 打包文件"></a>4.1 打包文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This example uses zip but standard library</span></span><br><span class="line"><span class="comment">// also supports tar archives</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"archive/zip"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Create a file to write the archive buffer to</span></span><br><span class="line">    <span class="comment">// Could also use an in memory buffer.</span></span><br><span class="line">    outFile, err := os.Create(<span class="string">"test.zip"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> outFile.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a zip writer on top of the file writer</span></span><br><span class="line">    zipWriter := zip.NewWriter(outFile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add files to archive</span></span><br><span class="line">    <span class="comment">// We use some hard coded data to demonstrate,</span></span><br><span class="line">    <span class="comment">// but you could iterate through all the files</span></span><br><span class="line">    <span class="comment">// in a directory and pass the name and contents</span></span><br><span class="line">    <span class="comment">// of each file, or you can take data from your</span></span><br><span class="line">    <span class="comment">// program and write it write in to the archive</span></span><br><span class="line">    <span class="comment">// without </span></span><br><span class="line">    <span class="keyword">var</span> filesToArchive = []<span class="keyword">struct</span> &#123;</span><br><span class="line">        Name, Body <span class="keyword">string</span></span><br><span class="line">    &#125; &#123;</span><br><span class="line">        &#123;<span class="string">"test.txt"</span>, <span class="string">"String contents of file"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"test2.txt"</span>, <span class="string">"\x61\x62\x63\n"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create and write files to the archive, which in turn</span></span><br><span class="line">    <span class="comment">// are getting written to the underlying writer to the</span></span><br><span class="line">    <span class="comment">// .zip file we created at the beginning</span></span><br><span class="line">    <span class="keyword">for</span> _, file := <span class="keyword">range</span> filesToArchive &#123;</span><br><span class="line">            fileWriter, err := zipWriter.Create(file.Name)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    log.Fatal(err)</span><br><span class="line">            &#125;</span><br><span class="line">            _, err = fileWriter.Write([]<span class="keyword">byte</span>(file.Body))</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    log.Fatal(err)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up</span></span><br><span class="line">    err = zipWriter.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-解压文件"><a href="#4-2-解压文件" class="headerlink" title="4.2 解压文件"></a>4.2 解压文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This example uses zip but standard library</span></span><br><span class="line"><span class="comment">// also supports tar archives</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"archive/zip"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"path/filepath"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    zipReader, err := zip.OpenReader(<span class="string">"test.zip"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> zipReader.Close()</span><br><span class="line">    <span class="comment">// 遍历打包文件中的每一文件/文件夹</span></span><br><span class="line">    <span class="keyword">for</span> _, file := <span class="keyword">range</span> zipReader.Reader.File &#123;</span><br><span class="line">        <span class="comment">// 打包文件中的文件就像普通的一个文件对象一样</span></span><br><span class="line">        zippedFile, err := file.Open()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> zippedFile.Close()</span><br><span class="line">        <span class="comment">// 指定抽取的文件名。</span></span><br><span class="line">        <span class="comment">// 你可以指定全路径名或者一个前缀，这样可以把它们放在不同的文件夹中。</span></span><br><span class="line">        <span class="comment">// 我们这个例子使用打包文件中相同的文件名。</span></span><br><span class="line">        targetDir := <span class="string">"./"</span></span><br><span class="line">        extractedFilePath := filepath.Join(</span><br><span class="line">            targetDir,</span><br><span class="line">            file.Name,</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// 抽取项目或者创建文件夹</span></span><br><span class="line">        <span class="keyword">if</span> file.FileInfo().IsDir() &#123;</span><br><span class="line">            <span class="comment">// 创建文件夹并设置同样的权限</span></span><br><span class="line">            log.Println(<span class="string">"Creating directory:"</span>, extractedFilePath)</span><br><span class="line">            os.MkdirAll(extractedFilePath, file.Mode())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//抽取正常的文件</span></span><br><span class="line">            log.Println(<span class="string">"Extracting file:"</span>, file.Name)</span><br><span class="line">            outputFile, err := os.OpenFile(</span><br><span class="line">                extractedFilePath,</span><br><span class="line">                os.O_WRONLY|os.O_CREATE|os.O_TRUNC,</span><br><span class="line">                file.Mode(),</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatal(err)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">defer</span> outputFile.Close()</span><br><span class="line">            <span class="comment">// 通过io.Copy简洁地复制文件内容</span></span><br><span class="line">            _, err = io.Copy(outputFile, zippedFile)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatal(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-压缩文件"><a href="#4-3-压缩文件" class="headerlink" title="4.3 压缩文件"></a>4.3 压缩文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个例子中使用gzip压缩格式，标准库还支持zlib, bz2, flate, lzw</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"compress/gzip"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    outputFile, err := os.Create(<span class="string">"test.txt.gz"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    gzipWriter := gzip.NewWriter(outputFile)</span><br><span class="line">    <span class="keyword">defer</span> gzipWriter.Close()</span><br><span class="line">    <span class="comment">// 当我们写如到gizp writer数据时，它会依次压缩数据并写入到底层的文件中。</span></span><br><span class="line">    <span class="comment">// 我们不必关心它是如何压缩的，还是像普通的writer一样操作即可。</span></span><br><span class="line">    _, err = gzipWriter.Write([]<span class="keyword">byte</span>(<span class="string">"Gophers rule!\n"</span>))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">"Compressed data written to file."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解压缩文件"><a href="#解压缩文件" class="headerlink" title="解压缩文件"></a>解压缩文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个例子中使用gzip压缩格式，标准库还支持zlib, bz2, flate, lzw</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"compress/gzip"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打开一个gzip文件。</span></span><br><span class="line">    <span class="comment">// 文件是一个reader,但是我们可以使用各种数据源，比如web服务器返回的gzipped内容，</span></span><br><span class="line">    <span class="comment">// 它的内容不是一个文件，而是一个内存流</span></span><br><span class="line">    gzipFile, err := os.Open(<span class="string">"test.txt.gz"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    gzipReader, err := gzip.NewReader(gzipFile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> gzipReader.Close()</span><br><span class="line">    <span class="comment">// 解压缩到一个writer,它是一个file writer</span></span><br><span class="line">    outfileWriter, err := os.Create(<span class="string">"unzipped.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> outfileWriter.Close()</span><br><span class="line">    <span class="comment">// 复制内容</span></span><br><span class="line">    _, err = io.Copy(outfileWriter, gzipReader)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5，其它"><a href="#5，其它" class="headerlink" title="5，其它"></a>5，其它</h2><h3 id="5-1-临时文件和目录"><a href="#5-1-临时文件和目录" class="headerlink" title="5.1 临时文件和目录"></a>5.1 临时文件和目录</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">     <span class="string">"os"</span></span><br><span class="line">     <span class="string">"io/ioutil"</span></span><br><span class="line">     <span class="string">"log"</span></span><br><span class="line">     <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="comment">// 在系统临时文件夹中创建一个临时文件夹</span></span><br><span class="line">     tempDirPath, err := ioutil.TempDir(<span class="string">""</span>, <span class="string">"myTempDir"</span>)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Fatal(err)</span><br><span class="line">     &#125;</span><br><span class="line">     fmt.Println(<span class="string">"Temp dir created:"</span>, tempDirPath)</span><br><span class="line">     <span class="comment">// 在临时文件夹中创建临时文件</span></span><br><span class="line">     tempFile, err := ioutil.TempFile(tempDirPath, <span class="string">"myTempFile.txt"</span>)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Fatal(err)</span><br><span class="line">     &#125;</span><br><span class="line">     fmt.Println(<span class="string">"Temp file created:"</span>, tempFile.Name())</span><br><span class="line">     <span class="comment">// ... 做一些操作 ...</span></span><br><span class="line">     <span class="comment">// 关闭文件</span></span><br><span class="line">     err = tempFile.Close()</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除我们创建的资源</span></span><br><span class="line">     err = os.Remove(tempFile.Name())</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">     err = os.Remove(tempDirPath)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-通过HTTP下载文件"><a href="#5-2-通过HTTP下载文件" class="headerlink" title="5.2 通过HTTP下载文件"></a>5.2 通过HTTP下载文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">     <span class="string">"os"</span></span><br><span class="line">     <span class="string">"io"</span></span><br><span class="line">     <span class="string">"log"</span></span><br><span class="line">     <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">     newFile, err := os.Create(<span class="string">"devdungeon.html"</span>)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Fatal(err)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">defer</span> newFile.Close()</span><br><span class="line">     url := <span class="string">"http://www.devdungeon.com/archive"</span></span><br><span class="line">     response, err := http.Get(url)</span><br><span class="line">     <span class="keyword">defer</span> response.Body.Close()</span><br><span class="line">     <span class="comment">// 将HTTP response Body中的内容写入到文件</span></span><br><span class="line">     <span class="comment">// Body满足reader接口，因此我们可以使用ioutil.Copy</span></span><br><span class="line">     numBytesWritten, err := io.Copy(newFile, response.Body)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Fatal(err)</span><br><span class="line">     &#125;</span><br><span class="line">     log.Printf(<span class="string">"Downloaded %d byte file.\n"</span>, numBytesWritten)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-哈希和摘要"><a href="#5-3-哈希和摘要" class="headerlink" title="5.3 哈希和摘要"></a>5.3 哈希和摘要</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/md5"</span></span><br><span class="line">    <span class="string">"crypto/sha1"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"crypto/sha512"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 得到文件内容</span></span><br><span class="line">    data, err := ioutil.ReadFile(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算Hash</span></span><br><span class="line">    fmt.Printf(<span class="string">"Md5: %x\n\n"</span>, md5.Sum(data))</span><br><span class="line">    fmt.Printf(<span class="string">"Sha1: %x\n\n"</span>, sha1.Sum(data))</span><br><span class="line">    fmt.Printf(<span class="string">"Sha256: %x\n\n"</span>, sha256.Sum256(data))</span><br><span class="line">    fmt.Printf(<span class="string">"Sha512: %x\n\n"</span>, sha512.Sum512(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/md5"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="comment">//创建一个新的hasher,满足writer接口</span></span><br><span class="line">    hasher := md5.New()</span><br><span class="line">    _, err = io.Copy(hasher, file)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算hash并打印结果。</span></span><br><span class="line">    <span class="comment">// 传递 nil 作为参数，因为我们不通参数传递数据，而是通过writer接口。</span></span><br><span class="line">    sum := hasher.Sum(<span class="literal">nil</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"Md5 checksum: %x\n"</span>, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6，参考"><a href="#6，参考" class="headerlink" title="6，参考"></a>6，参考</h2><ul><li><a href="https://www.devdungeon.com/content/working-files-go" target="_blank" rel="noopener">Working with Files in Go</a></li><li><a href="https://golang.org/pkg" target="_blank" rel="noopener">Go Standard Library Documentation</a></li><li><a href="https://www.linux.com/learn/understanding-linux-file-permissions" target="_blank" rel="noopener">understanding-linux-file-permissions</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>一些生活好习惯</title>
    <url>/2019/02/23/life-good-habit/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><p>又是一个周末，又是晚睡晚起，早饭随便吃一点，总说着要注意休息，但总不当回事。</p><p>在此立一个flag，从今天起，如果不是特别紧急的事情，哪怕留到明天去做，我也一定要早点睡觉！！！</p><h2 id="每天要做"><a href="#每天要做" class="headerlink" title="每天要做"></a>每天要做</h2><ul><li><p>晚上十点前准时上床睡觉，早上六点起床。</p></li><li><p>坚持吃早饭，鸡蛋牛奶蔬菜面包水果玉米糊糊都行，吃六分饱即可。</p></li><li><p>上班骑车，或走路，锻炼身体，公司离住处很近，所以不要太急，过马路看红绿灯，礼让行人。</p></li><li><p>早上坚持练习英语口语，背记英语单词。</p></li><li><p>到了工作时间，先把工作上的事情做完，再做其他的。</p></li><li><p>中午保证半小时的睡眠时间，不玩手机。</p></li><li><p>完成一个<code>LeetCode</code>上的编程题。</p></li><li><p>出门前对自己一个微笑。</p></li><li><p>写日记。</p></li></ul><h2 id="每周要做"><a href="#每周要做" class="headerlink" title="每周要做"></a>每周要做</h2><ul><li><p>去健身房锻炼身体三次，跑步，肌肉练习均可。</p></li><li><p>至少完成一个ARTS。</p></li><li><p>和家里人打电话，对他们说我很好；和伶儿通个电话，并告诉她我很想你。</p></li><li><p>去吃点好吃的，见一见朋友，放松身心。</p></li></ul><h2 id="每月要做"><a href="#每月要做" class="headerlink" title="每月要做"></a>每月要做</h2><ul><li><p>做总结。</p></li><li><p>读完一本科普或小说。</p></li></ul><h2 id="每年要做"><a href="#每年要做" class="headerlink" title="每年要做"></a>每年要做</h2><ul><li><p>去一个自己从没去过的地方。</p></li><li><p>回家陪父母聊聊天。</p></li></ul><p><img src="/2019/02/23/life-good-habit/flower.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>健康</tag>
      </tags>
  </entry>
  <entry>
    <title>当你孤单时你会想起谁</title>
    <url>/2019/02/22/when-you-lonely-remand-who/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><p>这一周，我提前一天完成了我的任务，用<code>Golang</code>给视频转码写了个小工具，复习了二进制基础，文件操作和<code>Golang</code>基本语法。</p><p>下午，一位朋友and他女友来看我，一起吃了顿冒菜，让我这平淡的周末多了份意料之外的喜悦。</p><h2 id="亲爱的，你怎么不在我身边"><a href="#亲爱的，你怎么不在我身边" class="headerlink" title="亲爱的，你怎么不在我身边"></a>亲爱的，你怎么不在我身边</h2><p>距离上次会合已经过去一个月，却让我感觉如昨日。</p><p>想起我们一起看过日出，站在塔里木大桥上看日落，在乌鲁木齐大冬天跑出去看电影吃麻辣小龙虾，去西安吃酿皮和肉夹馍，到成都看熊猫。</p><p>可是，这个周末，亲爱的你为什么不在我身边。</p><h2 id="当你孤单时你会想起谁"><a href="#当你孤单时你会想起谁" class="headerlink" title="当你孤单时你会想起谁"></a>当你孤单时你会想起谁</h2><p>想起远在乌鲁木齐的父母，从此养成了报喜不报忧的“好习惯”；</p><p>想起远在厦门的凡儿，没事调侃两句，解解闷；</p><p>想起远在家里蹲的羊纪元，吹吹牛释放下压力；</p><p>想起远在西安做销售的魁拔，高中时教我弹吉他和护肤，在QQ炫舞上一同唱着《老男孩》；</p><h2 id="我要你在我身旁"><a href="#我要你在我身旁" class="headerlink" title="我要你在我身旁"></a>我要你在我身旁</h2><p>你说你毕设答辩结束就坐飞机来成都，我想起去年我也说，我答完辩把论文材料提交完毕立马坐最近的一趟飞机去成都找你，顺便把offer拿了。</p><p>现在过了一年，角色互换，我相信，我们的异地恋接近尾声。</p><p>我在成都等你。</p><p><img src="/2019/02/22/when-you-lonely-remand-who/wait.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>孤单</tag>
        <tag>思念</tag>
      </tags>
  </entry>
  <entry>
    <title>放假归来上班综合症</title>
    <url>/2019/02/12/return-to-work-after-vacation/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><p>春节结束，放假归来，已在公司上班两天。</p><p>向公司行政部申请买了块8G台式机内存条，额头上又隐约在冒痘痘了，半年过去了，难道还没有适应南方的气候？</p><p>伶儿说她明天早上七点就到乌鲁木齐了，距离我们下次见面就是她在学校答辩完，五月底六月初的样子。下次重逢，不要再分开了好吗？</p><p>哈哈，突然觉得自己好矫情，说这些。</p><p>昨天浑身酸痛，什么也不想做。今天试着看了些技术书，看不进去里面的概念，试着刷了几道LeetCode关于数组的题目，收获还行。</p><p>又要开始程序化的生活了，早起-骑车-工作-看书-下班-玩/学习-睡觉，如此循环。</p><p>好想做一些白日梦骗自己几分钟，又感到幼稚。</p><p>乱七八糟的写了些话，记录放假归来后内心烦躁的情绪。</p><p>不管怎样，生活还得继续，世界还等着我创造奇迹。</p><p><img src="/2019/02/12/return-to-work-after-vacation/dark.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>放假</tag>
      </tags>
  </entry>
  <entry>
    <title>提问学习带给我的收获</title>
    <url>/2019/02/01/ask-questions-learn-bring-me-harvest/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><p>写以此文，记录我这三天（1.30-2.1）的收获和感悟。</p><p>上周把一个定时删除的服务的版本提交了，本以为在过年前的一周基本没什么事了。然而部门老哥告诉我，之前我负责的一个流媒体服务还存在两处bug</p><ul><li><p>不支持多用户同时拉取视频流；</p></li><li><p>不支持重新连接；</p></li></ul><p>所以这周我又忙着修改bug,然而在前两天，我还是束手无策，找不到应对方案，一筹莫展。</p><p>到了第三天老哥带我一步步熟悉整体流程，细致到每个函数，每个入参，以及每个重要的代码。不断的提问，不断的思考，再不断的提出新的问题，时间过得飞快，我也饿得快。不过最终还是蛮开心的，通过这两处bug，让我重新回顾了流媒体服务的整体工作流程，以及Go语言中对<code>goroutine</code>和<code>channel</code>机制，印象最深的是以下两点：</p><h3 id="管道中的-lt"><a href="#管道中的-lt" class="headerlink" title="管道中的&lt;-"></a>管道中的<code>&lt;-</code></h3><p>简单来说就是这样子的：接受者&lt;-发送者。</p><p>然而中间会多个管道，所以我借用Go语言圣经中的三处例子做解释</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- x  <span class="comment">// x作为发送者发送给管道</span></span><br><span class="line">x = &lt;-ch <span class="comment">// 管道作为发送者发送数据给接受者x</span></span><br><span class="line">&lt;-ch  <span class="comment">// 管道发送数据，没有接收者，丢弃，同时造成管道堵塞，等待接收者</span></span><br></pre></td></tr></table></figure><p>所以我们可以具体化刚才说的发送接收流程，它应该为：接收者 &lt;- 管道 &lt;- 发送者。如果缺了接收者或发送者，都会造成管道堵塞。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>举个例子</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">mu sync.Mutex   <span class="comment">// guards balance</span></span><br><span class="line">balance <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    balance = balance + amount</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    b := balance</span><br><span class="line">    mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先Lock锁住，再使用Unlock解锁。</p><p>如果Lock中再套一个Lock，就会造成死锁，需要将前一个Lock解开才行。</p><h3 id="dlv调试流程"><a href="#dlv调试流程" class="headerlink" title="dlv调试流程"></a>dlv调试流程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,./dlv debug xxxx(程序名)  ##启动dlv调试</span><br><span class="line"></span><br><span class="line">2,r(restart)  </span><br><span class="line"></span><br><span class="line">3,c(continue)</span><br><span class="line"></span><br><span class="line">4,b(break)   ##打断点，可以打函数名，也可以打文件下对应的行号</span><br><span class="line"></span><br><span class="line">5,n(next)或s(step)  ##n按一次单步执行，后面只需一直按回车；遇到需要深究的函数按s进去查看</span><br><span class="line">##如果碰到多线程，建议在线程内打个断点</span><br><span class="line"></span><br><span class="line">6,bt(stack)  ##查看堆栈</span><br><span class="line"></span><br><span class="line">7,frame  ##查看指定堆栈的内容</span><br><span class="line"></span><br><span class="line">8,q(exit)     ##退出调试</span><br></pre></td></tr></table></figure><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li><p>接触一个新东西，除了保证理解了流程，还要对每个函数的作用，影响范围都要了然于胸才行；</p></li><li><p>流程这东西，光知道不行，最好的办法是自己画个流程图出来，一步步跟着代码走；</p></li><li><p>IDE有时会因为环境参数或内在bug而报错，所以推荐使用dlv(针对go)和gdb进行调试；</p></li><li><p>多对自己提几个为什么，有助于理解技术的本质；</p></li><li><p>心态放平和，坦然接受bug和不足，耐心寻求突破。</p></li></ul><p>最后附一组测试成功的图片^_^</p><p><img src="/2019/02/01/ask-questions-learn-bring-me-harvest/%E8%83%8C%E5%BD%B1.png" alt></p><p><img src="/2019/02/01/ask-questions-learn-bring-me-harvest/%E5%9B%BE.png" alt></p><p><img src="/2019/02/01/ask-questions-learn-bring-me-harvest/%E7%AC%91.png" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>Go</tag>
        <tag>收获</tag>
        <tag>提问</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-面试题3-数组中重复的数字-题目一</title>
    <url>/2019/01/27/sword-to-offer-03/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h3 id="题目一：找出数组中重复的数字"><a href="#题目一：找出数组中重复的数字" class="headerlink" title="题目一：找出数组中重复的数字"></a>题目一：找出数组中重复的数字</h3><p>在一个长度为n的数组里的所有数字都在0~n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>1，先把输入的数组排序；</p><ul><li>从头到尾扫描排序后的数组。排序一个长度为n的数组需要O(nlogn)的时间。</li></ul><p>2，利用哈希表；</p><p>3，根据数组下表找重复数字；(过程会在后面详细写出)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] &lt; <span class="number">0</span> || numbers[i] &gt; length - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(numbers[i] != i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == numbers[numbers[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                *duplication = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换numbers[i]和numbers[numbers[i]]        </span></span><br><span class="line">            <span class="keyword">int</span> temp = numbers[i];</span><br><span class="line">            numbers[i] = numbers[temp];</span><br><span class="line">            numbers[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><ul><li><p>对一维数组的理解。一维数组在内存中占据连续的空间，因此我们可以根据下标定位对应的元素。</p></li><li><p>学会通过具体例子找出其中的规律。</p></li></ul><p><a href="https://github.com/OctopusLian/CodingInterviewChinese2/blob/master/03_01_DuplicationInArray/FindDuplication.cpp" target="_blank" rel="noopener">本题源代码</a></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>刷题的步伐</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>数组</tag>
        <tag>数字</tag>
      </tags>
  </entry>
  <entry>
    <title>公司年会收获</title>
    <url>/2019/01/27/company-annual-meeting-harvest/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><p>2019年1月23日，我参加了公司的年会彩排+表演。</p><p>此次年会收获如下：</p><ul><li>成功站在舞池中央，C位出道！</li><li>步伐放慢一点，脚印踩实一些。</li><li>有激情，才能带动一批人。</li><li>再多坚持一会儿。</li></ul><p><img src="/2019/01/27/company-annual-meeting-harvest/center.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>收获</tag>
        <tag>年会</tag>
      </tags>
  </entry>
  <entry>
    <title>重新正视自己的知识焦虑</title>
    <url>/2019/01/21/agagin-face-my-knowledge-anxiety/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><p>今天在豆瓣上看到一篇文章，分享一下：<a href="https://www.douban.com/note/704294887/" target="_blank" rel="noopener">高效学习成长的丰沃土壤长什么样</a></p><h2 id="与知识付费的相识"><a href="#与知识付费的相识" class="headerlink" title="与知识付费的相识"></a>与知识付费的相识</h2><p>记得是大二的时候，下载了得到app，打开后看到里面琳琅满目的付费专栏，内容主要涉及管理学，经济学，科技和做人做事，价格基本是199元/年，我说“好贵！学生党买不起。”</p><p>后来经不住app里对专栏的介绍，我买了下吴军的《硅谷来信》，想跟着专栏学习下大师的思考方式和处世之道。不得不说，大师思考问题的维度和方式的确与我们不一样，因此拓宽了我的知识面，于是在一年后，我又坚持订阅了他的《谷歌方法论》。</p><p>再到后来大学毕业，我做了和服务器开发和算法相关的工作，在工作中深深感受到基础知识的匮乏，这时候一款名叫极客时间的app映入眼帘，在这里我看了相关介绍，陆续订阅了《数据结构与算法之美》和《程序员的基础数学》两个专栏。</p><p>还有其他类似的知识付费栏目，比如简书的付费阅读原创小说最后30%的章节内容；GitChat；知识星球。</p><h2 id="为什么需要付费"><a href="#为什么需要付费" class="headerlink" title="为什么需要付费"></a>为什么需要付费</h2><p>曾经我很纳闷，这些知识网上都可以找到的，为什么还需要知识付费呢？</p><p>我想主要原因有以下几个方面：</p><ul><li>作者辛辛苦苦写出来的，我们总要回馈一些财富出来；（20%）</li><li>网上内容良莠不齐，而作者是一路走过来的，因此有经验，会帮你整理出来，让你少走弯路；（60%）</li><li>对版权的一种保护；（20%）</li></ul><p>所以归根结底，是我们对获取知识的途径比较匮乏，需要有个人（比如专栏作者）把自己的学习心得和经验共享出来，供需要的人吸收，那么问题又来了，你吸收的这些知识，就一定是正确且有用的吗？</p><h2 id="正视焦虑"><a href="#正视焦虑" class="headerlink" title="正视焦虑"></a>正视焦虑</h2><p>我是一个喜欢有成就感持续驱动学习的人，这种成就感不是满足于一群人对我说“大佬 666”，而是每解决一个bug或close一个issue，搞懂一个模块的功能或者比昨天对框架有了更深入的理解。</p><p>然而，当我逐渐在学习底层的时候，我就会愈发现知识的不足，例如并发编程的原理，常用算法的核心思想，模块功能类比上的失误，以及对协议的认知偏差等等，这时候我很想一步登天，例如狂刷CSAPP，算法，但此时我已经产生了知识焦虑，犯了欲速则不达的错误。</p><h2 id="学会分辨正确但无用的知识"><a href="#学会分辨正确但无用的知识" class="headerlink" title="学会分辨正确但无用的知识"></a>学会分辨正确但无用的知识</h2><p>“学会分辨正确但无用的知识”——这时一位前辈给我提的建议。</p><p>现在，我终于明白了这句话的含义。</p><p>无用，其实绝大多数是因为自己没有经过深度思考，只是别人告诉你，有这么个知识，你可以拿来套用和当谈资。但是这个知识到底有什么用，在什么场合下适用，都是要经过自己思考和实践出来的。</p><h2 id="一个小例子"><a href="#一个小例子" class="headerlink" title="一个小例子"></a>一个小例子</h2><p>我有位高中玩的很要好的朋友，我当时总会调侃他的英语，然而我很佩服他的数学，虽然我做的数学题比他多，周末还报了数学辅导班，但是每当考试时，他都比我考的高。</p><p>我私下请教他学习数学的方法，他说你做题只满足做对就行，却没有从出题人的角度思考这道题，而我做这道题只花了五分钟，想这道题背后的用意以及举一反三的过程却花了我45分钟的时间。</p><p>的确，他经过深度思考了，所以知识是他的，而我是花钱（买课外资料，报辅导班）买了别人的解题思路，走了个捷径，现在想想，其实是走了弯路。</p><h2 id="关于知识焦虑的感触"><a href="#关于知识焦虑的感触" class="headerlink" title="关于知识焦虑的感触"></a>关于知识焦虑的感触</h2><ul><li><p>正视自己的焦虑，因为有焦虑，所以才有强烈的求知欲和学习的动力；</p></li><li><p>集中自己的时间和注意力，对枯燥的原理和底层的知识，进行深度思考；</p></li><li><p>对那种表面业务逻辑部分，花最少的时间把它做好，后面就抽更少的时间维护即可；</p></li><li><p>从源头开始阅读，尽量获取第一手的资料；</p></li><li><p>正视自己的不足，扎扎实实一步一个脚印坚持走下去；</p></li></ul><p>GOOD LUCK !</p><p><img src="/2019/01/21/agagin-face-my-knowledge-anxiety/alone.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>感悟</tag>
        <tag>知识付费</tag>
        <tag>焦虑</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_面试题1_赋值运算符函数</title>
    <url>/2019/01/17/sword-to-offer-01/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如下为类型CMyString的声明，请为该类型添加赋值运算符函数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span>* pData = <span class="literal">nullptr</span>);</span><br><span class="line">    CMyString(<span class="keyword">const</span> CMystring &amp;str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>关注点如下：</p><ul><li>是否把返回值的类型声明为该类型的引用，并在函数结束前返回实例自身的引用(*this)。</li><li>是否把传入的参数的类型声明为常量引用。</li><li>是否释放实例自身已有的内存。</li><li>判断传入的参数和当前的实例(*this)是不是同一个实例。</li></ul><h2 id="Show-Code"><a href="#Show-Code" class="headerlink" title="Show Code"></a>Show Code</h2><h3 id="经典，初级解法"><a href="#经典，初级解法" class="headerlink" title="经典，初级解法"></a>经典，初级解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span> = (<span class="keyword">const</span> CMyString &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">//返回实例自身的引用</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> []m_pData;</span><br><span class="line">    m_pData = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_pData,str.m_pData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><ul><li>C++基础语法，如运算符函数、常量引用；</li><li>对内存泄露的理解</li></ul><p><a href="https://github.com/OctopusLian/CodingInterviewChinese2/tree/master/01_AssignmentOperator" target="_blank" rel="noopener">本题源代码</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.cplusplus.com/reference/cstring/strcpy/" target="_blank" rel="noopener">cpp函数_strcpy</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>刷题的步伐</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>低调成长</title>
    <url>/2019/01/17/low-growth/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="意外惊喜"><a href="#意外惊喜" class="headerlink" title="意外惊喜"></a>意外惊喜</h2><p>这段时间有两个意外发生在我的身上</p><h3 id="头条邀请"><a href="#头条邀请" class="headerlink" title="头条邀请"></a>头条邀请</h3><p>下午打开Gmail邮箱，意外发现了除了Medium的推送外，还夹带着一封头条后端开发岗的邀请…<br><img src="/2019/01/17/low-growth/%E5%A4%B4%E6%9D%A1%E9%9D%A2%E8%AF%95.png" alt></p><h3 id="写书邀请"><a href="#写书邀请" class="headerlink" title="写书邀请"></a>写书邀请</h3><p>除了面试邀请，还在前段时间在博客园上收到了一家北京出版社编辑发的写开发实战书籍的邀请。<br>（写书曾经想过写，但不是现在写，因为技术还没有积淀下来，写了也是浪费精力和纸张）</p><h2 id="低调成长"><a href="#低调成长" class="headerlink" title="低调成长"></a>低调成长</h2><p>想起两年前我大二，对于这样的邀请我是可望而不可即的，因为技术太渣，校招时四轮笔试做了一塌糊涂。<br>但是，当现在机会摆在我的面前时，我不禁想问下自己，现在接受真的合适吗？<br>最好的目前并不一定适合自己。<br>现在的还处于学习上升期阶段，除了在部门内负责流媒体服务外，还要学习网络，数据库和算法相关知识，需要巩固C/C++和Go语言编程；不断的接受一些有挑战性的任务，在踩坑和写Bug中茁壮成长。<br>我一直相信，只要自己坚持做一件认为对的事情，培养成一个习惯（例如写日记，早起晨练，学习），那么这就是个如蛹化蝶的过程，最终将会振翅飞翔。<br><img src="/2019/01/17/low-growth/%E8%8A%B1%E6%B5%B7.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>惊喜</tag>
      </tags>
  </entry>
  <entry>
    <title>2019年计划要做的事</title>
    <url>/2019/01/15/2019-demand-do-something/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:12 GMT+0800 (CST) --><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>目前了解到的会涉及以下方面：</p><ul><li>流媒体服务<br>以Go语言为主；熟练掌握TCP/IP，HTTP原理；常用的MySQL和Redis数据库用法。</li><li>视音频编解码<br>C/C++语言为主；</li><li>图形图像<br>C/C++语言，OpenGL；OpenCV。</li></ul><h2 id="业余安排"><a href="#业余安排" class="headerlink" title="业余安排"></a>业余安排</h2><p>业余时间计划完成以下事情：</p><h3 id="附加技能"><a href="#附加技能" class="headerlink" title="附加技能"></a>附加技能</h3><ul><li>熟悉JavaScript，争取能完成一个在线简历模板；</li><li>熟练Java语言，希望能接1-2个毕设赚些零花钱；</li><li>LeetCode每周一题；</li></ul><h3 id="阅读提升"><a href="#阅读提升" class="headerlink" title="阅读提升"></a>阅读提升</h3><ul><li>极客时间上的四个专栏（左耳听风，趣谈网络，数据结构算法，数学基础）研读；</li><li>开始阅读大部头经典书籍，例如CSAPP和UNP，并认真完成章节的课后练习题；</li><li>Medium上争取两周内翻译一篇和自己学习工作相关的技术文章；</li><li>每天半小时学习口语；</li></ul><h3 id="培养兴趣爱好"><a href="#培养兴趣爱好" class="headerlink" title="培养兴趣爱好"></a>培养兴趣爱好</h3><ul><li>学习下拍照摄影，争取给女友拍出美美的照片～</li><li>继续在健身房练习街舞，希望今年可以练出托马斯回旋和大风车；</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>继续维护我的英语学习项目<a href="https://github.com/OctopusLian/VocabularyMap" target="_blank" rel="noopener">VocabularyMap</a>，争取在九月底国庆前完成词根词汇的拓展并加上中文释义。</li><li>继续坚持创作，幻想和思考。</li></ul><p><img src="/2019/01/15/2019-demand-do-something/%E5%8A%A0%E6%B2%B9.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>计划</tag>
        <tag>兴趣</tag>
      </tags>
  </entry>
  <entry>
    <title>新的开始</title>
    <url>/2019/01/14/new-begin/</url>
    <content><![CDATA[<!-- build time:Sun Jun 14 2020 11:34:13 GMT+0800 (CST) --><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>大家好，我的网名叫不会飞的章鱼（Zoctopus Zhang），活跃在简书、豆瓣、博客园和Github上，之前在博客园上坚持写技术博客长达两年半，截止目前已发布了两百多篇文章共23万人+的访问量，同时在简书上写文章积累了有十二万余字。然而，我一直很想创建一个自己的Blog，记录一些平时工作和生活上的收获和心得。<br>今天这个愿望终于实现了，在此我很感谢我的好友冰水鉴心的远程帮助。</p><h2 id="接下来准备做什么"><a href="#接下来准备做什么" class="headerlink" title="接下来准备做什么"></a>接下来准备做什么</h2><p>我本科学的专业是计算机科学与技术，2018年6月毕业后在一家上市游戏公司做了三个月的游戏服务器开发，之后因工作原因转行，目前主要做流媒体服务和与视音频相关的图形图像。<br>我想把我在工作中的学习心得和生活上的感悟记录下来。</p><h2 id="那么，现在就开始吧"><a href="#那么，现在就开始吧" class="headerlink" title="那么，现在就开始吧"></a>那么，现在就开始吧</h2><p>我不知道这条路我会走多远，但我至今不后悔我做出的每一个选择。因为我知道：念念不忘，必有回响。</p><p><img src="/2019/01/14/new-begin/%E5%85%89%E6%99%95.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>开始</tag>
      </tags>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>栈与单调栈：最大矩形面积</title>
    <url>/2020/06/07/geekbang-column-stack-and-monotonic-stack-maximum-rectangular-area/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>假设有一面木板墙，每块木板的宽度都是 1，你现在想在木板墙上，沿着平行于地面的方向，切割出一块矩形区域。问题来了，如果给出了每一块木板的高度，那么如何切出面积最大的矩形区域？矩形木板墙如下图所示：</p><p><img src="/2020/06/07/geekbang-column-stack-and-monotonic-stack-maximum-rectangular-area/mubanqiang.jpg" alt></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>图中有 7 块木板，每块木板的高度分别为：2、1、4、5、1、3、3。经过尝试，我们发现最大矩形就是红色阴影部分所示，也就是切割了高度为 4 和 5 两块木板，形成了一个高度为 4，宽度为 2 的矩形区域，这个最大面积为 8。</p><p>结论：<strong>切下来的最大的矩形，一定是以最大矩形所在区域最短那块木板作为其高度值。</strong></p><p>因此，可以枚举每一块木板，每次都以当前木板作为高度，就是把当前这块木板，当成是切出来的矩形区域中的最矮的木板，然后向左边和右边分别做延伸，切出此时的最大矩形区域。当把所有木板都试过一遍后，我们在所有枚举结果中比较出最大值，这个最大值就是我们要求的最大矩形面积。如果木板的个数为 n，那这种做法的时间复杂度接近于 O(n2)。</p><p>任务要求：将这个时间复杂度降低到 O(n)。</p><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><h3 id="栈：维护一种完全包含关系的结构"><a href="#栈：维护一种完全包含关系的结构" class="headerlink" title="栈：维护一种完全包含关系的结构"></a>栈：维护一种完全包含关系的结构</h3><p>栈就是一种后进先出的结构。</p><p><img src="/2020/06/07/geekbang-column-stack-and-monotonic-stack-maximum-rectangular-area/stack.jpg" alt></p><p>图中所示，入栈顺序分别是 蓝、绿、红，那么出栈顺序就一定是红、绿、蓝。图中每一个颜色的方块上标注的数字，就是每一个方块入栈及出栈的顺序。</p><p>从示意图中，我们还可以观察到一个有趣的事情，在顺序上而言，红色方块被绿色方块包裹着，绿色方块被蓝色方块包裹着。这种结构，像是程序的调用过程，如果把蓝色方块，看成是主函数的话，那么绿色方块就是主函数中调用的一个函数 A，红色方块就是 A 函数中调用的另外一个函数 B，三个函数调用的顺序是主函数、函数 A、函数 B。<br>而它们的执行结束顺序恰恰是相反的，首先是 函数 B 结束，然后是 函数 A 结束，最后是主函数结束。</p><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p><img src="/2020/06/07/geekbang-column-stack-and-monotonic-stack-maximum-rectangular-area/dandiaozhan.jpg" alt></p><p>如果说单调队列是维护区间最值的高效结构，单调栈就是维护最近大于或小于关系的高效结构。</p><h3 id="最大矩形面积"><a href="#最大矩形面积" class="headerlink" title="最大矩形面积"></a>最大矩形面积</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a, b) ((a) &gt; (b) ？ (a) : (b))</span></span><br><span class="line"><span class="keyword">int</span> s[MAX_N + <span class="number">5</span>], top;</span><br><span class="line"><span class="keyword">int</span> l[MAX_N + <span class="number">5</span>], r[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max_matrix_area</span><span class="params">(<span class="keyword">int</span> *h, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    h[<span class="number">0</span>] = h[n + <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    top = <span class="number">-1</span>, s[++top] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 找到每一块木板，左边第一块比其矮的木板编号</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">0</span> &amp;&amp; h[s[top]] &gt;= h[i]) --top;</span><br><span class="line">        l[i] = s[top];</span><br><span class="line">        s[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到每一块木板，右边第一块比其矮的木板编号</span></span><br><span class="line">    top = <span class="number">-1</span>, s[++top] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (top &gt;= <span class="number">0</span> &amp;&amp; h[s[top]] &gt;= h[i]) --top;</span><br><span class="line">        r[i] = s[top];</span><br><span class="line">        s[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在所有木板中，找到面积最大的矩形</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans = max(ans, (r[i] - l[r] - <span class="number">1</span>) * h[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：代码中假设木板的编号是从 1 到 n 的，然后，在数组的 0 位 及 n + 1 位分别加入两块高度为 -1 的虚拟木板，这是边界控制的一种技巧。也就是说，在每块木板向左搜索的时候，最远也就搜索到 0 号位就停止了，向右搜索的时候呢，最远搜索到 n + 1 位也就停止了。</p><p><strong>通过加入虚拟木板，代码中就少了相关的边界条件判断，这是一种很实用的技巧。</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>单调栈是用来维护最近大于或小于关系的数据结构。</li><li>单调栈就是堵住出口的单调队列，所以其时间复杂度与单调队列一致，平均到每个处理元素上，都是 O(1) 的时间复杂度。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>龙潭水乡半日游</title>
    <url>/2020/06/07/long-tan-shui-xiang-half-a-day-trip/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><p>今天看了天气，不是很热，和女朋友计划去龙潭水乡玩一玩。</p><p>坐车大概花了一个半小时，因为是快速公交，时间上节约了大概半小时。</p><p>到达指定地点后，哇，人很少，很有江南水乡的气息，和小学语文课本上见到的一样呢。</p><p>到处都是桥，路面凹凸不平，水面上的荷花很好看，景区内也有穿着汉服拍照的小哥哥小姐姐。</p><p>我和她选择了一些人比较少的地方取景，摆姿势，不得不说，自己私底下看了看讲拍摄的文章，还是很有用，女朋友夸我拍照技术也进步了，哈哈。(可想而知以前在拍照上打击的有多惨～～～)</p><p>溜达了一圈，不知是不是疫情的缘故，这里好多商家都只有店名，但房子内都已搬空，慢悠悠的走在街道上，迎面吹来的微风，看着波澜不惊的水面，心也归于平静，暂时忘却工作上的烦恼。</p><p>晚上回家，买了两斤小龙虾和自制的鸡腿抓饭当做晚饭，感谢又度过了一个轻松愉快的周末。</p><p><img src="/2020/06/07/long-tan-shui-xiang-half-a-day-trip/ltsx.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>旅行游记</category>
      </categories>
      <tags>
        <tag>龙潭水乡</tag>
        <tag>旅游</tag>
        <tag>散步</tag>
      </tags>
  </entry>
  <entry>
    <title>队列与单调队列：滑动区间最大值</title>
    <url>/2020/06/06/geekbang-column-queues-and-monotonous-queues-maximum-sliding-interval/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>滑动区间最大值，就是指在固定区间长度的前提下，在一个序列上，从前到后滑动这个区间窗口，每次窗口内部的最大值，就组成了滑动区间最大值。</p><p>例如，给你如下包含 8 个数字的序列，区间长度设置为 3：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[6 4 2] 10 3 8 5 9 -&gt; 6</span><br><span class="line">6 [4 2 10] 3 8 5 9 -&gt; 10</span><br><span class="line">6 4 [2 10 3] 8 5 9 -&gt; 10</span><br><span class="line">6 4 2 [10 3 8] 5 9 -&gt; 10</span><br><span class="line">6 4 2 10 [3 8 5] 9 -&gt; 8</span><br><span class="line">6 4 2 10 3 [8 5 9] -&gt; 9</span><br></pre></td></tr></table></figure><p>滑动区间从数字 6 开始出发，每次向右移动一个数字，同时把左边的一个数字丢出去，保持区间长度为 3，最后移动到数字 9 停止。可以看到，这个序列共包含 8 个数字，所以最后形成的滑动区间最大值共有 6 个，依次是 6、10、10、10、8、9。</p><p>常规解法：采用 O(nm) 的算法来完成，n 是区间长度，m 是窗口长度，就是枚举区间的终止位置，每次扫描区间内部，获得最大值。</p><p><strong>要求解法：时间复杂度降低到 O(n)。</strong></p><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><h3 id="初识队列"><a href="#初识队列" class="headerlink" title="初识队列"></a>初识队列</h3><p>先到先得，先入先出，每个元素都是从队列尾部入队，在头部被处理完后再出队。如下图所示：</p><p><img src="/2020/06/06/geekbang-column-queues-and-monotonous-queues-maximum-sliding-interval/queues.jpg" alt></p><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>单调队列的作用，就是用来维护在队列处理顺序中的区间最大值。维护的就是区间长度为 3 时候的最大值。当一个新的元素入队的时候，它会把其前面违反单调性的元素，都从队列中踢掉，最终将一直维护着一个最大值。</p><h3 id="滑动区间最大值"><a href="#滑动区间最大值" class="headerlink" title="滑动区间最大值"></a>滑动区间最大值</h3><p>本身就是求区间最大值的，所以也符合了单调队列应用的场景：维护在队列处理顺序中的区间最大值。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000</span></span><br><span class="line"><span class="keyword">int</span> q[MAX_N + <span class="number">5</span>], head, tail;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">interval_max_number</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    head = tail = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// a[i] 入队，将违反单调性的从队列 q 中踢出</span></span><br><span class="line">        <span class="keyword">while</span> (head &lt; tail &amp;&amp; a[q[tail - <span class="number">1</span>]] &lt; a[i]) tail--;</span><br><span class="line">        q[tail++] = i; <span class="comment">// i 入队</span></span><br><span class="line">        <span class="comment">// 判断队列头部元素是否出了窗口范围</span></span><br><span class="line">        <span class="keyword">if</span> (i - m == q[head]) head++;</span><br><span class="line">        <span class="comment">// 输出区间内最大值</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &gt;= m) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"interval(%d, %d)"</span>, i - m + <span class="number">1</span>, i);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" = %d\n"</span>, a[q[head]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数内部，依次处理数组中的每个元素，每次处理相应元素的时候，涉及到两个过程：</p><ul><li>第一个过程，是将当前元素入队。在入队之前，将队列尾部违反单调性的元素都从队列中踢出，这个就是第 7 行 while 过程的作用，之后就是将编号 i 入队即可。这里注意，单调队列里面，存储的是 a 数组的下标，而不是 a 数组的值。其实存储了下标，我们就可以索引到值，而在上一节二分查找的课里面，我们也见识过了，要是存储了值，想要反向索引下标是比较困难的。</li><li>第二个过程，就是判断单调队列头部的元素是否超出了窗口范围，也就是前面我们例子中你的学长毕业的过程，如果元素下标已经超出了窗口范围，就将队列头部元素出队。</li></ul><p>这样就可以保证，我们每次输出的，就都是滑动窗口内部的区间最大值了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>单调队列应用的场景：就是维护队列处理顺序中的区间最大值。</li><li>定义一种性质，并且维护这种性质。单调队列，维护的就是单调性。</li><li>单调队列处理单个元素的平均时间复杂度为什么是 O(1) 的。假设我们要处理 n 个元素，从整体上来看，每个元素会入队列 1 次，出队列最多也是 1 次，那么 n 个元素的总操作次数不会超过 2×n 次，平均到一个元素上就是 2 次，也就是常数次，记作 O(1) 时间复杂度。由此得知，处理 n 个元素的总时间复杂度，就是 O(n)。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>单调队列</tag>
        <tag>滑动区间</tag>
      </tags>
  </entry>
  <entry>
    <title>iPad上改变百度网盘播放速度的方法</title>
    <url>/2020/06/06/how-to-use-ipad-baiduyundisk-control-video-play-speed/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><p>百度网盘上的视频无法变速，我将分享一种我自认为最快解决的办法。</p><h2 id="步骤一：添加快捷指令"><a href="#步骤一：添加快捷指令" class="headerlink" title="步骤一：添加快捷指令"></a>步骤一：添加快捷指令</h2><p>打开<code>iPad</code>上的快捷指令；<br>选中<code>共享表单快捷指令</code>；<br>点击<code>更改视频速度</code>；<br>拉到最下面点击<code>添加快捷指令</code>。</p><h2 id="步骤二：Safari浏览器"><a href="#步骤二：Safari浏览器" class="headerlink" title="步骤二：Safari浏览器"></a>步骤二：Safari浏览器</h2><p>打开Safari浏览器，登录百度网盘，选中一个视频播放；<br>点击右上角有一个<strong>向上箭头</strong>的图标；<br>拉到下面有一个<code>更改视频速度</code>的选项；<br>选择可以接受的视频播放速度，完成。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.zhihu.com/question/65320947/answer/649400591" target="_blank" rel="noopener">iPad 百度网盘视频如何加速播放？</a><br><a href="https://www.bilibili.com/video/BV11K4y1C7S3?from=search&seid=16526850915632720540" target="_blank" rel="noopener">你的ipad还在用百度网盘和Alook看视频吗，教你免费的自定义倍速播放！</a></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Play-iPad</category>
      </categories>
      <tags>
        <tag>iPad</tag>
        <tag>百度</tag>
        <tag>网盘</tag>
        <tag>速度</tag>
      </tags>
  </entry>
  <entry>
    <title>重新认识数据结构：链表结构和思维</title>
    <url>/2020/06/03/geekbang-column-linked-list-structure-and-thinking/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>首先，我们定义一种数字名称，叫做“快乐数”。所谓快乐数就是经过有限次变换以后，等于 1 的数字。这个变换规则，给出一个非 1 的数字 a ，把它的位数拎出来，求各个位数的平方和，得到一个数字 b，如果数字 b 不是 1，那就对数字 b 的每一位数再做平方和，得到数字 c……经过不停的变换，确定最后能否得到 1。</p><p>例如，一开始的数字是 19，经过变换规则 12+92=82，得到数字 82；因为不是 1 ，所以接着做变换，就是 82+22=68，再做一次变换 62+82=100，最后一次做变换 12+02+02=1，得到了 1 以后，停止。</p><p>注：<a href="https://leetcode-cn.com/problems/happy-number/" target="_blank" rel="noopener">此题LeetCode链接</a></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul><li>首先，我们知道，整型表示的最大值是 231−1，大约是 20 亿左右。</li><li>例如，从 19 开始，依次得到的是：82、68、100、1 这些数字。也就是说，从一个数字开始，按照快乐数的计算规则，会得到一串数字序列。这其中就蕴含着链表重要的结构思维：<strong>从当前节点，唯一映射到下一个节点。快乐数序列中的数字，就是链表中的节点，如果当前数字确定了，下一个数字也就是确定了的，就像数字 19，下一个肯定是数字 82，这种映射规则，就是链表节点之间的指向关系。</strong></li><li>思维映射：所谓快乐数序列，最终的目标是能到 1，这个数字 1，其实就可以看成是链表中的空地址。</li><li>在整型范围内解决快乐数问题的话，1999999999 这个数字，按照各位平方和来进行计算，得到的下一个数字应该是 (9∗9^2+1)=730————&gt;这个快乐数链表中，节点数量绝对不会超过 731 个。一个不超过 731 个节点的链表，还总也走不到末尾，说明这个链表中有环。</li><li>因此，<strong>判断一个数字是否是快乐数，等价于判断链表中是否有环。</strong></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hasCycle</span><span class="params">(struct Node *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// p 是慢指针，q 是快指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">p</span> = <span class="title">head</span>, *<span class="title">q</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="comment">// 每次循环，p 走1步，q 走2步</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != q &amp;&amp; q); </span><br><span class="line">    <span class="keyword">return</span> p == q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="链表的操作"><a href="#链表的操作" class="headerlink" title="链表的操作"></a>链表的操作</h3><p>有如下函数接口定义：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct Node *<span class="title">erase</span><span class="params">(struct Node *head, <span class="keyword">int</span> ind)</span></span>;</span><br></pre></td></tr></table></figure><p>请你参照链表插入操作，实现一个链表节点删除的操作，删除函数传入两个参数，分别代表指向链表头结点的指针变量 head，以及要删除的节点位置 ind，返回值代表删除节点以后的链表头结点地址。</p><p>代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct Node *<span class="title">erase</span><span class="params">(strcut Node *head, <span class="keyword">int</span> ind)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> <span class="title">ret</span>, *<span class="title">p</span> = &amp;<span class="title">ret</span>, *<span class="title">q</span>;</span></span><br><span class="line">    ret.next = head;</span><br><span class="line">    <span class="keyword">while</span> (ind--) p = p-&gt;next;</span><br><span class="line">    q = p-&gt;next;</span><br><span class="line">    p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> ret.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/06/03/geekbang-column-linked-list-structure-and-thinking/linklist.jpg" alt></p><h3 id="如何求解环的长度，如上图，环的长度就是5"><a href="#如何求解环的长度，如上图，环的长度就是5" class="headerlink" title="如何求解环的长度，如上图，环的长度就是5"></a>如何求解环的长度，如上图，环的长度就是5</h3><p>如果链表中有环，那么采用快慢指针的方法，两个指针一定会在环中相遇。此时，可以让其中一个指针不动，另外一个指针再沿着环走一圈，直到两个指针再次相遇，这样，就能得到环的长度了。</p><h3 id="如何找到环的起点，如上图，3号点就是环的起点"><a href="#如何找到环的起点，如上图，3号点就是环的起点" class="headerlink" title="如何找到环的起点，如上图，3号点就是环的起点"></a>如何找到环的起点，如上图，3号点就是环的起点</h3><p>首先，假设从链表起始点到环的起点距离为 x，那么当快慢指针中的慢指针 p 刚刚走到环的起始点位置的时候，q 指针应该在环内部距离环起始点 x 的位置上，如图所示：</p><p><img src="/2020/06/03/geekbang-column-linked-list-structure-and-thinking/linklist2.jpg" alt></p><p>图中，q 指针距离环起始点 x 步，q 指针沿着链表向前走 y 步，就又可以到达环的起始点位置，如图所示 x + y 等于环长。也就是说，q 指针想要遇到 p 指针，就必须要追上 y 步的距离，又因为 p 指针每次走 1 步，q 指针每轮走 2 步，所以 q 指针每轮追上 1 步，也就是说，从此刻开始，当 q 指针追上 p 指针的时候，p 指针正好向前走了 y 步，如图所示：</p><p><img src="/2020/06/03/geekbang-column-linked-list-structure-and-thinking/linklist3.jpg" alt></p><p>此时，你会发现 p 点在环中走了 y 步以后，p 和 q 相遇了，也就意味着 p 点再走 x 步就到环的起始点了。而恰巧，从链表头结点开始到环的起始点也是 x 步，所以此时只需要让 p 站在相遇点，q 指针回到链表的起始点，然后两个指针以相同的速度，一起往后走，直到二者再次相遇的时候，相遇点就是环的起始点了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>数据结构 = 结构定义 + 结构操作，这个等式说明了我们学习数据结构的方法顺序。</li><li>单向链表节点中，存在数据域和指针域，指针域控制了链表的结构，一般不会根据应用场景的变化而变化，而数据域是根据应用场景的需求而设计的。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找：提升程序的查找效率</title>
    <url>/2020/06/03/geekbang-column-binary-search-improve-the-search-efficiency-of-the-program/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>假设你手上有 n 段长度不等的绳子，你现在想将这些绳子进行裁剪，裁剪出 k 条长度相等的绳子，注意，只能剪断绳子，不能拼接绳子。问题就是，你能得到的这 k 段绳子的最长长度是多长？</p><p><img src="/2020/06/03/geekbang-column-binary-search-improve-the-search-efficiency-of-the-program/shenzi.jpg" alt></p><p>如图所示，如果你手中有 3 条绳子，分别是 4 米、6 米 和 5 米，想要切出等长的 4 段，你会发现，每段最长就是 3 米。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul><li><p>采用枚举法，就是先尝试能不能切出至少 4 段的 1 米长绳子，如果可以的话，再去尝试每段长度 2 米是否可行，依次尝试下去，直到尝试不下去为止。最后一次尝试可行的长度，就是每段绳子的最长长度了。（效率太低，放弃。）</p></li><li><p>采用二分法。</p></li></ul><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="二分法示例代码"><a href="#二分法示例代码" class="headerlink" title="二分法示例代码"></a>二分法示例代码</h3><p>中心思想：<strong>不管如何调整区间，都要保证待查找数字，总是落在我们的由 L 和 R 标记的查找区间内部。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//入参：有序数组 arr，数组长度 n 和待查找数字 x</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;  <span class="comment">//查找区间不为空</span></span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>; <span class="comment">//l 和 r 的值，计算得到一个中间位置的下标 mid 值     </span></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == x) <span class="keyword">return</span> mid;  <span class="comment">//比较 mid 位置的值与 x 的大小关系，从而确定区间调整策略。</span></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; x) r = mid - <span class="number">1</span>;  <span class="comment">//如果 arr[mid] 大于 x，说明 x 值在区间的前半段，那么 mid 及 mid 位置以后的值，就不在下一次查找的范围之内了，我们就把区间的尾部位置 r 向前移动，移动到 mid - 1 位。</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;  <span class="comment">//arr[mid] 小于 x 时候的调整策略与之类似</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h3><ul><li>将每一段绳子的长度 x，与能切出来的绳子段数之间，看成一个映射关系，用函数 f(x) = y 来表示，代表每一段长度为 x 的情况下，最多能切出来 y 段绳子。</li><li>f 函数是一个单调函数，随着每一段长度的增加，能切出来的段数 y 是在减少的，而对于我们来说，就是要确定 y = k 时的 x 的最大值。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPS 1e-7  <span class="comment">//EPS 是一个宏，就是我们要控制的精度，一般控制在 10^−7 范围，两个值相差不到 10−7 的时候，我们就认为这两个浮点值相等。</span></span></span><br><span class="line"><span class="keyword">double</span> l[<span class="number">100</span>], n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入每一段的长度 x，返回最多能切多少段</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//变量 n 记录的是原始绳子的数量，l 数组记录的是每一段原始绳子的长度</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cnt += (<span class="keyword">int</span>)<span class="built_in">floor</span>(l[i] / x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">double</span> *l, <span class="keyword">double</span> *r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r - l &lt;= EPS) <span class="keyword">return</span> r;  <span class="comment">//递归程序的边界条件，是当 r - l 小于等于一个极小值的时候，就终止递归</span></span><br><span class="line">    <span class="keyword">double</span> mid = (l + r) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (f(mid) &lt; k) <span class="keyword">return</span> bs(l, mid, k);</span><br><span class="line">    <span class="keyword">return</span> bs(mid, r, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>二分算法框架，是求解具有单调性问题的利器。</li><li>二分算法，通常用来求解那些 f(x) = y 问题中，给定 y，求解 x 的问题。</li><li>数组和函数在思维层面，没有什么本质差别。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>算法</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>编译带OpenGL转场特技的FFmpeg</title>
    <url>/2020/06/01/build-add-gl-transition-ffmpeg/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="why"><a href="#why" class="headerlink" title="why"></a>why</h2><p>FFmpeg现成的版本里没有带<code>gl transition</code>转场特技，所以需要专门编译。</p><h2 id="step-1-clone-ffmpeg"><a href="#step-1-clone-ffmpeg" class="headerlink" title="step 1:clone ffmpeg"></a>step 1:clone ffmpeg</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://git.ffmpeg.org/ffmpeg.git ffmpeg</span><br></pre></td></tr></table></figure><p>（过程会有些漫长）</p><h2 id="step-2-x264-编译"><a href="#step-2-x264-编译" class="headerlink" title="step 2:x264 编译"></a>step 2:x264 编译</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure --enable-shared --enable-static --disable-asm  </span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h2 id="step-3-给ffmpeg打上补丁"><a href="#step-3-给ffmpeg打上补丁" class="headerlink" title="step 3:给ffmpeg打上补丁"></a>step 3:给ffmpeg打上补丁</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.将vf_gltransition.c拷贝到ffmpeg/libavfilter/</span><br><span class="line">2.在ffmpeg里面大上diff补丁，</span><br><span class="line">git apply ~/ffmpeg-gl-transition/ffmpeg.diff</span><br><span class="line">但是，也可以手动大补丁，只需要在/libavfilter/Makefile和/libavfilter/allfilters.c两个文件添加两行代码</span><br><span class="line">--- a/libavfilter/Makefile</span><br><span class="line">+++ b/libavfilter/Makefile</span><br><span class="line">@@ -367,6 +367,7 @@ OBJS-$(CONFIG_YADIF_FILTER)                  += vf_yadif.o</span><br><span class="line"> OBJS-$(CONFIG_ZMQ_FILTER)                    += f_zmq.o</span><br><span class="line"> OBJS-$(CONFIG_ZOOMPAN_FILTER)                += vf_zoompan.o</span><br><span class="line"> OBJS-$(CONFIG_ZSCALE_FILTER)                 += vf_zscale.o</span><br><span class="line">+OBJS-$(CONFIG_GLTRANSITION_FILTER)           += vf_gltransition.o</span><br><span class="line"></span><br><span class="line"> OBJS-$(CONFIG_ALLRGB_FILTER)                 += vsrc_testsrc.o</span><br><span class="line"> OBJS-$(CONFIG_ALLYUV_FILTER)                 += vsrc_testsrc.o</span><br><span class="line"> -----------------------------------------------------------</span><br><span class="line"> --- a/libavfilter/allfilters.c</span><br><span class="line">+++ b/libavfilter/allfilters.c</span><br><span class="line">@@ -357,6 +357,7 @@ extern AVFilter ff_vf_yadif;</span><br><span class="line"> extern AVFilter ff_vf_zmq;</span><br><span class="line"> extern AVFilter ff_vf_zoompan;</span><br><span class="line"> extern AVFilter ff_vf_zscale;</span><br><span class="line">+extern AVFilter ff_vf_gltransition;</span><br><span class="line"></span><br><span class="line"> extern AVFilter ff_vsrc_allrgb;</span><br><span class="line"> extern AVFilter ff_vsrc_allyuv;</span><br></pre></td></tr></table></figure><h2 id="step-4-添加依赖项"><a href="#step-4-添加依赖项" class="headerlink" title="step 4:添加依赖项"></a>step 4:添加依赖项</h2><h3 id="Ubuntu系统"><a href="#Ubuntu系统" class="headerlink" title="Ubuntu系统"></a>Ubuntu系统</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get -y install gcc g++ make xorg-dev pkg-config \</span><br><span class="line">                       libglew2.0 libglew-dev libglfw3-dev \</span><br><span class="line">                       nasm yasm libx264-dev libx265-dev libvpx-dev libglu1-mesa-dev \</span><br><span class="line">                       libmp3lame-dev libopus-dev libfdk-aac-dev</span><br></pre></td></tr></table></figure><p>如果运行命令失败，就一个个单独下。</p><h4 id="disable-EGL"><a href="#disable-EGL" class="headerlink" title="disable EGL"></a>disable EGL</h4><p>注释掉<code>define GL_TRANSITION_USING_EGL</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -v &quot;define GL_TRANSITION_USING_EGL&quot; /build/ffmpeg-gl-transition/vf_gltransition.c &gt; ffmpeg/libavfilter/vf_gltransition.c</span><br></pre></td></tr></table></figure><h2 id="step-5-编译ffmpeg"><a href="#step-5-编译ffmpeg" class="headerlink" title="step 5:编译ffmpeg"></a>step 5:编译ffmpeg</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ffmpeg; ./configure --enable-libx264 --enable-libx265 --enable-libvpx  --enable-libfdk-aac --enable-libmp3lame --enable-libopus --enable-nonfree --enable-gpl --enable-opengl --enable-filter=gltransition --extra-libs=&apos;-lGLEW -lglfw -ldl&apos;</span><br><span class="line"></span><br><span class="line">cd ffmpeg; make -j</span><br><span class="line">cd ffmpeg; make install</span><br></pre></td></tr></table></figure><p>编译结束后，执行<code>./ffmpeg</code>看到有<code>--extra-libs=&#39;-lGLEW -lglfw -ldl&#39;</code>表示编译成功。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ./ffmpeg</span><br><span class="line">ffmpeg version N-98018-gdd76226 Copyright (c) 2000-2020 the FFmpeg developers</span><br><span class="line">  built with gcc 5.4.0 (Ubuntu 5.4.0-6ubuntu1~16.04.12) 20160609</span><br><span class="line">  configuration: --enable-libx264 --enable-libx265 --enable-libvpx --enable-libfdk-aac --enable-libmp3lame --enable-libopus --enable-nonfree --enable-gpl --enable-opengl --enable-filter=gltransition --extra-libs=&apos;-lGLEW -lglfw -ldl&apos;</span><br><span class="line">  libavutil      56. 49.100 / 56. 49.100</span><br><span class="line">  libavcodec     58. 90.100 / 58. 90.100</span><br><span class="line">  libavformat    58. 44.100 / 58. 44.100</span><br><span class="line">  libavdevice    58.  9.103 / 58.  9.103</span><br><span class="line">  libavfilter     7. 84.100 /  7. 84.100</span><br><span class="line">  libswscale      5.  6.101 /  5.  6.101</span><br><span class="line">  libswresample   3.  6.100 /  3.  6.100</span><br><span class="line">  libpostproc    55.  6.100 / 55.  6.100</span><br><span class="line">Hyper fast Audio and Video encoder</span><br><span class="line">usage: ffmpeg [options] [[infile options] -i infile]... &#123;[outfile options] outfile&#125;...</span><br><span class="line"></span><br><span class="line">Use -h to get full help or, even better, run &apos;man ffmpeg&apos;</span><br></pre></td></tr></table></figure><h2 id="step-6-无窗口的时候我们可能还需要-with-glfw"><a href="#step-6-无窗口的时候我们可能还需要-with-glfw" class="headerlink" title="step 6:无窗口的时候我们可能还需要 with glfw"></a>step 6:无窗口的时候我们可能还需要 with glfw</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get -y install xvfb</span><br></pre></td></tr></table></figure><h2 id="step-7-测试"><a href="#step-7-测试" class="headerlink" title="step 7:测试"></a>step 7:测试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ffmpeg-gl-transition</span><br><span class="line">ln -s /usr/local/bin/ffmpeg .</span><br><span class="line">cd ffmpeg-gl-transition</span><br><span class="line">xvfb-run -s &apos;+iglx -screen 0 1920x1080x24&apos; bash concat.sh</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/transitive-bullshit/ffmpeg-gl-transition" target="_blank" rel="noopener">Github_ffmpeg-gl-transition</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>FFmpeg学习</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
        <tag>OpenGL</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构：大整数实战，提升 Shift-And 算法能力</title>
    <url>/2020/05/31/geekbang-column-data-structure-big-data-action-improve-Shift-And-algo-ability/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>如果给你一个文本串和模式串，让你查找文本串中是否包含模式串，你用程序怎么完成？</p><h3 id="字符串匹配问题"><a href="#字符串匹配问题" class="headerlink" title="字符串匹配问题"></a>字符串匹配问题</h3><p>在一个大的字符串里面，查找是否包含另外一个较小的字符串。</p><p><img src="/2020/05/31/geekbang-column-data-structure-big-data-action-improve-Shift-And-algo-ability/stringpipei.jpg" alt></p><h3 id="暴力法解决"><a href="#暴力法解决" class="headerlink" title="暴力法解决"></a>暴力法解决</h3><p>用模式串的首字母依次和文本串中的每一位对齐，每次对齐以后，看看所对应区域是否匹配，如果匹配就说明文本串包含模式串。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 暴力匹配算法程序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bruce_force</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *text, <span class="keyword">const</span> <span class="keyword">char</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历文本串每一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; text[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从文本串的第 i 位开始与模式串进行匹配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; p[j]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text[i + j] == p[j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 当代码到了这里，说明某一位不匹配</span></span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度是 O(nm)，其中，n 是文本串的长度，m 是模式串的长度。<br>如果文本串长度是 10，模式串长度是 3，那么这个程序差不多要计算 30 次，外层循环 10 次，内层循环每次循环 3 次。</p><p>效率比较差，放弃。</p><h2 id="Shift-And-算法"><a href="#Shift-And-算法" class="headerlink" title="Shift-And 算法"></a>Shift-And 算法</h2><p>基本流程：首先做信息的转换，然后利用位运算，完成单模匹配问题。</p><h3 id="Shift-And-中的信息转换"><a href="#Shift-And-中的信息转换" class="headerlink" title="Shift-And 中的信息转换"></a>Shift-And 中的信息转换</h3><p><img src="/2020/05/31/geekbang-column-data-structure-big-data-action-improve-Shift-And-algo-ability/bianma.jpg" alt></p><h3 id="利用位运算做匹配"><a href="#利用位运算做匹配" class="headerlink" title="利用位运算做匹配"></a>利用位运算做匹配</h3><p><img src="/2020/05/31/geekbang-column-data-structure-big-data-action-improve-Shift-And-algo-ability/pipei.jpg" alt></p><p>我们假设模式串的长度是 m ，code(str[i]) 代表了文本串第 i 位字符的编码，整个匹配过程，从前往后，依次处理文本串的每一位，处理到第 i 位的时候，就是用第 i 位字符的编码（code（str[i])），与 p 左移 1 位并或上 1 以后的值（p&lt;&lt; 1 | 1），做“按位与”运算，把得到的值赋给 p 变量。最终，当 p 的二进制表示的第 m 位为 1 时，说明匹配成功了。</p><p>示例，当模式串为 cdd，文本串为 acdd 时候的匹配流程：</p><p><img src="/2020/05/31/geekbang-column-data-structure-big-data-action-improve-Shift-And-algo-ability/shili.jpg" alt></p><h3 id="p-公式的理解与推导"><a href="#p-公式的理解与推导" class="headerlink" title="p 公式的理解与推导"></a>p 公式的理解与推导</h3><p><img src="/2020/05/31/geekbang-column-data-structure-big-data-action-improve-Shift-And-algo-ability/p.jpg" alt></p><p>其中 pm​ 代表 p 的二进制表示的第 m 位为 1，pm−1​ 表示 p 的二进制表示的第 m-1 位为 1。因为只有第 m-1 位为 1，才可能左移 1 位以后的结果第 m 位为 1。</p><h3 id="实现Shift-And-算法"><a href="#实现Shift-And-算法" class="headerlink" title="实现Shift-And 算法"></a>实现Shift-And 算法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shift_and</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *p_str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> code[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;, m = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 初始化每一个字符的编码</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; p_str[i]; i++, m++) &#123;</span><br><span class="line">        code[p_str[i]] |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        p = (p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>) &amp; code[str[i]];</span><br><span class="line">        <span class="comment">// 如果 p 所对应的模式串最高位为1，代表匹配成功</span></span><br><span class="line">        <span class="keyword">if</span> (p &amp; (<span class="number">1</span> &lt;&lt; (m - <span class="number">1</span>))) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>该算法只用了两次循环，一次循环是遍历模式串，生成编码 code 信息，第二次循环是遍历文本串 str，循环迭代得到 p 变量的值，直到 p 变量的第 m 位为 1 时，就代表匹配成功。</li><li>时间复杂度就是 O(n + m) 。意味着，同样是文本串 10000 的长度，模式串 1000 长度，Shift-And 算法，是暴力匹配算法效率的 1000 倍！</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>等价信息表示对于解决问题很重要。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构：突破基本类型的限制，存储更大的整数</title>
    <url>/2020/05/31/geekbang-column-data-structure-break-through-the-limitation-of-basic-types-and-store-larger-integers/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>请你实现一个程序，输出 2 的 1000 次方的结果是多少。</p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul><li>C 语言中给我们提供的 int 类型，肯定是无法完成这个任务的，因为它表示不了这么大的数字。</li><li>用 long long 类型来进行解决，但long long 是 64 位整型，也就是占 64 个 2 进制位，它顶多能表示 2 的 64 次方减 1 的结果，相对于 2 的 1000 次方来说，小太多了。</li><li>用double类型进行解决，但存在一个严重的问题，就是 double 是有精度损失的。<br>（double 的表示精度，一般来说是有效数字 15 位，就是一个数字，由左向右，从第一个不为零的数字起，向后 15 位都是准确的。因此 double 类型实际上也没有办法，准确表示 2 的 1000 次方的计算结果。）</li></ul><p>那该怎么办呢？</p><h2 id="编码解决"><a href="#编码解决" class="headerlink" title="编码解决"></a>编码解决</h2><h3 id="大整数表示法"><a href="#大整数表示法" class="headerlink" title="大整数表示法"></a>大整数表示法</h3><p><img src="/2020/05/31/geekbang-column-data-structure-break-through-the-limitation-of-basic-types-and-store-larger-integers/dazhengshu.jpg" alt></p><p>这种表示法中，使用数组的第 0 位存储数字的位数，因为 3526 有 4 位，所以数组的第 0 位就设置成了 4 这个值。接下来，数组从第 1 位到第 4 位记录的就是原数字 3526。</p><p>注意：这个数字是好像是倒着放置的，数字的最高位，也放在数组的最高位中。</p><h3 id="如何计算大整数加法"><a href="#如何计算大整数加法" class="headerlink" title="如何计算大整数加法"></a>如何计算大整数加法</h3><p>计算 445 + 9667：</p><p><img src="/2020/05/31/geekbang-column-data-structure-break-through-the-limitation-of-basic-types-and-store-larger-integers/dazhengshujiafa.jpg" alt></p><p>首先我们用大整数表示法，分别表示 445 和 9667 这两个数字；然后以位数最长的那个大整数，作为计算结果大整数的基础位数，445 和 9667 按位相加，得到一个 4 位的结果大整数，4 位分别是，9、10、10、12；最后我们再依次处理进位，就得到了底下那一行的结果：10112。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个交换两个变量值的宏 swap</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a, b) &#123; \</span></span><br><span class="line">    __typeof(a) <span class="keyword">_t</span> = a; \</span><br><span class="line">    a = b, b = <span class="keyword">_t</span>; \</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现大整数加法 a + b 的结果，存放在 c 中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">plus_big_integer</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 让 a 指向位数较长的那个数字</span></span><br><span class="line">    <span class="keyword">if</span> (a[<span class="number">0</span>] &lt; b[<span class="number">0</span>]) swap(a, b);</span><br><span class="line">    <span class="comment">// 大整数 c 的位数以 a 的位数为基准</span></span><br><span class="line">    c[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 循环模拟按位做加法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= b[<span class="number">0</span>]) c[i] = a[i] + b[i];      </span><br><span class="line">        <span class="keyword">else</span> c[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理每一位的进位过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c[i] &lt; <span class="number">10</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 判断是不是最高位产生了进位</span></span><br><span class="line">        <span class="comment">// 如果是最高位产生进位，就进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (i == c[<span class="number">0</span>]) c[++c[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">        c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">        c[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>要计算 2 的 1000 次方的结果，就是要计算 1000 次乘法，最终的结果由于数值太大，我们肯定要使用大整数表示法了，所以要想理解这个计算过程，我们还是得回到大整数表示法本身，所对应的数学模型理解上。</p><p><img src="/2020/05/31/geekbang-column-data-structure-break-through-the-limitation-of-basic-types-and-store-larger-integers/dazhengshushiyi.jpg" alt></p><p>如上图所示，我们把大整数表示法中，每一个数字所对应的位权写出来，那么数组中所存储 3、5、2、6 的大整数信息，其实等价于下面的那一行数学公式，即 3∗10^3+5∗10^2+2∗10^1+6∗10^0。</p><p>我们对 3526 这个大整数乘以 2，其实等价于对下面那个数学式子乘以 2，就可以得到如下结果：</p><p><img src="/2020/05/31/geekbang-column-data-structure-break-through-the-limitation-of-basic-types-and-store-larger-integers/dazhengshushiyi2.jpg" alt></p><p>对某个大整数乘 2 的操作，其实，可以看成是对这个大整数的每一位分别乘以 2 的操作，然后再仿照大整数加法的过程，依次处理进位即可。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 num 数组初始化成大整数表示的 1</span></span><br><span class="line"><span class="comment">// 作用就是做累乘变量</span></span><br><span class="line"><span class="keyword">int</span> num[<span class="number">400</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算 100 次 2 的 10 次方相乘的结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 对大整数的每一位乘以 2 的 10 次方</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= num[<span class="number">0</span>]; j++) num[j] *= <span class="number">1024</span>;      </span><br><span class="line">        <span class="comment">// 处理进位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= num[<span class="number">0</span>]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[j] &lt; <span class="number">10</span>) <span class="keyword">continue</span>;          </span><br><span class="line">            <span class="keyword">if</span> (j == num[<span class="number">0</span>]) num[++num[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">            num[j + <span class="number">1</span>] += num[j] / <span class="number">10</span>;</span><br><span class="line">            num[j] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出大整数</span></span><br><span class="line">    <span class="comment">// 由于大整数是倒着存的，所以输出的时候倒着遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num[<span class="number">0</span>]; i &gt;= <span class="number">1</span>; --i) <span class="built_in">printf</span>(<span class="string">"%d"</span>, num[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出</span></span><br><span class="line"><span class="comment"> * 10715086071862673209484250490600018105614048117055336074437503883703510511249361224931983788156958581275946729175531468251871452856923140435984577574698574803934567774824230985421074605062371141877954182153046474983581941267398767559165543946077062914571196477686542167660429831652624386837205668069376/</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>在大整数的表示法中，数字是从右到左，倒着存放在数组中的。</li><li>大整数的表示法，体现的是数据结构对于程序设计的作用。</li><li>大整数的加法和乘法过程，体现的则是算法对于程序设计的作用。</li><li><strong>算法的底层是数学。</strong></li><li>如果是计算流程不合理，我们需要改进算法；如果是数据表示受限，我们需要求助于数据结构。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>大整数表示法</tag>
        <tag>高精度表示法</tag>
      </tags>
  </entry>
  <entry>
    <title>框架思维：用筛法求解其他积性函数</title>
    <url>/2020/05/31/geekbang-column-frame-thinking-solve-other-productive-fuctions-by-sieve-method/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>求出 10000 以内所有数字的因数和。</p><p>可能已经想好的方法：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">10005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 循环遍历 1 到 10000 的所有数字</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 用 j 循环枚举数字 i 可能的因数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="comment">// 当 i%j 不等于 0 时，说明 j 不是 i 的因数</span></span><br><span class="line">            <span class="keyword">if</span> (i % j) <span class="keyword">continue</span>;</span><br><span class="line">            sum[i] += j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init_sum();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效率较低，所以弃了。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="数论积性函数"><a href="#数论积性函数" class="headerlink" title="数论积性函数"></a>数论积性函数</h3><p>所谓数论积性函数，首先，是作用在正整数范围的函数，也就是说函数 f(x) = y 中的 x 均是正整数。其次，是数论积性函数的一个最重要的性质，就是如果 n 和 m 互质，那么 f(n*m) = f(n) * f(m) 。</p><p><img src="/2020/05/31/geekbang-column-frame-thinking-solve-other-productive-fuctions-by-sieve-method/shulun.jpg" alt></p><h3 id="因数个数函数"><a href="#因数个数函数" class="headerlink" title="因数个数函数"></a>因数个数函数</h3><p>因数个数：就不难理解了，它指的是一个数字因数的数量。例如，数字 6，有 1、2、3、6 这 4 个因数，因数个数就是 4。</p><h3 id="素数筛框架"><a href="#素数筛框架" class="headerlink" title="素数筛框架"></a>素数筛框架</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000</span></span><br><span class="line"><span class="keyword">int</span> prime[MAX_N + <span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_prime</span><span class="params">()</span> </span>&#123;  <span class="comment">//初始化 prime 数组信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= MAX_N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prime[i]) <span class="keyword">continue</span>;  <span class="comment">//prime[i] 中记录的是数字 i 中最小的素因子</span></span><br><span class="line">        <span class="comment">// 素数中最小的素因子是其本身</span></span><br><span class="line">        prime[i] = i;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= MAX_N; j += i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prime[j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 如果 j 没有被标记过，就标记成 i</span></span><br><span class="line">            prime[j] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prime[i] == <span class="number">0</span>) prime[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000</span></span><br><span class="line"><span class="keyword">int</span> prime[MAX_N + <span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> g_cnt[MAX_N + <span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_g_cnt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1 的因数数量就是 1 个</span></span><br><span class="line">    g_cnt[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = i, cnt = <span class="number">0</span>, p = prime[i];</span><br><span class="line">        <span class="comment">// 得到数字 n 中，包含 cnt 个最小素因子 p</span></span><br><span class="line">        <span class="keyword">while</span> (n % p == <span class="number">0</span>) &#123;</span><br><span class="line">            cnt += <span class="number">1</span>;</span><br><span class="line">            n /= p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时数字 n 和最小素数 p 部分，就是互素的</span></span><br><span class="line">        g_cnt[i] = g_cnt[n] * (cnt + <span class="number">1</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>所谓代码框架，就是要活学活用。</li><li>在真正的工作中，你所做的事情，大多是在多种代码框架之间做选择及组合拼装，每个算法代码只会解决遇到的一部分问题。而你在使用这些算法代码的时候，往往不能照搬照用，反而要做一些适应性的改变，这些都是“框架思维”中所重视的。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>拉勾直播_90分钟带你玩转BAT算法面试_吃相难看</title>
    <url>/2020/05/26/lagou-live-90min-play-BAT-algo-interview/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="直播内容"><a href="#直播内容" class="headerlink" title="直播内容"></a>直播内容</h2><ul><li><del>1，为什么算法是大厂面试的必备项？</del></li><li><del>2，大厂高频算法面试题剖析</del></li><li><del>3，剖析大厂青睐的必备技能</del></li><li>4，想成为高薪Java工程师，该怎么办？</li></ul><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>麻烦用点心吧，123一晃而过，4才是重点——推销课程。</p><p>这样的直播，不听也罢。</p><p>在此建议各位，如果遇到这种免费直播，听听就好，别太认真，有些直播已推销为主，另外也需要认清自己，以及是否真的需要报班来学习，千万别被洗脑！</p><p>写以此文，记录这糟糕、吃相难看的直播。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>直播分享</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>算法</tag>
        <tag>BAT</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-287-find-the-duplicate-number | 寻找重复数</title>
    <url>/2020/05/26/Leetcode-287-find-the-duplicate-number/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">find-the-duplicate-number</a></p><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><ul><li>建立一个key为int，value为int的map；</li><li>第一遍<code>for range</code>循环遍历<code>nums</code>数组，将<code>nums</code>数组里的元素出现的次数记录进<code>map</code>中；</li><li>第二遍<code>for range</code>循环遍历<code>map</code>，将value不为1的num取出返回，即为重复数。</li></ul><p>这个解法需要用两次<code>for</code>循环，效率不高，下面我考虑用第二种解法。</p><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><ul><li>建立一个key为int，value为bool类型的map；</li><li>一遍<code>for range</code>循环遍历<code>nums</code>数组，如果这个<code>num</code>第一次出现，就将其value置为true，否则直接返回这个<code>num</code>，因为value为true代表这个<code>num</code>已经出现过一次了，第二次再遍历到它时，即为重复数。</li></ul><p>go代码</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> numsmap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> _,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> !numsmap[num] &#123;</span><br><span class="line">            <span class="comment">//只出现一次</span></span><br><span class="line">            numsmap[num] = <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>map</tag>
        <tag>array</tag>
        <tag>循环</tag>
      </tags>
  </entry>
  <entry>
    <title>框架思维：将素数筛算法写成框架算法</title>
    <url>/2020/05/24/geekbang-column-frame-thinking-write-the-prime-sieve-algo-as-a-frame-algo/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>求 1 万以内所有素数的和。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="素数筛算法介绍"><a href="#素数筛算法介绍" class="headerlink" title="素数筛算法介绍"></a>素数筛算法介绍</h3><p>所谓素数筛，是将其产出的信息存储在一个标记数组中，数组的第 i 位，标记的是 i 这个数字是否是合数的信息。如果 i 这个数字是合数，数组下标为 i 的位置就被标记成为 1，如果 i 不是合数，则数组下标为 i 的位置就是 0。素数筛就是通过一套算法流程，产生一个这样的数组。</p><p>算法流程：<br><img src="/2020/05/24/geekbang-column-frame-thinking-write-the-prime-sieve-algo-as-a-frame-algo/sushu-algo.jpg" alt></p><h3 id="素数筛代码框架"><a href="#素数筛代码框架" class="headerlink" title="素数筛代码框架"></a>素数筛代码框架</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[<span class="number">10005</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 素数筛的标记过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= <span class="number">10000</span>; i++) &#123;  <span class="comment">//从 2 开始遍历到根号 10000，也就是 100。</span></span><br><span class="line">        <span class="comment">//i &lt;= sqrt(10000) == i * i &lt;= 10000</span></span><br><span class="line">        <span class="comment">//这种改变是有好处的，会在代码运行速度上做提升，毕竟开方运算是很慢的，远远没有单独做一个乘法操作要快。</span></span><br><span class="line">        <span class="keyword">if</span> (prime[i]) <span class="keyword">continue</span>;  <span class="comment">//判断 i 这个数字是否被标记过的，如果被标记过，就说明是合数，就不执行后续操作。</span></span><br><span class="line">        <span class="comment">// 用 j 枚举所有素数 i 的倍数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= <span class="number">10000</span>; j += i) &#123;</span><br><span class="line">            prime[j] = <span class="number">1</span>; <span class="comment">// 将 j 标记为合数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000</span></span><br><span class="line"><span class="keyword">int</span> prime[MAX_N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化素数表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     prime[<span class="number">0</span>] = prime[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= MAX_N; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (prime[i]) <span class="keyword">continue</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> * i; j &lt;= MAX_N; j += i) &#123;</span><br><span class="line">             prime[j] = <span class="number">1</span>; <span class="comment">// 将 j 标记为合数</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init_prime();</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line">        sum += i * (<span class="number">1</span> - prime[i]); <span class="comment">// 素数累加</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：5736396</span></span><br></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1，因子分解程序正确性证明"><a href="#1，因子分解程序正确性证明" class="headerlink" title="1，因子分解程序正确性证明"></a>1，因子分解程序正确性证明</h3><blockquote><p>所谓的素因子分解，就是把一个整数，表示成为若干个素数相乘的形式，并且我们可以轻松的证明，这种只由素数表示的分解表示法，对于某个特定整数 N 来说，一定是唯一的。<br>例如，67689 这个数字就可以分解为：3 * 3 * 3 * 23 * 109 = 67689，其中 3、23、109 都是素数。</p></blockquote><p>下面呢，有一段素因子分解的程序：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印一个素因子，并且在中间输出 * 乘号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_num</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> *flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*flag == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">" * "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, num);</span><br><span class="line">    *flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i = <span class="number">2</span>, flag = <span class="number">0</span>, raw_n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    raw_n = n;</span><br><span class="line">    <span class="comment">// 循环终止条件，循环到 n 的平方根结束</span></span><br><span class="line">    <span class="keyword">while</span> (i * i &lt;= n) &#123;</span><br><span class="line">        <span class="comment">//①：只要 n 可以被 i 整除，就认为 i 是 n 的一个素因子</span></span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            print_num(i, &amp;flag);</span><br><span class="line">            n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//②：如果最后 n 不等于 1，就说明 n 是最后一个素数</span></span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">1</span>) print_num(n, &amp;flag);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" = %d\n"</span>, raw_n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>试证明：</p><ul><li><p>1，第 18 行代码中，只要 n 可以被 i 整除，i 就一定是素数，为什么？<br>假设 i 可以被 n 整除，但 i 不是素数，由算术基本定理可知，一个非素数的数字 N，一定可以分解为几个小于 N 的素数乘积的形式。我们不妨假设 i=p1​×p2​，这里 p1​ 和 p2​ 均为素数，如果变量 n 可以被 i 整除，那么 n 也一定可以被小于 i 的素数 p1​ 整除。而根据程序的运行流程，n 中已经不可能存在小于 i 的因子了，所以 p1​ 不具备存在的条件，故原假设不成立，i 是素数。</p></li><li><p>2，第 25 行代码中，为什么只要 n 不等于 1，n 就一定是素数呢？<br>在 while 循环处理过程中，数字 n 中已经不可能存在小于等于 i 的所有的因子了，又因为此时 i 是大于根号 n 的一个值，也就是说，在小于等于根号 n 范围内，找不到数字 n 的非 1 因子，而能够满足这种性质的数字，一定是素数。</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>想把具体“算法”升华成“算法思维”，首先要习惯性地总结算法的“框架思维”。</li><li>素数筛是用素数去标记掉这个素数所有的倍数。</li><li>清楚地知道素数筛在执行过程中，每一行的性质。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>框架</tag>
        <tag>素数</tag>
        <tag>合数</tag>
      </tags>
  </entry>
  <entry>
    <title>程序设计原则：把计算过程交给计算机</title>
    <url>/2020/05/24/geekbang-column-give-the-calculation-process-to-the-computer/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>求出 1000 以内所有 3 或 5 倍数的数字的和。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="一份合格的程序实现"><a href="#一份合格的程序实现" class="headerlink" title="一份合格的程序实现"></a>一份合格的程序实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1000</span>; i++) &#123;  <span class="comment">//循环遍历 1000 以内的所有整数</span></span><br><span class="line">        sum += i * (i % <span class="number">3</span> == <span class="number">0</span> || i % <span class="number">5</span> == <span class="number">0</span>);  <span class="comment">//把 3 或 5 的倍数累加到变量 sum 中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum);  <span class="comment">//最后输出 sum 变量的值，就是 1000 以内，所有 3 或 5 的倍数和。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提升计算效率"><a href="#提升计算效率" class="headerlink" title="提升计算效率"></a>提升计算效率</h3><p>利用等差数列求和公式：<br><img src="/2020/05/24/geekbang-column-give-the-calculation-process-to-the-computer/gongshi.jpg" alt></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum3 = (<span class="number">3</span> + <span class="number">999</span> / <span class="number">3</span> * <span class="number">3</span>) * (<span class="number">999</span> / <span class="number">3</span>) / <span class="number">2</span>;  <span class="comment">//1000 以内所有 3 的倍数的和 sum3</span></span><br><span class="line">    <span class="keyword">int</span> sum5 = (<span class="number">5</span> + <span class="number">999</span> / <span class="number">5</span> * <span class="number">5</span>) * (<span class="number">999</span> / <span class="number">5</span>) / <span class="number">2</span>;  <span class="comment">//1000 以内所有 5 的倍数的和 sum5</span></span><br><span class="line">    <span class="keyword">int</span> sum15 = (<span class="number">15</span> + <span class="number">999</span> / <span class="number">15</span> * <span class="number">15</span>) * (<span class="number">999</span> / <span class="number">15</span>) / <span class="number">2</span>; <span class="comment">//1000 以内所有 15 的倍数的和 sum15</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum3 + sum5 - sum15);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1，和的平方减平方和"><a href="#1，和的平方减平方和" class="headerlink" title="1，和的平方减平方和"></a>1，和的平方减平方和</h3><blockquote><ol><li>请编写一个程序，计算 100 以内自然数“和的平方”与“平方和”的差。</li><li>能否通过查阅资料，推导得到等差数列的平方和公式呢？</li></ol></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hepingfang</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> + n) * (<span class="number">1</span> + n) * n / <span class="number">4</span> + n * (n * n - <span class="number">1</span>) / <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pingfanghe</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> + n) * (<span class="number">1</span> + n) * n / <span class="number">4</span> + n * (n * n - <span class="number">1</span>) / <span class="number">12</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算 100 以内自然数“和的平方”与“平方和”的差</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d - %d = %d\n"</span>,hepingfang(n),pingfanghe(n),hepingfang(n)-pingfanghe(n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>具体的计算过程，计算机比你更擅长，所以请把具体的计算过程，留给计算机。</li><li>编写程序，其实是在描述和规定计算过程，而描述的方式不同，效率也不同。</li><li>不同的效率过程，就是我们所谓的不同的算法过程，记住：算法很重要。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
  </entry>
  <entry>
    <title>数学归纳法：搞定循环与递归的钥匙</title>
    <url>/2020/05/24/geekbang-column-math-induction-the-key-to-loop-and-recursion/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>实现一个可变循环层数的程序。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>我们可以一开始假设，有一个函数，是实现 5 层循环打印的程序，那么它会循环 n 次，每次调用一个实现 4 层循环打印的程序。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码框架</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_loop</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//代表 k 层循环的程序，然后循环 n 次，每次调用一个 k - 1 层循环的程序。</span></span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 打印一行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        print_loop(k - <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完善程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">100</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">入参：</span></span><br><span class="line"><span class="comment">total_k，代表了一共有多少层循环，这个参数是为了方便我们最后确定循环输出的上界</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_loop</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> total_k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = total_k; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != total_k) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        arr[k] = i;</span><br><span class="line">        print_loop(k - <span class="number">1</span>, n, total_k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, fib(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段程序中，fib 函数是求菲波那契数列第 n 项值的函数。菲波那契数列的定义如下：<br><img src="/2020/05/24/geekbang-column-math-induction-the-key-to-loop-and-recursion/fib.jpg" alt><br>根据如上内容，你需要完成两个小的思考题：</p><h3 id="1，请将上述菲波那契数列求解的程序从递归程序，改成循环程序。"><a href="#1，请将上述菲波那契数列求解的程序从递归程序，改成循环程序。" class="headerlink" title="1，请将上述菲波那契数列求解的程序从递归程序，改成循环程序。"></a>1，请将上述菲波那契数列求解的程序从递归程序，改成循环程序。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归写法</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if (n == 1 || n == 2) return 1; // 终止条件 -- 数学归纳法step1</span></span><br><span class="line"><span class="comment">        return fib(n-1) + fib(n-2); // 处理过程 -- 数学归纳法step2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环写法</span></span><br><span class="line">    <span class="keyword">int</span> f1 = <span class="number">1</span>, f2 = <span class="number">1</span>, f3;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        f3 = f1 + f2;</span><br><span class="line">        f1 = f2;</span><br><span class="line">        f2 = f3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2，请将上述递归程序的代码和数学归纳法中的步骤做一一对应。"><a href="#2，请将上述递归程序的代码和数学归纳法中的步骤做一一对应。" class="headerlink" title="2，请将上述递归程序的代码和数学归纳法中的步骤做一一对应。"></a>2，请将上述递归程序的代码和数学归纳法中的步骤做一一对应。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//数学归纳法中所谓的 k0​ 成立，这一步保证了，fib 函数计算的第 1 项 和 第 2 项的斐波那契函数值一定是正确的。</span></span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);  <span class="comment">//数学归纳法中的第二步，假设 ki​ 成立，证明 ki+1​ 也成立。</span></span><br><span class="line">    <span class="comment">//最后结论，这个fib 递归函数设计是正确的。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, fib(n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>数学归纳法中重要的两部分，一是要边界条件成立，二是证明转移过程成立。</li><li>程序设计最重要的是正确性，递归函数的正确性可以利用数学归纳法来保证。</li><li>递归程序设计中的重要的两部分：边界条件和处理过程。所谓边界条件，就是当递归函数中的参数等于多少的时候，可以直接返回的条件。处理过程呢，就是设计程序过程，处理递归调用的返回结果，根据递归调用的返回结果，得到本函数的结果。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>循环</tag>
        <tag>递归</tag>
        <tag>数学</tag>
        <tag>归纳</tag>
      </tags>
  </entry>
  <entry>
    <title>预处理命令：让编译器帮你写代码</title>
    <url>/2020/05/23/geekbang-column-Pre-processing-cmd-let-the-compiler-write-the-code-for-you/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>请你实现一个打印“漂亮日志格式”的方法。</p><p>首先我们先说“日志”的作用，程序中的“日志”，通常是指在程序运行过程中，输出的一些与程序当前状态或者数据相关的一些信息。这些信息，可以帮助程序开发人员做调试，帮助运营人员做数据分析，帮助管理人员分析日活等等。总而言之，一份合理的日志信息，是非常有价值的数据。而我们今天呢，接触一种最简单的日志形式，就是程序运行过程中的调试信息。</p><p>请你实现一个参数形式和 printf 函数一样的 log 方法，用法如代码所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">    func(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你会看到上述代码中，有一个和 printf 名字不一样可用法完全一样的方法叫做 log，而这个 log 的输出结果，和 printf 可不一样。</p><p>具体如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = 123</span><br><span class="line">[main, 10] a = 123</span><br><span class="line">[func, 4] a = 123</span><br></pre></td></tr></table></figure><p>你会看到 log 的方法，虽然和 printf 函数的用法一致，可在输出内容中，log 方法的输出明显比 printf 函数的输出要多了一些信息。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>如何定义一个支持可变参数的log宏：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> log(frm, args...) <span class="comment">// 假装这里有内容，后续展开讲解</span></span></span><br></pre></td></tr></table></figure><p>所以可以将 log 方法的使用方式与 printf 类似了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> log(frm, args...) printf(frm, args)</span></span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> log(frm, args...) &#123; \</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%s : %d] "</span>,__func__,__LINE__); \</span><br><span class="line">    <span class="built_in">printf</span>(frm, ##args); \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//"##"的作用是对token进行连接，这里的args就是token,如果token为空，那么不进行连接，所以允许省略可变参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//[main : 11] hello world</span></span><br></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1，没有-Bug-的-MAX-宏"><a href="#1，没有-Bug-的-MAX-宏" class="headerlink" title="1，没有 Bug 的 MAX 宏"></a>1，没有 Bug 的 MAX 宏</h3><blockquote><p>请你完善下面代码中的 MAX 宏，MAX 宏的作用，就是接受两个元素，选择出两个元素中的最大值。<br>完善以后的 MAX 宏，输出需要与如下给出的输出样例一致，注意，只能修改 MAX 宏的定义内容，不可以修改主函数中的内容。</p></blockquote><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P(item) printf(<span class="meta-string">"%s = %d\n"</span>, #item, item);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) <span class="comment">// TODO</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line">    P(MAX(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    P(<span class="number">5</span> + MAX(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    P(MAX(<span class="number">2</span>, MAX(<span class="number">3</span>, <span class="number">4</span>)));</span><br><span class="line">    P(MAX(<span class="number">2</span>, <span class="number">3</span> &gt; <span class="number">4</span> ? <span class="number">3</span> : <span class="number">4</span>));</span><br><span class="line">    P(MAX(a++, <span class="number">5</span>));</span><br><span class="line">    P(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果参考：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">MAX(2, 3) = 3</span></span><br><span class="line"><span class="comment">5 + MAX(2, 3) = 8</span></span><br><span class="line"><span class="comment">MAX(2, MAX(3, 4)) = 4</span></span><br><span class="line"><span class="comment">MAX(2, 3 &gt; 4 ? 3 : 4) = 4</span></span><br><span class="line"><span class="comment">MAX(a++, 5) = 6</span></span><br><span class="line"><span class="comment">a = 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>实现（思考过程是重点）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a, b) (&#123; \</span></span><br><span class="line">    __typeof(a) __a = (a), __b = (b); \</span><br><span class="line">    __a &gt; __b ? __a : __b; \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>C 语言的程序编译是一套过程，中间你必须搞懂的有：预处理阶段，编译阶段和链接阶段。</li><li>程序最终的功能，是由“待编译源码”决定的，而“待编译源码”是由各种各样的预处理命令决定的。</li><li>预处理命令之所以被称为“黑魔法”，是因为编译器会根据预处理命令改变你的源代码，这个过程，神秘而具有力量，功能强大。</li><li>代码中反斜杠的后面，不能出现任何其他内容。</li><li>宏定义只占用一行代码，为了增强宏定义的代码可读性，我们可以采用在行尾加反斜杠的技巧，来使得上下两行代码，变成编译器眼中的一行代码。</li><li>宏的作用，就是替换，要想理解最终的代码行为，必须从宏替换以后的代码入手分析。</li><li>条件编译相当于一种预处理阶段的代码剪裁技巧。</li><li>编译器预设的宏，有标准的，也有非标准的，非标准的代码会影响其可移植性。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>预处理</tag>
        <tag>宏定义</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手实现低配版 scanf 函数</title>
    <url>/2020/05/23/geekbang-column-DIY-scanf-function-by-yourself/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>仿照 scanf 函数，实现一个低配版的 my_scanf 函数。这个函数的功能，简单来说就是将一个字符串信息转换成整型数字，能够完成这个任务，你会更深刻的理解 scanf 函数，更深刻的理解参数设计。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个基础功能</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">98</span>;</span><br><span class="line">my_scanf(<span class="string">"12345"</span>, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, n); <span class="comment">// 输出 12345，而不是 98</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个基础功能</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">98</span>, m = <span class="number">0</span>;</span><br><span class="line">my_scanf(<span class="string">"123 45"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"n = %d m = %d"</span>, n, m); <span class="comment">// 输出 n = 123 m = 45</span></span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_scanf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">int</span> *ret)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>, flag = <span class="number">0</span>;  <span class="comment">//定义存放转换结果的 num 变量，用来标记正负数的flag 变量。0 代表正数，1 代表负数。</span></span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'-'</span>) str += <span class="number">1</span>, flag = <span class="number">1</span>; <span class="comment">//判断字符串中的第一位是不是字符 ‘-’，如果是字符 ‘-’，就将 flag 标记为 1，并且把 str 字符指针所指的位置，向后跳动一位，因为 ‘-’ 后面就是要转换的第一个数字字符了。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        num = num * <span class="number">10</span> + (str[i] - <span class="string">'0'</span>);  <span class="comment">//遍历字符串剩余的每一位，每次将当前字符所代表的数字，放到 num 数字的末尾。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) num = -num;  <span class="comment">//如果是负数，数字前需要加-</span></span><br><span class="line">    *ret = num;  <span class="comment">//把 num 中的值拷贝到 ret 所指向的存储区中，也就是主函数中的 n 变量的内存区中。</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1000</span>];  <span class="comment">//定义字符数组 str</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">65</span>;  <span class="comment">//定义整型变量 n</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);  <span class="comment">//读入一个字符串，将其保存在字符数组中</span></span><br><span class="line">    my_scanf(str, &amp;n);  <span class="comment">//使用 my_scanf 函数将字符数组中的字符串信息，转换成为整型信息存储在 n 中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n = %d\n"</span>, n);  <span class="comment">//使用 printf 函数输出 n 的值，加以确认</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>函数的作用，是做功能封装，以便在程序其他地方复用相关功能。</li><li>函数的参数传递过程，就是“实参”给“形参”赋值的过程，“实参”与“形参”之间互相独立，互不影响。</li><li>在函数参数设计中，一定要分清楚，传入参数和传出参数在功能上的差别。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>scanf</tag>
      </tags>
  </entry>
  <entry>
    <title>指针系列_指针变量也是变量</title>
    <url>/2020/05/23/geekbang-column-pointer-variables-are-also-variables/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>假设有如下结构体数组，请看如下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125; a[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>请用尽可能多的形式，替换下面代码中 &amp;a[1].x 的部分，使得代码效果不变：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> *<span class="title">p</span> = <span class="title">a</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p"</span>, &amp;a[<span class="number">1</span>].x);</span><br></pre></td></tr></table></figure><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="方法一，间接引用"><a href="#方法一，间接引用" class="headerlink" title="方法一，间接引用"></a>方法一，间接引用</h3><p>减号大于号（-&gt;），组合起来，叫做“间接引用”运算符，作用可以和“直接引用”运算符对比。</p><p>例如：a 是一个结构体变量，a 中有一个字段叫做 x，由 a 去找到 x，这个过程比较直接，我们就用 a.x 来表示。可如果 p 是一个指针，指向 a 变量，如果要是由 p 去找到 x，这个过程就是个间接的过程，所以我们就使用 p-&gt;x。<br>简单来说，就是：<strong>是结构体变量引用字段，就直接引用，如果是指针想引用字段，就是间接引用。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125; a[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> *<span class="title">p</span> = <span class="title">a</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p"</span>, &amp;((a + <span class="number">1</span>)-&gt;x));  <span class="comment">//用a+1定位到第二个结构体元素的首地址，然后间接引用x字段，最后再对 x 字段取地址，那么得到的和原任务中所输出的地址是一样的。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0x55e3c8fa0028</span></span><br></pre></td></tr></table></figure><h3 id="方法二，巧妙使用指针类型"><a href="#方法二，巧妙使用指针类型" class="headerlink" title="方法二，巧妙使用指针类型"></a>方法二，巧妙使用指针类型</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125; a[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> *<span class="title">p</span> = <span class="title">a</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p"</span>, &amp;(a[<span class="number">0</span>].y) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0x55e3c8fa0028</span></span><br></pre></td></tr></table></figure><p>利用地址类型这个知识点，先定位到 a[0] 元素中 y 字段的首地址，然后对 y 字段取地址，这个时候，由于 y 字段是整型，所以取到的地址类型就是整型地址，之后再对这个整型地址执行 +1 操作，得到的也是 a[1].x 的首地址。</p><p><img src="/2020/05/23/geekbang-column-pointer-variables-are-also-variables/address.jpg" alt="a数组内存结构示意图"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>可以通过 C 语言里面的工具来描述这种类型的特点，这个可以用来描述和定义新类型的工具，就叫做：结构体。</li><li>对于某个结构体类型而言，其存储单元大小，等于它当中占用空间最大的基础类型所占用的字节数量。</li><li>结构体的字段在内存中存储的顺序，是按照结构体定义时的顺序排布的，而且当本存储单元不够安放的时候，就从下个存储单元的头部开始安放。</li><li>指针是变量，指针是一种用来存储地址的变量。</li><li>指针的类型，决定了指针取值时所取的字节数量。</li><li>指针的类型，决定了指针加减法过程中，所跨越的字节数量。</li><li>无论是什么类型的指针，大小都相等，因为地址信息是统一规格的。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>变量</tag>
        <tag>结构体</tag>
        <tag>地址</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串_printf 的高级用法</title>
    <url>/2020/05/23/geekbang-column-strings-advanced-usage-of-printf/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>Q:printf 函数在输出浮点型数据的时候，如何保留位数呢？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2lf"</span>, <span class="number">3.1415926</span>);</span><br><span class="line"><span class="comment">//输出：3.14</span></span><br></pre></td></tr></table></figure><p>A:%lf 是 double 双精度浮点型输出的格式占位符，<strong>当我们想要保留小数点后两位的时候，只需要在 % 和 lf 中间加上 .2 即可</strong>，2 写在 .(点) 的后面代表小数点后 2 位。</p><p>实现一个能够保留小数点后 n 位的程序，这里的 n 是我们程序读入的一个变量。<br>例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入1：3.1415926 2</span><br><span class="line">输出1：3.14</span><br><span class="line"></span><br><span class="line">输入2：3.1415926 3</span><br><span class="line">输出3:3.142</span><br></pre></td></tr></table></figure><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>第一种：用<code>switch case</code>语句做</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> num;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf%d"</span>, &amp;num, &amp;n);</span><br><span class="line">    <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">"%.1lf\n"</span>, num); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, num); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, num); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">"%.4lf\n"</span>, num); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">"%.5lf\n"</span>, num); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如何优化呢？？？</p><p>第二种：printf 函数的第一个参数不就是个字符串，既然是字符串信息，那我只需要在 printf 语言前，拼接合适的字符串信息传给 printf 函数即可。</p><p>例如，要求保留 1 位小数的时候，我就拼接出来 “%.1lf” 字符串信息，要求保留 2 位小数的时候，就拼接处理出 “%.2lf”字符串信息即可。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> num;  <span class="comment">//定义一个浮点型变量 num</span></span><br><span class="line">    <span class="keyword">int</span> n;  <span class="comment">//定义一个整型变量 n</span></span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];  <span class="comment">//定义一个字符数组 str</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf%d"</span>, &amp;num, &amp;n);</span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">"%%.%dlf\n"</span>, n); <span class="comment">// %% 代表输出一个 %</span></span><br><span class="line">    <span class="built_in">printf</span>(str, num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1，体验利器"><a href="#1，体验利器" class="headerlink" title="1，体验利器"></a>1，体验利器</h3><blockquote><p>刚刚在上面，介绍了 sprintf 和 sscanf 两个字符串处理的利器工具，那么就请使用 sprintf 函数实现 strlen、strcpy、strcat 函数的功能，注意哦，只允许使用 sprintf 函数，模仿如上三个函数的功能。</p></blockquote><p>实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">1000</span>], str2[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, str1, str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str1 = %s\tstr2 = %s\n"</span>, str1, str2);</span><br><span class="line">    <span class="built_in">sprintf</span>(str1, <span class="string">"%s"</span>, str1);   <span class="comment">// strlen(str1)，输出str1 字符串中的字符数量</span></span><br><span class="line">    <span class="comment">//printf("strlen= %s\n",str1);</span></span><br><span class="line">    <span class="built_in">sprintf</span>(str1, <span class="string">"%s"</span>, str2);   <span class="comment">// strcpy(str1, str2)，把 str2 的内容复制到了 str1 中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str1 = %s\tstr2 = %s\n"</span>, str1, str2);</span><br><span class="line">    <span class="built_in">sprintf</span>(str1, <span class="string">"%s%s"</span>, str1, str2);   <span class="comment">// strcat(str1, str2)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str1 = %s\tstr2 = %s\n"</span>, str1, str2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2，优美的遍历技巧"><a href="#2，优美的遍历技巧" class="headerlink" title="2，优美的遍历技巧"></a>2，优美的遍历技巧</h3><blockquote><p>介绍完了字符串的相关知识以后，请思考如下问题，如何在不计算字符串长度的情况下，遍历字符串的每一位呢？<br>程序设计要求是，读入一个字符串，然后在不计算字符串长度的情况下，输出字符串中的每一个字符，每个字符占一行。其中所谓计算字符串长度的方法，包括但不限于 strlen，sprintf，先行 for 循环遍历统计等。</p></blockquote><p>实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">1000</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    循环的结束条件：</span></span><br><span class="line"><span class="comment">    任何信息在底层都是二进制存储的，那么其余字符均为非零值，也就是代表条件成立。</span></span><br><span class="line"><span class="comment">    只有一个字符的值是零值，就是我们之前所说的字符串中的最后一个特殊的，看不见的字符，\0 字符，</span></span><br><span class="line"><span class="comment">    这个字符所对应的整型值就是 0，也就是我们所谓的假值。那么这个循环，就会一直循环到字符串的最后一位，才会停止。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>具体结果就是值，明确知道等于多少的就是值。存储这些值的地方，就是变量，就是在程序中用来指代某片存储空间的名称，值就是存储空间里面的具体内容。</li><li>字符串信息可以存储在字符数组中，字符数组就是“变量”的概念，字符串就是“值”的概念。</li><li>sscanf 和 sprintf 函数，本质上在做的是以字符串为中间值，做各种数据类型之间的转换。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
  </entry>
  <entry>
    <title>数组：一秒钟，定义 1000 个变量</title>
    <url>/2020/05/23/geekbang-column-array-one-second-define-1000-variables/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>程序中读入一个整数 n，假设 n 不会大于 1000，请输出 1 到 n 的每一个数字二进制表示中的 1 的个数。</p><p>当 n 等于 7 的时候，我们把 1 到 7 的每个数字的二进制表示罗列出来，会得到下表所示内容：</p><p><img src="/2020/05/23/geekbang-column-array-one-second-define-1000-variables/array1.jpg" alt="到7的二进制表示"></p><p>根据表中的内容，如果你的程序编写成功的话，程序应该分别输出 1、1、2、1、2、2、3，这些输出内容分别代表每个数字二进制表示中 1 的数量。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果我们用一个数组 f 记录相应数字二进制表示中 1 的数量，那么 f[i] 就代表 i 这个数字二进制表示中 1 的数量，从而我们可以推导得到 f[i] = f[i &amp; (i - 1)] + 1，也就是说 i 比 i &amp; (i - 1) 这个数字的二进制表示中的 1 的数量要多一个，这样我们通过一步计算就得到 f[i] 的结果。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);  <span class="comment">//读入一个整数n，代表要求解的范围</span></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  <span class="comment">//循环n次</span></span><br><span class="line">        f[i] = f[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;  <span class="comment">//每一次通过递推公式f[i] = f[i &amp; (i - 1)] + 1 计算得到 f[i] 的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后输出 1 到 n 中每个数字二进制表示中 1 的个数。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">1 1 2 1 2 2 3 1 2 2 3 2 3 3 4 1 2 2 3 2 3 3 4 2 3 3 4 3 4 4 5 1 2 2 3 2 3 3 4 2 3 3 4 3 4 4 5 2 3 3 4 3 4 4 5 3 4 4 5 4 5 5 6 1 2 2 3 2 3 3 4 2 3 3 4 3 4 4 5 2 3 3 4 3 4 4 5 3 4 4 5 4 5 5 6 2 3 3 4 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1，去掉倍数"><a href="#1，去掉倍数" class="headerlink" title="1，去掉倍数"></a>1，去掉倍数</h3><blockquote><p>设计一个去掉倍数的程序，要求如下：<br>首先读入两个数字 n 和 m，n 的大小不会超过 10，m 的大小都不会超过 10000；<br>接下来读入 n 个各不相同的正整数，输出 1 到 m 中，有哪些数字无法被这 n 个正整数中任意的一个整除。</p></blockquote><p>例子</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">3 12</span><br><span class="line">4 5 6</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">1 2 3 7 9 11</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> check[<span class="number">1005</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//使用一个 check 数组作为标记，check[i] 等于 0，代表 i 这个数字不是 n 个数字中的任何一个数字的倍数。check[i] 等于 1，代表 i 这个数字能够被 n 个数字中的某个数字整除</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, num;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;num);  <span class="comment">//首先读入 n 个数字中的某一个，存储在 num 变量中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = num; j &lt;= m; j += num) &#123;</span><br><span class="line">            check[j] = <span class="number">1</span>;  <span class="comment">//循环 m 以内所有 num 的倍数，把每个数字的 check 值标记为 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (check[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);  <span class="comment">//最后我们循环把 1 到 m 中没有被标记的数字输出，就是符合题目要求的所有数字。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>使用数组，可以很方便的定义出一组变量存储空间，数组下标从 0 开始。</li><li>数据的最基本存储单位是字节，每一个字节都有一个独一无二的地址。</li><li>一个变量占用若干个字节，第一个字节的地址，是这个变量的首地址，称为：变量地址。</li><li>字节是存储数据的最基本单位，比特是表示信息的最基本单位。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>字节</tag>
        <tag>比特</tag>
      </tags>
  </entry>
  <entry>
    <title>随机函数：随机实验真的可以算 π 值吗</title>
    <url>/2020/05/22/geekbang-column-random-function/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>圆周率 π 对你来说肯定不是一个陌生的概念，它指的是圆的周长与直径的比值。在古代，数学家们为了计算 π 的精确值想尽方法，可能穷尽一生也不过精确到小数点后几位而已。但到了现在，你可能不相信，只要你知道 π 的定义，就可以利用编程轻易计算出 π 的值。那究竟怎么做到呢？</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="rand用法"><a href="#rand用法" class="headerlink" title="rand用法"></a>rand用法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, rand() % <span class="number">1000</span>); <span class="comment">// 永远输出固定值</span></span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, rand() % <span class="number">1000</span>); <span class="comment">// 每次运行都不同</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在第 6 行代码里，我们虽然使用了 rand() 函数，可每次运行都将输出同样的值，这是因为我们没有设置随机种子，每次运行时 rand() 函数所记录的起始值都相同，所以每次运行输出的随机值也都相同。</p></li><li><p>第 8 行代码中，由于我们根据程序运行时的当前时间设置了随机种子，每次运行程序，第 8 行都将输出不同的值。事实上，如果你在 srand() 函数里面设置一个固定值，每次运行程序，结果也都将是一样的。</p></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//循环每一次，让计算机帮我们做一次实验</span></span><br><span class="line">        <span class="keyword">double</span> x = <span class="number">1.0</span> * rand() / RAND_MAX;  <span class="comment">//rand() 随机函数，返回值的范围是[0, RAND_MAX]，通过该表达式计算，我们就得到了一个[0.0, 1.0] 之间的随机值了。</span></span><br><span class="line">        <span class="keyword">double</span> y = <span class="number">1.0</span> * rand() / RAND_MAX;</span><br><span class="line">        <span class="keyword">if</span> (x * x + y * y &lt;= <span class="number">1.0</span>) m += <span class="number">1</span>;  <span class="comment">//判断一下随机选择的点，是否在圆内部；如果在，我们就记录一次</span></span><br><span class="line">        n += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, <span class="number">4.0</span> * m / n); <span class="comment">//最后用落在圆里的次数比上总实验次数再乘以 4，就得到了 π 的近似值。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">3.141664</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1，设计迷你随机函数"><a href="#1，设计迷你随机函数" class="headerlink" title="1，设计迷你随机函数"></a>1，设计迷你随机函数</h3><blockquote><p>设计一个循环过程，循环 100 次，以不太明显的规律输出 1～100 中的每个数字。<br>要求 1：规律尽量不明显。<br>要求 2：只能使用循环和最基本的运算，不允许超前使用数组。</p></blockquote><p>例如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 5 15 45 34  1  3  9 27 81 41</span><br><span class="line">22 66 97 89 65 94 80 38 13 39</span><br><span class="line">16 48 43 28 84 50 49 46 37 10</span><br><span class="line">30 90 68  2  6 18 54 61 82 44</span><br><span class="line">31 93 77 29 87 59 76 26 78 32</span><br><span class="line">96 86 56 67100 98 92 74 20 60</span><br><span class="line">79 35  4 12 36  7 21 63 88 62</span><br><span class="line">85 53 58 73 17 51 52 55 64 91</span><br><span class="line">71 11 33 99 95 83 47 40 19 57</span><br><span class="line">70  8 24 72 14 42 25 75 23 69</span><br></pre></td></tr></table></figure><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%2d "</span>, n);</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">10</span> == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);  <span class="comment">//十个一列</span></span><br><span class="line">        n = (n * <span class="number">3</span>) % <span class="number">101</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>程序的灵魂在算法，算法的灵魂在数学。</strong></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>学习<code>rand</code>用法。</li><li>计算机中都是伪随机函数，也就是说，下一次的随机值，跟本次的随机值是相关的。</li><li>使用<code>srand</code>函数设置随机种子，也就是设置伪随机过程中的第一个起始点的位置。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>随机</tag>
        <tag>π</tag>
      </tags>
  </entry>
  <entry>
    <title>判断与循环_给程序加上处理逻辑</title>
    <url>/2020/05/21/geekbang-column-judge-and-loop-add-processing-logic-to-your-program/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>如果我给你一个由年月日组成的日期，再给你一个数字 X，你能否准确地让程序输出 X 天后的日期呢？<br>例如</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1989 11 20</span><br><span class="line">20</span><br><span class="line">1989 12 10</span><br></pre></td></tr></table></figure><p>数据中给出了 1989 年 11 月 20 日这个日期，然后问你 20 天后的日期是多少，你的程序应该输出 1989 年 12 月 10 日。特别需要注意的是，在这个任务中，你需要考虑到闰年中 2 月份的特殊性，闰年的 2 月有 29 天。</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>首先需要有一个循环，循环每一次，让计算机帮我们计算一次下一天的日期。</li><li>每次在计算下一天日期的过程中，先让日子加1，判断是否跨月，如果跨过了一个月份，就让日子从1开始，让月份加1，再判断是否跨年，如果跨年了，就让月份从1开始，年份加1。</li><li>注意2月份的月份天数的计算方法。<br>闰年的判断方法，满足其一即可：能被4整除，但不能被100整除；能被400整除。因此代码逻辑应该是这样<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span>) || year % <span class="number">400</span> == <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y, m, d, X; <span class="comment">// 定义存储 年月日 和 X 的变量</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;y, &amp;m, &amp;d); <span class="comment">// 读入年月日</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;X); <span class="comment">// 读入 X 值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; X; i++) &#123; <span class="comment">// 循环 X 次，每次向后推一天</span></span><br><span class="line">        d += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span> (m) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:            </span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>:&#123; <span class="comment">// 第一部分逻辑</span></span><br><span class="line">                <span class="keyword">if</span> (d &gt; <span class="number">31</span>) d = <span class="number">1</span>, m += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (m == <span class="number">13</span>) m = <span class="number">1</span>, y += <span class="number">1</span>;</span><br><span class="line">            &#125;; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:            </span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">11</span>: &#123; <span class="comment">// 第二部分逻辑 </span></span><br><span class="line">                <span class="keyword">if</span> (d &gt; <span class="number">30</span>) d = <span class="number">1</span>, m += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123; <span class="comment">// 第三部分逻辑</span></span><br><span class="line">                <span class="keyword">if</span> ((y % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">100</span> != <span class="number">0</span>) || y % <span class="number">400</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (d &gt; <span class="number">29</span>) d = <span class="number">1</span>, m += <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (d &gt; <span class="number">28</span>) &#123;</span><br><span class="line">                    d = <span class="number">1</span>, m += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, y, m, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1，打印乘法表"><a href="#1，打印乘法表" class="headerlink" title="1，打印乘法表"></a>1，打印乘法表</h3><blockquote><p>使用循环和条件判断，打印一个格式优美的 66 乘法表<br>要求 1：输出内容及样式参照下面给出的样例<br>要求 2：每两列之间用 \t 字符进行分隔，行尾无多余 \t 字符</p></blockquote><p>例子</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1*1=1</span><br><span class="line">1*2=2  2*2=4</span><br><span class="line">1*3=3  2*3=6  3*3=9</span><br><span class="line">1*4=4  2*4=8  3*4=12  4*4=16</span><br><span class="line">1*5=5  2*5=10  3*5=15  4*5=20  5*5=25</span><br><span class="line">1*6=6  2*6=12  3*6=18  4*6=24  5*6=30  6*6=36</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;  <span class="comment">//外层循环控制行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;  <span class="comment">//内层循环控制每一行的列数</span></span><br><span class="line">            <span class="comment">//第 i 行应该有 i 列，所以内层循环是从 1 循环到 i 为止。</span></span><br><span class="line">            j == <span class="number">1</span> || <span class="built_in">printf</span>(<span class="string">"\t"</span>);  <span class="comment">//如果左边条件不满足，就不会执行右边的的代码，所以：第一列前面不会多输出一个 \t 字符。而其他的情况呢，均会执行 printf("\t") 代码        </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d * %d = %d"</span>, j, i, i * j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>循环</tag>
        <tag>判断</tag>
        <tag>switch语句</tag>
      </tags>
  </entry>
  <entry>
    <title>时间的价值</title>
    <url>/2020/05/21/the-value-of-time/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><p>今天，收到一位学弟发来的消息，他收到了北京字节的<code>offer</code>，薪资五位数，本科应届毕业生，看了他发的薪资，讲真我酸了/(ㄒoㄒ)/~~</p><p>让我不禁想起上个月顿悟出的一件事：<strong>时间的价值，到底怎么体现时间的价值呢？</strong></p><p>我记得，我刚毕业入职一家公司，做图形学方面的研发，有一次下班，和我的导师并肩走向地铁站时，我说我多么喜欢这一份工作，他很好奇的问我：你真的喜欢做这个吗？别这么早下定论，至少我到现在还没有找到我喜欢做什么。</p><p>也许只是他随口一说，但此时此景，他的话又放佛在我耳边清晰的回响起来：你真的喜欢做这个吗…</p><p>在后面持续至少20个月的工作生涯里，我兴奋过，厌倦过，苦恼过，迷茫过，直到上个月我才突然顿悟出来：喜欢与不喜欢，无非就是觉得自己是否能体现其存在的价值，如果在他人眼来这份职业（或者是你正在做的事情）价值为0，但我自己却非常感兴趣，那它就是无价的；如果只是用来谋生，那么唯有<code>money</code>，才是检验你过的是否有价值的一个衡量标准。</p><p>最后，希望我可以早日找到————让自己不惜一切也要拼命守护的东西。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>时间</tag>
        <tag>价值</tag>
        <tag>人生</tag>
        <tag>守护</tag>
      </tags>
  </entry>
  <entry>
    <title>教你输出彩色的文字</title>
    <url>/2020/05/19/geekbang-column-teach-you-to-output-colored-text/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>学到如何设计一个读入字符串，并且按照字符串信息中规定的颜色，输出相应颜色文本内容的方法程序。<br>例如当我们：</p><ul><li>输入：red:color content， 输出红色的：color content</li><li>输入：blue:color content，输出蓝色的：color content</li><li>输入：yellow:color content，输出黄色的：color content</li></ul><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>输入输出很好设计，关键是<strong>如何让字体显示不同的颜色呢</strong></p><p>转义字符</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">格式：\033[属性代码&#123;;属性代码...&#125;m输出内容\033[0m</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\033[1;4;33mhello color\033[0m"</span>);  <span class="comment">//输入高亮黄色带下划线的 hello color</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>0 代表关闭所有属性</li><li>1 代表高亮 / 粗体</li><li>4 代表下划线</li><li>33 代表黄色</li></ul><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1，位数输出"><a href="#1，位数输出" class="headerlink" title="1，位数输出"></a>1，位数输出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计算一个输入整数的十进制表示的位数？</span><br><span class="line">条件 1：允许有多余输出的情况下，怎么实现？</span><br><span class="line">条件 2：只允许输出数字位数的时候，又该怎么实现？</span><br><span class="line">请单纯考虑使用 printf 一族函数方法实现。</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" has %d digits\n"</span>, <span class="built_in">printf</span>(<span class="string">"%d"</span>, n)); <span class="comment">// 有多余输出</span></span><br><span class="line">    <span class="keyword">char</span> output[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">sprintf</span>(output, <span class="string">"%d"</span>, n);  <span class="comment">//sprintf 也是 printf 一族函数中的一员，它的返回值与 printf 含义相同</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ret); <span class="comment">// 无多余输出</span></span><br><span class="line">    <span class="comment">//return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2，读入一行字符串"><a href="#2，读入一行字符串" class="headerlink" title="2，读入一行字符串"></a>2，读入一行字符串</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请大家自行实现一个读入一行字符串，并且输出相关内容的程序，思考如下：</span><br><span class="line">条件 1：如果字符串中没有空格，怎么实现？</span><br><span class="line">条件 2：如果字符串中有空格，又该怎么实现？</span><br><span class="line">请单纯考虑用 scanf 一族函数方法实现。</span><br></pre></td></tr></table></figure><p>实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//[]代表了一个集合，用来控制 %s 在读入过程中可以读入的字符集合的</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%[^\n]s"</span>, str);  <span class="comment">//只要不是换行符，就可以继续读入</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><h3 id="部分颜色代码"><a href="#部分颜色代码" class="headerlink" title="部分颜色代码"></a>部分颜色代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字背景颜色: 40--49                字颜色: 30--39</span><br><span class="line">40: 黑                           30: 黑</span><br><span class="line">41: 红                           31: 红</span><br><span class="line">42: 绿                           32: 绿</span><br><span class="line">43: 黄                           33: 黄</span><br><span class="line">44: 蓝                           34: 蓝</span><br><span class="line">45: 紫                           35: 紫</span><br><span class="line">46: 深绿                         36: 深绿</span><br><span class="line">47：白色                         37：白色</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>此文记录我复习和巩固C语言基础的开端，后面会发布一系列学习笔记，加油！</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>编程入门</category>
      </categories>
      <tags>
        <tag>文字</tag>
        <tag>C语言</tag>
        <tag>输入</tag>
        <tag>输出</tag>
      </tags>
  </entry>
  <entry>
    <title>兴隆湖半日游</title>
    <url>/2020/05/16/xing-long-hu-half-a-day-trip/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><p>今天和女朋友计划去兴隆湖游玩。</p><p>由于住的地方比较远，倒两趟公交，所以吃过午饭就准备出发了。</p><p>到达目的地后，第一感受是这里人真少，空气很清新，我俩在湖边慢悠悠的散着步，看着有小朋友们玩滑板，还有小姐姐在练舞蹈。</p><p>期间女朋友突然肚子饿了，去一家超市买辣条，明明上面标着是3元/袋，店家说要4.5元，女朋友二话不说就扫码付款，我提出的疑惑后，店家连声说抱歉，给我女朋友退了1.5元。所以以后遇到困惑还是需要提出质疑的哦。</p><p>兴隆湖逛完了，又把旁边的鹿溪河生态区逛了逛，不得不说，安安静静的坐在椅子上，听着鸟叫的声音也是一种享受呢。</p><p>晚上到家准备买些菜，毕竟领了成都的4张线下消费劵。买了很多的菜和水果，女朋友想吃烧烤，于是在一家路边摊点烧烤，md没有问老板烤串的价格，等选完了付款告诉我说是83元，我去，我让他再算一遍，他给我说荤的是6元，素的是2元，有些是3元的，加了一遍又是83元，行吧，我是觉得平时再怎么点也不会超过50的，算理亏了，店家的数学应该还过得去，只能暗自表示下次一定别再来吃了。</p><p>就这样，结束了一天的行程。远离了喧嚣，人与人之间的勾心斗角，这样的感觉真好。</p><p><img src="/2020/05/16/xing-long-hu-half-a-day-trip/jing1.jpg" alt></p><p><img src="/2020/05/16/xing-long-hu-half-a-day-trip/jing2.jpg" alt></p><p><img src="/2020/05/16/xing-long-hu-half-a-day-trip/jing3.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>旅行游记</category>
      </categories>
      <tags>
        <tag>旅行</tag>
        <tag>游记</tag>
        <tag>烧烤</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言的优点和缺点</title>
    <url>/2020/05/10/go-language-advantages-and-disadvantages/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li><p>1，性能</p></li><li><p>2，语言性能很重要</p></li><li><p>3，发者效率&amp;不要过于创新</p></li><li><p>4，并发性&amp;通道</p></li><li><p>5，快速的编译时间</p></li><li><p>6，打造团队的能力</p></li><li><p>7，强大的生态系统</p></li><li><p>8，GOFMT，强制代码格式</p></li><li><p>9，gRPC 和 Protocol Buffers</p></li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li><p>1，缺少框架</p></li><li><p>2，错误处理</p></li><li><p>3，软件包管理</p></li></ul><h2 id="个人使用感受"><a href="#个人使用感受" class="headerlink" title="个人使用感受"></a>个人使用感受</h2><p>个人觉得<code>Go</code>语言在做后端并发时非常方便，起一个<code>go func()</code>即可。缺点的话，目前（2020.5月之前）只遇到过<code>Go</code>因垃圾回收而引起的<code>CPU</code>占满的<code>Bug</code>。<br><code>Go</code>有<code>C</code>语言的指针和<code>Python</code>语法的优雅，写起来很舒服，同时也有强大的调试工具<code>Delve</code>。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://studygolang.com/articles/12907" target="_blank" rel="noopener">Go 语言的优点，缺点和令人厌恶的设计</a></li><li><a href="https://www.sohu.com/a/220085058_657921" target="_blank" rel="noopener">Go 在 TiDB 的实践</a></li><li><a href="https://developer.51cto.com/art/201710/555200.htm" target="_blank" rel="noopener">Go语言的9大优势和3大缺点</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>开发</tag>
        <tag>优点</tag>
        <tag>缺点</tag>
      </tags>
  </entry>
  <entry>
    <title>后浪</title>
    <url>/2020/05/04/back-rise/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><p>这是最好的时代，这是最坏的时代；这是智慧的时代，这是愚蠢的时代；这是信仰的时期，这是怀疑的时期；这是光明的季节，这是黑暗的季节；这是希望之春，这是失望之冬；人们面前有着各样事物，人们面前一无所有；人们正在直登天堂，人们正在直下地狱。</p><p>今天看了<a href="https://www.bilibili.com/video/BV1FV411d7u7?spm_id_from=333.851.b_696e7465726e6174696f6e616c486561646572.16" target="_blank" rel="noopener">bilibili献给新一代的演讲《后浪》</a>，让我感慨万分，脑海中想到了《双城记》的开头——<strong>这是最好的时代，这是最坏的时代</strong>。</p><h2 id="最好的时代"><a href="#最好的时代" class="headerlink" title="最好的时代"></a>最好的时代</h2><ul><li>信息量呈几何倍数的增长，我不出门也可以知晓天下事。</li><li>教育开始大众化，有<code>中国MOOC</code>，<code>网易云课堂</code>，<code>慕课网</code>等等在线学习网站，可以尽情学习我想学习的一切。</li><li>交通便利化，记得我大学时期给我父母抱怨上大学要坐13个小时的火车的时候，他们会说他从陕西坐到新疆，从北疆到南疆至少七天以上。而现在我可以坐飞机、动车、高铁、火车、大巴等交通工具去往我想去的地方，再也不局限于一座城市。</li><li>交友多元化，不再满足身边的一个小圈子，我可以活跃在各种论坛、网站、QQ微信群上，和其他大学的网友一起打比赛，请教问题。</li><li>大数据人工智能时代，许多事情由程序就可以帮你做最优的选择，比如外卖拼团，比如规划旅游路线。</li></ul><h2 id="最坏的时代"><a href="#最坏的时代" class="headerlink" title="最坏的时代"></a>最坏的时代</h2><p>目前好像还没有感受到，唯一记得最近的谈话是我亲戚对我说：“现在的年轻人，压力太大了。”</p><p>嗯…好像是这样。但是也得分情况，如果是我自己想去追寻的事情，再累也是身体累，而对于我极力反感的事情，我的心就已经很累了。</p><h2 id="心里有火，眼里有光"><a href="#心里有火，眼里有光" class="headerlink" title="心里有火，眼里有光"></a>心里有火，眼里有光</h2><p><strong>不用活着他们想象中的样子，他们这一代人的想象力不足以想象我们的未来。</strong>我觉得这句话说的很棒，越长大，就越发现和父母会产生隔阂，比如想去旅行，想去看看外面多姿多彩的世界。</p><p>犹记得我大一暑假，想去一趟高原当一回支教的志愿者，和父母沟通了快两个月才同意；大二暑假，我有一天回来突然对父母说“我想出去看看”，父母说“可以啊，坐公交去那个南湖，儿童乐园去看看”，我说“我想坐火车去其他城市”，于是和父母沟通了半个多月，最终才同意了我这场说走就走的旅行；大四暑假，我还在家没待够两天，就坐飞机去成都面试，拿<code>offer</code>，入职新公司。</p><p>是什么带给了我改变现状的行动，我想了很久，也复盘了当时我的心情，我想就是<strong>好奇心+勇气</strong>。</p><p>我今年刚过完24岁生日，看着自己在陌生城市逐渐稳固的步伐，账户上不多不少的存款，以及自己健康的体魄和仍然茂盛的头发（嘿嘿，据说程序员都爱这样说），这些都是我可以立马做出改变的资本。</p><p>未来，还会有无限可能。</p><p>奔涌吧，后浪。</p><h2 id="2020-5-21更新"><a href="#2020-5-21更新" class="headerlink" title="2020-5-21更新"></a>2020-5-21更新</h2><p>细品</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">麻：“师爷，您给翻译翻译，什么叫后浪，翻译翻译，什么，叫后浪”</span><br><span class="line"></span><br><span class="line">汤：“这还用翻译，年轻人嘛，新一代，都说了......”</span><br><span class="line"></span><br><span class="line">麻：“我让你翻译给我听，什么叫后浪！”</span><br><span class="line"></span><br><span class="line">汤：：“不用翻译，就是后浪啊，热爱生活嘛......”</span><br><span class="line"></span><br><span class="line">黄：“难道你听不懂什么叫后浪？”</span><br><span class="line"></span><br><span class="line">麻：“我就想让你翻译翻译，什么，叫后浪！！！”</span><br><span class="line"></span><br><span class="line">汤：“后浪嘛！”</span><br><span class="line"></span><br><span class="line">麻：“翻译出来给我听，什么TM的叫后浪！什么TM的叫TM的后浪！”</span><br><span class="line"></span><br><span class="line">汤：“什么TM的叫后浪啊？”黄：“后浪就是新一代青年，可以选择玩单反，开跑车，玩跳伞，在欧洲旅游拍vlog，明白了吗？”</span><br><span class="line"></span><br><span class="line">汤：“这就是后浪呀！”</span><br><span class="line"></span><br><span class="line">麻：“翻译翻译”</span><br><span class="line"></span><br><span class="line">汤，黄：“.....？？？”</span><br><span class="line"></span><br><span class="line">麻：“翻译翻译！”</span><br><span class="line"></span><br><span class="line">汤：“后浪，就是前浪的儿子和女儿！”</span><br><span class="line"></span><br><span class="line">麻：“噢，大哥这TM是后浪啊。”</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul><li><a href="https://www.zhihu.com/question/392359306" target="_blank" rel="noopener">如何评价 B 站 2020 年五四青年节宣传短片《后浪》？</a></li></ul><p><img src="/2020/05/04/back-rise/back-rise.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下使用gcc调试c语言程序</title>
    <url>/2020/05/03/linux-gcc-debug-c-program/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>看到一些用<code>C语言</code>写的数据结构的程序，很不错，想用<code>gcc</code>调试一下程序，增进记忆，本文记录学习和使用<code>gcc</code>调试<code>C程序</code>的过程。</p><h2 id="使用gcc"><a href="#使用gcc" class="headerlink" title="使用gcc"></a>使用gcc</h2><h3 id="1，生成可调试程序test"><a href="#1，生成可调试程序test" class="headerlink" title="1，生成可调试程序test"></a>1，生成可调试程序test</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -o test -g BinarySortTree.c</span><br></pre></td></tr></table></figure><h3 id="2，gdb开始调试"><a href="#2，gdb开始调试" class="headerlink" title="2，gdb开始调试"></a>2，gdb开始调试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb test</span><br></pre></td></tr></table></figure><h3 id="3，设置断点"><a href="#3，设置断点" class="headerlink" title="3，设置断点"></a>3，设置断点</h3><p>这里可以设置行数，或者函数名</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">break 118</span><br></pre></td></tr></table></figure><h3 id="4，运行程序"><a href="#4，运行程序" class="headerlink" title="4，运行程序"></a>4，运行程序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">run</span><br></pre></td></tr></table></figure><h3 id="5，调试"><a href="#5，调试" class="headerlink" title="5，调试"></a>5，调试</h3><ul><li>n，一行一行的执行</li><li>c，continue-执行到下一个断点处</li><li>print,打印出变量信息</li></ul><h3 id="6，退出调试"><a href="#6，退出调试" class="headerlink" title="6，退出调试"></a>6，退出调试</h3><p>quit</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在<code>gdb</code>中如果遇到困惑，可以输入<code>help</code>获取相关帮助信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List of classes of commands:</span><br><span class="line"></span><br><span class="line">aliases -- Aliases of other commands</span><br><span class="line">breakpoints -- Making program stop at certain points</span><br><span class="line">data -- Examining data</span><br><span class="line">files -- Specifying and examining files</span><br><span class="line">internals -- Maintenance commands</span><br><span class="line">obscure -- Obscure features</span><br><span class="line">running -- Running the program</span><br><span class="line">stack -- Examining the stack</span><br><span class="line">status -- Status inquiries</span><br><span class="line">support -- Support facilities</span><br><span class="line">tracepoints -- Tracing of program execution without stopping the program</span><br><span class="line">user-defined -- User-defined commands</span><br><span class="line"></span><br><span class="line">Type &quot;help&quot; followed by a class name for a list of commands in that class.</span><br><span class="line">Type &quot;help all&quot; for the list of all commands.</span><br><span class="line">Type &quot;help&quot; followed by command name for full documentation.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.</span><br><span class="line">Command name abbreviations are allowed if unambiguous.</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文简单记录了使用<code>gdb</code>的常用命令，个人比较喜欢这种用命令行的方式去调试程序，当然也可以去<code>VSCode</code>等软件去做。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>C语言学习</category>
      </categories>
      <tags>
        <tag>Debug</tag>
        <tag>gcc</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang中Slice和Array有何不同</title>
    <url>/2020/04/17/interview-golang-slice-and-array-difference/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="《Go-Program-Language》定义"><a href="#《Go-Program-Language》定义" class="headerlink" title="《Go Program Language》定义"></a>《Go Program Language》定义</h3><p>数组是一个由固定长度的特定类型元素组成的序列， 一个数组可以由零个或多个元素组成。<br>因为数组的长度是固定的， 因此在Go语言中<strong>很少直接使用数组</strong>。</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ul><li>默认情况下， 数组的每个元素都被初始化为元素类型对应的零值， 对于数字类型来说就是0。</li></ul><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><h3 id="《Go-program-language》定义"><a href="#《Go-program-language》定义" class="headerlink" title="《Go program language》定义"></a>《Go program language》定义</h3><p>Slice（ 切片） 代表变长的序列， 序列中每个元素都有相同的类型。 一个slice类型一般写作[]T， 其中T代表slice中元素的类型； slice的语法和数组很像， 只是没有固定长度而已。</p><h3 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h3><ul><li>内置的append函数用于向slice追加元素。<br>（注意：append函数对于理解slice底层是如何工作的非常重要，此问题后面再详细阐述。）</li></ul><h2 id="Difference"><a href="#Difference" class="headerlink" title="Difference"></a>Difference</h2><h3 id="Go-program-language》"><a href="#Go-program-language》" class="headerlink" title="Go program language》"></a>Go program language》</h3><p>数组和slice之间有着紧密的联系。<br>一个slice是一个轻量级的数据结构， 提供了访问数组子序列（ 或者全部） 元素的功能， 而且slice的底层确实引用一个数组对象。 一个slice由三个部分构成： <strong>指针、 长度和容量</strong>。 指针指向第一个slice元素对应的底层数组元素的地址， 要注意的是slice的第一个元素并不一定就是数组的第一个元素。 长度对应slice中元素的数目； 长度不能超过容量， 容量一般是从slice的开始位置到底层数据的结尾位置。内置的len和cap函数分别返回slice的长度和容量。</p><h2 id="个人小结"><a href="#个人小结" class="headerlink" title="个人小结"></a>个人小结</h2><ul><li>平时开发中对<code>Slice</code>用的较多，因为<code>Slice</code>可以自动扩容；</li><li>slice由三个部分构成： <strong>指针、 长度和容量</strong>。</li><li>array由两个部分构成： <strong>指针、长度</strong>。</li><li>内置的append函数是针对<code>slice</code>操作的。</li><li><code>slice</code>需要用内置的<code>make</code>函数创建。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>数组</tag>
        <tag>Golang</tag>
        <tag>切片</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器输入www.baidu.com为什么能渲染出百度页面</title>
    <url>/2020/04/17/interview-enter-www-baidu-com-why-can-render-baidu-page/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><p>注：此问题涉及计算机网络的深度和广度，内容较多，本文将陆续将相关信息整理出来。</p><p>有好的资源或回答欢迎留言。</p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>主要分两部分，网络通信和页面渲染。</p><h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><h4 id="1，在浏览器中输入www-baidu-com"><a href="#1，在浏览器中输入www-baidu-com" class="headerlink" title="1，在浏览器中输入www.baidu.com"></a>1，在浏览器中输入<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></h4><h4 id="2，应用层DNS解析域名"><a href="#2，应用层DNS解析域名" class="headerlink" title="2，应用层DNS解析域名"></a>2，应用层DNS解析域名</h4><h4 id="3，应用层客户端发送HTTP请求"><a href="#3，应用层客户端发送HTTP请求" class="headerlink" title="3，应用层客户端发送HTTP请求"></a>3，应用层客户端发送HTTP请求</h4><h4 id="4，传输层TCP传输报文"><a href="#4，传输层TCP传输报文" class="headerlink" title="4，传输层TCP传输报文"></a>4，传输层TCP传输报文</h4><h4 id="5，网络层IP协议查询MAC地址"><a href="#5，网络层IP协议查询MAC地址" class="headerlink" title="5，网络层IP协议查询MAC地址"></a>5，网络层IP协议查询MAC地址</h4><h4 id="6，数据到达数据链路层"><a href="#6，数据到达数据链路层" class="headerlink" title="6，数据到达数据链路层"></a>6，数据到达数据链路层</h4><h4 id="7，服务器接收数据"><a href="#7，服务器接收数据" class="headerlink" title="7，服务器接收数据"></a>7，服务器接收数据</h4><h4 id="8，服务器响应请求"><a href="#8，服务器响应请求" class="headerlink" title="8，服务器响应请求"></a>8，服务器响应请求</h4><h4 id="9，服务器返回相应文件"><a href="#9，服务器返回相应文件" class="headerlink" title="9，服务器返回相应文件"></a>9，服务器返回相应文件</h4><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/jeffleo/article/details/77151646" target="_blank" rel="noopener">从输入URL到浏览器显示页面发生了什么</a></li><li><a href="https://blog.csdn.net/qq_16681169/article/details/50866290" target="_blank" rel="noopener">在浏览器中输入www.baidu.com后执行的全部过程</a></li><li><a href="https://blog.csdn.net/yaotengjian/article/details/80457774" target="_blank" rel="noopener">【网络】 输入www.baidu.com后的过程详解</a></li><li>《网络是怎样连接的》</li><li><a href="https://segmentfault.com/a/1190000002611809" target="_blank" rel="noopener">从输入 URL 到页面加载完成发生了什么事</a></li><li><a href="https://div.io/topic/457" target="_blank" rel="noopener">从输入 URL 到页面加载完成的过程中都发生了什么事情？</a></li><li><a href="https://www.cnblogs.com/xianyulaodi/p/6547807.html" target="_blank" rel="noopener">【原】老生常谈-从输入url到页面展示到底发生了什么</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>面试</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>场景题_从A服务获取用户id，从B服务获取用户信息</title>
    <url>/2020/04/16/interview-use-A-get-userid-and-use-B-get-userinfo/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有这样一个场景，需要你从A服务中获取多个用户id，然后根据用户id请求B服务获取用户信息，如何用<code>Golang</code>的<code>channel</code>和协程来实现？</p><h2 id="问题思考和实现"><a href="#问题思考和实现" class="headerlink" title="问题思考和实现"></a>问题思考和实现</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>由于从A服务中获取的是一个数组形式的用户id，所以我可以考虑从A服务获取用户id后，再用<code>for range</code>循环遍历每一个用户id，给每个用户建立一个通道，开个协程请求B服务获取用户信息，再通过通道传回来。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> userinfo UserInfo</span><br><span class="line"></span><br><span class="line"><span class="comment">//1，请求A服务获取用户id</span></span><br><span class="line">userids := GetAserver()</span><br><span class="line"></span><br><span class="line"><span class="comment">//2，请求B服务获取用户信息</span></span><br><span class="line"><span class="keyword">for</span> _,userid := <span class="keyword">range</span> userids &#123;</span><br><span class="line">    userid_chan := <span class="built_in">make</span>(<span class="keyword">chan</span> userinfo)</span><br><span class="line">    <span class="keyword">go</span> GetBserver(userid_chan,userid)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> info := &lt;- userid_chan:</span><br><span class="line">                <span class="keyword">return</span> info</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ul><li>每个用户新建一个<code>channel</code>，很浪费</li><li>数据量大了，这样做很不好</li></ul><h3 id="方法二-待完善"><a href="#方法二-待完善" class="headerlink" title="方法二(待完善)"></a>方法二(待完善)</h3><p>建立2个<code>channel</code>和2个协程 一个协程用来获取用户id数组g1，一个协程服务负责请求B服务获取用户信息g2, g1通过<code>channel</code>给g2，然后g2将请求到的用户信息再通过<code>channel</code>反馈回去。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> userinfo UserInfo</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> g1()</span><br><span class="line"><span class="keyword">go</span> g2()</span><br><span class="line"></span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> userinfo)</span><br><span class="line"></span><br><span class="line"><span class="comment">//g1通过`channel`给g2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g1</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">g2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法三-待完善"><a href="#方法三-待完善" class="headerlink" title="方法三(待完善)"></a>方法三(待完善)</h3><p><strong>核心思路是，A服务的携程不能阻塞，尽量并发等待B的数据。</strong><br>A要新建一个go用来接收B发过来的数据，A的ID可以直接用chan发送到B，B用一个单独的chan一次一个的方式发送结构体到新建的go，新建的go可以打包发给A，或者直接转发给A，所有数据接收完成后，新建的go退出；<br>ID可以一次批量发送，结构体可以用chan，一次一个的处理，也可以打包批次处理，这个可以看需求。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> UserInfo <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> userinfo UserInfo</span><br></pre></td></tr></table></figure><h2 id="问题复盘"><a href="#问题复盘" class="headerlink" title="问题复盘"></a>问题复盘</h2><ul><li>这个问题的核心是：你如何才能并发处理异步请求，特别是大当量数据的情况。</li><li>并发考虑做个消息队列。</li></ul><h2 id="特别感谢"><a href="#特别感谢" class="headerlink" title="特别感谢"></a>特别感谢</h2><p>特别感谢<code>Go项目实战</code>群里的三位大佬提供的思路：@star,@J,@钢之镇魂曲</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>服务</tag>
        <tag>并发</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>左耳听风，右耳聆心</title>
    <url>/2020/03/31/happy-24-birthday-listening-wind-and-heart/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><p>我步入丛林 因为我希望活得随意 我希望活得深刻 吸取生命所有的精华 把非生命的一切都击溃 以免我在弥留之际 发现自己从未真正活过。</p><p>今天是我大学毕业之后过的第二个生日，是的，过了今天，我就24岁了。</p><p>突然发现我坚持了七年写日记的习惯，在毕业后竟然断更了。</p><p>每天得过且过，忘记了昨天，也看不清未来。</p><h4 id="我的写作之路"><a href="#我的写作之路" class="headerlink" title="我的写作之路"></a>我的写作之路</h4><p>我记忆中记得最开始练习写作，是小时候的语文考试，每次考试要写超过300字的作文，这让我很苦恼，为什么是300字，100字也挺好的啊。</p><p>于是不停的看书，积累好词好句，然后在考试的时候，数着格子，计算着我要写多少字就可以达到及格的要求，很苦恼。</p><p>上了初中，喜欢上了写小说，尤其是科幻小说，只可惜这些不能为我的作文加分，于是开始到处抄作文，然后套用到模板中，只是当我写完了文章，我连我自己写的是什么都不知道。</p><p>直到上了高三，上补习班的老师，一位幽默风趣的男老师，据说是自治区语文命题组成员，告诉我们要用八个自然段，准备了十几个材料模型，教我们如何套模板，并告知我们，应试作文可以造假，反正也查不出来，关键是你要往出题者的意图上去靠….哦，原来这就是“写作”啊。</p><p>直到读了大学，没有了那么多条条框框的束缚，我才发觉，写作竟然是如此有趣，当你内心思绪紊乱，同时有多个想法冒出的时候，可以通过写作，将这些点串成线，线在汇聚成面，放佛在织一张很大的网。</p><p>我仍记得，在我大二那年，我在学习了单片机C语言和汇编知识后，要做一个课程设计出来，于是我查资料，做测试，请教同学，写了十几页演算纸，最后我在想，把它记录下来吧，扔掉怪可惜的。于是在实验室里，从下午两点到晚上七点半，一直在捋逻辑，然后写在博客上，发布出去。多年之后，发现那篇文章用搜索引擎搜出来排名第一，令我感到意外的同时又感到惊喜。</p><p>从那时开始，我将自己学习的收获，以及对生活的感悟记录下来，大学毕业时写下了三百多篇文章，只是没想到无心插柳的举动，竟为我后续面试求职和人脉拓展起到了关键作用。</p><h4 id="起风了"><a href="#起风了" class="headerlink" title="起风了"></a>起风了</h4><p>有位好朋友说，好习惯一定不能断，不然再试着找回来就很困难了。</p><p>我们面临的诱惑太多，如果说在学校面临的是学习和爱情，那么工作后除了学习、爱情，还有工作，人际沟通，经济，生存等，太多太多太多需要自己去注意的地方，在不经意间分散着自己的时间和精力。</p><p>所以，请让自己的时间变得有价值起来，这句话也是我前两个月顿悟出来的。</p><p>也许有人会说你变得冷漠无情了，那就让他说去吧，对你有影响吗？</p><p>有一位朋友说，我有时太在意别人的看法，却忘记了最终的目的，太着急了，以至于乱的方寸，错误频出，实则是降低了效率，所以，请把步调放慢一些。</p><p>很感谢他这么坦诚的说出我的问题，我曾反思过为什么会这样，而追根溯源就是和习惯有关，和曾经的环境有关。</p><p>所以，试着放慢步伐，把每一步都踩扎实，才不会在风中摇摆不定，找不到出口。</p><h4 id="象牙塔与现实的脱节"><a href="#象牙塔与现实的脱节" class="headerlink" title="象牙塔与现实的脱节"></a>象牙塔与现实的脱节</h4><p>曾经在学校读书的时候，遇到过3-5年的开发大佬，也有工作10年以上的架构师，他们都感慨一句“读书真好”，直到现在我才明白这四个字所蕴含的情感。</p><p>在学校，老师教导我们要善良，要乐于助人，却没有告诉我们善良的后果是什么；<br>在学校，老师教导我们要诚实守信，但遇到现实你敢这样做吗；<br>在学校，有问题可以找老师，找同学，而现实中全靠自己解决；<br>…</p><p>今年一月初，晚上我行走在四川大学江安校区内，走在校园的林荫小道上，看着背着书包往返于图书馆的学生们，放佛也找到了自己曾经的身影。</p><h4 id="曾经不代表现在"><a href="#曾经不代表现在" class="headerlink" title="曾经不代表现在"></a>曾经不代表现在</h4><p>工作最大的收获就在于，只要功夫下到位，潜力也是可以被激发出来的。</p><p>那些曾经自认为不擅长的技能，在经过刻意练习和实践后也能够熟练掌握。</p><p>曾经我最害怕在人多的地方骑自行车，现在已经成为一名骑行路程接近3000公里的老骑手；曾经我自认为没有写程序的天赋，然而我也通过看别人代码，自己动手刷了leetcode 200道以上的算法题；曾经我以为写<code>Linux Shell</code>脚本很难，然而我因为项目需要只用了一下午就可以掌握；曾经我遇到<code>Bug</code>心跳就会加速，然而经过两个重量级项目的历练，我熟练掌握了排查问题的流程；曾经我喜欢单干，然而我现在发现和大佬进行技术交流有时也会加深我的记忆和理解…</p><h4 id="左耳听风，右耳聆心"><a href="#左耳听风，右耳聆心" class="headerlink" title="左耳听风，右耳聆心"></a>左耳听风，右耳聆心</h4><p>我的创作时间一般喜欢选定在晚上，尤其是接近零点的时候，这时放佛给我一种进入新的一天的仪式感，同时也是因为万籁俱寂，可以聆听自己内心深处，最真实的感受。</p><p>写作，就是把我在这个世界上听到的，看到的，想到的，品到的，悟到的，记录下来，留给需要的人看，如果能对你们产生一些触动，那么对于我写作的价值也就达到了。</p><p>人生的意义是什么？我到现在都无法下结论。但我至少能这么说：我知道，在我离世时闭上了双眼，却敞开了心灵。</p><p>念，祝你24岁生日快乐！^_^</p><pre><code>念
2020年3月31日凌晨一点
于成都</code></pre><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>生日快乐</category>
      </categories>
      <tags>
        <tag>生日祝福</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker学习和命令的使用</title>
    <url>/2020/03/18/docker-study-and-use/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="为什么要用Docker"><a href="#为什么要用Docker" class="headerlink" title="为什么要用Docker"></a>为什么要用Docker</h2><p>在做软件服务时，有些程序对环境要求极其苛刻，比如必须把<code>C++</code>的库都安装好，且放到指定位置才行，这样就会对测试和运维人员造成极大的工作负担，因此我们利用<code>Docker</code>的<strong>一键编译，到处运行</strong>的特点，给自己的服务创建一个镜像，然后开启一个容器，将端口号和路径映射出来。</p><h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><h3 id="查询本机存在的镜像"><a href="#查询本机存在的镜像" class="headerlink" title="查询本机存在的镜像"></a>查询本机存在的镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h3 id="查询本机中所有创建的容器"><a href="#查询本机中所有创建的容器" class="headerlink" title="查询本机中所有创建的容器"></a>查询本机中所有创建的容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><h3 id="查询正在运行的容器"><a href="#查询正在运行的容器" class="headerlink" title="查询正在运行的容器"></a>查询正在运行的容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><h3 id="创建一个容器并进入这个容器"><a href="#创建一个容器并进入这个容器" class="headerlink" title="创建一个容器并进入这个容器"></a>创建一个容器并进入这个容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it -p 20002:20002 -v /data/:/data/ 47aae5c9b731  /usr/start.sh</span><br></pre></td></tr></table></figure><ul><li>run: 创建一个容器，并让它跑起来</li><li>-it: 进入这个容器</li><li>-d: 后台运行这个容器</li><li>-p: 映射端口号</li><li>-v: 映射路径</li><li>/usr/start.sh: 运行容器后默认执行的脚本文件</li></ul><h3 id="启动一个容器"><a href="#启动一个容器" class="headerlink" title="启动一个容器"></a>启动一个容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker start 容器id</span><br></pre></td></tr></table></figure><h3 id="进入一个正在运行的容器"><a href="#进入一个正在运行的容器" class="headerlink" title="进入一个正在运行的容器"></a>进入一个正在运行的容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器id bash</span><br></pre></td></tr></table></figure><h3 id="停止正在运行的容器"><a href="#停止正在运行的容器" class="headerlink" title="停止正在运行的容器"></a>停止正在运行的容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop 容器id</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.dockerinfo.net/document" target="_blank" rel="noopener">Docker中文文档</a></li><li><a href="https://docs.docker.com" target="_blank" rel="noopener">Docker Documentation</a></li><li><a href="https://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">菜鸟教程_Docker 教程</a></li><li><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">阮一峰_Docker 入门教程</a></li></ul><p>(待更新)</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Docker学习</category>
      </categories>
      <tags>
        <tag>容器</tag>
        <tag>Docker</tag>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title>极客Live-大厂面试那些问题，平时真的不会用到吗</title>
    <url>/2020/03/17/geekbang-live-interview-problem-to-solve-work/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="直播简介"><a href="#直播简介" class="headerlink" title="直播简介"></a>直播简介</h2><p>直播老师：李玥-京东资深架构师</p><p>你将获得：</p><ul><li>1，大厂面试题考点</li><li>2，如何在平时工作中积累自己的核心能力</li><li>3，面试题和实际工作的交集与并集</li></ul><h2 id="直播笔记"><a href="#直播笔记" class="headerlink" title="直播笔记"></a>直播笔记</h2><h3 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h3><p>你能走多远，取决于你填坑的能力有多大。</p><h3 id="关于简历"><a href="#关于简历" class="headerlink" title="关于简历"></a>关于简历</h3><p>简历可以适当夸大，比如精通xx，熟练yy,zz.</p><h3 id="高并发与海量数据"><a href="#高并发与海量数据" class="headerlink" title="高并发与海量数据"></a>高并发与海量数据</h3><p>小厂：单机，人肉，低可用</p><p>大厂：分布式，自动化，高可用</p><h3 id="大厂面试套路"><a href="#大厂面试套路" class="headerlink" title="大厂面试套路"></a>大厂面试套路</h3><ul><li><p>项目经历</p></li><li><p>基础知识</p></li><li><p>智力测验</p></li><li><p>目标职位需要的技术知识<br>可以看看MQ;分布式;</p></li><li><p>高并发和海量数据</p></li></ul><ul><li><p>知识的深度和广度</p></li><li><p>对前沿技术的了解</p></li></ul><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ul><li><p>如果有十年以上经验，要面试大厂，建议看看顶级学术期刊的最新最前沿的论文；</p></li><li><p>用<code>google</code>搜索</p></li><li><p>仔细看开源项目的文档</p></li><li><p>架构师是个<code>title</code>，平时还需要写代码；但有些公司的架构师相当于技术顾问</p></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>直播分享</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>直播</tag>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>最怕常年不联系的朋友突然的关心</title>
    <url>/2020/02/22/most-afraid-of-strange-friends-studdenly-care/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><p>最近有件事让我既喜又悲，那就是常年不联系的朋友，对我突然的关心。</p><h2 id="大学好友lss"><a href="#大学好友lss" class="headerlink" title="大学好友lss"></a>大学好友lss</h2><p>过年没事看到lss的朋友圈，说他在乌鲁木齐的公司晋升了高级主管，我很开心，于是找他闲聊了几句。</p><p>然后就问我“兄弟，办信用卡不”，我说不办，立马用哈哈缓解尴尬的气氛，还不死心的说一句“帮我问问身边的呗，有需要可以联系我”。</p><p>我回了句好吧之后，立马结束了聊天。</p><h2 id="高中同学djx"><a href="#高中同学djx" class="headerlink" title="高中同学djx"></a>高中同学djx</h2><p>高一是一个班的同学，文静，好学，前些天突然QQ联系我做过小游戏没，要给客户群活跃气氛用，我就帮她想办法，然后加上微信后开始步入正题“微信上绑工行卡没”，一句话放佛让我懂了她主动联系我的真实目的。</p><p>我立马拒绝绑卡，我觉得没必要，她仍然坚持说帮个忙嘛，我没理，就这样在尬聊中结束了。</p><h2 id="办卡的目的"><a href="#办卡的目的" class="headerlink" title="办卡的目的"></a>办卡的目的</h2><p>随后我咨询了在四大会计师事务所之一工作的朋友，为什么会有这么多办卡的？她解释道：办信用卡就和花呗的原理一样，只不过逾期了要给银行交利息，至于为什么有办卡的，估计是银行员工有指标要拉人。</p><h2 id="铁心"><a href="#铁心" class="headerlink" title="铁心"></a>铁心</h2><p>还是应了那句话：最怕常年不联系的人突然的关心。</p><p>记得上大学那会，一到寒暑假宿舍群安静的要命，突然一位舍友问我一句“在吗”，我猜测应该是找我有事，或者借钱，于是故意等过了八个小时后才回复他，最后也印证了我的猜想。</p><p>也记得在大三暑假那会，我在北京去找中农的好友玩，在一家商场碰到一位美女在推销英语课程，说是帮个忙嘛，她只是为了完成指标，我心一软就答应了，写下自己的联系方式，结果从那天开始到此后的一年时间内，总是接到来自上海、北京、杭州的推销电话，我真是感到无语。</p><p>因此，以后再遇到这种类似的情况，不管当年交情有多么的深厚，不好意思，从此我们是陌路。</p><p>我有时也在问自己，这样是不是太铁石心肠了？——是吗，也许吧。但没办法，社会就是这个样子，你要为了完成指标而四处充当销售，用当年的友情去变现自己的业绩，但我也是有自己的底线，不容逾越！</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>朋友</tag>
        <tag>利益</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-lcof-05-ti-huan-kong-ge | 替换空格</title>
    <url>/2020/02/13/Leetcode-lcof-05-ti-huan-kong-ge/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/" target="_blank" rel="noopener">面试题05.替换空格</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="使用Go-strings包"><a href="#使用Go-strings包" class="headerlink" title="使用Go strings包"></a>使用Go strings包</h3><p>替换字符串，直接用<code>strings.Replace</code>解决。<br>第一个参数为源字符串，第二个参数表示被替换的部分，第三个参数表示最终被替换成的值，第四个参数表示替换的次数，-1表示不限制次数。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">replaceSpace</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> strings.Replace(s, <span class="string">" "</span>, <span class="string">"%20"</span>, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode-剑指offer题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>lcof</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-189-rotate-array | 旋转数组</title>
    <url>/2020/02/13/Leetcode-189-rotate-array/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href>leetcode中国</a></li></ul><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><h3 id="方法一，暴力求解"><a href="#方法一，暴力求解" class="headerlink" title="方法一，暴力求解"></a>方法一，暴力求解</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="comment">//暴力解决</span></span><br><span class="line">    <span class="keyword">var</span> temp,previous <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;k;i++ &#123;</span><br><span class="line">        previous = nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="built_in">len</span>(nums);j++ &#123;</span><br><span class="line">            temp = nums[j]</span><br><span class="line">            nums[j] = previous</span><br><span class="line">            previous = temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二，使用额外的数组"><a href="#方法二，使用额外的数组" class="headerlink" title="方法二，使用额外的数组"></a>方法二，使用额外的数组</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="comment">//使用额外的数组</span></span><br><span class="line">    a := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">        a[(i+k) % <span class="built_in">len</span>(nums)] = nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">        nums[i] = a[i]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-387-first-unique-character-in-a-string | 字符串中的第一个唯一字符</title>
    <url>/2020/02/11/Leetcode-387-first-unique-character-in-a-string/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">leetcode中国</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>1，建立一个字符为<code>key</code>，出现次数为<code>int</code>类型的<code>map</code>；<br>2，第一次循环，记录字符串中每个字符出现的次数；<br>3，第二次循环，找出<code>index</code>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstUniqChar</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// build hash map : character and how often it appears</span></span><br><span class="line">    cmap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">byte</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(s);i++ &#123;</span><br><span class="line">        c := s[i]</span><br><span class="line">        cmap[c] = cmap[c] + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find the index</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(s);i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> cmap[s[i]] == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>哈希表</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-242-valid-anagram | 有效的字母异位词</title>
    <url>/2020/02/07/Leetcode-242-valid-anagram/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">leetcode中国</a></p><h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isAnagram</span><span class="params">(s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    countmap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">uint8</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		countmap[s[i]]++</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(t); i++ &#123;</span><br><span class="line">        countmap[t[i]]--</span><br><span class="line">        <span class="keyword">if</span> countmap[t[i]] &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>字符串比较</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-283-move-zeroes | 移动零</title>
    <url>/2020/02/07/Leetcode-283-move-zeroes/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">leetcode中国</a></li></ul><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">moveZeroes</span><span class="params">(nums []<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    index := <span class="number">0</span></span><br><span class="line">    <span class="comment">//1，先将非0的数排到数组前面</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> v != <span class="number">0</span> &#123;</span><br><span class="line">            nums[index] = v</span><br><span class="line">            index++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2，再排是0的数到nums数组后面</span></span><br><span class="line">    <span class="keyword">for</span> i:=index;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">        nums[i] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>循环</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-412-fizz-buzz | Fizz Buzz</title>
    <url>/2020/02/02/Leetcode-412-fizz-buzz/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/fizz-buzz/" target="_blank" rel="noopener">leetcode中国</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>按照题目要求的一步步写，读取<code>n</code>的值，然后开始一个<code>for</code>循环在里面一个个判断满足的结果，注意要先将<code>既是3又是5的倍数</code>这一条件进行优先判断。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fizzBuzz</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> re []<span class="keyword">string</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;=n;i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> (i%<span class="number">3</span> == <span class="number">0</span> &amp;&amp; i%<span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            re = <span class="built_in">append</span>(re,<span class="string">"FizzBuzz"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i%<span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            re = <span class="built_in">append</span>(re,<span class="string">"Buzz"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i%<span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            re = <span class="built_in">append</span>(re,<span class="string">"Fizz"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            re = <span class="built_in">append</span>(re,strconv.Itoa(i))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>循环</tag>
      </tags>
  </entry>
  <entry>
    <title>极客时间直播_王争_前Google工程师的算法学习与面试经验分享</title>
    <url>/2020/01/09/geekbang-live-wangzheng-algo-interview/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="嘉宾"><a href="#嘉宾" class="headerlink" title="嘉宾"></a>嘉宾</h2><p>王争，前<code>Google</code>工程师</p><h2 id="直播大纲"><a href="#直播大纲" class="headerlink" title="直播大纲"></a>直播大纲</h2><ul><li>1，掌握数据结构和算法的方法；</li><li>2，判定掌握数据结构和算法的标准；</li><li>3，应对算法面试的一些技巧分享。</li></ul><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="学习算法的目的"><a href="#学习算法的目的" class="headerlink" title="学习算法的目的"></a>学习算法的目的</h3><ul><li>1，用于工作</li><li>2，应付面试</li><li>3，潜移默化的提高逻辑思维能力，提高编码能力</li></ul><h3 id="应付面试"><a href="#应付面试" class="headerlink" title="应付面试"></a>应付面试</h3><ul><li>1，看一些优秀的算法专栏</li><li>2，刷<code>leetcode</code></li></ul><h3 id="算法面试到底考察候选人什么？"><a href="#算法面试到底考察候选人什么？" class="headerlink" title="算法面试到底考察候选人什么？"></a>算法面试到底考察候选人什么？</h3><ul><li>1，逻辑思维能力</li><li>2，编写复杂代码的能力</li><li>3，基本数据结构和算法的掌握</li><li>4，时间空间复杂度分析的能力，代码的性能分析能力</li><li>5，编写Bug，free代码的能力</li><li>6，代码是否整洁，是否符合编码规范</li></ul><h2 id="应对算法面试多一些小技巧"><a href="#应对算法面试多一些小技巧" class="headerlink" title="应对算法面试多一些小技巧"></a>应对算法面试多一些小技巧</h2><ul><li><p>1，多搜面经，知己知彼</p></li><li><p>2，练习白板编程<br>在面试前，你要在纸上多练习一下，能够做到脑袋里想好算法之后，能一气呵成的写出代码。</p></li><li><p>3，尽量保证代码没有bug<br>测试要考虑正确情况，错误情况和边界情况。</p></li><li><p>4，尽量保证代码规范<br>在纸上写完之后，如果看着太乱，建议再迅速的抄写一遍。</p></li><li><p>5，要有时间意识<br>对于一些简单算法题目，面试官还会考察你是否能快速写出代码。</p></li><li><p>6，先用最简单的方法解决<br>拿到一道算法题后，先想最简单的解决方法，说给面试官听，然后再进行优化。<br>这样做的目的是一方面是缓和自己的紧张情绪，另一方面可能要闷头想很久，面试官很难知道你的进度，也没法做指导。</p></li></ul><h2 id="算法面试书籍推荐"><a href="#算法面试书籍推荐" class="headerlink" title="算法面试书籍推荐"></a>算法面试书籍推荐</h2><p>个人整理的一些适合准备算法面试时看的书籍，欢迎补充</p><ul><li>《程序员面试金典（第6版）》</li><li>《编程之美》</li><li>《剑指offer》</li><li>《程序员代码面试指南：IT名企算法与数据结构题目最优解》</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>直播学习</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>直播</tag>
        <tag>算法</tag>
        <tag>极客邦</tag>
      </tags>
  </entry>
  <entry>
    <title>我的老师们</title>
    <url>/2020/01/01/my-teachers/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><p>从小学，中学到大学，我遇到过许多各式各样的老师，此文写于我遇到的老师，以及从他们身上学习到的东西。</p><h2 id="小学"><a href="#小学" class="headerlink" title="小学"></a>小学</h2><p>小学的老师没什么印象，只记得我小学三年级时，肚子疼的走不动路，然后班主任就在冬天一步一步把我背回了家，当时让我的父母很感动，然后老师嘱咐了我父母几句，就冒着风雪又走回了学校。</p><p>小学五年级的时候，数学老师要做一个观摩课，需要用到乒乓球，问谁家有，而我天真的以为我父母是开店的，这些都有，于是就说我有，明天给你带来。然而回家后我爸说乒乓球卖完了，然后我就忘记这件事了，结果第二天中午我父亲给我带饭时，老师气汹汹的问我为什么没有带乒乓球过来，眼睛瞪得贼大，吓坏了我，只见我父亲小心翼翼的说“孩子也是作业多，忘记了，老师您是下午有课吧，我中午去买”。于是下午我父亲带着买好的乒乓球，才让老师的课继续讲了下去。</p><p>这件事，让我明白了<strong>既然许诺要做的事，就一定要做到，即使做不到，也要提前告知对方。</strong></p><p>（然而，我事后觉得这位数学老师小题大做，全程我就没看你从箱子里取出乒乓球，唉…总之，最后这些乒乓球有些是我在打乒乓球时打烂的。）</p><h2 id="中学"><a href="#中学" class="headerlink" title="中学"></a>中学</h2><p>初中的班主任，性格还好，很年轻，教我们思想品德课。</p><p>记得初一时，太顽皮，经常被老师叫到办公室去谈话，然而第一次月考，我竟然考到了全班第二，把我给开心坏了，然而老师告诉我，你高兴什么，你全年级才排第30名。我当时心想，天呐，我竟然排这么高的名次，但表面上还得装作惋惜的样子。</p><p>初中还有个语文老师，个子比较矮，上课只口述，很少写板书，问其原因，说是粉笔灰对身体有害，可笑，既然知道有害，你为什么要选择来当老师呢？</p><p>高中的班主任是个语文老师，有次她让我们对一个诗人的情感进行扩写，我扩写到停不住笔变成想象了，结果把这份作业上交了，次日中午全班的作业都发了，唯独我的没有发，我以为老师要当众表扬我，结果等我坐到座位上，老师把昨天要求扩写的作业像废纸一样扔到了我面前，并说我要基于事实扩写，我受够了被要求，想掌握一次主动权，于是说出了“老师，请不要扼杀我的才华”。这句话很奏效，直接把老师怼回去了，然而，她后面直接当着全班的面批评我，让我无地自容。</p><p>后来高二分班，我被分配进了一个男老师的班级。</p><p>而我这个班主任，我觉得很有商业头脑，我的女同桌告诉我，这个老师利用寒暑假在自己的客厅搭了一个小教室，让20个左右的学生挤进家里补物理课，一个寒假下来赚好几万，而我有次在班里去问他物理题，他爱理不理的样子让我很生气，于是我后来有物理上的问题，直接跑到高一带我物理的张老师那里去问了。</p><h2 id="大学"><a href="#大学" class="headerlink" title="大学"></a>大学</h2><p>大学碰到过各式各样的老师，对以下几个老师印象极为深刻</p><ul><li><p>班主任<code>S</code>：很感谢他大学四年的指导，虽然我很反感他上课老讲他在长安大学怎么怎么样，毕业后在北京怎么怎么样（遇到这种情况我一般私底下看小说或算法书），但我至今记得他大二时给我说<strong>不要把眼光局限在学校里，多向优秀的人去学习</strong>，以及大三时告诫我<strong>想要在这个世界生存下来，先适应这个世界的生存法则，再寻求转机</strong>。毕业前也感谢他私底下给我签了请假条上的字，让我赶上了大城市校招的末班车。</p></li><li><p>编译原理老师<code>L</code>：这个老师是我大学学院里最讨厌的老师之一，没有本事，却天天上课吹牛逼，有时还要和我做算法竞赛交易，例如指导老师报他的名字，到时得奖了给我奖励100元，呵呵，谁稀罕你那点钱，于是我果断拒了。</p></li><li><p>学院的一位副教授<code>G</code>：这位老师是我另外讨厌的一个人，虽然没有和他正面接触过，但那大大的脸上镶着一双小小的眼睛令我印象深刻，他会在其他学院的计算机基础课上吹牛说写程序的人是多么多么牛逼，你们这些文科生是进不来的，我当时听到我朋友说这些话我就想骂一句 放屁，他（指<code>G</code>）算什么东西，有什么资格评价你们学文科的！后来又听说班级聚餐时逼迫那些女生喝酒，我就对他的厌恶又加深的一分。他带队<code>acm</code>去参加比赛，为了多捞点学校的钱，把学生的毕设答辩全不当一回事。</p></li><li><p>学院数据结构老师<code>W</code>：这位老师印象深刻的一幕是，上了一节数据结构课，念<code>PPT</code>，后来为了嘚瑟自己写一个单链表删除的程序，结果硬是卡了大半节课还没找到<code>bug</code>，最后被我身边一位高中打信息学奥赛的湖南朋友分分钟解决。大三时看他因为贪污学校公款被举报，登上了学校的首页，我很高兴。</p></li></ul><h2 id="社会"><a href="#社会" class="headerlink" title="社会"></a>社会</h2><p>进入了社会，我发现我进入了另外一种学校，这里的许多人都是我的老师，有毕业刚进入公司带我做项目的导师，有我敬佩的同事，以及<code>leader</code>。</p><p>我想，未来我还会在这所社会学校中学到更多的东西。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>往事如风</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>老师</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业18个月，我终于在这座城市活了下来</title>
    <url>/2019/12/30/graduate-18-months-i-finally-survived-in-the-city/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2019年12月19日，星期四，我在成都，写下了这句话，距离的毕业后的第一天入职，已经过去了整整十八个月。现在，我终于敢说，我在这座城市活了下来。</p><p>犹记得，大学还有半年就毕业时，经历了考研失败的我，在考虑去哪座城市发展时，高中好友涛说，来成都嘛，找工作可以先住我家，于是，我跟父母说明情况后，就来到了成都。</p><p>在这里，我逐渐学会了如何独立成长，如何与自己独处，如何照顾自己，以及如何与他人协作。</p><p>从大一到大四，可能唯一的遗憾就是没有去实习过。</p><p>寒假时间短，冬天基本就是在家，或者出去看看那似曾相识的街道，在雪地里和妹妹打雪仗。</p><p>犹记得，最快乐最有意义的时光都是在暑假度过————支教，远途旅行，以及在家准备考研。</p><p>毕业后的18个月，失去父母庇护的我，学习着如何写简历，投简历，面试，以及签下了我的第一份劳务合同，第一个月拿到了试用期的薪资，那一刻我放佛觉得我长大了，不再需要问父母要生活费，可以自己自给自足。</p><h2 id="亲爱的小孩，今天有没有哭"><a href="#亲爱的小孩，今天有没有哭" class="headerlink" title="亲爱的小孩，今天有没有哭"></a>亲爱的小孩，今天有没有哭</h2><h3 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h3><p>毕业后最大的收获，就在于适应了职场生存的法则。</p><p>犹记得，刚入职的时候，第一次用<code>Go</code>写一个定时删除服务，涉及了大量的文件处理，设计模式和并发等知识点，当我写完后，我感觉很有成就感，后来，当这个服务产品化后，出现了一个内存泄露的问题，我又用性能分析工具层层剖析，解决了它。</p><p>但我知道这只是小试牛刀，接着我有接手了一个核心调度的项目，然而这个项目给我的打击太大，比如逻辑很复杂，导致和产品对需求的时候，都不敢保证这个需求什么时候能做出来；又比如当整个系统出来了问题时，会把所有的<code>Bug</code>都指派给我，然后我就挨个去打断点，看日志去排查；又比如有一次，因为需求太多，做不完，每天被<code>leader</code>和其他同事催着赶进度时，我只能偷偷跑到卫生间去哭上五分钟，然后擦干眼泪继续做。</p><p>为什么我对这两件事这么记忆尤新呢，因为它让我看到了一个程序员工作的缩影：提需求——编码——测试——改<code>Bug</code>——新的需求…周而复始。</p><p>在工作中，我也总结了一些研发和改<code>Bug</code>的经验</p><ul><li>1，和产品经理沟通是双向的，当他/她提出一个需求时，最好是根据自己的理解把他/她的话再复述一遍，以确认是否信息一致，当然最好写在文档里，后面可以防止产品频繁变需求（虽然这个愿望有些微小）；</li><li>2，编码时，最好理清逻辑，在脑海中画好逻辑时序图，接着写代码就会轻松许多；</li><li>3，最好在容易出错，以及频繁赋值的地方打上日志，后期出现<code>Bug</code>时好及时有效地定位问题；</li><li>4，如果出现<code>Bug</code>了，最好在已经出现<code>Bug</code>的机器上再复现一遍，当然也可以在本地搭一个完整的测试环境，这样最好；</li><li>5，运用性能分析工具，解决完<code>Bug</code>后，最好详细将<code>Bug</code>出现的原因和解决过程个最终结果记录下来，方便以后自己查阅；</li><li>6，将自己的研发时间定在25-35分钟一块，中间最好不要被别人打断；</li><li>7，学会使用搜索引擎，尽量用<code>Google</code>和<code>Bing</code>，将问题切换成英文描述，搜出来的文章质量会高一些；</li><li>8，是你的问题，及时承担，不是你的问题，找到证据后迅速甩锅。</li></ul><p>以上是我个人在写程序的经验小结。</p><h3 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h3><ul><li>1，自己做的饭真好吃</li></ul><p>2019年最大的感受就是学会了做饭。</p><p>自己买了电磁炉，照着网上的步骤开始学会炒素菜，炒荤菜。接着依葫芦画瓢，不断调整酱油、盐、鸡精的比例，味道和颜色也好了许多。</p><p>我想今年过年家里又多了个做饭的帮手。</p><ul><li>2，一觉睡到自然醒的感觉真爽</li></ul><p>项目不忙的时候，六点半下班，回去看看书，玩玩手机，十一点前关灯睡觉，早上一觉睡到自然醒，再看看表，八点多，没事，还来得及。</p><p>这段<code>一觉睡到自然醒</code>的时光，让我又找回了睡觉的乐趣，同时对<code>996</code>的厌恶又加深了一些。</p><ul><li>3，睡前水乳护肤很舒服</li></ul><p>从大学买的一套曼秀雷敦，到18年毕业时买的高夫男士全套，再到今年的百雀羚，我逐渐学会了护肤这一技能。</p><p>先用清水洗一遍脸，再涂上洗面奶清一遍，再用爽肤水，护肤乳，后面还可以用面霜，眼霜除皱纹，上班时还可以抹一层隔离霜，每次护理完，感觉脸像生命一样在自由的呼吸，很清爽。</p><h3 id="在这座城市，哭过，笑过"><a href="#在这座城市，哭过，笑过" class="headerlink" title="在这座城市，哭过，笑过"></a>在这座城市，哭过，笑过</h3><p>在一座陌生的城市，给我最大的感触就是，一切都只能靠自己。</p><p>找房子，你需要现场去验房，签合同；找工作，需要自己投简历，面试，签劳动合同；工作完成不了，你需要自己加班赶进度。</p><p>折磨你，也在成就你。</p><p>谢谢你，让我变得更坚强。</p><h2 id="要感谢的人"><a href="#要感谢的人" class="headerlink" title="要感谢的人"></a>要感谢的人</h2><ul><li>感谢我的父母对我只身前往陌生城市的支持；</li><li>感谢我的女友，教会为如何护肤，告诫我不要一到周末就想着外面吃，要自己买菜做饭；</li><li>感谢我在成都结识的好友，在知道我要面试时，分享了他宝贵的面试经验并整理成文档分享给我；</li><li>感谢我在健身房结识的一位好友，一起健身，劳逸结合，在健身中释放一天的压力；</li><li>感谢我在游戏公司时结识的一位前辈，他教会我把眼界放长远一些；</li><li>感谢我在公司部门内刚入职时带我的导师，教会我如何设计程序，分享他的所见所闻和工作经验；</li></ul><p>谢谢你们的帮助，让我在这一年内学会了许多技能，它们是我在这黑暗森林中得以生存的资本。</p><h2 id="文章链接"><a href="#文章链接" class="headerlink" title="文章链接"></a>文章链接</h2><ul><li><a href="https://octopuslian.github.io/2019/03/28/first-work-project-havest/">第一次做项目学到的技术之外的东西</a></li><li><a href="https://octopuslian.github.io/2019/05/31/a-project-deadline-note/">记一次项目演示前赶deadline的经历</a></li></ul><p><img src="/2019/12/30/graduate-18-months-i-finally-survived-in-the-city/live.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>我那些奇葩的舍友们</title>
    <url>/2019/12/27/weird-roommates/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><p>前几天做了一个梦，梦见我的舍友了，而我的第一反应，就是想打他们。</p><p>为什么想打，因为那是我曾压抑许久的潜意识。</p><p>我的本科大学在一座十八线的小城市里，记得第一天入学报到，学姐说计算机专业的宿舍已经满员了，于是把我分配到和通信专业的一个宿舍，结果就开始了我的噩梦之旅。</p><p>宿舍虽然是六人间，但加上我总共只有五个人，分别是舍友M，舍友H，舍友C和舍友W。</p><p>大一和大二都还好，真正感到无语的情景是从大三开始。（也许大二就开始了，但我忘记了）</p><p>记得有这几件事情触动了我。</p><h4 id="舍友C宿舍抽烟"><a href="#舍友C宿舍抽烟" class="headerlink" title="舍友C宿舍抽烟"></a>舍友C宿舍抽烟</h4><p>有次我重感冒，感冒到感觉嗓子冒烟，吃了药，中午在床上午休，舍友C边看剧边抽烟，我呛到实在忍不住，温柔的对他说一声“我感冒了，麻烦别抽烟了好吗？”，结果他当做没听见继续抽。</p><h4 id="舍友M的猥琐"><a href="#舍友M的猥琐" class="headerlink" title="舍友M的猥琐"></a>舍友M的猥琐</h4><p>舍友M戴着眼镜，看着挺斯文的，但是在他那斯文的外表下，我却看到了一颗猥琐的心。</p><p>为什么会这样说，因为他每天晚上，都会无缘无故的给我们讲一些黄色笑话，有些“语言”都是我无法理解的，结果他却无缘无故的笑起来，关键是还总拿我举例，有时还语言攻击其他专业的一些女生。</p><p>对这样的人，我只能呵呵。</p><h4 id="满口脏话，瘦骨如柴的H"><a href="#满口脏话，瘦骨如柴的H" class="headerlink" title="满口脏话，瘦骨如柴的H"></a>满口脏话，瘦骨如柴的H</h4><p>舍友H在我看来是重朋友友情的，然而，我很反感他打英雄联盟时的满口脏话，有时甚至不打了专门停下来和别人对骂，我在想至于吗，不就是个游戏吗，大不了不玩了呗。</p><p>大四谈恋爱了，一天到晚电话没完没了了，白天就算了，你TMD晚上凌晨三点还在和女朋友堡电话粥，你还让我们睡觉吗？哦不对，不是我们，是我，因为其他三个还没有入睡，于是，我只能用耳塞，或者放BBC让自己催眠。</p><p>最令我感到愤怒的是舍友H有次打游戏塔让敌方推了，于是就拿我撒气，问我为什么凳子摆在他那，不好意思，凳子只是摆在我上床休息时的梯子那，于是就开始各种言语攻击，我当时真有拿起凳子朝他后脑勺砸下去的打算，但是我忍住了，我不能因为这样一个人渣断送我的前程，我想到时候我父母一定会很伤心。</p><h4 id="自卑自大贪小便宜的W"><a href="#自卑自大贪小便宜的W" class="headerlink" title="自卑自大贪小便宜的W"></a>自卑自大贪小便宜的W</h4><p>同样，舍友W也是一个重情义的人，而且很聪明，期末考试不光能令自己通过，而且还能给另外三个舍友拿下助攻。</p><p>然而，令我感到惊悚的一点就是，你非常自卑，为什么这么说，因为有次舍友们在谈论大城市有多么多么好的时候，我就是在大城市长大的，而我只是阐述我觉得大城市也没那么好，我还是比较向往乡村…然而当我的话还没有说完时，你就从床上坐起来恶狠狠的看着我说“咋了，农村人咋了？！” 我很懵逼锕。</p><p>不管你能不能看到这段话，至少这是我压抑在心里的话，不好意思，我没有瞧不起农村。</p><p>同样的情节也发生在舍友M身上，又是舍友们在谈论初高中住宿，我说我好羡慕你们啊，初高中住宿，我初高中都是住家里，大学才住宿，从你们身上学到了好多生活常识，而舍友M，你是TMD脑回路有问题吗，莫名其妙的对我说了句“咋了，你以为就你是家养的，我们就是散养的是吧”。</p><p>而最让我感到无语的是，在我临近毕业准备去成都工作时，你说了一句“出去记得好好做人…”，我当时听到这句话，真想一巴掌扇烂你的嘴，你有什么资格说这句话？？？就因为你比我大一岁？</p><h4 id="What-a-Fuck"><a href="#What-a-Fuck" class="headerlink" title="What a Fuck !"></a>What a Fuck !</h4><p>从那以后，我谨言慎行，少说话，早上起来，去吃早饭，然后去图书馆或者实验室学习，晚上等图书馆或教学楼关门的时候出来，回宿舍洗漱完就睡觉。</p><p>然而好景不长，记得我有次参加算法竞赛拿了省一，要去北京参赛，回来后已经过去了十二天，舍友M、H和W一致叫我把宿舍的桶装水连换两次，我问其原因，他们说上周你去北京参赛了，所以那桶水你改换，我说我这十二天没有喝一口水吧，不好意思我不换；然后舍友M说你去北京参赛这段时间宿舍停了一天电，是我们其余四人垫付的，你也应该交，我说停电那一天我在外面，我没有用过一丝电，我不叫；然后他又说你每天早晨八点起床开灯，晚上十一点半回来用灯，这电费应该交，我TM快无语了，宿舍每个月免费使用36度电，难道我每天早晨起床用半小时电，晚上回来用半小时电，这点电一个月就能超过6度？ 于是舍友M不说话了，然后舍友C回来问我们在吵什么，听完缘由后，他说了句这钱本来就不该他（指我）掏啊，我心想终于有个明事理的人了，结果舍友C下一句话对我说，你要是实在掏不起那点钱，我就帮你掏吧….我TM掏不起那点钱，我只是不想被你们无缘无故欺负罢了！</p><p>后来我把这件事和我家人说起，他们很诧异，怎么会有如此不要脸的人，然后父亲就告诉说实在不行就掏了吧，家里不欠这点钱，我苦笑说了句，这不是钱不钱的事情，如果我掏了这个钱，后面会不会还有其他奇葩的需求需要我交钱。</p><p>后来，我和舍友关系决裂，他们聚餐从不叫我（反正从大学进来到毕业，也就只在刚开始一起吃过一次），说起吃饭，有次说好一块出去吃饭，舍友H手贱开了一句英雄联盟，然后舍友C也开了一局，结果等舍友H打完了准备去吃饭，舍友H还没打完，见状舍友C又重开了一局，等舍友C打完第一局后见舍友H又开了第二局，于是舍友C又开了第二局，我在想，你们能不能动点脑子啊，吃完饭回来开N局都没事，于是，说好的六点去吃饭，一直拖到八点，去他妈的聚餐，老子自己去吃了。</p><p>每每想起你们这些人的行为，我就想作呕，我是怎样和你们一块度过了四年，哦不，其实准确的说是三年半，因为中间有一个多学期搬到别的宿舍去住了，因为，<strong>我实在受不了了！！！</strong></p><p>考研究生的时候，各种讽刺挖苦，等我混好了，又是各种巴结。</p><p>在临近毕业还有两个月，奇葩的学校突发奇想要大家都换宿舍，真是无语。</p><p>舍友C边哭边给辅导员说不想搬到隔壁宿舍，因为隔壁宿舍太臭了，怕染上味道找不到女朋友，于是自告奋勇地说我和舍友W愿意换到那个宿舍，我于是私底下问了舍友W愿意换宿舍？他一句草泥马老子什么时候说要换，让我知道舍友C在说谎。</p><p>后来我把舍友C给辅导员求情这一段告诉了舍友W，H，M，他们都很愤怒，说是同一个屋檐下住了快四年，最后为了利益只顾自己，于是大家把舍友C孤立了起来，舍友W还说瞎了狗眼以前还帮舍友C作弊，传答案，舍友M还说舍友C天天趁你们不在的时候，私底下骂你们呢。</p><p>（顺便我想告诉舍友C，你当时在床上肚子疼的下不了床，周围人都不理你的样子，真是狼狈！）</p><p>其实，这些我都知道，从舍友C的眼神中我就可以看出来，只是，我不想惹事，所以一直忍，因为我相信这件事是包不住的。就像：</p><ul><li>舍友H曾经在宿舍里单独和我说舍友C和舍友M的自私，洗发水用完了自己不买，全用他的，真是受够了；</li><li>舍友W和我在去图书馆的路上说宿舍没一个好东西，都是自私的；</li><li>舍友C一天到晚嘴碎天天评论别人，骂舍友H像个女人，骂舍友W像个娘炮泡，不够男人（请问怎么算男人，难道满嘴脏话黄段子就是man吗？），骂舍友M最讨厌的人之一。</li></ul><p>这些“单独的谈话”我都知道，我只是不说罢了。</p><p>以前舍友M还说，我发现你从进来到现在，好像从来没有一次给我们请过客哎，我也是无语，给你们吃水果，给你们买烤鸭，你们都TMD忘记了吗？？？</p><p>我过生日那天，我自己买了瓜子水果和蛋糕，只是希望你们能陪我过一个19岁的生日，舍友C和舍友H一直在打游戏，达到十二点半熄灯了才来过生日，舍友M就跟蔫了一样摊在床上不下来。————这是我过的最差的一次生日，18岁的前的每一个生日，我都和我的家人快乐的度过，但在宿舍，我只有感到寒心与无助！！！</p><p>每次受委屈后，我都和家人打电话，边哭边打，想着早点毕业离开这该死的地方。</p><p>2018年5月底，当我拍完班级毕业照后，我第二天就申请了离校，离开了这个我再也不会来的地方，我用四年的经历，告诫我的父母，<strong>环境真的很重要！！！</strong></p><p>当我离开校园，踏上回家的旅程时，那一刻，我的心是自由的。</p><p>愿我能依旧保持自由的心。</p><h3 id="最后要说的话"><a href="#最后要说的话" class="headerlink" title="最后要说的话"></a>最后要说的话</h3><p>这篇文章的感受，是我长久压抑在自己内心深处的感受，现在写完感觉释然了好多。</p><p>我不知道在读这篇文章的你，有没有遇到类似文中的<code>W,H,C,M</code>这样的人，如果没有遇到，那么你很幸运，生活质量又高了一分。</p><p>很感谢那些安慰开导过我的朋友（尤其是学法律的朋友），我从小到成年从来没有过这样如此一再挑战我心理和尊严底线的经历，我曾多少次想要张开獠牙，挣开道德的约束，拿起身边最尖锐的东西，用力戳破这四周的虚伪和愤怒，但是最后一丝理智告诉我一定要忍耐，因为我这一凳子下去，可能一辈子就毁了。</p><blockquote><p>最后我想对<code>W,H,C,M</code>说，倘若我们还能相遇，倘若你还是那么冥顽不顾，那么你绝对绝对绝对不会有在学校那么好的运气了。<br>（但愿我们不要再相遇。）</p></blockquote><p><img src="/2019/12/27/weird-roommates/free.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>往事如风</category>
      </categories>
      <tags>
        <tag>奇葩</tag>
        <tag>愤怒</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-2-add-two-numbers | 两数相加</title>
    <url>/2019/12/23/Leetcode-2-add-two-numbers/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">leetcode中国</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="comment">//先考虑特殊情况</span></span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &amp;&amp; l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l1 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l2 == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sum := l1.Val + l2.Val</span><br><span class="line">    nextNode := addTwoNumbers(l1.Next, l2.Next)</span><br><span class="line">    <span class="keyword">if</span> sum &lt; <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;ListNode&#123; Val: sum, Next: nextNode &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tempNode := &amp;ListNode&#123;</span><br><span class="line">            Val: <span class="number">1</span>,</span><br><span class="line">            Next: <span class="literal">nil</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &amp;ListNode&#123;</span><br><span class="line">            Val: sum - <span class="number">10</span>,</span><br><span class="line">            Next: addTwoNumbers(nextNode, tempNode),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-292-nim-game | Nim 游戏</title>
    <url>/2019/12/19/Leetcode-292-nim-game/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/nim-game/" target="_blank" rel="noopener">leetcode中国</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>只要不被4整除就行。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canWinNim</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (n % <span class="number">4</span> != <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>合理分析问题，做数学归纳，有时候可以化繁为简，一眼洞穿题目的本质！</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://leetcode-cn.com/problems/nim-game/solution/nimyou-xi-by-leetcode/" target="_blank" rel="noopener">leetcdoe官方解答</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数学归纳</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-557-reverse-words-in-a-string-iii | 反转字符串中的单词 III</title>
    <url>/2019/12/19/Leetcode-557-reverse-words-in-a-string-iii/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="noopener">leetcode中国</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>1，先将字符串分解成数组</li><li>2，使用<code>for range</code>循环取出数组中的元素，并执行反转字符串的操作</li><li>3，将反转后的字符串<code>append</code>进一个新的<code>string</code>类型的数组</li><li>4，循环遍历这个新的<code>string</code>类型的数组，拼接成一个字符串，返回最终结果</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseWords</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	ss := strings.Fields(s)</span><br><span class="line">	<span class="keyword">var</span> results []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> _, str := <span class="keyword">range</span> ss &#123;</span><br><span class="line">		<span class="keyword">var</span> shift_str []<span class="keyword">byte</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(str); i++ &#123;</span><br><span class="line">			shift_str = <span class="built_in">append</span>(shift_str, str[<span class="built_in">len</span>(str)-i<span class="number">-1</span>])</span><br><span class="line">		&#125;</span><br><span class="line">		results = <span class="built_in">append</span>(results, <span class="keyword">string</span>(shift_str))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	re := <span class="string">""</span></span><br><span class="line">	<span class="keyword">for</span> index, value := <span class="keyword">range</span> results &#123;</span><br><span class="line">		<span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">			re = re + value</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			re = re + <span class="string">" "</span> + value</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> re</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，此方案不是最优解，后期再更新优化后的解法，目前只为快速解决题目。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>字符串</tag>
        <tag>反转</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-70-climbing-stairs | 爬楼梯</title>
    <url>/2019/12/17/Leetcode-70-climbing-stairs/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">leetcode中国</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>第一层：0+1=1种<br>第二层：1+1=2种<br>第三层：2+1=3种<br>第四层：3+2=5种<br>第五层：5+3=8种<br>第六层：8+5=13种<br>…</p><p>得出结论：<strong>第<code>x</code>层爬楼梯的方法数量=第<code>x-1</code>层种+第<code>x-2</code>层种</strong></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">        <span class="comment">//小于2，直接返回值</span></span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FirstNum := <span class="number">1</span></span><br><span class="line">    SecondNum := <span class="number">2</span></span><br><span class="line">    result := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">3</span>;i&lt;=n;i++ &#123;</span><br><span class="line">        result = FirstNum + SecondNum  <span class="comment">//当前层 = 倒数第一层 + 倒数第二层</span></span><br><span class="line">        FirstNum = SecondNum</span><br><span class="line">        SecondNum = result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-9-palindrome-number | 回文数</title>
    <url>/2019/12/16/Leetcode-9-palindrome-number/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">leetcode中国</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="第一种解法"><a href="#第一种解法" class="headerlink" title="第一种解法"></a>第一种解法</h3><ul><li>1，先将<code>x</code>转为字符串类型，这样好根据下标来判断是否为回文数；</li><li>2，声明<code>i</code>和<code>j</code>两个<code>int</code>型变量，其中<code>i</code>在字符串<code>x</code>的最左边，<code>j</code>在字符串<code>x</code>的最右边，<code>i</code>从左往右开始递增，<code>j</code>从右往左开始递减，每次当<code>i</code>递增和<code>j</code>递减一次后，判断<code>i</code>和<code>j</code>下标所对应的元素是否相等，如果不相等，说明不是回文数，返回<code>false</code>，否则最终返回<code>true</code>。</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	x_str := strconv.Itoa(x) <span class="comment">// 整型转换为字符串</span></span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(x_str)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">		<span class="comment">//i从左开始，j从右开始，i递增，j递减，逐个判断下标i和j对应的数字是否相等</span></span><br><span class="line">		<span class="keyword">if</span> x_str[i] != x_str[j] &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://leetcode-cn.com/problems/palindrome-number/solution/dong-hua-hui-wen-shu-de-san-chong-jie-fa-fa-jie-ch/" target="_blank" rel="noopener">动画：回文数的三种解法 | 法解种三的数文回：画动</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>回文数</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-136-single-number | 只出现一次的数字</title>
    <url>/2019/12/15/Leetcode-136-single-number/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">leetcode中国</a></li><li><a href="https://leetcode.com/problems/single-number/" target="_blank" rel="noopener">leetcode</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>第一步，新建一个<code>map</code>，用一个<code>for</code>循环，记录<code>nums</code>数组中出现的元素和次数，如果重复出现，<code>value</code>置为2，出现一次置为1；</li><li>第二步，再用一个<code>for</code>循环，遍历这个新建<code>map</code>，判断<code>value</code>为是否1，如果为1，就把<code>value</code>为1对应的<code>key</code>返回即可。</li></ul><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    numsmap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> _,v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> numsmap[v] != <span class="number">0</span> &#123;</span><br><span class="line">            numsmap[v] = <span class="number">2</span>  <span class="comment">//有重复，value为2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            numsmap[v] = <span class="number">1</span>  <span class="comment">//无重复，value为1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> numsmap &#123;</span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">1</span> &#123;</span><br><span class="line">            result = k  <span class="comment">//返回那个只出现一次的数字</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-344-reverse-string | 反转字符串</title>
    <url>/2019/12/12/Leetcode-344-reverse-string/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">leetcode中国</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一步，使用<code>for</code>循环，将数组<code>s</code>里的最后一位<code>append</code>进新数组<code>result</code>，以此类推<br>第二步，将新数组<code>result</code>里的值复制到数组s即可</p><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseString</span><span class="params">(s []<span class="keyword">byte</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="keyword">byte</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(s);i++&#123;</span><br><span class="line">        result = <span class="built_in">append</span>(result,s[<span class="built_in">len</span>(s)-i<span class="number">-1</span>])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> result &#123;</span><br><span class="line">        s[k] = v</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-78-subsets | 子集</title>
    <url>/2019/12/12/Leetcode-78-subsets/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">leetcode中国</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//复制数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copySlice</span><span class="params">(src []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	temp := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> _, i := <span class="keyword">range</span> src &#123;</span><br><span class="line">		temp = <span class="built_in">append</span>(temp, i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subsets</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	result = <span class="built_in">append</span>(result, []<span class="keyword">int</span>&#123;&#125;) <span class="comment">//第一步 包含空集</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        length := <span class="built_in">len</span>(result)</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; length; j++ &#123;</span><br><span class="line">			<span class="comment">//设定两个下标元素,从0开始遍历nums的值</span></span><br><span class="line">			<span class="comment">//里层复制数组,接着append进去下标为j的值组成nums的一个子集,再append进result数组</span></span><br><span class="line">			result = <span class="built_in">append</span>(result, <span class="built_in">append</span>(copySlice(result[j]), nums[i]))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>代码直接写成<code>for j := 0; j &lt; length; j++</code>会超出内存限制，我在本地虚拟机上运行时，会卡爆电脑，原因正在找。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-26-remove-duplicates-from-sorted-array | 删除排序数组中的重复项</title>
    <url>/2019/12/12/Leetcode-26-remove-duplicates-from-sorted-array/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">leetcode中国</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>用<code>for</code>循环从数组<code>nums</code>末尾的最后一个数字开始遍历，让数组<code>nums</code>末尾最后一个数字与末尾最后倒数第二个数字做比较，如果后一个等于前一个，则从数组中删除后一个元素，直到遍历完成，返回新数组的长度。</p><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeDuplicates</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="built_in">len</span>(nums)<span class="number">-1</span>;i&gt;<span class="number">0</span>;i-- &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">            nums = <span class="built_in">append</span>(nums[:i],nums[i+<span class="number">1</span>:]...)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-53-maximum-subarray | 最大子序和</title>
    <url>/2019/12/10/Leetcode-53-maximum-subarray/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/maximum-subarray" target="_blank" rel="noopener">leetcode中文</a><br><a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">leetcode</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="暴力解"><a href="#暴力解" class="headerlink" title="暴力解"></a>暴力解</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">//一个临时值，和一个最大值</span></span><br><span class="line">    temp,max := <span class="number">0</span>,nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp + nums[i]) &gt; nums[i] &#123;</span><br><span class="line">            temp = temp + nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> temp &gt; max &#123;</span><br><span class="line">            max = temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max  <span class="comment">//返回最大值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">//dp解法</span></span><br><span class="line">    <span class="keyword">var</span> dp = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">    max := nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="comment">//做判断</span></span><br><span class="line">        <span class="keyword">if</span> (dp[i - <span class="number">1</span>] + nums[i]) &gt; nums[i] &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> dp[i] &gt; max &#123;</span><br><span class="line">            max = dp[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/golangban-dong-tai-gui-hua-fu-sha-gua-ban-si-lu-sh/" target="_blank" rel="noopener">golang版动态规划，附傻瓜版思路（傻瓜也能看懂）</a></li><li><a href="https://leetcode-cn.com/problems/maximum-subarray/solution/golangjie-fa-si-lu-by-iphpt/" target="_blank" rel="noopener">Golang解法+思路</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>暴力求解</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-7-reverse-integer | 整数反转</title>
    <url>/2019/12/08/Leetcode-7-reverse-integer/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">leetcode中国</a></li><li><a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">leetcode</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>需要解决两个问题</p><ul><li>1，排除为0的情况</li><li>2，反转数字</li></ul><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//考虑x为负数的情况</span></span><br><span class="line">        <span class="keyword">return</span> -reverse(-x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> re <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> x != <span class="number">0</span> &#123;</span><br><span class="line">        re = re*<span class="number">10</span> + x%<span class="number">10</span></span><br><span class="line">        x = x/<span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> re &lt; <span class="number">0x7fffffff</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> re</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-217-contains-duplicate | 存在重复元素</title>
    <url>/2019/12/07/Leetcode-217-contains-duplicate/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/contains-duplicate" target="_blank" rel="noopener">leetcode中国</a><br><a href="https://leetcode.com/problems/contains-duplicate/" target="_blank" rel="noopener">leetcode</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先考虑到特殊情况，<strong>nums数组元素为0和1，直接返回false</strong><br>设置计数变量<code>count</code>，将第一次遍历数组得到的元素与第二次遍历数组得到的元素做判断，如果两数相等，就将<code>count</code>加1，在结束循环后对<code>count</code>做判断，<code>count</code>值不等于0返回<code>true</code>，否则返回<code>false</code>。</p><p>这里尤其需要注意，第一次遍历数组的下标一定比第二次遍历出的数组元素下标大，举个例子：<br>输入<code>[1,2,3,1]</code>，判断这个数组里有没有重复元素，第一次遍历<code>nums[0]</code>得到1，那么第二次遍历时肯定不能从<code>nums[0]</code>开始，必须从<code>nums[1]</code>开始往后累加，不然在同一个数组中，将下标相等的两个元素做比较，肯定相等，从而AC不通过。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">containsDuplicate</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> || <span class="built_in">len</span>(nums) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="comment">//考虑nums特殊情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i+<span class="number">1</span>;j&lt;<span class="built_in">len</span>(nums);j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[i] == nums[j] &#123;</span><br><span class="line">                count++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> count != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附录，踩坑记录"><a href="#附录，踩坑记录" class="headerlink" title="附录，踩坑记录"></a>附录，踩坑记录</h2><h3 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h3><p>创建一个<code>shift</code>数组，第一步先遍历<code>nums</code>数组，将每次遍历取出的<code>num</code>与<code>shift</code>数组里的值做判断，如果相等就代表重复，<code>count</code>增1，最后在循环结束后，对<code>count</code>做判断，如果不等于1，返回<code>true</code>，否则返回<code>false</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一版</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">containsDuplicate</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> shift []<span class="keyword">int</span></span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _,num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(shift) == <span class="number">0</span> &#123;</span><br><span class="line">            shift = <span class="built_in">append</span>(shift,num)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> _,s := <span class="keyword">range</span> shift &#123;</span><br><span class="line">                <span class="keyword">if</span> s == num &#123;</span><br><span class="line">                    count++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            shift = <span class="built_in">append</span>(shift,num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> count != <span class="number">1</span> &amp;&amp; count != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第一版存在的问题"><a href="#第一版存在的问题" class="headerlink" title="第一版存在的问题"></a>第一版存在的问题</h4><ul><li>为什么要复制数组，直接用原来的<code>nums</code>数组做<code>range</code>不可以吗？</li><li><code>append</code>数组有问题</li><li>没有考虑<code>nums</code>数组元素为1和0两种特殊情况</li><li>判断条件只需满足<code>count != 0</code>即可</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>暴力求解</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-122-best-time-to-buy-and-sell-stock-ii | 买卖股票的最佳时机II</title>
    <url>/2019/12/06/Leetcode-122-best-time-to-buy-and-sell-stock-ii/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><ul><li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">买卖股票的最佳时机 II</a></li><li><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. Best Time to Buy and Sell Stock II</a></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于没有规定交易次数，所以可以遍历<code>prices</code>数组。<br>如果后一个比前一个大，做差，并累积利润，最后返回结果。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    maxProfit := <span class="number">0</span>  <span class="comment">//最大利润</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(prices)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> prices[i+<span class="number">1</span>] &gt; prices[i] &#123;</span><br><span class="line">            <span class="comment">//如果后一笔比前一笔数额大，做减法，累积利润</span></span><br><span class="line">            maxProfit = maxProfit + prices[i+<span class="number">1</span>] - prices[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-121-best-time-to-buy-and-sell-stock | 买卖股票的最佳时机</title>
    <url>/2019/12/05/Leetcode-121-best-time-to-buy-and-sell-stock/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">原题链接</a><br><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">中文原题链接</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>1，暴力求解，直接求出买入和买出的最大值返回即可。</li></ul><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>方法一：暴力法求解</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    maxProfit := <span class="number">0</span>  <span class="comment">//最大利润</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(prices); j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[j] - prices[i] &gt; maxProfit) &#123;</span><br><span class="line">                maxProfit = prices[j] - prices[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>暴力求解</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵导读_《微积分入门》_第七天_柯西判别法</title>
    <url>/2019/11/23/turing-read-introduce-to-calculus-day7/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="知识点概览"><a href="#知识点概览" class="headerlink" title="知识点概览"></a>知识点概览</h2><p>本节定理的证明十分精彩，几乎把前面所学到的知识的板块，集训似的演练一遍。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>（位置在书本的第十八面，定理1.13）</p><p><img src="/2019/11/23/turing-read-introduce-to-calculus-day7/1.jpg" alt></p><p><img src="/2019/11/23/turing-read-introduce-to-calculus-day7/2.jpg" alt></p><p><img src="/2019/11/23/turing-read-introduce-to-calculus-day7/3.jpg" alt></p><p><img src="/2019/11/23/turing-read-introduce-to-calculus-day7/4.jpg" alt></p><p><img src="/2019/11/23/turing-read-introduce-to-calculus-day7/5.jpg" alt></p><h3 id="证明α是数列极限"><a href="#证明α是数列极限" class="headerlink" title="证明α是数列极限"></a>证明α是数列极限</h3><p><img src="/2019/11/23/turing-read-introduce-to-calculus-day7/6.jpg" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>从定义上认真理解到位，很重要。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://wikipedia.hk.wjbk.site/wiki/%E6%9F%AF%E8%A5%BF%E5%88%A4%E5%88%A5%E6%B3%95" target="_blank" rel="noopener">维基百科_柯西判别法</a></li></ul><p><img src="/2019/11/23/turing-read-introduce-to-calculus-day7/day7.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>数学学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>TURING</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵导读_《微积分入门》_第六天_数列极限的基本概念</title>
    <url>/2019/11/22/turing-read-introduce-to-calculus-day6/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="/2019/11/22/turing-read-introduce-to-calculus-day6/9.jpg" alt></p><p><img src="/2019/11/22/turing-read-introduce-to-calculus-day6/8.jpg" alt></p><p><img src="/2019/11/22/turing-read-introduce-to-calculus-day6/7.jpg" alt></p><p><img src="/2019/11/22/turing-read-introduce-to-calculus-day6/6.jpg" alt></p><p>4，不收敛数列</p><h3 id="论证定理1-2"><a href="#论证定理1-2" class="headerlink" title="论证定理1.2"></a>论证定理1.2</h3><p><img src="/2019/11/22/turing-read-introduce-to-calculus-day6/4.jpg" alt></p><h3 id="充分性的证明"><a href="#充分性的证明" class="headerlink" title="充分性的证明"></a>充分性的证明</h3><p><img src="/2019/11/22/turing-read-introduce-to-calculus-day6/1.jpg" alt></p><p><img src="/2019/11/22/turing-read-introduce-to-calculus-day6/10.jpg" alt></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://wikipedia.hk.wjbk.site/wiki/%E6%95%B0%E5%88%97" target="_blank" rel="noopener">维基百科_数列</a></li><li><a href="https://wikipedia.hk.wjbk.site/wiki/%E6%9E%81%E9%99%90" target="_blank" rel="noopener">维基百科_极限</a></li></ul><p><img src="/2019/11/22/turing-read-introduce-to-calculus-day6/day6.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>数学学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>TURING</tag>
        <tag>极限</tag>
        <tag>数列</tag>
        <tag>证明</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵导读_《微积分入门》_第五天_实数的加法</title>
    <url>/2019/11/21/turing-read-introduce-to-calculus-day5/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="知识点概览"><a href="#知识点概览" class="headerlink" title="知识点概览"></a>知识点概览</h2><ul><li>证明实数的加法</li></ul><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>向量，既有大小，又有方向，具有平行四边形法则的量。</p><p><img src="/2019/11/21/turing-read-introduce-to-calculus-day5/6.jpg" alt></p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><ul><li>1，为什么不把S看成a/2，t看成b/2？</li></ul><p>s+t = (a+b)/2 则当a,b大于0时，(a+b)/2 &lt; (a+b)成立</p><p>若a,b &lt;0，则(a+b) &gt; (a+b)，不可取</p><p><img src="/2019/11/21/turing-read-introduce-to-calculus-day5/5.jpg" alt></p><p><img src="/2019/11/21/turing-read-introduce-to-calculus-day5/4.jpg" alt></p><h3 id="证明实数的加法"><a href="#证明实数的加法" class="headerlink" title="证明实数的加法"></a>证明实数的加法</h3><p><img src="/2019/11/21/turing-read-introduce-to-calculus-day5/3.jpg" alt></p><p><img src="/2019/11/21/turing-read-introduce-to-calculus-day5/2.jpg" alt></p><h3 id="证明定理1-11"><a href="#证明定理1-11" class="headerlink" title="证明定理1.11"></a>证明定理1.11</h3><p><img src="/2019/11/21/turing-read-introduce-to-calculus-day5/dingli1-11.jpg" alt></p><p>举例</p><p>绝对值：在数轴上，代表一个数的点，与原点的距离，叫做这个数的<strong>绝对值</strong>，记作|α|。<br>那么|α|=|α-0|。</p><p><img src="/2019/11/21/turing-read-introduce-to-calculus-day5/test.jpg" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>此节难度适中，主要需掌握证明实数加法的原理和思想。</p><p>（反复阅读，不停思考）</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://wikipedia.hk.wjbk.site/wiki/%E5%90%91%E9%87%8F" target="_blank" rel="noopener">维基百科_向量</a></li><li><a href="https://wikipedia.hk.wjbk.site/baike-%E5%8A%A0%E6%B3%95" target="_blank" rel="noopener">维基百科_加法</a></li><li><a href="https://wikipedia.hk.wjbk.site/wiki/%E7%BB%9D%E5%AF%B9%E5%80%BC" target="_blank" rel="noopener">维基百科_绝对值</a></li></ul><p><img src="/2019/11/21/turing-read-introduce-to-calculus-day5/day5.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>数学学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>TURING</tag>
        <tag>实数</tag>
        <tag>加法</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵导读_《微积分入门》_第四天_实数的定义（下）</title>
    <url>/2019/11/20/turing-read-introduce-to-calculus-day4/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="知识点概览"><a href="#知识点概览" class="headerlink" title="知识点概览"></a>知识点概览</h2><ul><li>无理数性质的论证</li><li>实数的连续性</li></ul><h2 id="实数的连续性"><a href="#实数的连续性" class="headerlink" title="实数的连续性"></a>实数的连续性</h2><p><img src="/2019/11/20/turing-read-introduce-to-calculus-day4/shishulianxu1.jpg" alt></p><p><img src="/2019/11/20/turing-read-introduce-to-calculus-day4/shishulianxu2.jpg" alt></p><h2 id="定理1-6"><a href="#定理1-6" class="headerlink" title="定理1.6"></a>定理1.6</h2><p><img src="/2019/11/20/turing-read-introduce-to-calculus-day4/test1.jpg" alt></p><p><img src="/2019/11/20/turing-read-introduce-to-calculus-day4/test2.jpg" alt></p><p><img src="/2019/11/20/turing-read-introduce-to-calculus-day4/test3.jpg" alt></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li><p>存在 = 至少有一个。</p></li><li><p>《微积分入门》第十面要精读，熟读。</p></li><li><p>抽屉原理：三个球放两个抽屉，如果每个抽屉都要放的话，至少一个抽屉会放两个球。</p></li><li><p>弧度制</p></li></ul><p><img src="/2019/11/20/turing-read-introduce-to-calculus-day4/hudu.jpg" alt></p><h4 id="疑惑，为什么已经有角度制了，还要增加弧度制？"><a href="#疑惑，为什么已经有角度制了，还要增加弧度制？" class="headerlink" title="疑惑，为什么已经有角度制了，还要增加弧度制？"></a>疑惑，为什么已经有角度制了，还要增加弧度制？</h4><p>角度制存在两种进制：1，在度、分、秒间，是60进制；2，在度以上，秒以下为10进制。<br>在描述连续变化角的角度的时候是非常繁琐的，所以建议用<code>弧度制</code>。</p><p>弧度制本质就是长度，可以用实数表示，而实数具有连续性。<br>弧长 除以 半径长，把单位约掉后它就是一个纯数量，而且只有一个10进制。</p><h4 id="数学魅力，什么都没有，即拥有整个世界？！"><a href="#数学魅力，什么都没有，即拥有整个世界？！" class="headerlink" title="数学魅力，什么都没有，即拥有整个世界？！"></a>数学魅力，什么都没有，即拥有整个世界？！</h4><p><img src="/2019/11/20/turing-read-introduce-to-calculus-day4/world.jpg" alt></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本次学习定理1.4，1.5和1.6的证明，需要细细品味；</p><p>了解了弧度制、角度制和抽梯原理。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://wikipedia.hk.wjbk.site/baike-%E9%B4%BF%E5%B7%A2%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">维基百科_鴿巢原理</a></li><li><a href="https://wikipedia.hk.wjbk.site/baike-%E5%BC%A7%E5%BA%A6" target="_blank" rel="noopener">维基百科_弧度</a></li></ul><p><img src="/2019/11/20/turing-read-introduce-to-calculus-day4/day4.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>数学学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>TURING</tag>
        <tag>实数</tag>
        <tag>定理证明</tag>
        <tag>无理数</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵导读_《微积分入门》_第三天_实数的定义（上）</title>
    <url>/2019/11/19/turing-read-introduce-to-calculus-day3/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="知识点概览"><a href="#知识点概览" class="headerlink" title="知识点概览"></a>知识点概览</h2><ul><li>集合知识在分析学中应用的最初步尝试；</li><li>反证法的应用；</li><li>形式逻辑学。</li></ul><h2 id="证明定理1-1"><a href="#证明定理1-1" class="headerlink" title="证明定理1.1"></a>证明定理1.1</h2><p><img src="/2019/11/19/turing-read-introduce-to-calculus-day3/dingli1-1-z1.jpg" alt></p><p><img src="/2019/11/19/turing-read-introduce-to-calculus-day3/dingli1-1-z2.jpg" alt></p><h2 id="证明定理1-3"><a href="#证明定理1-3" class="headerlink" title="证明定理1.3"></a>证明定理1.3</h2><p><img src="/2019/11/19/turing-read-introduce-to-calculus-day3/dingli1-3-z1.jpg" alt></p><p><img src="/2019/11/19/turing-read-introduce-to-calculus-day3/dingli1-3-z2.jpg" alt></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li><p>课后两点告诫：1，认真，反复阅读课文；2，以智商和毅力的极限去积极思考问题。</p></li><li><p>定理1.2的证明方法，在 人教版数学必修一A第七面。</p></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>此节主要讲解了有关实数的几个重要的定理证明，有难度，需要反复阅读，反复领悟。</p><p><img src="/2019/11/19/turing-read-introduce-to-calculus-day3/day3.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>数学学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>TURING</tag>
        <tag>实数</tag>
        <tag>定理证明</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵导读_《微积分入门》_第二天_第一章实数_第一节序言</title>
    <url>/2019/11/18/turing-read-introduce-to-calculus-day2/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>集合的基本知识的具体应用；</li><li>映射的初步知识；</li><li>有理数的基本性质；</li><li>无穷等比数列求和的方法；</li><li>有理数的局限性</li></ul><h2 id="无穷等比数列求和的方法"><a href="#无穷等比数列求和的方法" class="headerlink" title="无穷等比数列求和的方法"></a>无穷等比数列求和的方法</h2><p>公比$q = a_n / a_n-1$</p><p>求和 $S_n = a_1 + a_1<em>q^2 + a_1</em>q^3 + … + a_n*q^n-1$ (1)式</p><p>两边同时乘以<code>q</code>，q<em>S_n = a_1</em>q^2 + a_1<em>q^3 + … + a_n</em>q^n-1 + a_n*q^n$ (2)式</p><p>令(2)式 - (1)式： q<em>S_n - Sn = a_1*q^n - a_1<br>S_n</em>(q-1) = a_1<em>(q^n - 1)<br>S_n = a_1</em>(q^n - 1) / q - 1</p><p>当 n -&gt; 无穷大 ，q^n -&gt; 0， S_n ≈ a_1*(0-1)/q - 1<br>S_n ≈ a_1 / 1- q</p><p><img src="/2019/11/18/turing-read-introduce-to-calculus-day2/bi.jpg" alt></p><h3 id="关于pai"><a href="#关于pai" class="headerlink" title="关于pai"></a>关于pai</h3><p>3 &lt; pai &lt;3 + 1<br>3 + 0.1 &lt; pai &lt; 3 + 0.2<br>3 + 0.1 + 0.04 &lt; pai &lt; 3 + 0.1 + 0.05<br>.<br>.<br>.<br>不足近似数列 &lt; pai &lt; 过剩近似数列</p><p><img src="/2019/11/18/turing-read-introduce-to-calculus-day2/pai.jpg" alt></p><h3 id="区间套理论"><a href="#区间套理论" class="headerlink" title="区间套理论"></a>区间套理论</h3><p>用两个端点都是有理数的区间，去一层套一层，直至到极限的情况下，定义出一个实数。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>数轴是规定了原点，正方向和单位长度的直线</p><p>不是有理数的实数是无理数。</p><p>有限小数的补集 -&gt; 无限小数</p><p>循环小数都是有理数</p><h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><ul><li><p>本节收获了等比数列求和的推导过程（记得上高中那会这个公式可以出一道大题和一道选择或填空题）；</p></li><li><p>对有理数和有理直线的定义。</p></li><li><p>数的范围，就像下面这张图</p></li></ul><p><img src="/2019/11/18/turing-read-introduce-to-calculus-day2/youli.jpg" alt></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://wikipedia.hk.wjbk.site/wiki/%E6%97%A0%E7%90%86%E6%95%B0" target="_blank" rel="noopener">维基百科_無理數</a></li><li><a href="https://wikipedia.hk.wjbk.site/baike-%E6%9C%89%E7%90%86%E6%95%B0" target="_blank" rel="noopener">维基百科_有理数</a></li></ul><p><img src="/2019/11/18/turing-read-introduce-to-calculus-day2/day2.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>数学学习</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>TURING</tag>
        <tag>实数</tag>
        <tag>有理数</tag>
      </tags>
  </entry>
  <entry>
    <title>图灵导读_《微积分入门》_第一天_集合与函数的基本性质</title>
    <url>/2019/11/16/turing-read-introduce-to-calculus-day1/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="知识点总览"><a href="#知识点总览" class="headerlink" title="知识点总览"></a>知识点总览</h2><ul><li>1，集合的基本概念；</li><li>2，交集、并集、补集、全集、子集、空集；</li><li>3，函数的基本概念；</li><li>4，映射与函数。</li></ul><h2 id="集合的基本概念"><a href="#集合的基本概念" class="headerlink" title="集合的基本概念"></a>集合的基本概念</h2><p>由确定的研究对象构成的总体叫做<strong>集合</strong>，集合的作用是归集（或归纳）与界定。</p><p>集合的性质：<br>1，元素的确定性；<br>2，元素的互异性；<br>3，元素的无序性；-&gt; 暗示可以排序也可以不排序</p><p>共同特征，归集的条件，门槛</p><p>E = { x∈Z | x=2k+1 k∈Z }</p><ul><li>x 表示这个集合中的元素一般形式，它表示的形式为整数集</li><li>| 起分界作用</li><li>{} 起界定作用</li></ul><h2 id="交集、并集、补集、全集、子集、空集；"><a href="#交集、并集、补集、全集、子集、空集；" class="headerlink" title="交集、并集、补集、全集、子集、空集；"></a>交集、并集、补集、全集、子集、空集；</h2><p>任意元素a∈集合A，都有元素a∈集合B，那么集合A是集合B的子集；</p><p>任意集合A中的元素a 属于 集合B，且 任意集合B中的元素b 属于 集合A，那么集合A等于集合B（元素绝对相等）；</p><p>集合的基数 / 集合的势 ：一个集合中包含元素的个数。</p><p>例如，A = {1,2,3}，那么集合A的势为 |A| = 3。</p><p>空集：不含有任何元素的集合叫做<strong>空集</strong>，表示 A ≠ ∅；∅ = {} = {x| x≠x}</p><p><img src="/2019/11/16/turing-read-introduce-to-calculus-day1/kongji.jpg" alt></p><h3 id="反证法"><a href="#反证法" class="headerlink" title="反证法"></a>反证法</h3><p>证明：空集是任何集合的子集，是任何非空集合的真子集。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设 A是任意一个集合</span><br><span class="line">假设 ∅ 不是 集合A的子集</span><br><span class="line">那么至少有一个元素a∈∅，且a∉集合A</span><br><span class="line">不可能，因为空集中是不含任何元素的，所以假设不成立，因此证明了：</span><br><span class="line"></span><br><span class="line">空集是任何集合的子集，是任何非空集合的真子集。</span><br></pre></td></tr></table></figure><h3 id="一个例子了解交集、并集和补集"><a href="#一个例子了解交集、并集和补集" class="headerlink" title="一个例子了解交集、并集和补集"></a>一个例子了解交集、并集和补集</h3><p>假设集合A表示会唱歌的同学，集合B表示会跳舞的同学，那么</p><p>交集：既会唱歌又会跳舞，A∩B；</p><h3 id="笛卡尔积-直积"><a href="#笛卡尔积-直积" class="headerlink" title="笛卡尔积(直积)"></a>笛卡尔积(直积)</h3><p>A={1,2,3}，B={a,b,c}<br>AxB={(a,b)| a∈A,b∈B}，构成一个有序的元素对-&gt;AxB的元素<br>AxB={(1,a)(1,b)(1,c)(2,a)(2,b)(2,c)(3,a)(3,b)(3,c)}</p><p>BxA={(a,1)(a,2)(a,3)(b,1)(b,2)(b,3)(c,1)(c,2)(c,3)}</p><p>所以通常情况下 AxB ≠ BxA</p><p>所以笛卡尔积不满足交换律。</p><h4 id="它有什么用？"><a href="#它有什么用？" class="headerlink" title="它有什么用？"></a>它有什么用？</h4><p>假设一个食堂提供主食A={馒头，包子，米饭，面条}<br>假设一个食堂提供饮料B={可乐，豆浆，奶茶，果汁}<br>假设一个食堂提供甜点C={土豆泥，冰淇淋，苹果派，蛋挞}</p><p>假设一个学生必须吃一种主食，一种饮料，一种甜点，所以</p><p>AxBxC = {(a,b,c)| a∈A,b∈B,c∈C}</p><p>|A|=4 * |B|=4 * |C|=4 -&gt; 64种吃法</p><h2 id="函数与映射"><a href="#函数与映射" class="headerlink" title="函数与映射"></a>函数与映射</h2><p>函数在数学中为两不为空集的集合间的一种对应关系：输入值集合中的每项元素皆能对应​​唯一一项输出值集合中的元素。<br><img src="/2019/11/16/turing-read-introduce-to-calculus-day1/func1.jpg" alt></p><p><img src="/2019/11/16/turing-read-introduce-to-calculus-day1/func2.jpg" alt></p><p>注：映射的范围包含于函数。</p><p>假设 y = f(x),x∈A<br>在集合A中任意一个元素x都与集合B中的f(x)一一对应</p><p><img src="/2019/11/16/turing-read-introduce-to-calculus-day1/func3.jpg" alt></p><p>{(x,y)∈RxR|y=f(x),x∈A} ——函数图像的集合表示法。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><h3 id="集合中的符号"><a href="#集合中的符号" class="headerlink" title="集合中的符号"></a>集合中的符号</h3><p>Q-有理数集，Z-整数集，N-自然数集，R-实数集</p><p>通常大写拉丁字母表示集合，小写拉丁字母表示元素</p><p>集合相等的定义 -&gt; 元素必须绝对相等；</p><p>任意—表示所有</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节课是图灵导读01期《微积分入门》的第一节课，主要重温了集合，函数、映射这些基础知识。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://stevenshi.me/2017/06/26/hexo-insert-formula/" target="_blank" rel="noopener">hexo中插入数学公式</a></li><li><a href="https://wikipedia.hk.wjbk.site/baike-%E7%AC%9B%E5%8D%A1%E5%84%BF%E7%A7%AF" target="_blank" rel="noopener">维基百科_笛卡儿积</a></li><li><a href="https://wikipedia.hk.wjbk.site/wiki/%E9%9B%86%E5%90%88" target="_blank" rel="noopener">维基百科_集合</a></li><li><a href="https://wikipedia.hk.wjbk.site/wiki/%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">维基百科_函数</a></li><li><a href="https://wikipedia.hk.wjbk.site/wiki/%E6%98%A0%E5%B0%84" target="_blank" rel="noopener">维基百科_映射</a></li></ul><p><img src="/2019/11/16/turing-read-introduce-to-calculus-day1/day1.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>数学学习</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>数学</tag>
        <tag>TURING</tag>
        <tag>集合</tag>
        <tag>映射</tag>
      </tags>
  </entry>
  <entry>
    <title>世界又少了一个单纯善良的人</title>
    <url>/2019/11/14/the-world-has-lost-a-simple-and-kind-human/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>前天女朋友回来告诉我，说她在下班途中碰到一个马来西亚的华人，来成都出差，在问路，于是她和那位华人多聊了几句，昨天回来后闷闷不乐，还流眼泪，我再三询问原因，她才告诉我说被骗了，自己怎么这么傻…被骗的过程我就不赘述了，网上搜关键字<strong>买烟骗局</strong>。</p><p>而我写下这篇文章，一是阐述这样的一种骗局，二是感慨，世界上又少了一位单纯善良的人。</p><h2 id="善良有错吗？"><a href="#善良有错吗？" class="headerlink" title="善良有错吗？"></a>善良有错吗？</h2><p>我记得，从小学，初中，高中这十二年的教育中，无论是从语文书，还是思想品德书上，都告诉我们要做一个正直善良的人，要孝敬父母，尊老爱幼，朋友有难要伸出援手，遇到困难学会忍受，相信雨过天晴这样大篇章的废话套话。</p><p>但是，要做到这些的前提，就是你要有资本。</p><p>在这个星球上生活了二十三年，有一些本来需要遗忘又不经意回想的瞬间，让我不得不在此时此景下记录下来，例如</p><ul><li>上高中时，在乌鲁木齐坐公交，碰到一个老头(这么称呼说明我并不尊重他)投了币，径直走向一个上面坐着小孩的座位，把他拉了起来，自己坐了下去，给老人让座没有错，但请对自己鲁莽的动作说一声抱歉，因为你确实吓到那位小孩了；</li><li>去上大学，坐十三个小时的火车，想上卫生间，在门口排队时，有些大人不顾其他人的感受，直接插队；</li><li>在大学里，帮助某些人，明明主动权在自己手上，却偏偏别人以为这是你必须帮我的义务(真是可笑)；</li><li>晚上休息时，舍友外放看直播，我吵得睡不着，但当我练习吹口琴时旁边人就不耐烦，那一刻，我有了脑子一热砍人的想法；</li><li>上大三时一位老师直接和我谈一笔和算法竞赛有关的交易，无奈我很讨厌他，委婉的拒绝了，结果那门科目我就挂了(当时我预测我的卷面分至少在80分以上)，原来，老师没有那么神圣，他们也是人，也有自己的七情六欲;</li><li>去济南玩时，一天内碰到两个乞讨者，追着我叫我给他and她一点钱；</li><li>大学毕业，独自去一座城市生活，在软件园遇到一个女子，问我借20元坐地铁，说明天给我，转账后第二天微信被拉黑；</li></ul><p>所以，善良有错吗？</p><p>善良没有错，但是你要有资本，有承受贡献善良后的风险。</p><p>如果没有资本，即使被所谓的社会道德谴责，我也会无动于衷。</p><p>由于女朋友被骗的金额够不到2000，不构成诈骗罪，所以到公安局只是立案，不会调查，具体进展我会及时更新，而我只能在下班时在诈骗地点附近转悠，期待都找到骗女友钱的骗子，如果真能找到，我一定要给上一拳头，顺便补上几脚。</p><p><strong>我可以一直保持善良，在心里立一尊佛，但是当佛倒了，我就会变成魔。</strong></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.zhihu.com/question/278929215/answer/404243094" target="_blank" rel="noopener">知乎_被骗买两条中华烟？</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>社会</tag>
        <tag>骗局</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04环境安装FFmpeg</title>
    <url>/2019/11/13/ubuntu1804-ffmpeg-install/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><p>学习视音频技术，要了解<code>FFmpeg</code>，本文将介绍在<code>Linux</code>下安装官方<code>FFmpeg</code>的步骤。</p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p>使用<code>Git</code>下载</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/FFmpeg/FFmpeg</span><br></pre></td></tr></table></figure><h3 id="使用configure命令"><a href="#使用configure命令" class="headerlink" title="使用configure命令"></a>使用configure命令</h3><ul><li>先下载<code>yasm</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install yasm    //这儿需要先安装yasm,否则configure会报错</span><br></pre></td></tr></table></figure><ul><li>使用<code>configure</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure --prefix=./ffmpeg_install</span><br></pre></td></tr></table></figure><p>注：<code>--prefix=./ffmpeg_install</code>的作用是将新编译的<code>FFmpeg</code>放入这个目录下，没有这一项将默认安装执行<code>configure</code>命令的位置。</p><ul><li>使用<code>make</code>命令</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line"></span><br><span class="line">或 make j8  //指定系统用8核来运行</span><br></pre></td></tr></table></figure><ul><li>使用<code>make install</code>命令完成安装</li></ul><p>进入<code>ffmpeg_install</code>的<code>bin</code>目录下，运行<code>FFmpeg</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ./ffmpeg_install/bin</span><br><span class="line">$ ./ffmpeg</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/qq_31186123/article/details/81180918" target="_blank" rel="noopener">ubuntu 编译安装ffmpeg</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>FFmpeg学习</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
        <tag>Ubuntu</tag>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title>如何释放压力</title>
    <url>/2019/11/11/how-to-reduce-pressure/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="压力来源"><a href="#压力来源" class="headerlink" title="压力来源"></a>压力来源</h2><p>我个人觉得压力的渠道主要有这些：</p><ul><li><p>单调，日复一日的生活，没有新鲜感；</p></li><li><p>对未来的迷茫</p></li><li><p>焦虑(知识，未来)</p></li><li><p>生理期</p></li></ul><h2 id="减压方式"><a href="#减压方式" class="headerlink" title="减压方式"></a>减压方式</h2><p>人是一种群体性动物，所以每天和周围人说说话也是释放压力的一种方式，然而有些时候节奏过快，而像类似程序员这种天天和机器打交道的职业，可能时间久了连一句语序正确的话都说不出了，或者说出的话都是间隔相同，带分号(;)隔开？亦或是进行并发同时阐述多种话语？hhh调皮一下。</p><h3 id="写日记"><a href="#写日记" class="headerlink" title="写日记"></a>写日记</h3><p>这是我坚持了(3+4+1.5)八年半的习惯，不得不说这是我首选的宣泄方式，从高中对某个女孩的暗恋，到大学对这教育体制的不满又无能为力的心情，以及毕业顺利拿到<code>offer</code>的喜悦，记录着我心智成长的艰辛过程。</p><h3 id="慢跑"><a href="#慢跑" class="headerlink" title="慢跑"></a>慢跑</h3><p>很怀念大学时期每晚在操场跑步的时光，从图书馆自习出来后，戴上无线耳机去操场慢跑3-5圈，然后回宿舍泡热水脚洗漱睡觉，第二天又精神饱满的去学习。</p><h3 id="瑜伽"><a href="#瑜伽" class="headerlink" title="瑜伽"></a>瑜伽</h3><p>有段时间加班严重，回到家就想躺在床上，背部及其难受，无意间在<code>keep</code>上发现一个长达16分钟的睡前舒缓瑜伽课程，于是跟着视频练习起来，效果很满意。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>打电话、看书、睡觉、打游戏？？？</p><p>部门老哥推荐的一本<a href="ps://book.douban.com/subject/26590889/" target="_blank" rel="noopener">《情绪急救》</a></p><h3 id="关于焦虑"><a href="#关于焦虑" class="headerlink" title="关于焦虑"></a>关于焦虑</h3><p>周末看完了阮一峰老师写的书《未来世界的幸存者》，让我不自在的又焦虑了起来，技术迭代太快，我怕我跟不上时代的节奏，称为了淘汰者。</p><p>可是，这又有什么办法呢？人的生命如此渺小，如沧海一粟，实在难以想象一千年后的技术水平会是什么样子。</p><p>最后以我很喜欢的一句话结尾</p><p><strong>吾生也有涯，而知也无涯。以有涯随无涯，殆已！已而为知者，殆而已矣！为善无近名，为恶无近刑，缘督以为经，可以保身，可以全生，可以养亲，可以尽年</strong></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>压力</tag>
        <tag>健康</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04环境下安装Java</title>
    <url>/2019/11/10/ubuntu1804-install-java/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="安装java"><a href="#安装java" class="headerlink" title="安装java"></a>安装java</h2><p>在Ubuntu系统上安装以下两个软件：</p><ul><li>Java运行时环境Java Runtime Environment（JRE）</li><li>Java开发工具包Java Development Kit（JDK）</li></ul><p>命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装jre</span><br><span class="line">sudo apt install default-jre</span><br><span class="line"></span><br><span class="line">安装jdk</span><br><span class="line">sudo apt install default-jdk</span><br></pre></td></tr></table></figure><h2 id="第一个Java程序"><a href="#第一个Java程序" class="headerlink" title="第一个Java程序"></a>第一个Java程序</h2><p>创建一个<code>test.java</code>的文件</p><p>在这个文件里写入以下代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存文件并关闭</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过Java编译器编译第一个程序</span><br><span class="line">javac test.java</span><br><span class="line"></span><br><span class="line">编译java源代码</span><br><span class="line">java test</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/freeking101/article/details/80522586" target="_blank" rel="noopener">Ubuntu18.04安装和配置 Java JDK 和 JRE，并卸载自带OpenJDK</a></li><li><a href="https://www.linuxidc.com/Linux/2018-10/155020.htm" target="_blank" rel="noopener">在Ubuntu终端中运行第一个Java程序</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Java学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Ubuntu</tag>
        <tag>安装</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>演示结束后的开心与喜悦</title>
    <url>/2019/11/10/happy-after-ai-demo-show/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="昆明大学演示"><a href="#昆明大学演示" class="headerlink" title="昆明大学演示"></a>昆明大学演示</h2><p>十月中下旬，突然被<code>leader</code>安排去做一个和<code>FFmpeg</code>相关的重组视音频片段的服务，说是项目演示用。</p><p>于是我快速搭建好服务器的框架，接着开始不断的构造和测试<code>FFmpeg</code>命令(不得不说<code>FFmpeg</code>确实是视音频领域的”瑞士军刀”)，经过一番波折后(加了两天班)，服务跑了起来，和<code>python</code>程序联调一下午+一晚上后，10月底昆明大学演示上通过，很开心。</p><h2 id="领导演示"><a href="#领导演示" class="headerlink" title="领导演示"></a>领导演示</h2><p>进入十一月后，又来了新的演示，印象最深的是有一天心情实在不好，下班时以为没什么问题了，于是就回家了，结果刚到家部门同事打电话通知我回公司改<code>bug</code>，虽然心里不太乐意，但还是回去了，然后发觉是配置文件出的问题，程序没问题。后面两天的演示也是一切顺利。</p><h2 id="周末游天府芙蓉园"><a href="#周末游天府芙蓉园" class="headerlink" title="周末游天府芙蓉园"></a>周末游天府芙蓉园</h2><p>周末去天府芙蓉园逛了一圈，持续的输出，早出晚归，让我似乎忘记了沐浴在阳光中是一种什么样的感觉。</p><p>犹记得我高一第一次接触编程时，将一堆字母输入在屏幕上，然后点击<code>run</code>后屏幕打出<code>hello world</code>的兴奋感，不知道现在从事研发后，兴趣和责任，哪个更重一些呢？</p><p><a href="./sunshine.png"></a></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
        <tag>项目</tag>
        <tag>人工智能</tag>
        <tag>收录</tag>
        <tag>服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang操作Redis数据库小结</title>
    <url>/2019/11/03/golang-redis-op/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>十月中旬要做出一个和<code>Redis</code>相关的服务，在此记录<code>Golang</code>操作<code>Redis</code>的笔记。</p><h2 id="Golang操作Redis"><a href="#Golang操作Redis" class="headerlink" title="Golang操作Redis"></a>Golang操作Redis</h2><p>(内容还在更新中…)</p><h3 id="使用redisgo包"><a href="#使用redisgo包" class="headerlink" title="使用redisgo包"></a>使用redisgo包</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/garyburd/redigo/redis"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c, err := redis.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:6379"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"Connect to redis error"</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> c.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//写入值</span></span><br><span class="line">	_, err = c.Do(<span class="string">"SET"</span>, <span class="string">"username"</span>, <span class="string">"nick"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"redis set failed:"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读取key对应的value值</span></span><br><span class="line">	username, err := redis.String(c.Do(<span class="string">"GET"</span>, <span class="string">"username"</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"redis get failed:"</span>, err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"Get username %v \n"</span>, username)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从右往左，存一个名字为mylist的列表</span></span><br><span class="line">	_, err = c.Do(<span class="string">"lpush"</span>, <span class="string">"mylist"</span>, <span class="string">"ofo"</span>, <span class="string">"mobike"</span>, <span class="string">"foo"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"redis lpush failed"</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从左往右，给一个名字为mylist的列表存值</span></span><br><span class="line">	_, err = c.Do(<span class="string">"rpush"</span>, <span class="string">"mylist"</span>, <span class="string">"bluegogo"</span>, <span class="string">"xiaolan"</span>, <span class="string">"xiaoming"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"redis rpush failed"</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取这个列表的长度</span></span><br><span class="line">	num, err := c.Do(<span class="string">"llen"</span>, <span class="string">"mylist"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"mylist get len err"</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"mylist's len is "</span>, num)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取mylist列表下表从0到10的值</span></span><br><span class="line">	values, err := redis.Values(c.Do(<span class="string">"lrange"</span>, <span class="string">"mylist"</span>, <span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"lrange err"</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"mylist is:"</span>)</span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">		fmt.Printf(<span class="string">" %s "</span>, v.([]<span class="keyword">byte</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	_, err = c.Do(<span class="string">"ltrim"</span>, <span class="string">"mylist"</span>, <span class="number">0</span>, <span class="number">4</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"ltrim error"</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		values, err = redis.Values(c.Do(<span class="string">"lrange"</span>, <span class="string">"mylist"</span>, <span class="number">0</span>, <span class="number">4</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"ltrim failed:"</span>, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">"ltrim mylist is:"</span>)</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"%s "</span>, v.([]<span class="keyword">byte</span>))</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	val, err := c.Do(<span class="string">"lindex"</span>, <span class="string">"mylist"</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"lindex error:"</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"lindex get result :%s\n"</span>, val)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = c.Do(<span class="string">"rpoplpush"</span>, <span class="string">"mylist"</span>, <span class="string">"mybike"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"rpoplpush failed:"</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		values, err = redis.Values(c.Do(<span class="string">"lrange"</span>, <span class="string">"mylist"</span>, <span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"lrange failed:"</span>, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"rpoplpush %s\n"</span>, v.([]<span class="keyword">byte</span>))</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		values, err = redis.Values(c.Do(<span class="string">"lrange"</span>, <span class="string">"mybike"</span>, <span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"lrange failed:"</span>, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">			<span class="comment">//fmt.Println(string(v.([]byte)))</span></span><br><span class="line">			fmt.Printf(<span class="string">"rpoplpush %s\n"</span>, v.([]<span class="keyword">byte</span>))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = c.Do(<span class="string">"lset"</span>, <span class="string">"mylist"</span>, <span class="number">2</span>, <span class="string">"mysql"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"lset error:"</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	val, err = c.Do(<span class="string">"lindex"</span>, <span class="string">"mylist"</span>, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"lset error:"</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"lset get result:%s\n"</span>, val)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = c.Do(<span class="string">"lrem"</span>, <span class="string">"mylist"</span>, <span class="number">1</span>, <span class="string">"mysql"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"lrem error"</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		values, err = redis.Values(c.Do(<span class="string">"lrange"</span>, <span class="string">"mylist"</span>, <span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"ltrim failed:"</span>, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"lrem mylist: %s"</span>, v.([]<span class="keyword">byte</span>))</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = c.Do(<span class="string">"lpop"</span>, <span class="string">"mylist"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"lpop failed:"</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		values, err = redis.Values(c.Do(<span class="string">"lrange"</span>, <span class="string">"mylist"</span>, <span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"lpop failed:"</span>, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">"lpop mylist :"</span>)</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">			fmt.Printf(<span class="string">"lpop mylist %s"</span>, v.([]<span class="keyword">byte</span>))</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = c.Do(<span class="string">"rpop"</span>, <span class="string">"mylist"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"rpop failed"</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		values, err = redis.Values(c.Do(<span class="string">"lrange"</span>, <span class="string">"mylist"</span>, <span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">"rpop failed:"</span>, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">"rpop mylist :"</span>)</span><br><span class="line">		<span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">			<span class="comment">//fmt.Println(string(v.([]byte)))</span></span><br><span class="line">			fmt.Printf(<span class="string">"lpop mylist %s"</span>, v.([]<span class="keyword">byte</span>))</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res, err := c.Do(<span class="string">"blpop"</span>, <span class="string">"mylist"</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"blpop error"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"blpop from mylist get:%s\n"</span>, res)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res, err = c.Do(<span class="string">"blpop"</span>, <span class="string">"tmpbike"</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"blpop time out"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"blpop from tmpbike get:"</span>, res)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res, err = c.Do(<span class="string">"brpop"</span>, <span class="string">"tmpbike"</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"brpop error"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"brpop from tmpbike get :%s\n"</span>, res)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res, err = c.Do(<span class="string">"brpop"</span>, <span class="string">"mybike"</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"brpop time out"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"brpop from mybike get:%s "</span>, res)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">菜鸟教程_Redis教程</a></li><li><a href="https://www.jianshu.com/p/89ca34b84101" target="_blank" rel="noopener">Golang操作redis指南</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>Redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业16个月的面经整理以及思考</title>
    <url>/2019/10/21/interview-think-and-life/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在写这篇文章之前，先简单介绍要自己的情况。</p><p>2018年6月计算机专业本科毕业，放弃了学校的校招，只身前往成都市求职。</p><p>在经历了两周的投简历，经历了笔试，面试，被培训机构忽悠，外包公司等，最终入职了一家上市游戏公司，三个月后辞职去了一家互联网公司做图形图像视音频算法，本文将记录我毕业工作这16个月的感悟和经验。</p><p>注：以下将以采访的形式分享自己的观点。</p><h2 id="为什么会选择放弃校招？"><a href="#为什么会选择放弃校招？" class="headerlink" title="为什么会选择放弃校招？"></a>为什么会选择放弃校招？</h2><p>因为我是在新疆上的大学，而我认为那里的互联网还是有些落后，技术这东西更新迭代非常快，之前也在学校面过海康威视的技术支持和一家央企的<code>Java</code>开发，虽然个人感觉难度不大(只要不挂科，毕业拿到双证，户口在新疆，笔试面试这些很水)，但我最终还是选择放弃并在毕业时坐飞机来成都。</p><h2 id="第一次一个人去一座陌生的城市，心里是什么样的感觉，在求职路上有没有遇到什么困难？"><a href="#第一次一个人去一座陌生的城市，心里是什么样的感觉，在求职路上有没有遇到什么困难？" class="headerlink" title="第一次一个人去一座陌生的城市，心里是什么样的感觉，在求职路上有没有遇到什么困难？"></a>第一次一个人去一座陌生的城市，心里是什么样的感觉，在求职路上有没有遇到什么困难？</h2><p>先说下内心的感受，刚开始我父母是不同意我去一座陌生的城市的，觉得待在乌鲁木齐也挺好的啊，后来我和他们耐心沟通后，并承诺待不下去就回来，他们才放过。</p><p>一个人刚来成都时，借宿在朋友家，她白天上班，我就在拉勾、智联招聘、<code>Boss</code>直聘上不断地投简历，只要是和我大学学的东西稍微沾边的。过了段时间，电话就打来了，基本上是确认本人在成都市，顺利毕业拿到双证的就安排面试，于是，我开始了我社招的正式面试：</p><ul><li><p>第一家是游戏公司<code>Unity</code>岗，在我刚准备第二天去该公司面试时，负责人在微信上说了句：我们公司是包培训的，培训半年包就业，月薪在<code>xx-yy</code>k以上，于是我断定这是一家游戏公司，放弃；</p></li><li><p>第二家是一家北京做人工智能的公司找人工智能实习生，开头带个“欣”字，结果过去之后大门口一张闪闪发光的优秀培训机构映入眼帘，接着我被叫去一个小房间，开始给我讲<code>python</code>多么多么好，你看那些川大电科研究生毕业都找不到工作还不是来我这培训(不好意思，请不要把小概率事件扩大)，我无动于衷，并拒绝了培训，放弃；</p></li><li><p>第三家是外包，说主要接美团，腾讯，华为的外包，加班多但是成长快，但我不想去，原因就不说了，放弃；</p></li><li><p>第四家是一家做音乐的公司，招的<code>Java</code>开发，我大学总共写的<code>Java</code>不超过20行，于是硬着头皮去面试，数据结构那些答的还好，被问到<code>Java</code>虚拟机我主动要求停止面试，放弃；</p></li><li><p>第五家是一家创业游戏公司，先让我做了一些<code>C#</code>笔试题，接着问我能不能接受<code>996</code>和<code>9910</code>加班，我说考虑下，于是也没有了下文；</p></li><li><p>第六家是一家上市游戏公司，经历了<code>HR面-技术面-HR面-Boss-面</code>后，顺利拿到<code>offer</code>，面试经验已整理到下面的参考链接中。</p></li></ul><p>列举了这些面试经历后，我只是想阐述当你校招或刚毕业面临社招时，当你已经失去了<code>应届大学毕业生</code>这个保护伞后，你会遇到各式各样的面试，所以请诸位擦亮眼睛，多问几个为什么。</p><h2 id="第一份工作感觉如何，为什么辞职？"><a href="#第一份工作感觉如何，为什么辞职？" class="headerlink" title="第一份工作感觉如何，为什么辞职？"></a>第一份工作感觉如何，为什么辞职？</h2><h3 id="第一印象"><a href="#第一印象" class="headerlink" title="第一印象"></a>第一印象</h3><p>第一份做游戏研发方面的工作，很兴奋，对研发游戏的每一个步骤都充满了好奇，例如服务端，客户端，策划，美术等。</p><p>大牛很多，给我推荐参考书籍，项目代码质量很高，和在学校写的课设毕设天壤之别。</p><p>活动福利多，比如一些游戏开发大赛，也有幸去厦门参考了一次<code>Game Pith Time</code>。</p><h3 id="So，为什么辞职"><a href="#So，为什么辞职" class="headerlink" title="So，为什么辞职"></a>So，为什么辞职</h3><p>详见参考文章链接<code>离职，新的开始</code>，在此不赘述。</p><h2 id="辞职后做了什么？"><a href="#辞职后做了什么？" class="headerlink" title="辞职后做了什么？"></a>辞职后做了什么？</h2><p>离职后在家躺了三天，然后开始在牛客网上刷题，再投简历，因为之前已经有了一定的工作经验，因此遇到培训机构的概率降低了。之后收到了一家做视音频的发来的面试邀请，约定了面试时间后就去面试，三场面试很快通过拿了<code>offer</code>。</p><h2 id="有什么面试经验想要分享吗？"><a href="#有什么面试经验想要分享吗？" class="headerlink" title="有什么面试经验想要分享吗？"></a>有什么面试经验想要分享吗？</h2><p>面试经验在下面的链接中会详细阐述，在此分享下个人感受</p><ul><li><p>1，个人认为开发/研发面试时，能力:面试发挥 = 7:3，为什么这样说，因为面试是可以突击来的，而能力是突击不来的，即使突击成功，接下来的3-6个月的试用期负责人有足够的时间了解你；</p></li><li><p>2，保持好奇，追根究底，务实基础；</p></li><li><p>3，可以去听一些师哥师姐的面试经验，如果条件允许最好面对面交谈；</p></li><li><p>4，时刻知道自己需要什么，还差什么，如何实现；</p></li><li><p>5，建议不要总沉迷技术书籍，适当接触一些哲学，有助于培养自己的思辨能力，因为在当你入职研发岗时，能力又是其次，最重要的是要弄清楚产品的需求。</p></li></ul><h2 id="最后还有想说的吗？"><a href="#最后还有想说的吗？" class="headerlink" title="最后还有想说的吗？"></a>最后还有想说的吗？</h2><p>转眼间已经工作了16个月，其实有时候还会梦见在学校悠哉的生活，5元的饭菜，800/一年的宿舍，以及一瓶水，一把椅子，一台电脑坐一天，晚上在操场上慢跑的生活，然后早餐的闹铃又会把这一切打破。</p><p>现在在完成需求的同时，及时利用碎片时间去看一些书籍或视频，在星球里看一看大佬们分享的职场经验，再结合自己的实际情况加以学习利用。</p><p>我们的路还很长，所以如果遇到简历被刷，面试被拒，也不要灰心。</p><p>祝求职顺利！</p><h2 id="参考文章链接"><a href="#参考文章链接" class="headerlink" title="参考文章链接"></a>参考文章链接</h2><ul><li><a href="https://www.jianshu.com/p/df2ea79b027c" target="_blank" rel="noopener">心酸，又是一家培训机构</a></li><li><a href="https://www.ituring.com.cn/article/506666" target="_blank" rel="noopener">应届毕业生求职经验分享</a></li><li><a href="https://www.cnblogs.com/OctoptusLian/p/9157266.html" target="_blank" rel="noopener">飞鱼科技游戏开发岗面试经验</a></li><li><a href="https://www.cnblogs.com/OctoptusLian/p/9634250.html" target="_blank" rel="noopener">离职，新的开始</a></li><li><a href="https://www.cnblogs.com/OctoptusLian/p/9797313.html" target="_blank" rel="noopener">华栖云科技图形图像视音频算法岗面试经验</a></li><li><a href="https://octopuslian.github.io/2019/04/07/about-996-i-want-to-say/">关于996，我想说</a></li></ul><p>(注意，此文已发布早牛客网上，点击<a href="https://www.nowcoder.com/discuss/321386" target="_blank" rel="noopener">链接</a>)</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>生活</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>博客尘埃落定</title>
    <url>/2019/10/13/blog-decision/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="开端"><a href="#开端" class="headerlink" title="开端"></a>开端</h2><p>2019年1月停更博客园，到现在为止已经接近十个月了。</p><p>在此期间试过<code>冰水鉴心</code>给我推荐的<code>hexo</code>，<code>ghost</code>这些风格的博客，最终从经济和简约的角度，选择了<code>hexo</code>。感谢他的热心帮助和答疑。</p><p>在搭建博客的过程，我发现前端真是很有意思，也许是给我带来的持续反馈机制吧。所以后面不光要关注后端和底层，可以适当去学习下前端的知识。</p><p>目前博客风格已尘埃落定，以后计划所有的学习收获和感想都优先发布在这里。</p><p>明天又是崭新的一天，坚持。</p><h3 id="2019年10月18日更新"><a href="#2019年10月18日更新" class="headerlink" title="2019年10月18日更新"></a>2019年10月18日更新</h3><p>感谢@枫林无归提供的<code>hexo-plugin-gitalk</code>插件。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>乐山一日游</title>
    <url>/2019/09/15/travel-le-shan-one-day/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="启程准备"><a href="#启程准备" class="headerlink" title="启程准备"></a>启程准备</h2><p>启程时间：9月15日早上，从成都到乐山坐高铁只需要50分钟。<br>所需物品：手机，钱包（身份证，零钱，车票），充电宝，充电线，雨伞，水杯，零食</p><h2 id="开始旅行"><a href="#开始旅行" class="headerlink" title="开始旅行"></a>开始旅行</h2><p>到乐山站后，先导航去芳芳家翘脚牛肉店吃午饭，然而到那时正好到了饭点，门口排起了长队，我预估到我至少要两个小时以上，于是放弃，买了个烧饼吃，接着前往下一个小吃街。</p><a id="more"></a><p>然而去了下一个小吃街，甜皮鸭店门口排起了长队，我看甜皮鸭以斤算价（一斤最便宜要30元），基本是按一只起卖，女朋友说太腻了，不排了，于是去四方豆腐店（排了三十多人）和小豆海棠（排了八个人），结果也排起了队，放弃。最后去了一家豆腐脑店，店了一碗牛肉粉，一晚牛肉豆腐脑，一碗水果冰粉，很好吃。</p><p>接下来坐车去乐山大佛，比较坑的是，乐山大佛的售票处离乐山大佛入口有一公里远，所以下次去的话，建议到乐山大佛入口处买票，成人价80元/人。<br>进了乐山大佛入口后，先是一个大大的佛字映入眼帘，接着就是爬台阶，如果要听讲解的话，可以请个导游，或者扫旁边的二维码花10元买个语音讲解。爬了半个多小时到达山上，看大了乐山大佛的头，不得不说，场景确实让人震撼，不过更让我震撼的是许多人排队去走栈道，不知道是去干嘛，据说是近距离欣赏大佛，无奈我又选择了放弃。逛了一会，然后下山去吃晚饭。</p><p>坐公交抵达另一处小吃街，比较出名的是叶婆婆和黄鸡肉两家钵钵鸡店，但是门口排着队，我换了一家档次也算不错的在吃，期间也品尝了下烧麦，个人觉得就是饺子的缩小版。吃了六分饱后，去了张公桥小吃街，买了酥肉咔饼（感觉就是肉夹馍），叶儿粑，味道不错。</p><p>吃完这些已经是晚上八点，于是我和女朋友坐公交赶去乐山站坐回成都的高铁。结果在公交车上人太多，我转了个身发现一位老大爷从我后面快速把手缩了回去，我猜测可能是人太多把他手卡住了吧，但我觉得不对劲，把书包翻过来正手拿着，结果发现我书包被拉开了半个口，接着刚好到站了那位缩手回去的老大爷也下车了，我检查了下包内的东西，没有少。</p><h2 id="旅行收获"><a href="#旅行收获" class="headerlink" title="旅行收获"></a>旅行收获</h2><ul><li>超过半小时需要步行到达的地方，最好选择共享单车或公交。</li><li>去看景点时如果不想请导游可以下个语音讲解。</li><li>防人之心不可无。</li><li>学会拍照很重要。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>旅行游记</category>
      </categories>
      <tags>
        <tag>旅游</tag>
        <tag>开心</tag>
        <tag>美食</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04升级Go版本</title>
    <url>/2019/08/15/ubuntu1804-update-go-version/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>因为我本机系统上的Go版本是<code>10.4</code>的，不支持<code>Go Module</code>，想升级到最新的<code>go12.7</code>。</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="1，先下载最新的源码文件"><a href="#1，先下载最新的源码文件" class="headerlink" title="1，先下载最新的源码文件"></a>1，先下载最新的源码文件</h3><p>上<a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a>下载自己需要的源码文件，我需要的是<code>go1.12.7.linux-amd64.tar.gz</code>。</p><h3 id="2，解压"><a href="#2，解压" class="headerlink" title="2，解压"></a>2，解压</h3><p>执行命令<code>tar -C /usr/local -zxvf go1.12.7.linux-amd64.tar.gz</code>,会覆盖到原先的<code>go</code>目录。</p><h3 id="3，复制可执行文件"><a href="#3，复制可执行文件" class="headerlink" title="3，复制可执行文件"></a>3，复制可执行文件</h3><p>如果不是第一次安装，需要将<code>/usr/local/go/bin</code>目录下的文件复制到<code>/usr/bin</code>下。</p><h3 id="4，检查环境配置"><a href="#4，检查环境配置" class="headerlink" title="4，检查环境配置"></a>4，检查环境配置</h3><p>打开<code>/etc/profile</code>文件检查环境配置参数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=$HOME/code/go</span><br><span class="line">PATH=$PATH:$GOROOT/bin:$GOPATH/bin</span><br></pre></td></tr></table></figure><p>命令<code>source /etc/profile</code>使环境生效。</p><h3 id="5，检查版本号"><a href="#5，检查版本号" class="headerlink" title="5，检查版本号"></a>5，检查版本号</h3><p>执行<code>go version</code>命令，输出版本号为<code>go version go1.12.7 linux/amd64</code></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，Ubuntu18.04下完成Go版本升级。<br>后面如果版本有更新，可照此方法再升级一遍。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Linux</tag>
        <tag>升级</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言调试工具-Dlv使用</title>
    <url>/2019/07/28/go-dlv-tool-use/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./dlv debug</span><br></pre></td></tr></table></figure><h3 id="打断点"><a href="#打断点" class="headerlink" title="打断点"></a>打断点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b 文件名.go:行号 或 函数名</span><br></pre></td></tr></table></figure><h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c(continue)</span><br></pre></td></tr></table></figure><p>重启</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">r(restart)</span><br></pre></td></tr></table></figure><h3 id="下一行"><a href="#下一行" class="headerlink" title="下一行"></a>下一行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n (next)</span><br></pre></td></tr></table></figure><h3 id="进入函数"><a href="#进入函数" class="headerlink" title="进入函数"></a>进入函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s (step)</span><br></pre></td></tr></table></figure><h3 id="退出函数"><a href="#退出函数" class="headerlink" title="退出函数"></a>退出函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stepout</span><br></pre></td></tr></table></figure><h3 id="查看堆栈"><a href="#查看堆栈" class="headerlink" title="查看堆栈"></a>查看堆栈</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bt</span><br></pre></td></tr></table></figure><h3 id="查看打了断点的列表"><a href="#查看打了断点的列表" class="headerlink" title="查看打了断点的列表"></a>查看打了断点的列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bp (breakpoints)</span><br></pre></td></tr></table></figure><h3 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clear 断点号</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>delve</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Go vendor应用</title>
    <url>/2019/07/10/go-vendor-application/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="为什么要用它"><a href="#为什么要用它" class="headerlink" title="为什么要用它"></a>为什么要用它</h2><p>控制包的依赖，例如一个项目引用的是A包1.0版本后编译成功，结果几个月后A包tag号升到了2.3，而我们平时用<code>go get</code>命令是直接从<code>master</code>分支下引入的，因此可能会造成引入了同样的包，但编译不通过的问题。<br>而如果这个项目中存在<code>vendor</code>文件夹，<code>go</code>项目编译时就会优先编译<code>vendor</code>文件夹里的包。</p><h2 id="问题还原"><a href="#问题还原" class="headerlink" title="问题还原"></a>问题还原</h2><p>今天编译一个用<code>Go</code>写的语音识别服务的项目，缺失的A包用<code>go get</code>命令获取了，但编译后显示<code>xxx function not defined</code>，而我查了这个<code>xxx</code>函数是A包声明好的，这是什么原因呢。<br>原因就在于<strong>版本不匹配</strong>。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="简单直接的方法"><a href="#简单直接的方法" class="headerlink" title="简单直接的方法"></a>简单直接的方法</h3><p>在该项目下新建一个<code>vendor</code>文件夹，假如这个包是引入<code>github</code>上的，就在这下面建立基于<code>github</code>的路径，像这样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── 20hours</span><br><span class="line">│   ├── 20hours</span><br><span class="line">│   ├── demo.txt</span><br><span class="line">│   ├── file.png</span><br><span class="line">│   └── main.go</span><br><span class="line">├── testgo</span><br><span class="line">├── test.go</span><br><span class="line">└── vendor</span><br><span class="line">    └── github.com</span><br><span class="line">        └── name</span><br><span class="line">            └── A</span><br></pre></td></tr></table></figure><p>获取包的指定版本号仓库文件，可以用命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone v版本号 httpurl  </span><br><span class="line"></span><br><span class="line">举例:获取版本号为1.4.1的go-socket.io包  </span><br><span class="line">git clone v1.4.1 https://github.com/googollee/go-socket.io</span><br></pre></td></tr></table></figure><h3 id="推荐的方法，使用dep构建"><a href="#推荐的方法，使用dep构建" class="headerlink" title="推荐的方法，使用dep构建"></a>推荐的方法，使用dep构建</h3><p>网上教程很多，在此不做赘述</p><ul><li><a href="https://golang.github.io/dep/docs/introduction.html" target="_blank" rel="noopener">dep官方文档</a></li><li><a href="https://godoc.org/github.com/golang/dep/cmd/dep" target="_blank" rel="noopener">dep_Godoc</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>vendor</tag>
      </tags>
  </entry>
  <entry>
    <title>炒菜心得小结</title>
    <url>/2019/07/06/cokking-feeling/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><p>女友工作了，于是开始商议在家自己做饭，顺便把第二天中午的也做好，带到公司去吃。<br>本文记录这段时间做饭炒菜的收获。<br>炒菜心得</p><p>炒菜前需要把菜洗干净，然后把菜和肉切薄。<br>接着进入炒菜步骤：</p><pre><code>首先，热锅冷油：先把锅烧热，再倒入冷油。
如果是肉，先倒肉，接着赶紧翻炒，防止粘锅。
肉翻的差不多后，倒入切好的蒜，可以入味和杀菌。
倒入料酒，去腥味。
倒入老抽酱油（凉菜用生抽）。
其次倒入不容易煮熟的菜，例如青椒，进行翻炒。
再倒入容易熟的菜进行翻炒。
洒盐。
快熟的时候关火，洒鸡精，然后用余温翻炒。</code></pre><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>如果闻到糊味，就倒一些凉水。</li><li>炒肉前可以加入料酒和酱油搅拌均匀放置。</li><li>炒肉时可以放入适量的豆瓣酱。</li></ul><h2 id="小试牛刀-自制冒菜"><a href="#小试牛刀-自制冒菜" class="headerlink" title="小试牛刀_自制冒菜"></a>小试牛刀_自制冒菜</h2><pre><code>1，买一个冒菜底料（和火锅底料类似）
2，准备食材</code></pre><p>素菜：鱼豆腐，娃娃菜，金针菇，海带，土豆片，土豆粉，火腿肠<br>荤菜：鸡胸肉，牛肉丸子，蟹棒，虾饺，毛肚，千层肚，午餐肉</p><pre><code>3，洗菜
4，切菜，切肉
5，烧水，煮沸
6，先倒入荤菜
7，再倒入素菜
8，煮熟，关火，试吃</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>认真做好一件事，真的很开心！</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>厨艺学习</category>
      </categories>
      <tags>
        <tag>炒菜</tag>
        <tag>学习</tag>
        <tag>系统</tag>
        <tag>youtube</tag>
      </tags>
  </entry>
  <entry>
    <title>流媒体收录流程</title>
    <url>/2019/07/06/stream-media-collection-process/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>因为工作相关，所以写篇文章记录下这整体的业务流程。</p><h2 id="收录"><a href="#收录" class="headerlink" title="收录"></a>收录</h2><h3 id="文字简述"><a href="#文字简述" class="headerlink" title="文字简述"></a>文字简述</h3><p>收录，简单来说就是将视频流保存成视频文件，比如后缀名为mp4,flv,ts等。那么需要哪些模块呢</p><ul><li>前端：展示给用户看的，同时将用户点击的请求数据发送给后端做处理；</li><li>数据中转服务：在前端传给调度服务的数据格式可能会有误，所以中间要经过这个服务，对数据进行加工（一般是<code>json</code>封装）后发送给对方；</li><li>调度服务：负责所有数据库表的创建，记录的添加，修改，删除的操作；将要收录的源流分发给空闲的收录服务器；如果源流的码率较高，需要用转码服务器转成低码文件后收录；</li><li>源流和设备信息检测服务：检测源流的状态是否异常，如果异常就反馈给前端；检测设备的<code>CPU</code>，物理存储，内存的使用占比情况；</li><li>收录服务：开始收录时，由调度服务发给收录服务一个信号，收录服务开始工作，如果不需要收录了，也是由调度服务发给收录服务一个信号，收录服务停止工作；</li><li>转码服务：如果源流的码率过高，例如有8000k，而用户那边的网速又很差，这样会导致视频收录下来播放给用户会显得很卡，影响用户体验，因此需要经过转码服务将高码率的源流转成低码率后，再由收录服务进行收录；</li><li>迁移服务：收录下来后，其他模块可能也会需要，这时需要做迁移。</li><li>适配服务：如果添加的流类型是收录服务器不支持的，需要通过适配服务转换成收录服务支持的，再进行收录。</li><li>定时删除服务：收录的视频文件过多，极其占用物理存储资源，所以需要定时删除。这个定时删除服务就是做这样的事情。</li></ul><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="/2019/07/06/stream-media-collection-process/streamsystem_o.png" alt></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>最开始做这个我不知道是干嘛用的，直到部门老哥给我讲了下<code>Youtube</code>的视频播放过程，让我看到当你的网速不好时，为了保证视频的流畅，画质会差一些，等你网速好了画质再变得高清点。<br>而我这个原理和它类似。<br>注意，收录服务器和转码服务器在图示为了简洁只画了一台，实际上现场要部署很多台。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>流媒体学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>系统</tag>
        <tag>youtube</tag>
        <tag>视音频</tag>
        <tag>收录</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-448-Find All Numbers Disappeared in an Array | 找到所有数组中消失的数字</title>
    <url>/2019/07/01/Leetcode-448-Find-All-Numbers-Disappeared-in-an-Array/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">Find All Numbers Disappeared in an Array</a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>题目意思是找出1～n(n是指数组的长度)内没有出现的数。例如[4,3,2,7,8,2,3,1]里1~8没有出现的数有5,6，所以输出就是[5,6]。</p><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDisappearedNumbers</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)  <span class="comment">//获取数组的长度</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>;i &lt; n;i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> nums[i]<span class="number">-1</span> != i &amp;&amp; nums[i] != nums[nums[i]<span class="number">-1</span>] &#123;</span><br><span class="line">			nums[i],nums[nums[i]<span class="number">-1</span>] = nums[nums[i]<span class="number">-1</span>],nums[i]  <span class="comment">//交换位置</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ans := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>;i &lt; n;i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i]<span class="number">-1</span> != i &#123;</span><br><span class="line">			ans = <span class="built_in">append</span>(ans,i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-88-Merge Sorted Array | 合并两个有序数组</title>
    <url>/2019/07/01/Leetcode-88-Merge-Sorted-Array/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.com/problems/merge-sorted-array/" target="_blank" rel="noopener">merge-sorted-array</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums1 []<span class="keyword">int</span>, m <span class="keyword">int</span>, nums2 []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">	nums := <span class="built_in">make</span>([]<span class="keyword">int</span>,n+m)  <span class="comment">//创建一个混合数组，长度是nums1和nums2的和</span></span><br><span class="line">	<span class="comment">//三个变量i，j，k，分别指向nums1，nums2，和混合数组的末尾</span></span><br><span class="line">	<span class="keyword">for</span> i,j,k := <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>;i &lt; m || j &lt; n;k++ &#123;</span><br><span class="line">		<span class="keyword">if</span> i &lt; m &amp;&amp; j &lt; n &#123;</span><br><span class="line">			<span class="keyword">if</span> nums1[i] &lt; nums2[j] &#123;</span><br><span class="line">				nums[k] = nums1[i]</span><br><span class="line">				i++</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				nums[k] = nums2[j]</span><br><span class="line">				j++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> i &lt; m &#123;</span><br><span class="line">			nums[k] = nums1[i]</span><br><span class="line">			i++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			nums[k] = nums2[j]</span><br><span class="line">			j++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">copy</span>(nums1,nums)  <span class="comment">//把nums的数拷贝到nums1里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg常用命令整理</title>
    <url>/2019/07/01/ffmpeg-command-finish/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="检测源流信息"><a href="#检测源流信息" class="headerlink" title="检测源流信息"></a>检测源流信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i 源流地址</span><br></pre></td></tr></table></figure><h2 id="推流"><a href="#推流" class="headerlink" title="推流"></a>推流</h2><h3 id="把A-MP4和B-mp4打包进同一个ts流，并推到本机的10003端口"><a href="#把A-MP4和B-mp4打包进同一个ts流，并推到本机的10003端口" class="headerlink" title="把A.MP4和B.mp4打包进同一个ts流，并推到本机的10003端口"></a>把A.MP4和B.mp4打包进同一个ts流，并推到本机的10003端口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -re -i A.mp4  -re -i B.mp4  -map 0:0 -map 0:1 -map 1:0 -map 1:1  -program program_num=1:title=videoA:st=0:st=1 -program program_num=3:title=videoB:st=2:st=3 -c copy -f mpegts udp://localhost:10003</span><br></pre></td></tr></table></figure><p>以此类推</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">推一路流</span><br><span class="line">ffmpeg -re -i A.mp4 -map 0:0 -map 0:1 -program program_num=1:title=videoA:st=0:st=1  -f mpegts udp://localhost:10003</span><br><span class="line"></span><br><span class="line">推三路流</span><br><span class="line">ffmpeg -re -i shenzhen.ts  -re -i guangdong.ts -re -i girl.mp4  -map 0:0 -map 0:1 -map 1:0 -map 1:1 -map 0:0 -map 0:1 -program program_num=1:title=videoA:st=0:st=1 -program program_num=3:title=videoB:st=2:st=3 -program program_num=5:title=videoXXX:st=4:st=5 -f mpegts udp://localhost:10003</span><br></pre></td></tr></table></figure><p>循环推一路流，不做编码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -re -stream_loop -1 -i aaa.xx -c copy -f mpegts udp://localhost:10003</span><br></pre></td></tr></table></figure><h3 id="命令参数解释"><a href="#命令参数解释" class="headerlink" title="命令参数解释"></a>命令参数解释</h3><ul><li>re:realtime 推的速度，按当前帧率推</li><li>map 0:0 第一个流的视频</li><li>map 0:1 第一个流的音频</li><li>map 1:0 第二个流的视频</li><li>map 1:1 第二个流的音频</li><li>program_num=1:title=videoA:st=0:st=1 0,1合成一个视频videoA</li><li>program program_num=3:title=videoB:st=2:st=3 2,3合成一个视频videoB</li><li>-stream_loop 循环推流</li><li>-c copy 将视频中压缩的数据复制</li><li>-c:v libh264 将视频流强制转换为h264编码</li></ul><h2 id="查看流中的program信息"><a href="#查看流中的program信息" class="headerlink" title="查看流中的program信息"></a>查看流中的program信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffprobe -show_programs -print_format json -timeout 5000000 -i udp://localhost:10003</span><br></pre></td></tr></table></figure><ul><li>注意:这个命令有返回值，<code>0</code>表示执行成功，<code>1</code>表示失败。</li></ul><h2 id="将流中的program-1和program-3分别截取5s钟的时间，生成了两个文件"><a href="#将流中的program-1和program-3分别截取5s钟的时间，生成了两个文件" class="headerlink" title="将流中的program 1和program 3分别截取5s钟的时间，生成了两个文件"></a>将流中的program 1和program 3分别截取5s钟的时间，生成了两个文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -timeout 5000000 -i udp://localhost:10003  -t 0:0:5  -map p:1 -c copy  1.mp4 -t 0:0:5 -map p:3 -c copy 3.mp4</span><br></pre></td></tr></table></figure><ul><li>注意。此时推的是复合流。</li></ul><h2 id="对视频流抽帧"><a href="#对视频流抽帧" class="headerlink" title="对视频流抽帧"></a>对视频流抽帧</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i 源流地址 -vframes 1 -vf scale=90:51 图片存放路径</span><br></pre></td></tr></table></figure><h2 id="重复推流"><a href="#重复推流" class="headerlink" title="重复推流"></a>重复推流</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -re -stream_loop -1 -i aaa.xx -c copy -f mpegts udp://localhost:10003</span><br><span class="line"></span><br><span class="line">./ffmpeg -re  -i -stream_loop -1 startslient.mp3  -c:a aac -f flv rtmp://123.56.17.184/live/znn</span><br></pre></td></tr></table></figure><h2 id="将流保存成文件"><a href="#将流保存成文件" class="headerlink" title="将流保存成文件"></a>将流保存成文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i 流地址 -c copy 文件名</span><br><span class="line"></span><br><span class="line">例如:</span><br><span class="line">ffmpeg -i udp://localhost:10003 -c copy test.ts</span><br></pre></td></tr></table></figure><h2 id="检测源流中是否有静音"><a href="#检测源流中是否有静音" class="headerlink" title="检测源流中是否有静音"></a>检测源流中是否有静音</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i silence.mp3 -af silencedetect=noise=0.0001 -f null -</span><br><span class="line">(默认音频中如果有2秒是静音，就认为是有静音的)</span><br><span class="line"></span><br><span class="line">持续让ffmpeg检测音频5秒</span><br><span class="line">ffmpeg -i silence.mp3 -af silencedetect=noise=0.0001 -t 0:0:5 -f null -</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>FFmpeg学习</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
        <tag>视音频</tag>
      </tags>
  </entry>
  <entry>
    <title>Go test单元测试小技巧</title>
    <url>/2019/06/30/golang-test-tips/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>周五在做<code>go test</code>测试时，碰到个问题，我要对一个<code>xxx</code>函数写测试样例，然而它的首字母是小写的，没有导出，单元测试过不去，而这个<code>xxx</code>函数外面还有一个<code>YYY</code>函数首字母是大写的，但要经过很长的逻辑才能到<code>xxx</code>函数。这时我又要完成对<code>xxx</code>函数进行测试，又不想经过<code>YYY</code>函数走逻辑，该怎么办呢？</p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>首先，绝对不能做的事：</p><ul><li>将<code>xxx</code>函数改为首字母大写的<code>Xxx</code>函数<br>原因：很多地方都在调这个函数，你改了这一处只满足你这次的测试，那其他基本业务流程也就崩了。</li></ul><p>我目前是在<code>test</code>文件夹里新建了一个<code>xxx_test.go</code>测试文件，样子长这样</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Testxxx</span><span class="params">(t testing.T)</span></span>&#123;</span><br><span class="line">    control.XXX()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>xxx</code>函数是在<code>control</code>包里，因此我要在<code>control</code>包下建一个<code>export.go</code>文件</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> control</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> XXX = xxx</span><br></pre></td></tr></table></figure><p>然后执行<code>go test</code>命令，它会遍历<code>control</code>包下的所有文件，这时<code>export.go</code>文件 里的<code>var XXX = xxx</code>就起到了一个桥梁作用。</p><p>这时测试的时候就不需要再经过<code>YYY</code>的逻辑走到<code>xxx</code>函数里面。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://studygolang.com/topics/9332" target="_blank" rel="noopener">付费用户「每日一学」2019-06-14：你应该知道的单元测试小技巧</a></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
        <tag>技巧</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go test单元测试小技巧</title>
    <url>/2019/06/30/go-test-tips/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>周五在做<code>go test</code>测试时，碰到个问题，我要对一个<code>xxx</code>函数写测试样例，然而它的首字母是小写的，没有导出，单元测试过不去，而这个<code>xxx</code>函数外面还有一个<code>YYY</code>函数首字母是大写的，但要经过很长的逻辑才能到<code>xxx</code>函数。这时我又要完成对<code>xxx</code>函数进行测试，又不想经过<code>YYY</code>函数走逻辑，该怎么办呢？</p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>首先，绝对不能做的事：</p><ul><li>将<code>xxx</code>函数改为首字母大写的<code>Xxx</code>函数<br>原因：很多地方都在调这个函数，你改了这一处只满足你这次的测试，那其他基本业务流程也就崩了。</li></ul><p>我目前是在<code>test</code>文件夹里新建了一个<code>xxx_test.go</code>测试文件，样子长这样</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Testxxx</span><span class="params">(t testing.T)</span></span>&#123;</span><br><span class="line">    control.XXX()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>xxx</code>函数是在<code>control</code>包里，因此我要在<code>control</code>包下建一个<code>export.go</code>文件</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> control</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> XXX = xxx</span><br></pre></td></tr></table></figure><p>然后执行<code>go test</code>命令，它会遍历<code>control</code>包下的所有文件，这时<code>export.go</code>文件 里的<code>var XXX = xxx</code>就起到了一个桥梁作用。</p><p>这时测试的时候就不需要再经过<code>YYY</code>的逻辑走到<code>xxx</code>函数里面。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://studygolang.com/topics/9332" target="_blank" rel="noopener">付费用户「每日一学」2019-06-14：你应该知道的单元测试小技巧</a></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>单元测试</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Git更改远程推送的仓库地址</title>
    <url>/2019/06/29/git-change-push-remote-rep/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>本地代码推送到远程仓库地址时，有时地址会发生变更，所以需要更改，<code>git</code>命令如下</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="查看远程仓库地址"><a href="#查看远程仓库地址" class="headerlink" title="查看远程仓库地址"></a>查看远程仓库地址</h3><figure class="highlight plain"><figcaption><span>remote -v```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 添加远程仓库链接  </span><br><span class="line"></span><br><span class="line">```git remote add 远程仓库链接</span><br></pre></td></tr></table></figure><p>所以当年<code>push</code>代码的时候，是<code>git push -u 链接名 分支名</code></p><h3 id="更改远程仓库链接名"><a href="#更改远程仓库链接名" class="headerlink" title="更改远程仓库链接名"></a>更改远程仓库链接名</h3><figure class="highlight plain"><figcaption><span>remote rename 老链接名 新链接名```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 删除远程链接仓库链接名</span><br><span class="line"></span><br><span class="line">```git remote remove 链接名</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Git学习</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>push</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员10x工作法</title>
    <url>/2019/06/23/programmer-10x-work/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul><li>01：面对问题时，用思考框架问问自己，现状、目标和路径。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Where are we?（我们现在在哪？）</span><br><span class="line">Where are we going?（我们要到哪儿去？）</span><br><span class="line">How can we get there?（我们如何到达那里？）</span><br></pre></td></tr></table></figure></li><li>02：遇到事情，倒着想。</li><li>03：在做任何事之前，先定义完成的标准。</li><li>04：在做任何需求或任务之前，先定好验收标准。</li><li>05：尽早提交代码去集成。</li><li>06：默认所有需求都不做，直到弄清楚为什么要做这件事。</li><li>07：扩大自己工作的上下文，别把自己局限在一个“程序员”的角色上。</li><li>08：在动手做一件事之前，先推演一番。</li><li>09：问一下自己，我的工作是不是可以用数字衡量。</li><li>10：设计你的迭代0清单，给自己的项目做体检。</li><li>11：动手做一个工作之前，请先对它进行任务分解。</li><li>12：多写单元测试。</li><li>13：我们应该编写可测的代码。</li><li>14：将任务拆小，越小越好。</li><li>15：按照完整实现一个需求的顺序去安排分解出来的任务。</li><li>16：要想写好测试，就要写简单的测试。</li><li>17：想要管理好需求，先把需求拆小。</li><li>18：尽量做最重要的事。</li><li>19：做好产品开发，最可行的方式是采用 MVP（最小可行产品）。</li><li>20：通过沟通反馈，不断升级自己的编解码能力。</li><li>21：用业务的语言写代码。</li><li>22：多面对面沟通，少开会。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我昨天做了什么？  </span><br><span class="line">我今天打算做什么？  </span><br><span class="line">我在过程中遇到了什么问题，需要请求帮助。</span><br></pre></td></tr></table></figure></li><li>23：多尝试用可视化的方式进行沟通。</li><li>24：做好持续集成的关键在于，快速反馈。</li><li>25：定期复盘，找准问题根因，不断改善。</li><li>26：多走近用户。</li><li>27：事情往前做，有问题尽早暴露。</li><li>28：多输出，让知识更有结构。</li><li>29：请谨慎地将工作自动化。</li><li>30：将你的工作过程自动化。</li><li>31：有体系地学习运维知识。</li><li>32：将部署纳入开发的考量。</li><li>33：将验收测试自动化。</li><li>34：把函数写短。</li><li>35：构建好你的领域模型。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">万维钢有期节目里提到芯片设计时讲到了分层以及模型的概念。分层或模型，实质是因为人的认知能力有</span><br><span class="line">限不得已而为之的。学习计算机，我们都知道晶体管，即便早就忘了它的原理。实际上晶体管涉及非常深</span><br><span class="line">奥的物理学知识，这是绝大多数人一辈子都不需要了解的物理学。抛开复杂艰深的物理学，晶体管的本质</span><br><span class="line">却很简单，它就是一个包含通和不通两个状态的开关，这就是它构建的模型。</span><br><span class="line">在开关的模型基础之上，信息论的创立者香农用一篇硕士论文构建了逻辑门这层。他证明了可以用最简单</span><br><span class="line">的开关，实现所有逻辑运算。</span><br><span class="line">逻辑运算层次之上，就是我们所知道的CPU模型。再往上，就是我们所熟悉的信息世界</span><br></pre></td></tr></table></figure></li><li>36：用简单技术解决问题，直到问题变复杂。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一方面，有人会因为对业务量级理解不足，盲目低估其他人系统的复杂度；另一方面，也有人会盲目应用技</span><br><span class="line">术，给系统引入不必要的复杂度，让自己陷入泥潭。</span><br><span class="line">作为拥有技术能力的程序员，我们都非常在意个人技术能力的提升，但却对在什么样情形下，什么样的技术</span><br><span class="line">更加适用考虑得不够。采用恰当的技术，解决当前的问题，是每个程序员都应该仔细考虑的问题。</span><br></pre></td></tr></table></figure></li><li>37：学习领域驱动设计。</li><li>38：了解一个项目，从大图景开始。</li><li>39：小步改造遗留系统，不要回到老路上。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">构建测试防护网，保证新老模块功能一致；</span><br><span class="line">分成小块，逐步替换；</span><br><span class="line">构建好领域模型；</span><br><span class="line">寻找行业中关于系统构建的最新理解。</span><br></pre></td></tr></table></figure></li><li>40：在学习区工作和成长。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从目前的发展来看，IT 行业依然是一个非常有前景的行业，但想在这条路上走好，需要我们成为 “T ”型</span><br><span class="line">人才，也就是“一专多能”。一专多能的前提是“一专”，让自己成为某个方面的专家。这个专家要放在行</span><br><span class="line">业的标准去看，这才能降低因为一个公司的波动而造成的影响。</span><br><span class="line">成为行业专家，要向行业的大师学习，给自己定下一个高的目标，然后是脚踏实地，找适合自己的问题去解</span><br><span class="line">决，让自己一直在学习区成长。</span><br></pre></td></tr></table></figure></li></ul><h2 id="答疑解惑"><a href="#答疑解惑" class="headerlink" title="答疑解惑"></a>答疑解惑</h2><h3 id="单元测试做不好，是否会影响到-CI-的效果？"><a href="#单元测试做不好，是否会影响到-CI-的效果？" class="headerlink" title="单元测试做不好，是否会影响到 CI 的效果？"></a>单元测试做不好，是否会影响到 CI 的效果？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CI 作为一个单独的实践，本身是很简单的，但它可以成为提纲挈领的主线，帮助团队不断改善自己</span><br><span class="line">的开发过程。</span><br></pre></td></tr></table></figure><h3 id="老板参加复盘，不敢说真话怎么办？"><a href="#老板参加复盘，不敢说真话怎么办？" class="headerlink" title="老板参加复盘，不敢说真话怎么办？"></a>老板参加复盘，不敢说真话怎么办？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">问题，是改进的前提条件。</span><br></pre></td></tr></table></figure><h3 id="国内的技术信息落后吗？"><a href="#国内的技术信息落后吗？" class="headerlink" title="国内的技术信息落后吗？"></a>国内的技术信息落后吗？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">国内程序员真正落后的不是信息，而是观念。</span><br></pre></td></tr></table></figure><h3 id="如何管理上级？"><a href="#如何管理上级？" class="headerlink" title="如何管理上级？"></a>如何管理上级？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一，管理上级的预期。</span><br><span class="line">第二，帮助上级丰富知识。</span><br><span class="line">第三，说出你的想法。</span><br></pre></td></tr></table></figure><h3 id="面对不了解的技术，我该如何分解任务？"><a href="#面对不了解的技术，我该如何分解任务？" class="headerlink" title="面对不了解的技术，我该如何分解任务？"></a>面对不了解的技术，我该如何分解任务？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先把它变成你熟悉的技术。</span><br></pre></td></tr></table></figure><h3 id="项目时间紧，该怎么办？"><a href="#项目时间紧，该怎么办？" class="headerlink" title="项目时间紧，该怎么办？"></a>项目时间紧，该怎么办？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">混淆了目标与现状。</span><br><span class="line">目标是应该怎么做，现状是我们正在怎么做。我们都知道</span><br><span class="line">现状是什么样的，问题是，你对现状满意吗？如果每个人都对现状是满意的，就不会有人探索更好的做法。</span><br><span class="line">假设现在不忙了，你知道该怎么改进吗？</span><br><span class="line"></span><br><span class="line">自动糊改进：</span><br><span class="line">把测试覆盖率检查加入到工程里，得到现有的测试覆盖率。</span><br><span class="line">将测试覆盖率加入持续集成，设定当前测试覆盖率为初始值。测试覆盖率不达标，不许提交代码。</span><br><span class="line">每周将测试覆盖率调高，比如，5%或10%，直到测试覆盖率达到100%。</span><br></pre></td></tr></table></figure><h3 id="多个功能同时开发，怎么办？"><a href="#多个功能同时开发，怎么办？" class="headerlink" title="多个功能同时开发，怎么办？"></a>多个功能同时开发，怎么办？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在主分支开发模型中，有一些常见的解决多功能并行开发的方法，其中，Feature Toggle 是最常用的一个，</span><br><span class="line">也就是通过开关，决定哪个功能是对外可用的。</span><br></pre></td></tr></table></figure><h3 id="如何在实际工作中推行新观念？"><a href="#如何在实际工作中推行新观念？" class="headerlink" title="如何在实际工作中推行新观念？"></a>如何在实际工作中推行新观念？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">找到愿意和你一起改变的人，做一件具体的事。</span><br></pre></td></tr></table></figure><h3 id="测试怎么写？"><a href="#测试怎么写？" class="headerlink" title="测试怎么写？"></a>测试怎么写？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">关于外部系统的测试，你可以先通过接口隔离开来，然后，通过模拟服务或本地可控的方式进行</span><br><span class="line">测试。</span><br></pre></td></tr></table></figure><h3 id="IntelliJ-IDEA-怎么学？"><a href="#IntelliJ-IDEA-怎么学？" class="headerlink" title="IntelliJ IDEA 怎么学？"></a>IntelliJ IDEA 怎么学？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个工具怎么学？我的经验就是去用。我没有专门学过 IntelliJ IDEA，只是不断地在使用它。</span><br><span class="line">遇到问题就去找相应的解决方案。</span><br><span class="line">也有一些辅助的方法可以帮助我们练习，</span><br><span class="line">比如，我们会给新员工发放 IntelliJ IDEA 的快捷键卡片，写代码休息之余，可以拿来看一下；</span><br><span class="line">再比如，IntelliJ IDEA 有一个插件叫 Key Promoter X，</span><br><span class="line">如果你用鼠标操作，它会给你提示，帮你记住快捷键</span><br></pre></td></tr></table></figure><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li><a href="https://www.infoq.cn/article/function-switch-realize-better-continuous-implementations" target="_blank" rel="noopener">使用功能开关更好地实现持续部署</a></li><li><a href="https://martinfowler.com/articles/feature-toggles.html" target="_blank" rel="noopener">Feature Toggles (aka Feature Flags)</a></li><li><a href="https://www.unixhot.com/page/ops" target="_blank" rel="noopener">运维知识体系</a></li><li><a href="https://www.unixhot.com/page/cache" target="_blank" rel="noopener">Web缓存知识体系</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>工作</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode_905_Sort-Array-By-Parity | 按奇偶排序数组</title>
    <url>/2019/06/19/LeetCode-905-Sort-Array-By-Parity/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><a href="https://leetcode.com/problems/sort-array-by-parity/?utm_source=LCUS&utm_medium=ip_redirect_q_uns&utm_campaign=transfer2china" target="_blank" rel="noopener">905. Sort Array By Parity</a></p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><ul><li>Python</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArrayByParity</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> A[i] % <span class="number">2</span> &gt; A[j] % <span class="number">2</span>:</span><br><span class="line">                A[i], A[j] = A[j], A[i] <span class="comment">#互换</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> A[i] % <span class="number">2</span> == <span class="number">0</span>: i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> A[j] % <span class="number">2</span> == <span class="number">1</span>: j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure><ul><li>C++</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortArrayByParity(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                swap(A[i--],A[len--]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode_977_Squares-of-a-Sorted-Array | 有序数组的平方</title>
    <url>/2019/06/19/LeetCode-977-Squares-of-a-Sorted-Array/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><ul><li><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener">leetcode中国</a></li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>此题比较简单，意思就是对数组里的数字进行排序和开平方。代码如下</p><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            A[i] = A[i] * A[i];  <span class="comment">//对数组中每个数都平方</span></span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(A);  <span class="comment">//对数组进行排序</span></span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Python</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span><span class="params">(self, A: <span class="string">'List[int]'</span>)</span> -&gt; 'List[int]':</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> x*x</span><br><span class="line">        <span class="keyword">return</span> sorted(map(f,A))</span><br></pre></td></tr></table></figure><h2 id="开启刷题之路"><a href="#开启刷题之路" class="headerlink" title="开启刷题之路"></a>开启刷题之路</h2><p>加入了大佬创建的刷题圈，目标是一天一道LeetCode算法题，按专题刷，加油！</p><p><img src="/2019/06/19/LeetCode-977-Squares-of-a-Sorted-Array/sky.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-485-Max Consecutive Ones | 最大连续1的个数</title>
    <url>/2019/06/17/Leetcode-485-Max-Consecutive-Ones/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.com/problems/max-consecutive-ones/" target="_blank" rel="noopener">Max Consecutive Ones</a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="题目意思"><a href="#题目意思" class="headerlink" title="题目意思"></a>题目意思</h3><p>给定一个二进制数组，计算数组中出现的最大连续1的个数。</p><p>注意：</p><ul><li>输入数组只包含0和1</li><li>数组长度是正整数并且不会超过10000</li></ul><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>遍历数组并对连续的数计数，最终取最大值。</p><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><ul><li><p>错误</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> max <span class="keyword">int</span>  <span class="comment">//声明最大值</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i &lt;= <span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> _,v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[i] = v &#123;</span><br><span class="line">				max++</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				max=<span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>正确1</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	count := <span class="number">1</span></span><br><span class="line">	<span class="comment">//考虑特殊情况</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &amp;&amp; nums[<span class="number">0</span>] == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] == nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[i] == <span class="number">1</span> &#123;</span><br><span class="line">				count++  <span class="comment">//计数</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			count = <span class="number">1</span>  <span class="comment">//没有合适的就置为1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> count &gt; res &#123;</span><br><span class="line">			res = count</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>正确2</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sum, max <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		sum += v</span><br><span class="line">		sum *= v</span><br><span class="line">		<span class="keyword">if</span> sum &gt; max &#123;</span><br><span class="line">			max = sum</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>知识星球Go项目实战爬虫项目总结</title>
    <url>/2019/06/16/zsxq-go-project-action-crawler-summary/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>知识星球<code>Go项目实战</code>的第一个实战项目—&gt;爬虫。<br>本文记录直播内容和相关细节。</p><h2 id="前端相关"><a href="#前端相关" class="headerlink" title="前端相关"></a>前端相关</h2><p>DOM，CSS选择器，jQuery</p><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><ul><li>前端：Bootstrap和jQuery</li><li>后端：Go</li><li>数据库：MySQL</li></ul><h3 id="数据库设计思路"><a href="#数据库设计思路" class="headerlink" title="数据库设计思路"></a>数据库设计思路</h3><ul><li>job_info 表：我们计划抓取猎聘、Boss直聘和拉钩网三个网站的 Go 语言相关职位信息。通过分析三个网站上的职位信息数据，结合咱们的目标，设计了 job_info 表；</li><li>crawl_rule 表：针对 job_info 表的设计，我们希望在网站职位的详情页能够获取到相应信息。因为每个网站页面结构不同，抓取策略也会不一样，因此有了此表；</li><li>auto_crawl_rule 表：crawl_rule 表是针对一个职位详情页的，但我们不可能手动一个页面一个页面抓取，而是希望能够提供一些信息将某个网站上相关职位信息批量抓取。此表用于抓取职位列表信息，进而抓取一个个职位信息；</li></ul><h3 id="数据库设计原则和注意事项-重点"><a href="#数据库设计原则和注意事项-重点" class="headerlink" title="数据库设计原则和注意事项(重点)"></a>数据库设计原则和注意事项(重点)</h3><p>1，字段不允许 NULL 且提供默认值，即 NOT NULL DEFAULT xx；<br>2，选择合适的最小数据类型；<br>3，确保是非负数的字段，加上 unsigned;<br>4，使用 COMMENT 给字段加备注；<br>5，表一般应该有 created_at 字段；<br>6，没特殊情况，请使用 InnoDB 引擎；<br>7，字符编码使用 utf8mb4；<strong>不要用utf8</strong><br>8，VARCHAR 类型的长度值使用 2 的幂次方减1或减2，比如 varchar(127) varchar(255) varchar(510) 因为 510 这个数字（长度）本身需要 2 个字节存储。（也就是长度超过 255 之后，用两个字节存储长度，所以减 2）；<br>9，根据查询条件，建立必要的索引；<br>10，NOT NULL，确保它一定不是NULL；</p><h3 id="项目结构和代码组织"><a href="#项目结构和代码组织" class="headerlink" title="项目结构和代码组织"></a>项目结构和代码组织</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── cmd  //项目入口，主程序</span><br><span class="line">│   └── crawler</span><br><span class="line">│       ├── background.go</span><br><span class="line">│       ├── crawler</span><br><span class="line">│       └── main.go</span><br><span class="line">├── config  //配置信息</span><br><span class="line">│   └── config.yaml</span><br><span class="line">├── dao  //数据访问对象，直接和数据存储打交道</span><br><span class="line">│   ├── auto_crawl_rule.go</span><br><span class="line">│   ├── auto_crawl_rule_test.go</span><br><span class="line">│   ├── crawl_rule.go</span><br><span class="line">│   ├── db.go</span><br><span class="line">│   └── job.go</span><br><span class="line">├── docs  //文档</span><br><span class="line">│   └── db.sql</span><br><span class="line">├── global  //全局信息，初始化</span><br><span class="line">│   ├── app.go</span><br><span class="line">│   ├── error.go</span><br><span class="line">│   └── init.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── http  //</span><br><span class="line">│   ├── controller  //MVC 的 controller</span><br><span class="line">│   │   ├── job_handler.go</span><br><span class="line">│   │   └── job_handler_test.go</span><br><span class="line">│   ├── middleware  //http的中间件</span><br><span class="line">│   │   ├── logger.go</span><br><span class="line">│   │   └── recover.go</span><br><span class="line">│   └── routes.go</span><br><span class="line">├── LICENSE</span><br><span class="line">├── logic  //业务逻辑</span><br><span class="line">│   ├── crawler</span><br><span class="line">│   │   ├── colly.go</span><br><span class="line">│   │   ├── goquery.go</span><br><span class="line">│   │   ├── parser.go</span><br><span class="line">│   │   └── work.go</span><br><span class="line">│   └── job.go</span><br><span class="line">├── model  //映射的结构体</span><br><span class="line">│   ├── auto_crawl_rule.go</span><br><span class="line">│   ├── crawl_rule.go</span><br><span class="line">│   └── job_info.go</span><br><span class="line">├── README.md</span><br><span class="line">├── template  //模板</span><br><span class="line">│   ├── detail.html</span><br><span class="line">│   └── index.html</span><br><span class="line">└── util  //辅助工具</span><br><span class="line">    ├── file.go</span><br><span class="line">    ├── http.go</span><br><span class="line">    ├── int.go</span><br><span class="line">    └── ip.go</span><br></pre></td></tr></table></figure><h3 id="关于配置文件"><a href="#关于配置文件" class="headerlink" title="关于配置文件"></a>关于配置文件</h3><p>1，写死，保底<br>2，通过配置拿到数据，两种形式，读取配置文件和命令行参数传递过来<br>3，读环境变量</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本项目主要熟悉和培养用Go设计项目的框架，同时也把前段时间学习的知识点做了综合运用。下面记录下一些关键信息：</p><ul><li>熟悉<code>go mod</code></li><li>执行数据库语句的代码和数据库语句最好分开来操作</li><li>数据量很大的时候，最好不要随意改变数据表中的字段，不然服务会挂</li><li>项目中还有待完善的部分，例如<code>Colly</code>的实现，结构体转数据表或数据表转结构体，选择分析器的部分</li></ul><h2 id="提问环节"><a href="#提问环节" class="headerlink" title="提问环节"></a>提问环节</h2><p>Q1:cmd下为什么要有crawler文件夹<br>如果cmd下放main.go，编译出来的文件名叫什么？—cmd</p><p>Q2:并发版爬虫？什么时候成分布式的啊<br>抓的太频繁，会被封。</p><p>Q3:測試 controller 會直接對 db 調用，不知道這樣好嗎</p><p>Q4:http 为什么要加 recover ？ 默认没有么</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>爬虫</tag>
        <tag>Go</tag>
        <tag>知识星球</tag>
      </tags>
  </entry>
  <entry>
    <title>Git如何更新fork后的repository</title>
    <url>/2019/06/10/how-to-update-git-fork-repository/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有一个仓库A，我经过<code>fork</code>后变成了仓库B，当仓库A已经有了新提交时，我需要更新仓库B，该怎么办呢？</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>1,首先，检查一下当前的配置，看看当前有没有已经设置了上游，这要使用<code>git remote -v</code>命令。</p><p>2,将原repository设置为自己fork出的repository的上游（upstream）。运用如下的命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git</span><br></pre></td></tr></table></figure><p>3,运行<code>git fetch upstream</code>命令，如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">remote: Enumerating objects: 122, done.</span><br><span class="line">remote: Counting objects: 100% (122/122), done.</span><br><span class="line">remote: Compressing objects: 100% (90/90), done.</span><br><span class="line">remote: Total 97 (delta 40), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (97/97), done.</span><br><span class="line">From https://gitea.com/zsxq/jobs_crawler</span><br><span class="line"> * [new branch]      master     -&gt; upstream/master</span><br></pre></td></tr></table></figure><p>4,<code>git checkout master</code>，这是保证切换到本地的repository的master上，如果本来就在，那么这一步不是必须的。</p><p>5,运行<code>git merge upstream/master</code>命令，将upstream/master上的更新合并到本地的master上，其实就是将第三步中download到.git文件夹下的那些change合并到本地的master中。如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Updating e9540a6..c31fadf</span><br><span class="line">Fast-forward</span><br><span class="line"> README.md                      |   8 +-</span><br><span class="line"> cmd/crawler/background.go      |  42 ++++++++</span><br><span class="line"> cmd/crawler/main.go            |  32 +++---</span><br><span class="line"> config/config.yaml             |  18 +++-</span><br><span class="line"> dao/auto_crawl_rule.go         |  79 +++++++++++++++</span><br><span class="line"> dao/auto_crawl_rule_test.go    |  38 +++++++</span><br><span class="line"> dao/crawl_rule.go              |  44 ++++++++</span><br><span class="line"> dao/db.go                      |  19 ++--</span><br><span class="line"> dao/job.go                     | 101 ++++++++++++++++++-</span><br><span class="line"> docs/db.sql                    |  19 ++--</span><br><span class="line"> global/app.go                  |  77 ++++++++++++++</span><br><span class="line"> global/init.go                 |  35 +++++++</span><br><span class="line"> go.mod                         |   5 +-</span><br><span class="line"> go.sum                         |   3 +</span><br><span class="line"> http/controller/job_handler.go |  79 ++++++++++++++-</span><br><span class="line"> http/middleware/logger.go      |  35 +++++++</span><br><span class="line"> logic/crawler/colly.go         |  46 +++++++++</span><br><span class="line"> logic/crawler/goquery.go       | 221 +++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> logic/crawler/parser.go        |  68 +++++++++++++</span><br><span class="line"> logic/crawler/work.go          |  55 ++++++++++</span><br><span class="line"> logic/job.go                   |  14 ++-</span><br><span class="line"> model/auto_crawl_rule.go       |  31 ++++++</span><br><span class="line"> model/crawl_rule.go            |  26 +++++</span><br><span class="line"> model/job_info.go              |   2 +-</span><br><span class="line"> template/detail.html           |  49 +++++++++</span><br><span class="line"> template/index.html            |  70 +++++++++++++</span><br><span class="line"> util/file.go                   |  18 ++++</span><br><span class="line"> util/http.go                   |  21 ++++</span><br><span class="line"> util/int.go                    |   8 ++</span><br><span class="line"> util/ip.go                     |  37 +++++++</span><br><span class="line"> 30 files changed, 1253 insertions(+), 47 deletions(-)</span><br></pre></td></tr></table></figure><p>这时我在用<code>gitk</code>命令查看<br><img src="/2019/06/10/how-to-update-git-fork-repository/git-fork.png" alt="git-fork"></p><p>6,如果本地没有什么自己独立的更新的话，那么将执行”Fast-forward”的合并。如果本地有自己独立的更新，而又会引起冲突的话，则要解决冲突，再commit.</p><p>关于解决冲突，如果明确所有冲突都是使用upstream/master上的来override自己的，那么可以直接运行如下命令，则无需解决冲突了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge -X theirs upstream/master</span><br></pre></td></tr></table></figure><p>注意，以上步骤结束后，仅仅是本地的fork出的repository和原repository取得了同步，如果想让远程的fork出的repository也同样取得同步，必须再git push上去。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://help.github.com/en/articles/syncing-a-fork" target="_blank" rel="noopener">Syncing a fork</a></li><li><a href="https://help.github.com/en/articles/configuring-a-remote-for-a-fork" target="_blank" rel="noopener">Configuring a remote for a fork</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>Git</tag>
        <tag>fork</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-66-Plus One | 加一</title>
    <url>/2019/06/10/Leetcode-66-Plus-One/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.com/problems/plus-one/" target="_blank" rel="noopener">plus one</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>模拟十进制进位加法</li><li>注意处理有进位的情况</li></ul><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><ul><li><p>解法一</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plusOne</span><span class="params">(digits []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	digitslength := <span class="built_in">len</span>(digits)  <span class="comment">//获取数组长度</span></span><br><span class="line">	<span class="keyword">for</span> i := digitslength - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i-- &#123;</span><br><span class="line">		<span class="keyword">if</span> digits[i] &lt; <span class="number">9</span> &#123;  <span class="comment">//判断数组尾部是否小于9</span></span><br><span class="line">			digits[i]++</span><br><span class="line">			<span class="keyword">return</span> digits</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//有进位的情况</span></span><br><span class="line">		digits[i] = <span class="number">0</span>  <span class="comment">//数组最后一位置为0</span></span><br><span class="line">		res := []<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;  </span><br><span class="line">		res = <span class="built_in">append</span>(res,digits...)</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法二</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plusOne</span><span class="params">(digits []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	digits = <span class="built_in">append</span>(digits,<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(digits) - <span class="number">1</span>;i &gt; <span class="number">0</span>;i-- &#123;</span><br><span class="line">		digits[i] = digits[i] + digits[i<span class="number">-1</span>]</span><br><span class="line">		digits[i<span class="number">-1</span>] = digits[i]/<span class="number">10</span>  <span class="comment">//取除数</span></span><br><span class="line">		digits[i] %= <span class="number">10</span>  <span class="comment">//取余数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> digits[<span class="number">0</span>] == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> digits[<span class="number">1</span>:]</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> digits</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title>文字直播：消息推送系统介绍</title>
    <url>/2019/06/09/text-live-introduction-message-push-system/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>直播内容:主要讨论周洋在360做的消息推送系统，主要分为以下几个部分：</p><ul><li>关于push系统对比与性能指标的讨论~</li><li>消息系统架构介绍</li><li>哪些因素决定了推送系统的效果？</li><li>go语言开发问题与解决方案</li><li>消息系统的运维，测试</li></ul><h2 id="直播开始"><a href="#直播开始" class="headerlink" title="直播开始"></a>直播开始</h2><p>360消息系统更确切的说是长连接push系统，目前服务于360内部50多个产品，开发平台数千款app，也支持部分聊天业务场景，单通道多app复用，支持上行数据，提供接入方不同粒度的上行数据和用户状态回调服务。<br>目前整个系统按不同业务分成9个功能完整的集群，部署在10个idc上（每个集群覆盖不同的idc），实时在线2亿量级.<br>通常情况下，pc，手机，甚至是智能硬件上的360产品的push消息，基本上是从我们系统发出的，期望大家收到的push都是自己关心的… 如果不是，请相信，“我们不生产消息，我们只是消息的搬运工”~<br>很多同行比较关心go语言在实现push系统上的性能问题，单机性能究竟如何，能否和其他语言实现的类似系统做对比么？甚至问如果是创业,第三方云推送平台，推荐哪个?<br>其实各大厂都有类似的push系统，市场上也有类似功能的云服务。包括我们公司早期也有erlang，nodejs实现的类似系统，也一度被公司要求做类似的对比测试。<br>我感觉在讨论对比数据的时候，很难保证大家环境和需求的统一，我只能说下我这里的体会，数据是有的，但这个数据前面估计会有很多定语~</p><h2 id="一些重要指标"><a href="#一些重要指标" class="headerlink" title="一些重要指标"></a>一些重要指标</h2><h3 id="1，单机的连接数指标。"><a href="#1，单机的连接数指标。" class="headerlink" title="1，单机的连接数指标。"></a>1，单机的连接数指标。</h3><p>做过长连接的同行，应该有体会，如果在稳定连接情况下，连接数这个指标，在没有网络吞吐情况下对比，其实意义往往不大，维持连接消耗cpu资源很小，每条连接tcp协议栈会占约4k的内存开销，系统参数调整后，我们单机测试数据，最高也是可以达到单实例300w长连接。<br>但做更高的测试，我个人感觉意义不大。因为实际网络环境下，单实例300w长连接，从理论上算压力就很大：因为实际弱网络环境下，移动客户端的断线率很高，假设每秒有1000分之一的用户断线重连。300w长连接，每秒新建连接达到3w，这同时连入的3w用户，要进行注册，加载离线存储等对内rpc调用，另外300w长连接的用户心跳需要维持,假设心跳300s一次，心跳包每秒需要1w tps。<br>单播和多播数据的转发，广播数据的转发，本身也要响应内部的rpc调用，300w长连接情况下，gc带来的压力，内部接口的响应延迟能否稳定保障。<br>这些集中在一个实例中，可用性是一个挑战。所以线上单实例不会hold很高的长连接,实际情况也要根据接入客户端网络状况来决定。</p><h3 id="2，消息系统的内存使用量指标"><a href="#2，消息系统的内存使用量指标" class="headerlink" title="2，消息系统的内存使用量指标"></a>2，消息系统的内存使用量指标</h3><p>这一点上，使用go语言情况下，由于协程的原因，会有一部分额外开销。但是要做两个推送系统的对比，也有些需要确定问题。<br>比如系统从设计上是否需要全双工（即读写是否需要同时进行）如果半双工，理论上对一个用户的连接只需要使用一个协程即可（这种情况下，对用户的断线检测可能会有延时），如果是全双工，那读/写各一个协程。两种场景内存开销是有区别的.</p><p>另外测试数据的大小往往决定我们对连接上设置的读写buffer是多大，是全局复用的，还是每个连接上独享的，还是动态申请的。另外是否全双工也决定buffer怎么开. 不同的策略，可能在不同情况的测试中表现不一样。</p><h3 id="3，每秒消息下发量"><a href="#3，每秒消息下发量" class="headerlink" title="3，每秒消息下发量"></a>3，每秒消息下发量</h3><p>这一点上，也要看我们对消息到达的QoS级别(回复ack策略区别），另外架构策略，每种策略有其更适用的场景，是纯粹推，还是推拉结合。甚至是否开启了消息日志，日志库的实现机制，缓冲开多大，flush策略,这些都影响整个系统的吞吐量。另外为了HA，增加了内部通信成本，为了避免一些小概率事件，提供闪断补偿策略，这些都要考虑进去。如果所有的都去掉，那就是比较基础库的性能了.</p><p>所以我只能给出大概数据，24核，64G的服务器上，在Qos为message at least，纯粹推的情况，消息体256B<del>1kB情况下，单个实例100w实际用户（200w+）协程，峰值可以达到2</del>5w的QPS…<br>内存可以稳定在25G左右，gc时间在200<del>800ms左右.（还有优化空间） 我们正常线上单实例用户控制在80w以内，单机最多两个实例</del><br>事实上，整个系统在推送的需求上，对高峰的输出不是提速，往往是进行限速，以防push系统瞬时的高吞吐量，转化成对接入方业务服务器的ddos攻击<br>所以对于性能上，我感觉大家可以放心使用，至少在我们这个量级上，经受过考验，go1.5到来后，确实有之前投资又增值了的感觉~<br>下面是对消息系统的大概介绍，之前一些同学可能在gopher china上可以看到分享，这里简单讲解下架构和各个组件功能，额外补充一些当时遗漏的信息：<br>架构图如下，所有的service都 written by golang.<br><img src="/content/images/2019/06/0b8323ed2b40742005a9a6b2010f85b.jpg" alt="0b8323ed2b40742005a9a6b2010f85b"></p><h2 id="几个大概重要组件介绍如下"><a href="#几个大概重要组件介绍如下" class="headerlink" title="几个大概重要组件介绍如下"></a>几个大概重要组件介绍如下</h2><h3 id="dispatcher-service"><a href="#dispatcher-service" class="headerlink" title="dispatcher service"></a>dispatcher service</h3><p>根据客户端请求信息，将应网络和区域的长连接服务器的，一组IP传送给客户端。客户端根据返回的IP，建立长连接，连接Room service.</p><h3 id="room-Service"><a href="#room-Service" class="headerlink" title="room Service"></a>room Service</h3><p>长连接网关，hold用户连接，并将用户注册进register service，本身也做一些接入安全策略、白名单、IP限制等</p><h3 id="coordinator-service"><a href="#coordinator-service" class="headerlink" title="coordinator service"></a>coordinator service</h3><p>用来转发用户的上行数据，包括接入方订阅的用户状态信息的回调，另外做需要协调各个组件的异步操作，比如kick用户操作,需要从register拿出其他用户做异步操作.</p><h3 id="saver-service"><a href="#saver-service" class="headerlink" title="saver service"></a>saver service</h3><p>是存储访问层，承担了对redis和mysql的操作，另外也提供部分业务逻辑相关的内存缓存，比如广播信息的加载可以在saver中进行缓存。另外一些策略，比如客户端sdk由于被恶意或者意外修改，每次加载了消息，不回复ack，那服务端就不会删除消息，消息就会被反复加载，形成死循环，可以通过在saver中做策略和判断。（客户端总是不可信的）</p><h3 id="center-service"><a href="#center-service" class="headerlink" title="center service"></a>center service</h3><p>提供给接入方的内部api服务器，比如单播或者广播接口，状态查询接口等一系列api,包括运维和管理的api.</p><h3 id="举两个常见例子，了解工作机制："><a href="#举两个常见例子，了解工作机制：" class="headerlink" title="举两个常见例子，了解工作机制："></a>举两个常见例子，了解工作机制：</h3><p>比如发一条单播给一个用户，center先请求Register获取这个用户之前注册的连接通道标识、room实例地址，通过room service下发给长连接。<br>Center Service比较重的工作如全网广播，需要把所有的任务分解成一系列的子任务，分发给所有center，然后在所有的子任务里，分别获取在线和离线的所有用户，再批量推到Room Service。通常整个集群在那一瞬间压力很大。<br>deployd/agent service 用于部署管理各个进程，收集各组件的状态和信息,zookeeper和keeper用于整个系统的配置文件管理和简单调度</p><h2 id="关于推送的服务端架构"><a href="#关于推送的服务端架构" class="headerlink" title="关于推送的服务端架构"></a>关于推送的服务端架构</h2><p>常见的推送模型有长轮训拉取，服务端直接推送（360消息系统目前主要是这种），推拉结合（推送只发通知，推送后根据通知去拉取消息）.<br>拉取的方式不说了，现在并不常用了，早期很多是nginx+lua+redis，长轮训，主要问题是开销比较大，时效性也不好, 能做的优化策略不多。<br>直接推送的系统，目前就是360消息系统这种，消息类型是消耗型的，并且对于同一个用户并不允许重复消耗,如果需要多终端重复消耗，需要抽象成不同用户。<br>推的好处是实时性好，开销小，直接将消息下发给客户端，不需要客户端走从接入层到存储层主动拉取.<br>但纯推送模型，有个很大问题，由于系统是异步的，他的时序性无法精确保证。这对于push需求来说是够用的，但如果复用推送系统做im类型通信，可能并不合适。</p><h2 id="这里还有一个常见话题，哪些因素决定推送系统的效果？"><a href="#这里还有一个常见话题，哪些因素决定推送系统的效果？" class="headerlink" title="这里还有一个常见话题，哪些因素决定推送系统的效果？"></a>这里还有一个常见话题，哪些因素决定推送系统的效果？</h2><h3 id="首先是sdk的完善程度"><a href="#首先是sdk的完善程度" class="headerlink" title="首先是sdk的完善程度"></a>首先是sdk的完善程度</h3><p>sdk策略和细节完善度，往往决定了弱网络环境下最终推送质量.</p><p>1.SDK选路策略,最基本的一些策略如下：<br>有些开源服务可能会针对用户hash一个该接入区域的固定ip，实际上在国内环境下不可行，最好分配器（dispatcher）是返回散列的一组，而且端口也要参开，必要时候，客户端告知是retry多组都连不上，返回不同idc的服务器。因为我们会经常检测到一些case，同一地区的不同用户，可能对同一idc内的不同ip连通性都不一样，也出现过同一ip不同端口连通性不同，所以用户的选路策略一定要灵活，策略要足够完善.<br>另外在选路过程中，客户端要对不同网络情况下的长连接ip做缓存，当网络环境切换时候(wifi 2G,3G)，重新请求分配器，缓存不同网络环境的长连接ip.</p><p>2.客户端对于数据心跳和读写超时设置,完善断线检测重连机制<br>针对不同网络环境，或者客户端本身消息的活跃程度，心跳要自适应的进行调整并与服务端协商，来保证链路的连通性。并且在弱网络环境下，除了网络切换（wifi切3G）或者读写出错情况，什么时候重新建立链路也是一个问题。客户端发出的ping包，不同网络下，多久没有得到响应，认为网络出现问题，重新建立链路需要有个权衡。另外对于不同网络环境下，读取不同的消息长度，也要有不同的容忍时间，不能一刀切。好的心跳和读写超时设置，可以让客户端最快的检测到网络问题，重新建立链路，同时在网络抖动情况下也能完成大数据传输。</p><p>3.结合服务端做策略<br>另外系统可能结合服务端做一些特殊的策略，比如我们在选路时候，我们会将同一个用户尽量映射到同一个room service实例上。断线时，客户端尽量对上次连接成功的地址进行重试。主要是方便服务端做闪断情况下策略，会暂存用户闪断时实例上的信息，重新连入的时候，做单实例内的迁移，减少延时与加载开销.</p><p>4.客户端保活策略<br>很多创业公司愿意重新搭建一套push系统，确实不难实现，其实在协议完备情况下（最简单就是客户端不回ack不清数据），服务端会保证消息是不丢的。但问题是为什么在消息有效期内,到达率上不去？<br>往往因为自己app的push service存活能力不高。选用云平台或者大厂的，往往sdk会做一些保活策略，比如和其他app共生，互相唤醒，这也是云平台的push service更有保障原因~ 我相信很多云平台旗下的sdk，多个使用同样sdk的app，为了实现服务存活，是可以互相唤醒和保证活跃的~ 另外现在push sdk本身是单连接，多app复用的，这为sdk实现，增加了新的挑战~</p><p>综上，对我来说，选择推送平台，优先会考虑客户端sdk的完善程度~ 对于服务端，选择条件稍微简单，要求部署接入点（IDC）越要多，配合精细的选路策略，效果越有保证，至于想知道哪些云服务有多少点，这个群里来自各地的小伙伴们，可以合伙测测~</p><p>这个系统在开发过程中遇到挑战和优化策略，给大家看下当年的一张图，在第一版优化方案上线前一天截图~</p><p>可以看到，内存最高占用69G，GC时间单实例最高时候高达3<del>6s.这种情况下，试想一次悲剧的请求，经过了几个正在执行gc的组件，后果必然是超时… gc照成的接入方重试，又加重了系统的负担。遇到这种情况当时整个系统最差情况每隔2，3天就需要重启一次</del></p><p><img src="/content/images/2019/06/2b01512149c092fa9edf1e4023d7ed0.jpg" alt="2b01512149c092fa9edf1e4023d7ed0"></p><p>当时出现问题，现在总结起来，大概以下几点</p><p>1.散落在协程里的I/O，Buffer和对象不复用。<br>当时由于对go的gc效率理解有限，比较奔放，程序里大量short live的协程，对内通信的很多io操作，由于不想阻塞主循环逻辑或者需要及时响应的逻辑，通过单独go协程来实现异步。这回会gc带来很多负担。</p><p>针对这个问题，应尽量控制协程创建，对于长连接这种应用，本身已经有几百万并发协程情况下，很多情况没必要在各个并发协程内部做异步io，因为程序的并行度是有限，理论上做协程内做阻塞操作是没问题。<br>如果有些需要异步执行，比如如果不异步执行，影响对用户心跳或者等待response无法响应，最好通过一个任务池，和一组常驻协程，来消耗，处理结果，通过channel再传回调用方. 使用任务池还有额外的好处，可以对请求进行打包处理，提高吞吐量，并且可以加入控量策略.</p><p>2.网络环境不好引起激增<br>go协程相比较以往高并发程序，如果做不好流控，会引起协程数量激增。早期的时候也会发现，时不时有部分主机内存会远远大于其他服务器，但发现时候，所有主要profiling参数都正常了。<br>后来发现，通信较多系统中，网络抖动阻塞是不可免的(即使是内网)，对外不停accept接受新请求，但执行过程中，由于对内通信阻塞，大量协程被创建，业务协程等待通信结果没有释放，往往瞬时会迎来协程暴涨. 但这些内存在系统稳定后，virt和res都并没能彻底释放，下降后，维持高位。<br>处理这种情况，需要增加一些流控策略，流控策略可以选择在rpc库来做，或者上面说的任务池来做，其实我感觉放在任务池里做更合理些，毕竟rpc通信库可以做读写数据的限流，但它并不清楚具体的限流策略，到底是重试还是日志还是缓存到指定队列。任务池本身就是业务逻辑相关的，它清楚针对不同的接口需要的流控限制策略。</p><p>3.低效和开销大的rpc框架<br>早期rpc通信框架比较简单，对内通信时候使用的也是短连接。这本来短连接开销和性能瓶颈超出我们预期，短连接io效率是低一些，但端口资源够，本身吞吐可以满足需要，用是没问题的，很多分层的系统，也有http短连接对内进行请求的。但早期go版本，这样写程序，在一定量级情况，是支撑不住的。短连接大量临时对象和临时buffer创建，在本已经百万协程的程序中，是无法承受的。所以后续我们对我们的rpc框架作了两次调整。</p><p>第二版的rpc框架，使用了连接池，通过长连接对内进行通信（复用的资源包括client和server的：编解码Buffer、Request/response），大大改善了性能。</p><p>但这种在一次request和response还是占用连接的，如果网络状况ok情况下，这不是问题，足够满足需要了，但试想一个room实例要与后面的数百个的register，coordinator，saver，center，keeper实例进行通信，需要建立大量的常驻连接，每个目标机几十个连接，也有数千个连接被占用。</p><p>非持续抖动时候（持续逗开多少无解），或者有延迟较高的请求时候，如果针对目标ip连接开少了，会有瞬时大量请求阻塞，连接无法得到充分利用。第三版增加了Pipeline操作，Pipeline会带来一些额外的开销，利用tcp的全双特性，以尽量少的连接完成对各个服务集群的rpc调用。</p><p>4.GC时间过长<br>Go的Gc仍旧在持续改善中，大量对象和buffer创建，仍旧会给gc带来很大负担，尤其一个占用了25G左右的程序。之前go team的大咖邮件也告知我们，未来会让使用协程的成本更低，理论上不需要在应用层做更多的策略来缓解gc. （目前最新版本，Go 的 GC 已经有了很大的改进）</p><p>改善方式，一种是多实例的拆分，如果公司没有端口限制，可以很快部署大量实例，减少gc时长，最直接方法。不过对于360来说，外网通常只能使用80和433。因此常规上只能开启两个实例。当然很多人给我建议能否使用SO_REUSEPORT，不过我们内核版本确实比较低，并没有实践过。另外能否模仿nginx，fork多个进程监控同样端口，至少我们目前没有这样做，主要对于我们目前进程管理上，还是独立的运行的，对外监听不同端口程序，还有配套的内部通信和管理端口，实例管理和升级上要做调整。</p><p>解决gc的另两个手段，是内存池和对象池,不过最好做仔细评估和测试，内存池、对象池使用，也需要对于代码可读性与整体效率进行权衡。<br>这种程序一定情况下会降低并行度，因为用池内资源一定要加互斥锁或者原子操作做CAS，通常原子操作实测要更快一些。CAS可以理解为可操作的更细行为粒度的锁（可以做更多CAS策略，放弃运行，防止忙等）。这种方式带来的问题是，程序的可读性会越来越像C语言，每次要malloc，各地方用完后要free，对于对象池free之前要reset，我曾经在应用层尝试做了一个分层次结构的“无锁队列”</p><p>上图左边的数组实际上是一个列表，这个列表按大小将内存分块，然后使用atomic操作进行CAS。但实际要看测试数据了，池技术可以明显减少临时对象和内存的申请和释放，gc时间会减少，但加锁带来的并行度的降低，是否能给一段时间内的整体吞吐量带来提升，要做测试和权衡…</p><p><img src="/content/images/2019/06/d5fb44dcbb01cb30d4820ece2db74fb.jpg" alt="d5fb44dcbb01cb30d4820ece2db74fb"></p><p>在我们消息系统，实际上后续去除了部分这种黑科技，试想在百万个协程里面做自旋操作申请复用的buffer和对象，开销会很大，尤其在协程对线程多对多模型情况下，更依赖于golang本身调度策略，除非我对池增加更多的策略处理，减少忙等，感觉是在把runtime做的事情，在应用层非常不优雅的实现。普遍使用开销理论就大于收益。<br>但对于rpc库或者codec库，任务池内部，这些开定量协程，集中处理数据的区域，可以尝试改造~<br>对于有些固定对象复用，比如固定的心跳包什么的，可以考虑使用全局一些对象，进行复用，针对应用层数据，具体设计对象池，在部分环节去复用，可能比这种无差别的设计一个通用池更能进行效果评估.</p><h2 id="架构迭代和迭代经验"><a href="#架构迭代和迭代经验" class="headerlink" title="架构迭代和迭代经验"></a>架构迭代和迭代经验</h2><p>下面介绍消息系统的架构迭代和一些迭代经验，由于之前在其他地方有过分享，后面的会给出相关链接，下面实际做个简单介绍，感兴趣可以去链接里面看</p><h3 id="架构迭代"><a href="#架构迭代" class="headerlink" title="架构迭代"></a>架构迭代</h3><p>根据业务和集群的拆分，能解决部分灰度部署上线测试，减少点对点通信和广播通信不同产品的相互影响，针对特定的功能做独立的优化.<br>消息系统架构和集群拆分，最基本的是拆分多实例，其次是按照业务类型对资源占用情况分类，按用户接入网络和对idc布点要求分类（目前没有条件，所有的产品都部署到全部idc）</p><p><img src="/content/images/2019/06/3bd38ef89d953b4a38ee82d3883845a.jpg" alt="3bd38ef89d953b4a38ee82d3883845a"></p><h3 id="简要介绍下我们的运维系统"><a href="#简要介绍下我们的运维系统" class="headerlink" title="简要介绍下我们的运维系统"></a>简要介绍下我们的运维系统</h3><p>我们利用Go原生的profiling工具，做了些可视化工作。可以对比多次上线出现的问题，通过压测程序复现部分瓶颈。定位cpu或者内存消耗的瓶颈。</p><p><img src="/content/images/2019/06/9d20e7fc447c0934ede155cd7a1ca5f.jpg" alt="9d20e7fc447c0934ede155cd7a1ca5f"></p><p><img src="/content/images/2019/06/d582183dc3ccbbc15ae6203fcb08762.jpg" alt="d582183dc3ccbbc15ae6203fcb08762"></p><p>另外，我们也可以对基础库代码做内嵌，将RPC库，Redis库，内存池命中数据等，做可视化的展示，统计它的QPS、网络带宽占用、idle与working，各种出错情况。然后再通过各种压测手段，观察优化性能点，上线前后是否有影响。如果一个系统不可评估就无法优化，利用压测评估就会发现一些潜在的问题。</p><p><img src="/content/images/2019/06/fd90a02582647647c1631b71a570164.jpg" alt="fd90a02582647647c1631b71a570164"></p><h3 id="系统的测试"><a href="#系统的测试" class="headerlink" title="系统的测试"></a>系统的测试</h3><p>go语言在并发测试上有独特优势。<br>在功能测试上，系统分成两套，一套是我们针对自己的功能，自己设计并测试，但这样难免会有问题。另一套是公司的自动化测试部门（python实现的<del>）根据我们的功能来测试。双保险</del><br><img src="/content/images/2019/06/c1e3523ce678de3c2a5e0d763b6927a.jpg" alt="c1e3523ce678de3c2a5e0d763b6927a"></p><p>对于压力测试，目前主要针对指定的服务器，选定线上空闲的服务器做长连接压测。然后结合可视化，分析压测过程中的系统状态。但压测早期用的比较多，但实现的统计报表功能和我理想有一定差距。理论上压测完后，可以根据协议版本，汇总每一次压测进程详细数据，业务的QPS数量、每秒钟建立连接数量，极限状态下的cpu和内存消耗，等每一个考核细节。现在只是能看一个大概趋势.对于细微的性能提升，没法评估，我们后续准备结合自己写的中央管理组件keeper，做这个数据收集和展示~</p><p>对于go语言适用的场景。之前在gopher china上，有过我个人的理解和概括：适用于重逻辑的io密集型应用.</p><p>我觉得最近出的golang开源产品都符合这种场景， go写网络并发程序给大家带来的便利，让大家把以往为了降低复杂度，拆解或者分层协作的组件，又组合在了一起。</p><p>比如go的web框架是在做负责并发的webserver和负责业务处理cgi程序，放在了webserver中。新近的一些go写的“智能”代理或者中间件，把很多原先分层控制或者不同功能但类似的子系统，以各种形式组装起来，reborn一个新的中间件或者新产品<del>包括之前百度放出的go-bfe也是把重逻辑和io密集型很好结合的产物</del>（群里有bfe的同学么，求更多资料）</p><p>个人感觉在国内互联网创业公司爆发环境下，大厂的复杂设备，很多将被golang重新打包成适用在一定量级下的“全能”工具箱~<br>以上就是今天的go分享~ 谢谢大家，欢迎提问~</p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>架构设计和概要（ 1小时的分享 文字总结）<br><a href="http://blog.qiniu.com/archives/3720" target="_blank" rel="noopener">http://blog.qiniu.com/archives/3720</a><br>关于基础库实现和性能参数对比表格：<br><a href="http://blog.golang.org/qihoo" target="_blank" rel="noopener">http://blog.golang.org/qihoo</a></p><h2 id="提问环节"><a href="#提问环节" class="headerlink" title="提问环节"></a>提问环节</h2><p>提问：对比kafaka这些消息系统 有什么优点？<br>回答：我们是消息推送系统 指的对客户端的高并发推送的 面对场景不一样</p><p>提问：hadoop生态圈的大数据，算重逻辑和IO密集型应用不？<br>回答：不算 Hadoop主要是计算</p><p>提问：这种推送的方式如何保证消息是有序到达的？<br>回答：如果要保证有序 需要重新设计协议 对消息编号 先存储 后拉取 可以按人存储也可以按订阅关系 目前花椒的im系统 属于这种场景 有机会大家感兴趣可以分享升级版本聊天架构</p><p>提问：golang适不适合写web应用<br>回答：这个可以单独一讲回答 我的建议新的应用 大并发的场景可以考虑 老项目酌情改写替换</p><p>提问：推送的消息会有多级转发吗？还是说客户端直接跟一个server保持长链接就完事了？<br>回答：当流量大到一定程度 可以多级转发 类似cdn架构 目前花椒直播的推送系统支持这种场景 为idc流量做分级转发 普通场景不需要</p><p>提问：极光推送跟这种推送的应用场景就是差不多吧？<br>回答：方案都类似 协议复杂度会不同 比如为了保证一致性采取编号 先存储后发送</p><p>提问：多级之间也是长链接吧<br>回答：多级别只是rpc调用 rpc通常keepalive</p><p>提问：推送系统目前支持什么协议呢？ mqtt？web socket？<br>回答：分传输层和协议层 传输层web socket 没问题 mqtt是一个具体交互协议了 不具备通用可比性</p><p>提问：推送系统里面有用到epoll吗？有没有开源地址？<br>回答：用的golang； go原生就是对epoll封装…目前不开源 安全公司理解下</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>直播学习</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>学习</tag>
        <tag>技术</tag>
        <tag>消息推送</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-1-Two Sum | 两数之和</title>
    <url>/2019/06/09/Leetcode-1-Two-Sum/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">two-sum</a></p><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = [<span class="number">2</span>]<span class="keyword">int</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="built_in">len</span>(nums) - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;  </span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                result[<span class="number">0</span>] = i</span><br><span class="line">                result[<span class="number">1</span>] = j</span><br><span class="line">                <span class="keyword">return</span> result[:]  <span class="comment">//返回结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; numsSize;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; numsSize;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] == target - nums[i])&#123;</span><br><span class="line">                a[<span class="number">0</span>] = i;</span><br><span class="line">                a[<span class="number">1</span>] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>LeetCode题解</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>端午安康以及我的高考</title>
    <url>/2019/06/08/duan-wu-and-my-gao-kao/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><p>昨天是中国的传统节日端午节，也是2019年高考的第一天。</p><p>她在端午节前一天下午来到了成都，我们相遇了，是的，相隔三千公里远外长达十个月的异地恋，终于宣告结束了。</p><p>端午节这一天，我们把房子整体收拾了一下，该扔的扔，该买的买，中午吃的冒菜，晚上买了鸭肉，虾尾，酸奶和啤酒庆祝。</p><p>今天是高考第一天，想起2014年我参加高考时，第一场语文作文后半段写的有些急，字都飞了起来；第二场数学填空选择做的很好，后面大题做的糟糕；第三场英语作文写的还可以；第四场理综一般般。后来回学校估分觉得应该能上个一本。</p><p>后来高考成绩公布，与我估分的偏差有些大，但还是能上个二本，然而我不甘心，思考着是复读还是去上大学。后来决定还是去上大学，因为我厌恶了高考那压抑的生活。</p><p>上了大学，遇见了各种各样的人，以及琳琅满目的社团和学生会。在每一次把酒言欢的夜晚，我独自坐在桌前，思考着我未来要走的路。当时的我很长一段时间都在自责与后悔中度过，放佛人生已成定数。</p><p>直到大二下学期，开始尝试打开窗户看外面的世界，开阔新视野的同时让我对自己的遭遇和学校看淡了些。大学毕业后，从事研发，专注于提升实力，前几天还意外被Go语言中文站长拉入了一个Go语言实践和布道者的群，里面的人大部分都是公司内的专家了，我有些激动，因为我从没有想过，我会离大佬们如此接近。未来的路，我想我会更坚定的走下去，因为这是一次他们对我的认可。</p><p>回忆了这么多，其实我想告诉正在准备高考的你，也是告诉那个曾经对未来惶恐不安的自己。人生就像一个长跑，也像一条正弦曲线，刚开始为0，然后你的事业会经历高峰和低谷，到高峰不要骄傲，到低谷不要气馁。</p><p>高考只是一道小山坡，未来的变数还有很多。</p><p>面带微笑，温暖前行。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>感悟</tag>
        <tag>端午</tag>
        <tag>高考</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu设置root账号登录</title>
    <url>/2019/06/04/ubuntu-set-up-root-login/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="这样做的原因"><a href="#这样做的原因" class="headerlink" title="这样做的原因"></a>这样做的原因</h2><p>如果你是用<code>root</code>权限去启动一个服务，而这个服务正在跑时，我又在根据它反馈的信息，对代码做调整，比如打日志，而修改完源代码后，你是无法保存文件的，原因是你用<code>root</code>执行它，而就应该用<code>root</code>权限去修改它，否则你的编辑是无效的，<code>push</code>上去的代码还是原来的。</p><h2 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h2><ul><li><p>使用<code>chown</code>命令修改文件或文件夹的拥有者，具体如下</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chown -R 用户名 文件夹名或文件名</span><br></pre></td></tr></table></figure></li><li><p>使用<code>chmod</code>命令直接开放代码所在目录的所有权限</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chmod -R 777 代码目录</span><br></pre></td></tr></table></figure></li><li><p>设置<code>root</code>账号登录。<br>不过一般<code>root</code>严格只用来管理服务器，只有少数人有该权限，所以在公司内不一定所有人都会有开启<code>root</code>的权限。<br>(在此感谢知识星球Go项目实战里的<code>Hy、per</code>提供的建议)</p></li></ul><h2 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h2><p>1，设置<code>root</code>用户密码</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure><p>（注意：以下步骤必须在<code>root</code>权限下操作）<br>2，修改<code>/root/.profile</code>文件<br>用<code>vim</code>打开该文件内容</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ~/.profile: executed by Bourne-compatible login shells.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$BASH</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [ -f ~/.bashrc ]; <span class="keyword">then</span></span><br><span class="line">    . ~/.bashrc</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">mesg n || <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>将最后一句<code>mesg n || true</code>修改为<code>tty -s&amp;&amp;mesg n || true</code></p><p>2，修改<code>/usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf</code>文件<br>在文件中添加以下内容</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#手动输入登录系统的用户名和密码</span></span><br><span class="line">greeter-show-manual-login=<span class="literal">true</span></span><br><span class="line"><span class="comment">#不允许guest登录</span></span><br><span class="line">all-guest=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>3，修改<code>/etc/pam.d/gdm-autologin</code>文件<br>注释掉</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#auth   required        pam_succeed_if.so user != root quiet_success</span></span><br></pre></td></tr></table></figure><p>4，修改<code>/etc/pam.d/gdm-password</code>文件<br>注释掉</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#auth   required        pam_succeed_if.so user != root quiet_success</span></span><br></pre></td></tr></table></figure><p>5，重新启动<code>ubuntu</code>系统，输入<code>root</code>名和密码登录即可。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>用<code>root</code>账户登录相当于给你重新创建一个新的桌面，所以个人建议是重装系统后就立马设置以<code>root</code>账户登录最佳。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Linux学习</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>root</tag>
        <tag>登录</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang并发中的FanIn范式学习</title>
    <url>/2019/06/02/learn-to-golang-fanin/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><p>在学习并发时，对<code>Fanin</code>和<code>Fanout</code>这两个范式印象深刻，特此记录一下学习心得。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>扇出（Fan-out）是一个术语，用于描述启动多个goroutines以处理来自管道的输入的过程，并且扇入（fan-in）是描述将多个结果组合到一个通道中的过程的术语。</p><p>画个图</p><p><img src="/2019/06/02/learn-to-golang-fanin/fanin_o.png" alt="fanin"></p><p><img src="/2019/06/02/learn-to-golang-fanin/fanout_o.png" alt="fanout"></p><p>这样做有什么好处呢，下面来看看源码。</p><h2 id="源码学习"><a href="#源码学习" class="headerlink" title="源码学习"></a>源码学习</h2><p>在<code>concurrent_map.go</code>文件中</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Iter returns an iterator which could be used in a for range loop.</span></span><br><span class="line"><span class="comment">// Deprecated: using IterBuffered() will get a better performence</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m ConcurrentMap)</span> <span class="title">Iter</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">Tuple</span></span> &#123;</span><br><span class="line">	chans := snapshot(m)</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Tuple)</span><br><span class="line">	<span class="keyword">go</span> fanIn(chans, ch)</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanIn</span><span class="params">(chans []<span class="keyword">chan</span> Tuple, out <span class="keyword">chan</span> Tuple)</span></span> &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(<span class="built_in">len</span>(chans))  <span class="comment">//总共要进入的管道数目</span></span><br><span class="line">	<span class="keyword">for</span> _, ch := <span class="keyword">range</span> chans &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span> Tuple)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> t := <span class="keyword">range</span> ch &#123;  <span class="comment">//取出每一个管道内的数据</span></span><br><span class="line">				out &lt;- t  <span class="comment">//将数据发送给管道接收者out</span></span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()  <span class="comment">//每取完一次管道内的数据，管道数目减1</span></span><br><span class="line">		&#125;(ch)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="built_in">close</span>(out)  <span class="comment">//管道内的数据已经取完，关闭管道接收者out</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画图演示下过程<br><img src="/2019/06/02/learn-to-golang-fanin/chan_o.png" alt="chan"></p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul><li><code>sync.WaitGroup</code><br>sync.WaitGroup只有3个方法，Add()，Done()，Wait()。其中Done()是Add(-1)的别名。简单的来说，使用Add()添加计数，Done()减掉一个计数，计数不为0, 阻塞Wait()的运行。<br>因此当计数为0时，也就是要进入的管道数都没有的时候，关闭管道。</li></ul><h2 id="FanIn范式的用途"><a href="#FanIn范式的用途" class="headerlink" title="FanIn范式的用途"></a>FanIn范式的用途</h2><p>在此引用我看到的一段话</p><blockquote><p>管道的一个有趣属性是它的各个阶段相互独立，方便组合。你可以多次重复使用管道的各个阶段。因此，在多个goroutine上重用管道的单个阶段实现并行化，将有助于提高管道的性能。<br>事实上，这种模式被称为扇入扇出。<br>那么在什么情况下适用于这种模式呢？如果出现以下两种情况，你就可以考虑这么干了：<br>不依赖模块之前的计算结果。<br>运行需要很长时间。</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.kancloud.cn/mutouzhang/go/596844" target="_blank" rel="noopener">扇入扇出_Concurrency in Go 中文笔记</a></li><li><a href="https://austburn.me/blog/a-better-fan-in-fan-out-example.html" target="_blank" rel="noopener">Go: A Better Fan-out, Fan-in Example</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>解决方案</tag>
        <tag>并发</tag>
        <tag>范式</tag>
        <tag>FanIn</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次项目演示前赶deadline的经历</title>
    <url>/2019/05/31/a-project-deadline-note/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>给新疆广电做的流媒体收录系统，原定于六月二十日研发完毕，无奈要提前演示，定到了五月底。所以我负责的地方需要抓紧进度。<br>同时下周一要做芒果TV的演示，我这里负责的模块网络端没有跑通。</p><h2 id="紧张"><a href="#紧张" class="headerlink" title="紧张"></a>紧张</h2><p>由于我之前在根据芒果TV的需求修改我负责的流媒体服务，改动较大（确切地说我已经改晕了），已经把最原始的功能都已经无法复现了，导致新疆广电的需求也无法完成。我在想，我该怎么办？</p><h2 id="转机"><a href="#转机" class="headerlink" title="转机"></a>转机</h2><p>在我即将感到绝望的一刻，产品负责人把部门的两位大佬打电话叫来，他看了下我的代码，改删的删，改增的增，在本地跑通后，放到测试环境上跑了一下，看了下日志，修改了几处异常，测试环境就跑通了，新疆广电的演示算是完成了。<br>而芒果TV的需求，涉及把业务流程搞懂再添加业务判断逻辑，和数据的封装和请求的发送，而我的问题就在于不知道这段逻辑代码放在哪里。不过还好最后有老哥带我一步步跟代码，最终把代码放到了正确的位置，测试也跑通了。</p><h2 id="经验教训和感受"><a href="#经验教训和感受" class="headerlink" title="经验教训和感受"></a>经验教训和感受</h2><ul><li>用<code>Go</code>写一个服务，应当首先用<code>curl</code>命令在本地跑通，接着写一个<code>Test</code>测试函数针对核心逻辑就行测试和修改，如果需要依赖其他服务，要么把需要的服务也部署起来，或者用<code>Nginx</code>去模拟<code>Mock</code>它（这个我还不会）。</li><li>越紧急的事情，一定要放宽心，深呼吸两次，不然很容易犯低级错误，比如该打日志的地方没有打，或者数据库查询语句写错，或者是变量名的格式没有写对，或者是<code>curl</code>命令请求时忘记在每一个出现<code>&quot;</code>加<code>\</code>（<code>curl</code>命令请求发<code>json</code>时的格式）。而这些细微的出错，最终都将导致自己，或者陪同的其他研发人员，甚至测试人员白忙活一阵。</li><li>一定要对服务器业务逻辑熟悉，一定要经常打断点去跟代码。</li><li>遇到<code>Panic</code>空指针报错，一定是一些值没有初始化造成的，而我是犯了一个低级错误：没有<code>error</code>，自己在日志中打了个<code>error.Error()</code>导致的，为此我付出了代价，全局搜索了<code>error.Error()</code>字段，把有问题的语句全部改了。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是错误的，一定要注意，直接会抛异常</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(xxx) == <span class="number">0</span> &#123;</span><br><span class="line">    Log.Error(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>遇到想不通的问题，多在存在疑惑的代码片段周围打满日志。</li><li>遇到的每一个<code>bug</code>，详细记录错误发生的原因，以及找到错误解决的方式，还有解决过程，记录完后要及时回看。</li><li>熟练使用<code>git</code>指令，不只满足于<code>add commit push</code>三步，还应该涉及合并，<code>cherry-pick</code>等比较危险的指令，这有益于减少管理代码和发版时瞎忙活的概率。</li><li>相比于研发，测试运维这些人在体力上都比较辛苦，所以建议能自己解决的就少给他们增添麻烦。也许是我看到他们一个电脑开着十几台虚拟机，远程连接里套着远程连接再套着远程连接，周围做前后端和产品都围着他时，才有的感触吧。</li></ul><p>问题警报解除后，同事问我，有没有是在给家乡做贡献的感觉。我说，有那么一点。但我心里更多的是对他们的感激与深深的惭愧，交代给我负责的项目，没有完成，同时也暴露了我的诸多开发上的问题。这些坑，我需要尽快填上。</p><p>希望项目演示一切顺利！</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>成长</tag>
        <tag>演示</tag>
        <tag>感悟</tag>
        <tag>收获</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang中的CPU占满100%及解决方案</title>
    <url>/2019/05/26/golang-cpu-100-solution/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><p>有一个流媒体适配服务，出现了<code>CPU</code>开销很大的问题，一个服务把<code>CPU</code>资源占满了，导致其他服务无法正常工作。<br>下面来详细记录发现<code>bug</code>和解决的流程。</p><h1 id="发现CPU开销很大"><a href="#发现CPU开销很大" class="headerlink" title="发现CPU开销很大"></a>发现CPU开销很大</h1><p>扫描发现，是垃圾回收导致 <code>CPU</code> 使用上升 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time: Mar 22, 2019 at 5:52pm (CST)</span><br><span class="line">Duration: 1mins, Total samples = 1.43mins (142.57%)</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof) tree </span><br><span class="line">Showing nodes accounting for 83.13s, 97.11% of 85.60s total</span><br><span class="line">Dropped 256 nodes (cum &lt;= 0.43s)</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">      flat  flat%   sum%        cum   cum%   calls calls% + context 	 	 </span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">                                            71.36s 99.86% |   runtime.gcDrain</span><br><span class="line">                                             0.10s  0.14% |   runtime.systemstack</span><br><span class="line">    48.56s 56.73% 56.73%     71.46s 83.48%                | runtime.scanobject</span><br><span class="line">                                            11.86s 16.60% |   runtime.heapBitsForObject</span><br><span class="line">                                            11.04s 15.45% |   runtime.greyobject</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">                                            11.86s 99.92% |   runtime.scanobject</span><br><span class="line">    11.87s 13.87% 70.60%     11.87s 13.87%                | runtime.heapBitsForObject</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">                                            11.04s   100% |   runtime.scanobject</span><br><span class="line">    11.02s 12.87% 83.47%     11.04s 12.90%                | runtime.greyobject</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">                                             6.53s 95.05% |   runtime.gosweepone.func1</span><br><span class="line">                                             0.34s  4.95% |   runtime.(*mheap).alloc</span><br><span class="line">     4.34s  5.07% 88.54%      6.87s  8.03%                | runtime.sweepone</span><br><span class="line">                                             2.53s 36.83% |   runtime.(*mspan).sweep</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">                                            74.42s   100% |   runtime.gcBgMarkWorker.func2</span><br><span class="line">     1.97s  2.30% 90.84%     74.42s 86.94%                | runtime.gcDrain</span><br><span class="line">                                            71.36s 95.89% |   runtime.scanobject</span><br><span class="line">                                             0.52s   0.7% |   runtime.pollWork</span><br><span class="line">----------------------------------------------------------+-------------</span><br></pre></td></tr></table></figure><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>之后考虑使用 <code>buffer pool</code>,</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 这里不再分配新的内存，而是从 buffer pool 里面 GET </span></span><br><span class="line">databuf = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">100000</span>)</span><br></pre></td></tr></table></figure><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>参考<a href="https://github.com/libp2p/go-buffer-pool" target="_blank" rel="noopener">go buffer pool</a></p><ul><li><p>先创建一个<code>buffer pool</code></p></li><li><p>在<code>Get</code>它</p></li><li><p>用完再<code>Put</code>回去</p></li><li><p>注意，最好在<code>Get</code>和<code>Put</code>时加锁。</p></li></ul><h1 id="是什么原因导致了CPU开销很大（重点）"><a href="#是什么原因导致了CPU开销很大（重点）" class="headerlink" title="是什么原因导致了CPU开销很大（重点）"></a>是什么原因导致了CPU开销很大（重点）</h1><p>当我们新建了一个有长度变量时，例如100<code>byte</code>的数组，那么它在操作系统内存中是这样展现的</p><p><img src="/2019/05/26/golang-cpu-100-solution/memory.png" alt></p><p>因此，当我们新建一个变量时，操作系统会在自己的运行内存里开辟一块内存给这个变量存数据用。当我们不需要这个数据时，或者说要删除这个变量时，<code>Golang</code>会执行垃圾回收机制。</p><p>然而当<code>Golang</code>在执行垃圾回收时，操作系统会不断对这些有或者没有被引用的变量进行扫描，这中间涉及操作系统的算法，我们不用深究，但是，在执行这种算法时，会占用<code>CPU</code>的资源，如果新开辟的变量和内存过多，就会导致系统不停的检查是否有不需要引用的变量了，从而造成占用<code>CPU</code>资源过多。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>创建一个<code>buffer pool</code></p><p>创建一个大的<code>buffer pool</code>，你需要内存时，向<code>buffer pool</code>获取一下<code>Get</code>，用完不需要时再还回去<code>Put</code>。</p><p><img src="/2019/05/26/golang-cpu-100-solution/bufferpool.png" alt></p><p>这样做的好处是，操作系统每次检查内存时，都只有一个<code>buffer pool</code>在引用，不增不减，于是也就减少<code>CPU</code>资源的消耗了。</p><h2 id="打个比方"><a href="#打个比方" class="headerlink" title="打个比方"></a>打个比方</h2><p>比如说操作系统就是一个土豪，借东西再换回来不收利息。它有一个很大的内存，周围许多人都想找它去借(新声明的变量并初始化)，刚开始借的人只有十几个，后面有上万个，于是它要每天记录谁借了多少内存出去，谁还没有归还，归还的直接从记录上把名字划掉(垃圾回收)。后来操作系统烦了，于是就建了一个很大的内存池，够所有人分批次借，只要借完及时归还就行，而它每次去看这个内存池有没有变小即可，省了不少精力。</p><p>而这个内存池就是<code>go buffer pool</code>的作用。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>建议给<code>Get</code>和<code>Put</code>加锁，防止多个协程同时借阅，造成竞争冒险。<br>这个<code>CPU</code>占满问题涉及<code>Golang</code>的垃圾回收机制，这块是要点，一定要搞明白。</p><h1 id="参考文章和资源"><a href="#参考文章和资源" class="headerlink" title="参考文章和资源"></a>参考文章和资源</h1><ul><li><a href="https://github.com/libp2p/go-buffer-pool" target="_blank" rel="noopener">go buffer pool</a></li><li><a href="http://legendtkl.com/2017/04/28/golang-gc/" target="_blank" rel="noopener">Golang 垃圾回收剖析</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>解决问题记录</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>解决方案</tag>
        <tag>CPU占满</tag>
      </tags>
  </entry>
  <entry>
    <title>吊车尾</title>
    <url>/2019/05/23/in-the-end/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><p>这一周感觉过得好慢，也许是我太压抑了的缘故吧。</p><p>周一，让我做一个新需求，周二，又增加了一个新需求，让我抓紧时间，五月底要上线，然而我周二下午发现这个需求有问题，周三又讨论了一上午定下来要修改的部分。然而就在今天，又说这些不重要了，先把另外一个新需求做了。</p><p>好吧，我认了，毕竟是拿人钱财，替人干活。你说干嘛我干嘛。</p><p>然而，新需求是在老项目的一个逻辑上做的，而我对这块业务不熟悉，于是请教，接着受打击，这已经成为我工作的家常便饭了。</p><p>晚上回家，突然想看火影，看李使用八门遁甲开了五门虐我爱罗最终获得凯老师的认可，看鸣人中忍考试最终用实力证明给宁次看我不是吊车尾，看迈特凯开了死门虐拥有六道能力的斑。</p><p>他们都在坚持不懈的贯彻自己的忍道。</p><p>那我在编程上的忍道又是什么呢？</p><p>我喜欢钻研新东西，喜欢用自己的方式去创新，然而我现在经验不足，只能通过大佬的源代码窥探其中工程设计的奥妙。</p><p>我能力不足，但又不肯认输；我进步缓慢，原来，突然发现自己真的是一无是处，放佛成了部门的吊车尾。</p><p>今天我不知道在内心深处有多少次想过放弃，但我实在不甘心，不跨过这个坎，我怎么成长？！</p><p>只能在深夜再给自己打气，让自己挺住，毕竟，在那些大佬看来，这真的是一件微不足道的挫折罢了。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>挫折</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang中的内存泄露及解决方案</title>
    <url>/2019/05/14/Golang-memory-leak-solution/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><p>工作中记一次碰到内存泄漏的解决过程。</p><h1 id="发现内存泄露"><a href="#发现内存泄露" class="headerlink" title="发现内存泄露"></a>发现内存泄露</h1><p>写的一个定时删除文件的服务，结果无缘无故被系统杀死了。</p><p>于是我设置了参数，每隔30s启动一次。并用<code>dmesg</code>命令查看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1700172.849656] Out of memory: Kill process 1195 (SliceDyson) score 730 or sacrifice child</span><br><span class="line">[1700172.849665] Killed process 1195 (SliceDyson) total-vm:13314968kB, anon-rss:8693980kB, file-rss:116kB</span><br></pre></td></tr></table></figure><p>确定是内存泄露造成的。</p><h1 id="使用pprof分析造成内存泄露的原因"><a href="#使用pprof分析造成内存泄露的原因" class="headerlink" title="使用pprof分析造成内存泄露的原因"></a>使用pprof分析造成内存泄露的原因</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><p><a href="https://golang.org/pkg/runtime/pprof/" target="_blank" rel="noopener">golang pprof 的文档</a> 里面给了一个例子，如何把 <code>pprof</code> 信息输出到文件里面</p></li><li><p><a href="https://www.reddit.com/r/golang/comments/6kv625/my_app_has_memory_leaks_how_to_find_them/" target="_blank" rel="noopener">Reddit 上这篇文章</a>，提到了如何通过对比两次 <code>heap</code> 的结构，来判断到底哪些内存没有释放：</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">One thing you can do is to compare 2 heap pprofs. You can do it like this:</span><br><span class="line"></span><br><span class="line">    Extract a heap profile heap0.pprof</span><br><span class="line"></span><br><span class="line">    Add some load to the application</span><br><span class="line"></span><br><span class="line">    Extract another heap profile heap1.pprof</span><br><span class="line"></span><br><span class="line">    Compare them with go tool pprof -base heap0.pprof &lt;bin&gt; heap1.pprof</span><br><span class="line"></span><br><span class="line">This way you can see exactly what is increasing over time.</span><br></pre></td></tr></table></figure><ul><li><a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="noopener">https://blog.golang.org/profiling-go-programs</a></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>分析生成的<code>.pprof</code>文件</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go tool pprof 120.pprof </span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: Mar 6, 2019 at 9:27pm (CST)</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting for 603.20MB, 99.67% of 605.20MB total</span><br><span class="line">Dropped 1 node (cum &lt;= 3.03MB)</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">  603.20MB 99.67% 99.67%   605.20MB   100%  main.main</span><br><span class="line">         0     0% 99.67%   605.20MB   100%  runtime.main</span><br><span class="line">(pprof) ^C</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ go tool pprof 240.pprof </span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: Mar 6, 2019 at 11:42pm (CST)</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting for 2.81GB, 99.86% of 2.81GB total</span><br><span class="line">Dropped 6 nodes (cum &lt;= 0.01GB)</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    2.81GB 99.86% 99.86%     2.81GB   100%  main.main</span><br><span class="line">         0     0% 99.86%     2.81GB   100%  runtime.main</span><br></pre></td></tr></table></figure><ul><li>分析各个函数的占比情况</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">File: SliceDyson</span><br><span class="line">Type: inuse_objects</span><br><span class="line">Time: Mar 7, 2019 at 2:52pm (CST)</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof) web</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting for 6810, 100% of 6810 total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">      6554 96.24% 96.24%       6554 96.24%  main.GetXMLFiles</span><br><span class="line">       256  3.76%   100%        256  3.76%  vendor/golang_org/x/net/http2/hpack.addDecoderNode</span><br><span class="line">         0     0%   100%        256  3.76%  main.init</span><br><span class="line">         0     0%   100%       6554 96.24%  main.main</span><br><span class="line">         0     0%   100%        256  3.76%  net/http.init</span><br><span class="line">         0     0%   100%       6810   100%  runtime.main</span><br><span class="line">         0     0%   100%        256  3.76%  vendor/golang_org/x/net/http2/hpack.init</span><br><span class="line">         0     0%   100%        256  3.76%  vendor/golang_org/x/net/http2/hpack.init.0</span><br></pre></td></tr></table></figure><p>最后定位到造成内存泄露的原因，是<code>GetXMLFiles</code>函数造成的。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlFilesPath []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> LoopGetXmlFilesPath []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> AllTasks []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> tasks []*Task</span><br><span class="line"><span class="keyword">for</span> _, RootPath := <span class="keyword">range</span> ParseStorageINI(StorageINIPath) &#123;</span><br><span class="line">	xmlFilesPath = GetXMLFiles(RootPath)</span><br><span class="line">	<span class="keyword">for</span> _, xmlFilesPath_str := <span class="keyword">range</span> xmlFilesPath &#123;</span><br><span class="line">		LoopGetXmlFilesPath = <span class="built_in">append</span>(LoopGetXmlFilesPath, xmlFilesPath_str)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>把<code>xmlFilesPath</code>放到<code>for range</code>循环里面声明初始化即可</p><h1 id="是什么原因会导致内存泄露"><a href="#是什么原因会导致内存泄露" class="headerlink" title="是什么原因会导致内存泄露"></a>是什么原因会导致内存泄露</h1><h1 id="什么时候需要垃圾回收-GC"><a href="#什么时候需要垃圾回收-GC" class="headerlink" title="什么时候需要垃圾回收(GC)"></a>什么时候需要垃圾回收(GC)</h1><h1 id="参考文章和资源"><a href="#参考文章和资源" class="headerlink" title="参考文章和资源"></a>参考文章和资源</h1><ul><li><a href="https://stackoverflow.com/questions/48618201/how-to-release-memory-allocated-by-a-slice" target="_blank" rel="noopener">how-to-release-memory-allocated-by-a-slice</a></li><li><a href="https://stackoverflow.com/questions/37382600/cannot-free-memory-once-occupied-by-bytes-buffer" target="_blank" rel="noopener">cannot-free-memory-once-occupied-by-bytes-buffer</a></li><li><a href="http://legendtkl.com/2017/04/28/golang-gc/" target="_blank" rel="noopener">Golang垃圾回收剖析</a></li><li><a href="https://golang.org/pkg/runtime/pprof/" target="_blank" rel="noopener">pprof</a></li><li><a href="https://www.reddit.com/r/golang/comments/6kv625/my_app_has_memory_leaks_how_to_find_them/" target="_blank" rel="noopener">my_app_has_memory_leaks_how_to_find_them</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>解决问题记录</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>解决方案</tag>
        <tag>内存泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang踩坑集中整理</title>
    <url>/2019/05/14/golang-hit-pit-finish/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h1 id="append-x-1-与x-append-x-1-的区别"><a href="#append-x-1-与x-append-x-1-的区别" class="headerlink" title="append(x,1)与x = append(x,1)的区别"></a>append(x,1)与x = append(x,1)的区别</h1><p>今天有同事问我</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x,<span class="number">1</span>)</span><br><span class="line"><span class="comment">//append(x,1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//两者有什么区别</span></span><br></pre></td></tr></table></figure><p>我瞬间懵了，这不很明显吗？</p><p><code>x = append(x,1)</code>是在<code>x</code>的原先基础上增加了一个元素，所以<code>x</code>中元素为5，而<code>append(x,1)</code>没有赋返回值，所以会报错!</p><p>同事说，这不是重点，我是问你<code>append(x,1)</code>后<code>x</code>中的元素有几个。</p><p>于是，我想了下，同时也请教了他人，最终得出答案，<code>x</code>为4。</p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>append(x,1)之后相当于扩容，所以`append 的结果，底层会分配一个新的数组。</p><p>如果我不接收返回值，相当于还是append前，长度没变。<br>那么为什么要这样呢</p><p>此处引用polaris的解释</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">append 是 内置函数，必须要接收它的值。</span><br><span class="line">由此看来 go安全性做的确实好</span><br><span class="line">避免出现失误，没有将错误的append的结果保存</span><br></pre></td></tr></table></figure><p>因此</p><p>在<code>x := make([]int,4,4)</code>后，执行<code>x = append(x,1)</code>，长度为5；执行<code>append(x,1)</code>，长度为4.</p><p>注：可参考GO圣经中的Slice章节下的append用法介绍。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>再见乌鲁木齐，再见新疆</title>
    <url>/2019/05/11/goodbye-urumqi-goodbye-xinjiang/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><p><a href="./plane"></a></p><p>(本文有感于五一，完稿于母亲节)</p><p>5月6号晚，在乌鲁木齐的地窝堡国际机场，坐在飞机上，广播里说着飞机即将起飞，请关闭手机或调整为飞行模式，我知道，我又要和这座城市告别了。</p><p>父亲开车送我去机场的路上，在穿过蜘蛛山隧道时，落日的余晖洒向了这座城市，我看到了这里林立的高楼，和四通八达的街道，以及刚刚亮起来的路灯。</p><p>是的，这是我生活了二十二年的城市。</p><p>它完整的记录了我从孩童成长为工作者的心路历程。</p><p>就让我再穿越回过去，回忆这些转瞬即逝又弥足珍贵的记忆。</p><h1 id="与杨搭城堡"><a href="#与杨搭城堡" class="headerlink" title="与杨搭城堡"></a>与杨搭城堡</h1><p>时间：小学四年级。</p><p>地点：小巷子。</p><p>人物：童年玩伴杨</p><p>结束了一天在学校的学习，作业太少了，提前做完了，就算不会第二天去早点抄，玩耍才是最重要的！</p><p>我约了杨和我一起去沙堆上搭城堡（其实现在看来像是在打洞），我和他挖的正兴奋时，父亲怒气冲冲的过来把我像提小鸡一样提起来，告诫我不要玩沙子，把手弄脏了。</p><p>我给杨递了个眼色，于是给父亲保证再不会碰这个了。</p><p>等父亲走后，我又跑过去和他动工了。忙活到了晚上十点多，终于把城堡搭完了，筷子用断了好几根，脸也脏了，不过还是很开心呢。</p><p>虽然这些艺术品在大人看来一文不值，明天估计就要被毁了，但我知道那时的我看到自己辛苦搭建出来的东西后，充满了成就感。</p><h1 id="新华书店窃读记"><a href="#新华书店窃读记" class="headerlink" title="新华书店窃读记"></a>新华书店窃读记</h1><p>时间：小学五年级</p><p>地点：乌鲁木齐市南门新华书店</p><p>人物：童年玩伴杨</p><p>因为非常喜欢看冒险小虎队系列的侦探书，无奈杨用零花钱买的几本书已经被我看了两遍了，于是我和他计划，周末去书店看。</p><p>于是和父母说了一声后，周末吃过早饭和杨坐着61路公交车去书店，心里默念：今天我要看十本书！</p><p>抵达书店，上二楼后厅，拿书，找空地坐下来，动作一气呵成。</p><p>那一天，我记得是我生命中最充实最开心的时光，因为我把我的意识完全沉浸在侦探的世界里。</p><h1 id="街边小巷你追我打的欢快"><a href="#街边小巷你追我打的欢快" class="headerlink" title="街边小巷你追我打的欢快"></a>街边小巷你追我打的欢快</h1><p>时间：小学六年级</p><p>地点：街头小巷</p><p>人物：一群小屁孩</p><p>作业写完，叫上好朋友，一起去玩捉迷藏，真假孙悟空…反正就是各种跑。</p><p>有时候玩得过头了，十几个小娃娃追着我，我就东躲西藏，他们说抓住我有重赏。</p><p>就这样，间接锻炼了我奔跑的耐力和随机应变的决断力，也收获了一下午的喜悦。</p><h1 id="插卡游戏机街头霸王车轮战"><a href="#插卡游戏机街头霸王车轮战" class="headerlink" title="插卡游戏机街头霸王车轮战"></a>插卡游戏机街头霸王车轮战</h1><p>时间：初一、二年级</p><p>地点：韩家蛋糕盒厂</p><p>人物：韩，杨等游戏高手</p><p>初一认识了韩，因为他家有插卡游戏机，所以我经常跑他家里打游戏。</p><p>还记得当时我最爱玩街头霸王，最喜欢用一个黄头发发冲击波的格斗家和会放电的野兽。为了发出绝招，我把游戏手柄的方向键搓掉了，又把自己的大拇指搓肿了。经常玩到父母上门来找才肯结束。</p><p>除了街头霸王，还有四代魂斗罗，超级赛亚人等。</p><h1 id="地下游戏厅称霸记"><a href="#地下游戏厅称霸记" class="headerlink" title="地下游戏厅称霸记"></a>地下游戏厅称霸记</h1><p>时间：初一</p><p>地点：家对面的地下游戏厅</p><p>人物：游戏爱好者</p><p>家对面开了家游戏厅，里面有台球桌，还有两台PS2，在一个小隔间里还有四五台电脑，于是这里成了我放学和周末的天堂。</p><p>我充分发挥了自己善于钻研和学习的天分，不到两个月，没花一分钱，成了这家游戏厅里的游戏专家，没事给打三国无双的玩家指点一二，或者去和其他人联机CS1.6场场爆头。</p><p>后来因为白玩的次数太多了，被游戏厅老板拉入了黑名单。</p><h1 id="懵懂无知的好感"><a href="#懵懂无知的好感" class="headerlink" title="懵懂无知的好感"></a>懵懂无知的好感</h1><p>时间：初二</p><p>地点：某初中</p><p>人物：a gril</p><p>第一次对一个女孩产生好感应该就是这个时候吧。</p><p>想想也真是奇葩，产生好感那就表现的好一点就是，然而偏偏把自己最坏的一面表现了出来。</p><p>那种抑制不住的脸红和怦怦的心跳声，大概就是初恋的滋味吧，也是我再也回不去的青春。</p><p>虽然我已经记不清她的模样，但也是因为她的出现和离开，让我学会如何去用心喜欢上一个人。</p><h1 id="与赵的原始书信"><a href="#与赵的原始书信" class="headerlink" title="与赵的原始书信"></a>与赵的原始书信</h1><p>时间：初三</p><p>地点：无</p><p>人物：学习的榜样老赵</p><p>面临中考，每当这时候会与相互打气，还记得那时候没有手机，不能登QQ，于是就以最原始的方式保持通信—写信。</p><p>将信写好，装入那种放自动笔芯的圆筒内，然后交给顺路的人帮忙捎带给他，想想也是够机智的。</p><p>这种方式一直持续到高考结束，然后就戛然而止。</p><h1 id="影响我一生的良师益友"><a href="#影响我一生的良师益友" class="headerlink" title="影响我一生的良师益友"></a>影响我一生的良师益友</h1><p>时间：高三</p><p>地点：高中</p><p>人物：张，沈，杨，赵</p><p>高三，多么神圣的阶段，也许你的一分，就能干掉上千人，这是当时最流行的宣传语。</p><p>然而我又何尝不想拼搏努力呢。</p><p>只是，当我把自己想象成一台做题机器时，总会有人帮我找回本来的模样。</p><p>我想起，每当吃午饭的时候，我都会给凡儿和魁拔，讲述我自编的喜剧小说《高考命题组专家的故事》；我会在补习班内和杨还有赵吐槽这该死的高考题；我会咨询张老师是不是我太笨了为什么我一天睡五个小时，做题十个小时还是年级还不进步呢…</p><p>多年后当我再来看这些问题时，会觉得当时的我多么幼稚。</p><h1 id="大学毕业之后才懂"><a href="#大学毕业之后才懂" class="headerlink" title="大学毕业之后才懂"></a>大学毕业之后才懂</h1><ul><li>原来挣钱真的不容易</li><li>保持终生学习的观念，这是一个长跑</li><li>有空常回家看看</li><li>学习靠主动，工作靠自觉</li><li>有些人走着走着就会散了，你可以沉默一时，但不能一直活在这个阴影里</li><li>生命第一，生活第二，工作第三</li></ul><h1 id="再见乌鲁木齐，再见新疆"><a href="#再见乌鲁木齐，再见新疆" class="headerlink" title="再见乌鲁木齐，再见新疆"></a>再见乌鲁木齐，再见新疆</h1><p>这里有我忘不掉的人和景。</p><p>我想起和家人一起去阜康天池坐船看瀑布；一起去吐鲁番欣赏交河故城的荒凉，维吾尔族村寨，坎儿井的避暑好去处，火焰山的金箍棒温度计，葡萄沟的葡萄；一起去天山野生动物园里看狮子老虎大象长颈鹿，去植物园看各种花花草草，去游乐场玩碰碰车、旋转椅子和疯狂老鼠；一起自驾游去昌吉的杜氏旅游村；一起去石人沟骑马，我在湖边行走时右脚踏入沼泽地硬是左腿发力挣脱了出来；</p><p>我感谢家人给予我资金和精神上的鼓励，在我大二暑假时同意让我一个人走出去看看，这一走就是一个多月，走了十三座城市，路上遇到了许多社会上各个阶级的人，使我长了见识；感谢他们一如既往的支持我继续读研和深造，而不是逼着我赶紧就业，虽然最后没有成功考上。</p><p>我会想起和大学同学一起骑行一百二十公里去阿克苏的惊险刺激；和朋友去库车旅行，在沙漠公路上遭遇沙尘暴，方圆能见度不足三米的时候一辆越野车及时出现化解了危机；百里徒步去沙漠路上的艰辛，以及看到屹立不倒的胡杨，放佛沙漠中守护的卫士；</p><p>我会想起和女友夏天去的博斯腾湖，夜晚欣赏那静谧的孔雀河；冬天在公园里散步，差点把自己的耳朵冻掉；</p><p>我会想起和学校同学夏天扔水球，泼水冲凉，冬天打雪仗的开心；和慎在学校内散步，讨论物理化学题；和涛咨询人生困惑；和杨推着购物车在七一酱园，好家乡，友好里面乱逛；和好朋友去火焰山吃自助火锅烧烤，去八音和里唱歌，去人民电影院和和平都会踩点找最合适的场次；高三毕业去南山牧场吃烧烤，骑马。</p><p>仔细梳理，原来我留在这的回忆有这么多。</p><p>五一回家，看着周围熟悉的街道已经拆的差不多了，想想自己以后也是要一年才回一次家，不知明年回来时，这些记忆是否还能记住一半？</p><p>从我决定离开这座城市到一座新城市发展的时候，我知道我以后需要独自面临许多未知的阻碍。我要随机应变适应新的环境。</p><ul><li>我要更加坚强，来应对突如其来的质疑和压力；</li><li>我要更加机警，防止被套路；</li><li>我要更加勇敢，接受新挑战；</li><li>我要更加感恩，记住在这样一个陌生的城市里还愿意帮助我的人；</li><li>我要更加珍惜学习的机会；</li><li>我要学会接纳自己的不足。</li></ul><p>今天，我不认为一年前我放弃校招选择社招离开自己熟悉的环境而感到遗憾，并且我从没有如此神清气爽过，我放佛看到了重生，因为从此以后，我将不受束缚。</p><p><img src="/2019/05/11/goodbye-urumqi-goodbye-xinjiang/bohu" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>乌鲁木齐</tag>
        <tag>新疆</tag>
        <tag>告别</tag>
      </tags>
  </entry>
  <entry>
    <title>我们这一代人面临的知识焦虑</title>
    <url>/2019/04/28/we-face-knowledge-anxiety/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h1 id="为什么要写这样一篇文章"><a href="#为什么要写这样一篇文章" class="headerlink" title="为什么要写这样一篇文章"></a>为什么要写这样一篇文章</h1><p>零点整，和远在三千公里外的女友互道晚安后，继续刷我在极客时间上订阅的关于操作系统的专栏，无意间看到微信群里有人谈到焦虑，我想是时候写一篇文章，来聆听下自己的心声，因为不知道下次又等到什么时候去了。</p><h1 id="我的知识焦虑"><a href="#我的知识焦虑" class="headerlink" title="我的知识焦虑"></a>我的知识焦虑</h1><p>我最开始感到知识焦虑，是在我上大三的时候，当时下载了一个得到app，看到我尊敬的老师在里面建了专栏发文章，于是我咬牙拿出我半个月的伙食费，订阅了为期一年的专栏，于是我坚持早起打开app刷一篇文章，觉得不错还在下面进行留言。</p><p>讲真，我到现在都没有记住里面的内容，只记得当时讲的各种人生经验、理论、方法都很高大上，让我这小白大开眼界。</p><p>后来知识付费不知不觉就流行了起来，从得到app，到知识星球和小专栏，再到极客时间，于是美其名曰充分利用碎片化时间进行学习。</p><h1 id="为什么要知识付费"><a href="#为什么要知识付费" class="headerlink" title="为什么要知识付费"></a>为什么要知识付费</h1><p>说说我为什么会对一些专栏进行付费的原因</p><ul><li>得到某一领域技能的提点，从而提升在某领域的核心竞争力(主因)</li><li>与大佬近距离接触，沟通，不是常说“近朱者赤，近墨者黑”嘛</li><li>拓宽人脉，结识优秀的人</li><li>督促自己主动学习(既然花钱了，肯定想要回本啊)</li></ul><h1 id="那为什么会有知识焦虑呢"><a href="#那为什么会有知识焦虑呢" class="headerlink" title="那为什么会有知识焦虑呢"></a>那为什么会有知识焦虑呢</h1><p>在这里让我想起了木心的一首诗</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">记得早先少年时 大家诚诚恳恳 说一句是一句</span><br><span class="line"></span><br><span class="line">清早上火车站 长街黑暗无行人 卖豆浆的小店冒着热气</span><br><span class="line"></span><br><span class="line">从前的日色变得慢 车、马、邮件都慢 一生只够爱一个人</span><br><span class="line"></span><br><span class="line">从前的锁也好看 钥匙精美有样子 你锁了 人家就懂了</span><br></pre></td></tr></table></figure><p>从前的交通很慢，父母要从陕西到乌鲁木齐，要坐七天七夜的绿皮车；从前的网速邮件很慢，话费很贵，见字如面，惜字如金，只要能半个月写封信或通个电话那头的人就已经心满意足了；从前的人想法很简单，只要学一个技能，能混个饭饱饿不死就行。</p><p>然而那是二十年前的日子，现在是高速信息化时代，一切都在追寻快。</p><p>交通如果慢一点，就着急跺脚；视频通话稍微卡顿，就说网速太差；一个技能还没有吃透，又想着吃另一个，然而精力时间有限。</p><p>我一直在找寻产生知识焦虑的原因，如果让我追本溯源的话，我想，那就是当我们的野心还配不上我们的行动时，现实与理想的落差而造成的。</p><h1 id="IT，一个特殊的行业"><a href="#IT，一个特殊的行业" class="headerlink" title="IT，一个特殊的行业"></a>IT，一个特殊的行业</h1><p>IT，我觉得它与传统行业的差别在于，更新迭代速度非常快，稍微慢一点，你就会感觉到掉队。</p><p>比如新框架替换老框架，就像人体的新城代谢似的。</p><p>所以，在我们入了这个行业的时候，就要抱着终身学习的方向去努力。</p><h1 id="我曾如此焦虑过"><a href="#我曾如此焦虑过" class="headerlink" title="我曾如此焦虑过"></a>我曾如此焦虑过</h1><p>当我早上醒来时，去操场跑步，去食堂吃早饭，在校园的林荫小道上背半小时的新概念，看一会我订阅的专栏的更新，然后去教师上课，这时候视情况而定，如果老师在吹牛逼，就屏蔽掉，同时拿出自己到图书馆借阅的算法书或一些文学小说看；中午午休，下午没课去图书馆或实验室看书刷题写博客；晚饭过后继续做看书学习的循环。</p><p>这样的日子持续了很长时间，因为我不知道未来我会遇到什么样的竞争对手，不知道我遇到的同事是否比我强，如果比我强，拖后腿就难受了。<br>未知是恐惧的，所有的这一切促使我紧张而又焦虑的度过生活的每一天。</p><h1 id="战胜焦虑的过程"><a href="#战胜焦虑的过程" class="headerlink" title="战胜焦虑的过程"></a>战胜焦虑的过程</h1><p>这一切的改变源于一个人的出现。</p><p>直到她的出现我的生活中，让我知道原来学校外还有一些好吃的餐馆，原来秋天学校里通往教学楼的路是如此美丽，原来梨花开的那一刻竟是如此浪漫，原来和喜欢的人安安静静的坐在小水池旁边，一人各抱着半个西瓜啃是如此美好。</p><p>她说：<strong>生命苦短，及时行乐</strong>。</p><h1 id="适当焦虑"><a href="#适当焦虑" class="headerlink" title="适当焦虑"></a>适当焦虑</h1><p>现在的我，有时会因为新出现的需求和<code>bug</code>而忙前忙后，和各个岗位负责人做沟通，但我依旧会挤出晚上宝贵的睡前半小时，静下心来写一写日记，听几首喜欢的音乐。培养着和艺术，音乐，书法方面的爱好。</p><p>焦虑每一个人都会有，我也不例外。也许我们会为了自己道路远方的光而不断奔跑，但请别忘了适当停下来回首自己走过的路，因为那是属于你独一无二，不可替代的曾经。</p><p><img src="/2019/04/28/we-face-knowledge-anxiety/weroad.png" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>焦虑</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>感情这东西</title>
    <url>/2019/04/25/feelings/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><p>今天是2019年4月25日，距离她毕业离校到来成都，还有一个月的时间。</p><p>放佛是越到最后越按捺不住自己的情绪。感情这东西，真是有趣。</p><p>最近情绪不怎么稳定，运维上出现了两个bug已经拖了四天还没有解决，五一回家，想和女友聚一波去耍，无奈新疆太大，从她出学校到见我，还有坐两个小时的班车和十三个小时的火车（速度比较快的）。真是很惆怅。</p><p>我对她说，你要来，我肯定会给你把吃住安排好，带你去看美景，但是我也就在家呆六天，然后就要飞回成都工作。</p><p>感情这东西，真是神奇，长年累月，让两个素不相识的人在一起，成为伴侣，这样的感觉很美妙，然而，当两个人分开时，却要承受分开时思念的痛苦。</p><p>我希望这是我最后一次品尝，不管是不是最后一次，请不要再分开这么长的时间了。</p><p>而我，也绝对绝对绝对不会再让我爱的人离开我，也不会让她再受到半点委屈。</p><p>也许这就是爱情所赋予平凡人的力量吧。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>爱情</tag>
        <tag>毕业</tag>
      </tags>
  </entry>
  <entry>
    <title>Go项目结构设计过程点滴记录</title>
    <url>/2019/04/22/go-project-struct-design-note/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>之前在知识星球里星主让用<code>SMTP</code>协议实现邮件发送功能，看了<code>Max Li</code>的设计，并和他交流了一小时，在此将设计经验记录下来。</p><h1 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h1><p>设计一个项目的结构，有时候就像写文章一样，得分清层级。下面我将把讨论出的设计经验记录下来。</p><ul><li><p>main.go文件，当做项目的入口，里面可以写明版本号，读取配置文件，以及日志的初始化；</p></li><li><p>gomod文件，包管理</p></li><li><p>makefile文件，如果启动程序较多，可以写入makefile文件中，到时运行直接make即可；</p></li><li><p>pkg文件夹，存放项目的主要源代码</p></li><li><p>cmd文件夹，存放项目生成的可执行文件</p></li><li><p>config文件夹，存放配置文件，包含项目的基本配置信息</p></li><li><p>vendor文件夹，将依赖的包放入此目录中</p></li><li><p>util文件夹，项目中所写的小工具，例如进制转换，查错，类型转换，时间转时间戳等放入该文件件</p></li></ul><h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><h2 id="1，设计中难免会出现明文密码显示等相关信息，如何做到保密呢？"><a href="#1，设计中难免会出现明文密码显示等相关信息，如何做到保密呢？" class="headerlink" title="1，设计中难免会出现明文密码显示等相关信息，如何做到保密呢？"></a>1，设计中难免会出现明文密码显示等相关信息，如何做到保密呢？</h2><h2 id="2，如何做到在项目build同时自己更新tag号？"><a href="#2，如何做到在项目build同时自己更新tag号？" class="headerlink" title="2，如何做到在项目build同时自己更新tag号？"></a>2，如何做到在项目build同时自己更新tag号？</h2><p>参考<a href="https://github.com/ahmetb/govvv" target="_blank" rel="noopener">govvv</a></p><h2 id="3，怎样设计出一个框架，支持易扩展可维护呢？"><a href="#3，怎样设计出一个框架，支持易扩展可维护呢？" class="headerlink" title="3，怎样设计出一个框架，支持易扩展可维护呢？"></a>3，怎样设计出一个框架，支持易扩展可维护呢？</h2><p>我能想到的是，<code>web</code>服务设计接口，在接口中添加操作。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://idiomaticgo.com/post/best-practice/server-project-layout/" target="_blank" rel="noopener">Server Project Layout</a></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>写<code>demo</code>的时候，还是忍不住将所有的程序写进一个<code>main</code>函数里，又或者是新建一个<code>server.go</code>文件，然后一股脑的在里面做文章。</p><p>今天早上看星球里的朋友提出了一个问题，我觉得很对，在此摘录如下</p><blockquote><p>提高编程技能是很不容易的，一个人一旦习惯了某种编程思维就很难再突破。就说说我自己，一个业务用一般方法能实现的，我很难再去想到用接口，函数类型，闭包，反射等。虽然业务实现了，但总感觉代码写的很烂，自己看了都恶心。我相信大家一定有同感，教程和视频看了很多，也知道很多概念，但等到自己用的时候，又回到了旧的思维习惯。我觉得老大在布道go时，更应关注这方面的培养，知识的细节和技巧可以慢慢积累，但思维定势不突破，永远也不可能提高。</p></blockquote><p>今天和<code>Max Li</code>的沟通，还有在做项目时不断的以工程思维冲击着以前遗留下来的旧的思维习惯，我只想说，越早做出好的改变，成长的空间的也就越大。</p><p>共勉！</p><p><img src="/2019/04/22/go-project-struct-design-note/road" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>Go</tag>
        <tag>架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>暂时停留</title>
    <url>/2019/04/21/temporary-stay/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><p>前天，也就是星期五，我终于把我负责的流媒体收录系统上的<code>bug</code>和需求都清空了，成功打了<code>tag</code>号。</p><p>可以暂时休息下，思考一下前方的路该如何走？</p><p>有时候很好奇，大家都是24小时的时间，为什么有的人风生水起，有的人碌碌无为呢？</p><p>昨天去现场咨询了一下成都落户，本科以上学历+无房，落的是集体户口。嗯，觉得这块得好好了解下。不然以后再落会比较麻烦。</p><p>接下来要做的事情，似乎还有很多：</p><ul><li><p>流媒体收录关于管道，并发，以及<code>nginx</code>的服务还要细看下；</p></li><li><p>英语流利说的会员到期日还有80天，要抓紧时间了；</p></li><li><p>极客专栏上有关<code>Linux</code>操作系统内核，网络协议和数据库原理的的内容也需要更新；</p></li><li><p>给伶说好的画画，要在她五月底来成都前画完，虽然时间还很充裕，但不能再拖了。</p></li></ul><p>入职半年多，现在才真正感觉是在跟着大家一块做项目。</p><p>加油，努力！</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>远方</tag>
      </tags>
  </entry>
  <entry>
    <title>服务端漫游</title>
    <url>/2019/04/14/server-roam/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><p>注：本文内容源自<code>polaris</code>在知识星球<strong>Go项目实战</strong>中的直播，已获得本人许可。</p><h1 id="第一站：穿梭于Internet"><a href="#第一站：穿梭于Internet" class="headerlink" title="第一站：穿梭于Internet"></a>第一站：穿梭于Internet</h1><p><img src="/2019/04/14/server-roam/internet.png" alt></p><h1 id="第二站：协议"><a href="#第二站：协议" class="headerlink" title="第二站：协议"></a>第二站：协议</h1><p>重点掌握</p><ul><li>TCP/UDP</li><li>HTTP</li></ul><p>常考面试题</p><ul><li>TCP的三次握手过程</li><li>TCP的四次挥手过程</li></ul><h4 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h4><ul><li>《图解http协议》</li><li>《图解TCP协议》</li></ul><p>建议用<code>wireshark</code>抓包软件进行分析。</p><h1 id="第三站：Unix-Linux操作系统"><a href="#第三站：Unix-Linux操作系统" class="headerlink" title="第三站：Unix/Linux操作系统"></a>第三站：Unix/Linux操作系统</h1><p>掌握对<code>Unix/Linux</code>操作系统的常用操作指令操作，例如</p><ul><li><code>shell</code>脚本</li><li><code>vim</code>编辑器的使用</li><li><code>sed</code></li><li><code>awk</code></li></ul><p>多练习，多总结</p><p>网络编程方面需掌握</p><ul><li>Socket、Unix Domain Socket</li><li>进程间通讯</li></ul><h4 id="推荐书籍-1"><a href="#推荐书籍-1" class="headerlink" title="推荐书籍"></a>推荐书籍</h4><ul><li>《UNIX网络编程卷一：套接字》</li><li>《UNIX环境高级编程》</li><li>《Linux/Unix设计思想》</li></ul><h1 id="第四站：Nginx、Apache、Caddy、等Web-Server和核心功能"><a href="#第四站：Nginx、Apache、Caddy、等Web-Server和核心功能" class="headerlink" title="第四站：Nginx、Apache、Caddy、等Web Server和核心功能"></a>第四站：Nginx、Apache、Caddy、等Web Server和核心功能</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><img src="/2019/04/14/server-roam/server.png" alt></p><h2 id="Web-Server核心功能"><a href="#Web-Server核心功能" class="headerlink" title="Web Server核心功能"></a>Web Server核心功能</h2><ul><li>HTTP解析</li><li>HTTPS支持</li><li>虚拟主机(一个端口，多个域名)</li><li>静态资源</li><li>URL重写</li><li>gzip压缩</li><li>作为反向代理，和其他进程常用通讯协议的支持</li></ul><p>推荐学习了解下<code>Caddy</code></p><h1 id="第五站：常用的支持Web开发的语言"><a href="#第五站：常用的支持Web开发的语言" class="headerlink" title="第五站：常用的支持Web开发的语言"></a>第五站：常用的支持Web开发的语言</h1><ul><li>PHP(LAMP、LNMP)</li><li>Java</li><li>Python</li><li>Ruby</li><li>Go</li><li>C#(.NET)</li></ul><p>另外常用的数据结构和算法要有了解</p><h1 id="第六站：数据库"><a href="#第六站：数据库" class="headerlink" title="第六站：数据库"></a>第六站：数据库</h1><ul><li>关系数据库：SQLite,MySQL,Postgresql,SQL Server,Oracle</li><li>NoSQL：Redis,Mongodb,Cassandra,HBase</li><li>缓存：Redis,Memcached</li><li>其他：Go BoltDB,dgraph,CockroachDB</li></ul><p>入门数据库推荐使用<code>MySQL</code></p><h4 id="推荐书籍-2"><a href="#推荐书籍-2" class="headerlink" title="推荐书籍"></a>推荐书籍</h4><ul><li>《高性能MySQL》</li><li>《MySQL技术内幕InnoDB引擎》</li><li>《Redis实战》</li></ul><h1 id="第七站：架构"><a href="#第七站：架构" class="headerlink" title="第七站：架构"></a>第七站：架构</h1><ul><li>高可用，高性能，可扩展</li><li>分布式，CAP理论</li><li>分布式消息队列：Redis,ActiveMQ,RabbitMQ,ZeroMQ,Kafka,MetaMQ,RocketMQ等</li><li>常用的应用场景：异步处理，应用解耦，流量削峰和消息通讯</li><li>微服务</li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>直播后有个答疑环节，我将此次答疑的收货整理如下：</p><h4 id="关于服务端面试"><a href="#关于服务端面试" class="headerlink" title="关于服务端面试"></a>关于服务端面试</h4><p>面试考语言的分量比较小，因为服务端涉及的面比较广，需要学习的东西很多，有时候原理比语言更重要。</p><h4 id="关于承压"><a href="#关于承压" class="headerlink" title="关于承压"></a>关于承压</h4><p>在项目研发过程中，无论是测试还是上线跑，服务端会经常背锅，所以在压力上要及时调整好心态，做好和其他岗位人员的及时有效沟通。</p><h4 id="关于未来发展"><a href="#关于未来发展" class="headerlink" title="关于未来发展"></a>关于未来发展</h4><p>努力去大公司，做一些大项目，最好流量是千万级别以上的。</p><p>学无止境，一起努力！</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>服务端学习</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>数据库</tag>
        <tag>服务端</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>关于996，我想说</title>
    <url>/2019/04/07/about-996-i-want-to-say/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>最近Github上有一个叫<a href="https://github.com/996icu/996.ICU" target="_blank" rel="noopener">996.ICU</a>的项目很火，原因是它公开抵制国内的996工作制，这严重违反了劳动法。工作996，住院ICU。</p><p>于是我身边有朋友问我，996到底是什么意思，那么我先说下我个人的亲身经历吧。</p><h1 id="回忆"><a href="#回忆" class="headerlink" title="回忆"></a>回忆</h1><p>去年六月大学本科毕业后，幸运的入职一家上市游戏公司，从事游戏服务端开发，刚开始对新公司，新工作充满好奇，想着下班回去也没什么事，就多待会，熟悉公司的业务流程。于是在公司内，我算是比较活跃的一类。</p><p>游戏公司与其他互联网公司最大的不同在于，活动非常多，各种节日庆祝，生日庆祝，下午茶，大家其乐融融，嬉戏打闹，品尝美食，氛围很融洽…</p><p>2018年8月，隔壁一工作室出了一款暗黑类手游，IOS端零点开服，于是我看着他们工作室从早忙到深夜，要么服务器崩了，要么数据有误急需修改，有些策划兼当游戏客服，而我看到一小伙子有时还披着被子工作，莫不是凌晨都睡在公司了吧。</p><p>后来，我也要开始加班了，虽然我也并不知道为什么加班，明明可以六点半走的，莫不是为了八点的餐补，还是九点的滴滴打车报销？</p><p>再后来，我经常晚上回来，同租的老哥每次看我拖着疲惫的身子回来，一脸倦容，就知道我又加班了。</p><p>八月底，做了两个梦</p><ul><li>第一个梦是让我两天把《Java编程思想》看完，我被吓醒了；</li><li>第二个梦是半醒中，突然摸到了一双手在我后脑勺处，我吓的大叫了一声，后来才发现是我那双已经被压麻的手，因为太累，躺床上还没有调整好睡姿就已经睡着了。</li></ul><p>八月三十一号，我记得很清楚，那是我离猝死最近的距离…</p><p>那天，我坐在工位前，一直在看服务端主程用<code>Lua</code>语言写的球球大作战源码，虽然看不懂，但我还是坚持把这四千行的代码都过了一遍，吃晚饭的时候一激动，起身起的太快，感到心脏隐隐作痛，头昏脑涨，恍恍惚惚间已经不知道自己在哪里，在干什么。旁边的客户端同事告诉我赶紧休息下，不能再工作了。我想也是。</p><p>在回去的路上，我将我今天的症状对学西医的朋友描述的一遍，他说你这离猝死不远了，得好好休息。</p><p>我慌了，我再也不敢透支身体了！</p><p>九月初，转正答辩，虽然我列举了我这三个月的改变，和完成的事情，但当他们一脸不屑，以及对我提出的问题，我就能猜出我能否通过转正了，虽然我每天都在拼命加班，但产出在他们看来微乎其微，公司不养闲人，于是我光荣的提了离职申请。</p><p>九月十一号，我办好离职手续，出了公司，成了一名工作经验仅只有三个月的社会人士。</p><p>我很想找个没人的地方哭一次，但我知道，塞翁失马，焉知非福。如果这就是我所了解到的游戏生涯，那我的游戏开发的梦也可以就此宣告结束了。</p><h1 id="工作996，生病ICU"><a href="#工作996，生病ICU" class="headerlink" title="工作996，生病ICU"></a>工作996，生病ICU</h1><p>我觉得这个比喻真的很好，说的更直白点，就是有命赚钱，没命花钱。</p><p>曾经我以为996就是累点而已，多学点东西也是极好的。</p><p>现在想想错了。</p><p>996在消耗你的体力的同时，也在消耗你的自由支配时间。在你本应该下班好好玩耍或吃顿美食开始看书学习的时候，你却要在嘈杂的环境下持续输出。可想而知，在精力和体力都枯竭的情况下，怎么能高产出呢？</p><p>然后负责人觉得你每天工作十二个小时，产出还这么低，看来你能力不行嘛，明天可以走人了，我再招一批年轻的实习生进来。</p><p>于是最终吃亏的还是自己。</p><h1 id="关于996，我想说"><a href="#关于996，我想说" class="headerlink" title="关于996，我想说"></a>关于996，我想说</h1><ul><li><p>跟对<code>leader</code>很重要。在我看来，一个好<code>leader</code>可以成为自己学习的榜样。虽然我无法全面定义一个好<code>leader</code>到底是什么样子，但是有一点是可以证明的：就是不会总是在他人面前炫耀自己曾经获得过什么荣誉。毕竟那都是过去的事情，一个人总沉浸在过去，会影响现在以及对未来的判断。</p></li><li><p>对不应该加的班说不。工作重要的一点是能力，另一点就是沟通。对于不是自己负责的任务，及时说明原因，让负责人定夺，而不是一股脑的全都接下。</p></li><li><p>抓紧一切时间去学习，去提升自我。我相信那些大厂年薪过百万的人，即使不加班领导也不会拿他怎样，毕竟这种人是无法短期被替代的，同时掌握着公司内最核心的技术。</p></li><li><p>加班多工资多，加班少工作也低，放佛总不能找到一个完美的选择，那么就请平衡好自己的能力和野心。</p></li><li><p>提升工作效率是关键。比如设立番茄钟，遇到不懂的赶紧问。</p></li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>转眼间我已经工作快十一个月了，有时还会把自己想象是在校大学生。</p><p>从996到955，从睡眠不足到睡到自然醒精神的去上班，我知道我找到了适合自己的工作方式。</p><p>曾经看着红的蓝的绿的共享单车如三条颜色的河流缓缓的流向软件园，中间有分流到xx大厦，xx集团，我曾想过上班的意义是什么？</p><p>直到现在我也没彻底想明白，但我知道，上班绝不是去医院住ICU。</p><p>希望996这样的工作制能成为个例，也希望以后的程序员们可以早点下班。</p><p>Good Luck.</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>工作</tag>
        <tag>感悟</tag>
        <tag>加班</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Golang进行字符串的替换</title>
    <url>/2019/04/07/use-golang-string-replace/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//转换为字符串后追加到字节数组</span></span><br><span class="line">	slice := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	slice = strconv.AppendBool(slice, <span class="literal">true</span>)</span><br><span class="line">	<span class="comment">//第二个数为要追加的数，第三个数为指定10进制方式追加</span></span><br><span class="line">	slice = strconv.AppendInt(slice, <span class="number">1234</span>, <span class="number">10</span>)</span><br><span class="line">	slice = strconv.AppendQuote(slice, <span class="string">"abcgohello"</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"slice = "</span>, <span class="keyword">string</span>(slice))</span><br><span class="line"></span><br><span class="line">	<span class="comment">//其它类型转换为字符串</span></span><br><span class="line">	<span class="keyword">var</span> str <span class="keyword">string</span></span><br><span class="line">	str = strconv.FormatBool(<span class="literal">false</span>)</span><br><span class="line">	fmt.Println(<span class="string">"str = "</span>, str)</span><br><span class="line">	<span class="comment">//'f'指打印格式，以小数形式，-1指小数点位数，64以float64处理</span></span><br><span class="line">	str = strconv.FormatFloat(<span class="number">3.14</span>, <span class="string">'f'</span>, <span class="number">-1</span>, <span class="number">64</span>)</span><br><span class="line">	fmt.Println(<span class="string">"str = "</span>, str)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//整型转字符型</span></span><br><span class="line">	str = strconv.Itoa(<span class="number">6666</span>)</span><br><span class="line">	fmt.Println(<span class="string">"str = "</span>, str)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符串转其它类型</span></span><br><span class="line">	flag, err := strconv.ParseBool(<span class="string">"true"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err = "</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"flag = "</span>, flag)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符串转换为整型</span></span><br><span class="line">	a, _ := strconv.Atoi(<span class="string">"56479"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"a = "</span>, a)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="/2019/04/07/use-golang-string-replace/str.png" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>字符串</tag>
        <tag>替换</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串操作常用函数介绍</title>
    <url>/2019/04/07/golang-string-operation-function/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><ul><li>操作</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//"helloogo"中是否包含"hello"</span></span><br><span class="line">fmt.Println(strings.Contains(<span class="string">"helloogo"</span>, <span class="string">"hello"</span>))</span><br><span class="line">fmt.Println(strings.Contains(<span class="string">"helloogo"</span>, <span class="string">"goe"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//Join组合</span></span><br><span class="line">s := []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>, <span class="string">"hello"</span>, <span class="string">"mike"</span>, <span class="string">"go"</span>&#125;</span><br><span class="line">buf := strings.Join(s, <span class="string">"_"</span>)</span><br><span class="line">fmt.Println(<span class="string">"buf = "</span>, buf)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Index 查找子串所在位置</span></span><br><span class="line">fmt.Println(strings.Index(<span class="string">"abcdhello"</span>, <span class="string">"hello"</span>))</span><br><span class="line">fmt.Println(strings.Index(<span class="string">"abcdhello"</span>, <span class="string">"go"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//Repeat 重复打印</span></span><br><span class="line">buf = strings.Repeat(<span class="string">"go"</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="string">"buf = "</span>, buf)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Split 以指定的分隔符对字符串进行拆分</span></span><br><span class="line">buf = <span class="string">"hello&amp;abc&amp;go&amp;mike&amp;you"</span></span><br><span class="line">s2 := strings.Split(buf, <span class="string">"&amp;"</span>)</span><br><span class="line">fmt.Println(<span class="string">"s2 = "</span>, s2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Trim 去掉两头的字符</span></span><br><span class="line">buf = strings.Trim(<span class="string">"      are you ok    "</span>, <span class="string">" "</span>)</span><br><span class="line">fmt.Println(<span class="string">"buf = "</span>, buf)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Fields 去掉空格，把元素放入切片中</span></span><br><span class="line">s3 := strings.Fields(<span class="string">"    are you ok?    "</span>)</span><br><span class="line"><span class="keyword">for</span> i, data := <span class="keyword">range</span> s3 &#123;</span><br><span class="line">	fmt.Println(i, <span class="string">", "</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">buf =  abc_hello_mike_go</span><br><span class="line">4</span><br><span class="line">-1</span><br><span class="line">buf =  gogogo</span><br><span class="line">s2 =  [hello abc go mike you]</span><br><span class="line">buf =  are you ok</span><br><span class="line">0 ,  are</span><br><span class="line">1 ,  you</span><br><span class="line">2 ,  ok?</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>字符串</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次做项目学到的技术之外的东西</title>
    <url>/2019/03/28/first-work-project-havest/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><p>三月初转正后开始接手公司内的一个有关流媒体收录系统服务器方面的项目，和部门老哥，产品，测试，运维，前端交流，对需求，看bug，学习到了很多编程之外的技能，写篇文章记录下来。</p><h2 id="接手新项目"><a href="#接手新项目" class="headerlink" title="接手新项目"></a>接手新项目</h2><ul><li>把完整的接口说明文档，配置文件拿到手，大致先过一遍</li><li>学会打断点，代码不是文章，不能从头读到尾，除非是一个文件只有一个<code>main</code>函数从头跟到尾</li><li>有不懂就赶紧问，时间不等人！</li><li>大部分时间都是把逻辑理清楚，代码只是分分钟的事情。</li></ul><h2 id="与产品沟通"><a href="#与产品沟通" class="headerlink" title="与产品沟通"></a>与产品沟通</h2><ul><li>大部分产品是不写代码的，所以不要和他/她扯到程序内部的实现上，否则他/她会很懵逼</li><li>遇到需求完成不了或觉得有问题，应尽早提出来</li></ul><h2 id="与其他部门的沟通"><a href="#与其他部门的沟通" class="headerlink" title="与其他部门的沟通"></a>与其他部门的沟通</h2><ul><li>其实在做编码设计的时候，我的时间不是整块的，有时候会被测试，运维临时打断去处理bug</li><li>学会把时间整片化，例如25-30分钟做一件事情，如果中间被要求去解决<code>bug</code>，咨询他能否等10分钟</li><li>每次解决完一个<code>bug</code>，把问题和解决过程描述清楚，记录在<code>wiki</code>上，方便自己和其他相关人员以后查看</li><li>学会看日志，通过日志分析问题的所在</li></ul><h2 id="排查bug的基本流程"><a href="#排查bug的基本流程" class="headerlink" title="排查bug的基本流程"></a>排查bug的基本流程</h2><p>当运维、测试那里出现问题需要你来解决时，解决流程是这样的:</p><ul><li>先看配置文件是否正确，也许是模式<code>model</code>选错，也许是路径没有配置正确;</li><li>再看日志记录;(所以前提是自己要在关键模块打详细日志描述，方便排查问题)</li><li>然后再看版本号是否正确;</li><li>最后再将问题在本机复现，用<code>dlv</code>或<code>gdb</code>打断点调试找出问题;</li><li>当问题解决后，一定记得在<code>wiki</code>里做好相应的记录，原因有二，帮助自己整理和回顾项目中的业务流程，当另外的运维或测试碰到类似的问题时，直接让它看<code>wiki</code>记录就可以，自己可以专心干其他的事情。</li></ul><p>加油！这将是我正式开发和维护的第一个<code>Golang</code>语言的项目！</p><p><img src="/2019/03/28/first-work-project-havest/beautiful.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>成长</tag>
        <tag>感悟</tag>
        <tag>学习</tag>
        <tag>沟通</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>一点进展</title>
    <url>/2019/03/25/a-little-progress/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><p>今天部门老大问我项目进展怎样，我说有点慢，一个需求正在测试，还有四个需求没有开始实施。（我为什么要这么诚实？！）</p><p>中午和同事出去吃饭，他建议我先把接口列出来，然后把每一步要做的注释写出来，再将注释翻译成代码。</p><p>散步快结束时，董说你已经过了让我们告诉你如何做的阶段，现在只能是自己去探索，而我们告诉你是<code>true</code>或<code>false</code>。</p><p>当我听到这句话的时候，我竟然心中油然升起一种莫名其妙的喜悦。</p><p>是的，我已经转正了，已经离开学校九个多月了，应该学会独立解决问题和培养随机应变的能力。</p><p>企业不是学校，没有责任和义务告诉你每一步该怎么做。</p><p>谢谢给我指导的部门老哥们。</p><p>是我自己太矫情了，一直沉溺在学校的幻想中，不愿意走出来。</p><p>今天终于解决了第一个需求，不知明天能不能把第二个需求做完。</p><p>坚持，并学会改变。</p><p><img src="/2019/03/25/a-little-progress/smile.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>进步</tag>
      </tags>
  </entry>
  <entry>
    <title>一点小挫折</title>
    <url>/2019/03/23/some-setbacks/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><p>终于迎来了最难受的时期，流媒体收录服务，逻辑很杂，但不难，就是tmd理不清楚。</p><p>下周五要发版，现在东西搞定不了，该如何是好？</p><p>父母说，遇到困难就去解决，不要逃避，他们也说，这个东西以后就交给我来负责了！</p><p>可是，我真的能扛起这个重任吗？我反复问自己。</p><p>明天还有一天的时间，我想重新用dlv调试把每个流程弄懂。</p><p>希望可以来得及！</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>挫折</tag>
      </tags>
  </entry>
  <entry>
    <title>痛并成长着</title>
    <url>/2019/03/18/pain-and-growth/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><p>三月，对我来说是一个特殊的月份，特殊在:</p><ul><li>转正通过，开始接手公司项目;</li><li>月底我将23岁，每当这个时候，我都会感到莫名其妙的沉默寡言。</li></ul><p>上一周感觉过得很艰难，很充实，因为自己不会的很多，得一个个去补。</p><p>杨说叫我把B站上的20小时快速入门Go语言课程从新再系统学习一遍，虽然我觉得之前都接触过，但我还是欣然接受。现在课程已经过半，让我真正意识到，忘记自己曾经以为对的东西，推到重来，反而会有新的收获，也许这就是温故而知新吧。</p><p>这周很荣幸加入了Go语言中文网创始人创办的知识星球，与无闻，轩辕刃这些大佬一起学习Go语言，探究底层的本质。</p><p>技术文章我仍旧会继续坚持写下去，但我会逐渐摒弃数量，追求质量。</p><p>上周六和一位朋友去看漫展，然后去逛街，疯玩了一天，身心放松了下来，很是开心，让我忘却了工作上的烦恼。</p><p>我一直坚信，天将降大任于斯人也，必先苦其心智，饿其筋骨，劳其体肤…</p><p>加油!扛过去，胜利就在前方。</p><p><img src="/2019/03/18/pain-and-growth/whale.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>感悟</tag>
        <tag>挫折</tag>
      </tags>
  </entry>
  <entry>
    <title>转正才是工作的开始</title>
    <url>/2019/03/04/positive-is-work-begin/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><p>转正通过，也算是对我这六个月的一次认可吧。</p><p>然后有一老哥的流媒体服务相关的项目移交给我负责了，还有视音频编码，放佛之前是在过家家，现在才是正式工作的开始。</p><p>加油，机遇与挑战并存！</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>开始</tag>
        <tag>转正</tag>
      </tags>
  </entry>
  <entry>
    <title>对Go语言interface的理解</title>
    <url>/2019/03/03/golang-interface-understand/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h1 id="什么是interface"><a href="#什么是interface" class="headerlink" title="什么是interface"></a>什么是interface</h1><p>interface是一组method（方法）的组合，我们通过interface来定义对象的一组行为。</p><h1 id="interface类型"><a href="#interface类型" class="headerlink" title="interface类型"></a>interface类型</h1><p>interface类型定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口。<br>（如果给鸭子模型定义划水的方法，当我再新建立一个鸟的对象，让它实现划水的方法，这时我可以认为鸟也是鸭子）</p><p>一个例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段Human</span></span><br><span class="line">    school <span class="keyword">string</span></span><br><span class="line">    loan <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段Human</span></span><br><span class="line">    company <span class="keyword">string</span></span><br><span class="line">    money <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Human对象实现Sayhi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Hi, I am %s you can call me on %s\n"</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Human对象实现Sing方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">Sing</span><span class="params">(lyrics <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"La la, la la la, la la la la la..."</span>, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Human对象实现Guzzle方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">Guzzle</span><span class="params">(beerStein <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Guzzle Guzzle Guzzle..."</span>, beerStein)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Employee重载Human的Sayhi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Hi, I am %s, I work at %s. Call me on %s\n"</span>, e.name,</span><br><span class="line">        e.company, e.phone) <span class="comment">//此句可以分成多行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Student实现BorrowMoney方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">BorrowMoney</span><span class="params">(amount <span class="keyword">float32</span>)</span></span> &#123;</span><br><span class="line">    s.loan += amount <span class="comment">// (again and again and...)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Employee实现SpendSalary方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">SpendSalary</span><span class="params">(amount <span class="keyword">float32</span>)</span></span> &#123;</span><br><span class="line">    e.money -= amount <span class="comment">// More vodka please!!! Get me through the day!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义interface</span></span><br><span class="line"><span class="keyword">type</span> Men <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(lyrics <span class="keyword">string</span>)</span><br><span class="line">    Guzzle(beerStein <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> YoungChap <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(song <span class="keyword">string</span>)</span><br><span class="line">    BorrowMoney(amount <span class="keyword">float32</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ElderlyGent <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(song <span class="keyword">string</span>)</span><br><span class="line">    SpendSalary(amount <span class="keyword">float32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以知道</p><ul><li>interface可以被任意对象调用和实现。</li><li>一个对象可以实现任意多个interface。</li></ul><p>形象的比喻：每个物种都是一个类，我们给这个类定义一系列的行为，例如给鸟类定义可以飞行的行为，给狗定义可以“汪汪”的声音，给人类定义可以说话可以跑步的行为，那么当你和我都实现了说话和跑步的行为，你我都属于人类，你和我都实现了飞行的行为，你我都属于鸟类，以此类推。这么做的意义在于，实现代码的高度使用。</p><h1 id="思考：errors-这个-package-里面的-errors-New-到底是做什么的？"><a href="#思考：errors-这个-package-里面的-errors-New-到底是做什么的？" class="headerlink" title="思考：errors 这个 package 里面的 errors.New 到底是做什么的？"></a>思考：errors 这个 package 里面的 errors.New 到底是做什么的？</h1><p><code>errors</code>包实现了创建错误值的函数。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>使用字符串创建一个错误,可以类比fmt包的Errorf方法，差不多可以认为是New(fmt.Sprintf(…))。</p><p>例子</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(request <span class="keyword">string</span>)</span> <span class="params">(response <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> request == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="comment">//调用errors.New函数时传入一个由字符串代表的错误信息，它会返回</span></span><br><span class="line">		<span class="comment">//给我们一个包含了这个错误信息的error类型值。该值的静态类型是error</span></span><br><span class="line">		err = errors.New(<span class="string">"empty content"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	response = fmt.Sprintf(<span class="string">"echo: %s"</span>, request)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是返回一个自己定义的错误。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://golang.org/pkg/errors/" target="_blank" rel="noopener">gopkg-errors</a></p><p><a href="https://golang.org/src/errors/errors.go?s=293:320#L1" target="_blank" rel="noopener">New的实现</a></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>interface</tag>
      </tags>
  </entry>
  <entry>
    <title>开始学习一项新技术</title>
    <url>/2019/02/27/start-learn-new-technology/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><p>今天部门老哥说，周五会开始做一个新东西，会用到<code>Docker</code>，叫我先下载下来，后面要用。</p><p><code>Docker</code>这东西有段时间听过，是个容器，把应用放在里面跑，还是<code>Golang</code>的开源项目，对此我一直很好奇它和虚拟机相比究竟优点在哪里？</p><p>现在终于要开始接触它了！</p><p>加油，这两天先把手上的<code>flv</code>时移推进一下进度。</p><p><img src="/2019/02/27/start-learn-new-technology/docker.png" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Docker</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Go文件操作大全</title>
    <url>/2019/02/25/go-file-operation-finish/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h1 id="Go文件操作大全"><a href="#Go文件操作大全" class="headerlink" title="Go文件操作大全"></a>Go文件操作大全</h1><h2 id="1，介绍"><a href="#1，介绍" class="headerlink" title="1，介绍"></a>1，介绍</h2><h3 id="1-1-万物皆文件"><a href="#1-1-万物皆文件" class="headerlink" title="1.1 万物皆文件"></a>1.1 万物皆文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">One of the fundamental aspects of UNIX is that everything is a file. We don&apos;t necessarily know what the file descriptor maps to, that is abstracted by the operating system&apos;s device drivers. The operating system provides us an interface to the device in the form of a file.</span><br><span class="line"></span><br><span class="line">The reader and writer interfaces in Go are similar abstractions. We simply read and write bytes, without the need to understand where or how the reader gets its data or where the writer is sending the data. Look in /dev to find available devices. Some will require elevated privileges to access.</span><br></pre></td></tr></table></figure><p>在此引用刘超老师专栏里写的话</p><h4 id="Linux一切皆文件"><a href="#Linux一切皆文件" class="headerlink" title="Linux一切皆文件"></a>Linux一切皆文件</h4><ul><li>启动一个进程，需要一个程序文件，这是一个二进制文件</li><li>启动的时候，要加载一些配置文件，例如yml、properties等，这是配置文件；启动之后会打印一些日志，如果写到硬盘上，也是文本文件；如果我想把日志打印到交互控制台上，在命令行上打印出来，这是一个标准输出的stdout文件</li><li>这个进程的输出可以作为另一个进程的输入，这种方式称为管道，它也是一个文件</li><li>进程可以通过网络和其他进程进行通信，建立的Socket，也是一个文件</li><li>进程需要访问外部设备，设备也是一个文件</li><li>文件都被存储在文件夹里面，文件夹也是一个文件</li><li>进程运行起来，要想看到进程运行的情况，会在/proc下面有对应的进程号，也是一系列的文件</li></ul><h2 id="2，基本操作"><a href="#2，基本操作" class="headerlink" title="2，基本操作"></a>2，基本操作</h2><h3 id="2-1-创建空文件"><a href="#2-1-创建空文件" class="headerlink" title="2.1 创建空文件"></a>2.1 创建空文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    newFile *os.File</span><br><span class="line">    err     error</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    newFile, err = os.Create(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(newFile)</span><br><span class="line">    newFile.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-缩短文件"><a href="#2-2-缩短文件" class="headerlink" title="2.2 缩短文件"></a>2.2 缩短文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 裁剪一个文件到100个字节。</span></span><br><span class="line">    <span class="comment">// 如果文件本来就少于100个字节，则文件中原始内容得以保留，剩余的字节以null字节填充。</span></span><br><span class="line">    <span class="comment">// 如果文件本来超过100个字节，则超过的字节会被抛弃。</span></span><br><span class="line">    <span class="comment">// 这样我们总是得到精确的100个字节的文件。</span></span><br><span class="line">    <span class="comment">// 传入0则会清空文件。</span></span><br><span class="line">    err := os.Truncate(<span class="string">"test.txt"</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-获取文件信息"><a href="#2-3-获取文件信息" class="headerlink" title="2.3 获取文件信息"></a>2.3 获取文件信息</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    fileInfo os.FileInfo</span><br><span class="line">    err      error</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果文件不存在，则返回错误</span></span><br><span class="line">    fileInfo, err = os.Stat(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"File name:"</span>, fileInfo.Name())</span><br><span class="line">    fmt.Println(<span class="string">"Size in bytes:"</span>, fileInfo.Size())</span><br><span class="line">    fmt.Println(<span class="string">"Permissions:"</span>, fileInfo.Mode())</span><br><span class="line">    fmt.Println(<span class="string">"Last modified:"</span>, fileInfo.ModTime())</span><br><span class="line">    fmt.Println(<span class="string">"Is Directory: "</span>, fileInfo.IsDir())</span><br><span class="line">    fmt.Printf(<span class="string">"System interface type: %T\n"</span>, fileInfo.Sys())</span><br><span class="line">    fmt.Printf(<span class="string">"System info: %+v\n\n"</span>, fileInfo.Sys())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-重命名和移动文件"><a href="#2-4-重命名和移动文件" class="headerlink" title="2.4 重命名和移动文件"></a>2.4 重命名和移动文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    originalPath := <span class="string">"test.txt"</span></span><br><span class="line">    newPath := <span class="string">"test2.txt"</span></span><br><span class="line">    err := os.Rename(originalPath, newPath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-删除一个文件"><a href="#2-5-删除一个文件" class="headerlink" title="2.5 删除一个文件"></a>2.5 删除一个文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := os.Remove(<span class="string">"test.txt"</span>)  <span class="comment">//Remove 移除</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-打开和关闭文件"><a href="#2-6-打开和关闭文件" class="headerlink" title="2.6 打开和关闭文件"></a>2.6 打开和关闭文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 简单地以只读的方式打开。下面的例子会介绍读写的例子。</span></span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">    <span class="comment">// OpenFile提供更多的选项。</span></span><br><span class="line">    <span class="comment">// 最后一个参数是权限模式permission mode</span></span><br><span class="line">    <span class="comment">// 第二个是打开时的属性    </span></span><br><span class="line">    file, err = os.OpenFile(<span class="string">"test.txt"</span>, os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">    <span class="comment">// 下面的属性可以单独使用，也可以组合使用。</span></span><br><span class="line">    <span class="comment">// 组合使用时可以使用 OR 操作设置 OpenFile的第二个参数，例如：</span></span><br><span class="line">    <span class="comment">// os.O_CREATE|os.O_APPEND</span></span><br><span class="line">    <span class="comment">// 或者 os.O_CREATE|os.O_TRUNC|os.O_WRONLY</span></span><br><span class="line">    <span class="comment">// os.O_RDONLY // 只读</span></span><br><span class="line">    <span class="comment">// os.O_WRONLY // 只写</span></span><br><span class="line">    <span class="comment">// os.O_RDWR // 读和写</span></span><br><span class="line">    <span class="comment">// os.O_APPEND // 往文件末尾添加（Append）</span></span><br><span class="line">    <span class="comment">// os.O_CREATE // 如果文件不存在时则先创建这个文件</span></span><br><span class="line">    <span class="comment">// os.O_TRUNC // 文件打开时裁剪文件</span></span><br><span class="line">    <span class="comment">// os.O_EXCL // 和O_CREATE一起使用，文件不能存在</span></span><br><span class="line">    <span class="comment">// os.O_SYNC // 以同步I/O的方式打开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-判断这个文件是否存在"><a href="#2-7-判断这个文件是否存在" class="headerlink" title="2.7 判断这个文件是否存在"></a>2.7 判断这个文件是否存在</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    fileInfo *os.FileInfo</span><br><span class="line">    err      error</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 文件不存在则返回error</span></span><br><span class="line">    fileInfo, err := os.Stat(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line">            log.Fatal(<span class="string">"File does not exist."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">"File does exist. File information:"</span>)</span><br><span class="line">    log.Println(fileInfo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8-检查读写权限"><a href="#2-8-检查读写权限" class="headerlink" title="2.8 检查读写权限"></a>2.8 检查读写权限</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这个例子测试写权限，如果没有写权限则返回error。</span></span><br><span class="line">    <span class="comment">// 注意文件不存在也会返回error，需要检查error的信息来获取到底是哪个错误导致。</span></span><br><span class="line">    file, err := os.OpenFile(<span class="string">"test.txt"</span>, os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> os.IsPermission(err) &#123;</span><br><span class="line">            log.Println(<span class="string">"Error: Write permission denied."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">    <span class="comment">// 测试读权限</span></span><br><span class="line">    file, err = os.OpenFile(<span class="string">"test.txt"</span>, os.O_RDONLY, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> os.IsPermission(err) &#123;</span><br><span class="line">            log.Println(<span class="string">"Error: Read permission denied."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-9-改变权限、拥有者、时间戳"><a href="#2-9-改变权限、拥有者、时间戳" class="headerlink" title="2.9 改变权限、拥有者、时间戳"></a>2.9 改变权限、拥有者、时间戳</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用Linux风格改变文件权限</span></span><br><span class="line">    err := os.Chmod(<span class="string">"test.txt"</span>, <span class="number">0777</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改变文件所有者</span></span><br><span class="line">    err = os.Chown(<span class="string">"test.txt"</span>, os.Getuid(), os.Getgid())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改变时间戳</span></span><br><span class="line">    twoDaysFromNow := time.Now().Add(<span class="number">48</span> * time.Hour)</span><br><span class="line">    lastAccessTime := twoDaysFromNow</span><br><span class="line">    lastModifyTime := twoDaysFromNow</span><br><span class="line">    err = os.Chtimes(<span class="string">"test.txt"</span>, lastAccessTime, lastModifyTime)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-10-硬链接和软链接"><a href="#2-10-硬链接和软链接" class="headerlink" title="2.10 硬链接和软链接"></a>2.10 硬链接和软链接</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个硬链接。</span></span><br><span class="line">    <span class="comment">// 创建后同一个文件内容会有两个文件名，改变一个文件的内容会影响另一个。</span></span><br><span class="line">    <span class="comment">// 删除和重命名不会影响另一个。</span></span><br><span class="line">    err := os.Link(<span class="string">"original.txt"</span>, <span class="string">"original_also.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"creating sym"</span>)</span><br><span class="line">    <span class="comment">// Create a symlink</span></span><br><span class="line">    err = os.Symlink(<span class="string">"original.txt"</span>, <span class="string">"original_sym.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Lstat返回一个文件的信息，但是当文件是一个软链接时，它返回软链接的信息，而不是引用的文件的信息。</span></span><br><span class="line">    <span class="comment">// Symlink在Windows中不工作。</span></span><br><span class="line">    fileInfo, err := os.Lstat(<span class="string">"original_sym.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Link info: %+v"</span>, fileInfo)</span><br><span class="line">    <span class="comment">//改变软链接的拥有者不会影响原始文件。</span></span><br><span class="line">    err = os.Lchown(<span class="string">"original_sym.txt"</span>, os.Getuid(), os.Getgid())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3，读写"><a href="#3，读写" class="headerlink" title="3，读写"></a>3，读写</h2><h3 id="3-1-复制文件"><a href="#3-1-复制文件" class="headerlink" title="3.1 复制文件"></a>3.1 复制文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打开原始文件</span></span><br><span class="line">    originalFile, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> originalFile.Close()</span><br><span class="line">    <span class="comment">// 创建新的文件作为目标文件</span></span><br><span class="line">    newFile, err := os.Create(<span class="string">"test_copy.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> newFile.Close()</span><br><span class="line">    <span class="comment">// 从源中复制字节到目标文件</span></span><br><span class="line">    bytesWritten, err := io.Copy(newFile, originalFile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Copied %d bytes."</span>, bytesWritten)</span><br><span class="line">    <span class="comment">// 将文件内容flush到硬盘中</span></span><br><span class="line">    err = newFile.Sync()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-跳转到文件指定位置（Seek）"><a href="#3-2-跳转到文件指定位置（Seek）" class="headerlink" title="3.2 跳转到文件指定位置（Seek）"></a>3.2 跳转到文件指定位置（Seek）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, _ := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="comment">// 偏离位置，可以是正数也可以是负数</span></span><br><span class="line">    <span class="keyword">var</span> offset <span class="keyword">int64</span> = <span class="number">5</span></span><br><span class="line">    <span class="comment">// 用来计算offset的初始位置</span></span><br><span class="line">    <span class="comment">// 0 = 文件开始位置</span></span><br><span class="line">    <span class="comment">// 1 = 当前位置</span></span><br><span class="line">    <span class="comment">// 2 = 文件结尾处</span></span><br><span class="line">    <span class="keyword">var</span> whence <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">    newPosition, err := file.Seek(offset, whence)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Just moved to 5:"</span>, newPosition)</span><br><span class="line">    <span class="comment">// 从当前位置回退两个字节</span></span><br><span class="line">    newPosition, err = file.Seek(<span class="number">-2</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Just moved back two:"</span>, newPosition)</span><br><span class="line">    <span class="comment">// 使用下面的技巧得到当前的位置</span></span><br><span class="line">    currentPosition, err := file.Seek(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    fmt.Println(<span class="string">"Current position:"</span>, currentPosition)</span><br><span class="line">    <span class="comment">// 转到文件开始处</span></span><br><span class="line">    newPosition, err = file.Seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Position after seeking 0,0:"</span>, newPosition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-写文件"><a href="#3-3-写文件" class="headerlink" title="3.3 写文件"></a>3.3 写文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 可写方式打开文件</span></span><br><span class="line">    file, err := os.OpenFile(</span><br><span class="line">        <span class="string">"test.txt"</span>,</span><br><span class="line">        os.O_WRONLY|os.O_TRUNC|os.O_CREATE,</span><br><span class="line">        <span class="number">0666</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="comment">// 写字节到文件中</span></span><br><span class="line">    byteSlice := []<span class="keyword">byte</span>(<span class="string">"Bytes!\n"</span>)</span><br><span class="line">    bytesWritten, err := file.Write(byteSlice)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Wrote %d bytes.\n"</span>, bytesWritten)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-快写文件"><a href="#3-4-快写文件" class="headerlink" title="3.4 快写文件"></a>3.4 快写文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := ioutil.WriteFile(<span class="string">"test.txt"</span>, []<span class="keyword">byte</span>(<span class="string">"Hi\n"</span>), <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-使用缓存写"><a href="#3-5-使用缓存写" class="headerlink" title="3.5 使用缓存写"></a>3.5 使用缓存写</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打开文件，只写</span></span><br><span class="line">    file, err := os.OpenFile(<span class="string">"test.txt"</span>, os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="comment">// 为这个文件创建buffered writer</span></span><br><span class="line">    bufferedWriter := bufio.NewWriter(file)</span><br><span class="line">    <span class="comment">// 写字节到buffer</span></span><br><span class="line">    bytesWritten, err := bufferedWriter.Write(</span><br><span class="line">        []<span class="keyword">byte</span>&#123;<span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>&#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Bytes written: %d\n"</span>, bytesWritten)</span><br><span class="line">    <span class="comment">// 写字符串到buffer</span></span><br><span class="line">    <span class="comment">// 也可以使用 WriteRune() 和 WriteByte()   </span></span><br><span class="line">    bytesWritten, err = bufferedWriter.WriteString(</span><br><span class="line">        <span class="string">"Buffered string\n"</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Bytes written: %d\n"</span>, bytesWritten)</span><br><span class="line">    <span class="comment">// 检查缓存中的字节数</span></span><br><span class="line">    unflushedBufferSize := bufferedWriter.Buffered()</span><br><span class="line">    log.Printf(<span class="string">"Bytes buffered: %d\n"</span>, unflushedBufferSize)</span><br><span class="line">    <span class="comment">// 还有多少字节可用（未使用的缓存大小）</span></span><br><span class="line">    bytesAvailable := bufferedWriter.Available()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Available buffer: %d\n"</span>, bytesAvailable)</span><br><span class="line">    <span class="comment">// 写内存buffer到硬盘</span></span><br><span class="line">    bufferedWriter.Flush()</span><br><span class="line">    <span class="comment">// 丢弃还没有flush的缓存的内容，清除错误并把它的输出传给参数中的writer</span></span><br><span class="line">    <span class="comment">// 当你想将缓存传给另外一个writer时有用</span></span><br><span class="line">    bufferedWriter.Reset(bufferedWriter)</span><br><span class="line">    bytesAvailable = bufferedWriter.Available()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Available buffer: %d\n"</span>, bytesAvailable)</span><br><span class="line">    <span class="comment">// 重新设置缓存的大小。</span></span><br><span class="line">    <span class="comment">// 第一个参数是缓存应该输出到哪里，这个例子中我们使用相同的writer。</span></span><br><span class="line">    <span class="comment">// 如果我们设置的新的大小小于第一个参数writer的缓存大小， 比如10，我们不会得到一个10字节大小的缓存，</span></span><br><span class="line">    <span class="comment">// 而是writer的原始大小的缓存，默认是4096。</span></span><br><span class="line">    <span class="comment">// 它的功能主要还是为了扩容。</span></span><br><span class="line">    bufferedWriter = bufio.NewWriterSize(</span><br><span class="line">        bufferedWriter,</span><br><span class="line">        <span class="number">8000</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// resize后检查缓存的大小</span></span><br><span class="line">    bytesAvailable = bufferedWriter.Available()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Available buffer: %d\n"</span>, bytesAvailable)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-读取最多N个字节"><a href="#3-6-读取最多N个字节" class="headerlink" title="3.6 读取最多N个字节"></a>3.6 读取最多N个字节</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打开文件，只读</span></span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="comment">// 从文件中读取len(b)字节的文件。</span></span><br><span class="line">    <span class="comment">// 返回0字节意味着读取到文件尾了</span></span><br><span class="line">    <span class="comment">// 读取到文件会返回io.EOF的error</span></span><br><span class="line">    byteSlice := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">16</span>)</span><br><span class="line">    bytesRead, err := file.Read(byteSlice)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Number of bytes read: %d\n"</span>, bytesRead)</span><br><span class="line">    log.Printf(<span class="string">"Data read: %s\n"</span>, byteSlice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-读取正好N个字节"><a href="#3-7-读取正好N个字节" class="headerlink" title="3.7 读取正好N个字节"></a>3.7 读取正好N个字节</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Open file for reading</span></span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// file.Read()可以读取一个小文件到大的byte slice中，</span></span><br><span class="line">    <span class="comment">// 但是io.ReadFull()在文件的字节数小于byte slice字节数的时候会返回错误</span></span><br><span class="line">    byteSlice := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">2</span>)</span><br><span class="line">    numBytesRead, err := io.ReadFull(file, byteSlice)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Number of bytes read: %d\n"</span>, numBytesRead)</span><br><span class="line">    log.Printf(<span class="string">"Data read: %s\n"</span>, byteSlice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-读取至少N个字节"><a href="#3-8-读取至少N个字节" class="headerlink" title="3.8 读取至少N个字节"></a>3.8 读取至少N个字节</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打开文件，只读</span></span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    byteSlice := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">512</span>)</span><br><span class="line">    minBytes := <span class="number">8</span></span><br><span class="line">    <span class="comment">// io.ReadAtLeast()在不能得到最小的字节的时候会返回错误，但会把已读的文件保留</span></span><br><span class="line">    numBytesRead, err := io.ReadAtLeast(file, byteSlice, minBytes)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Number of bytes read: %d\n"</span>, numBytesRead)</span><br><span class="line">    log.Printf(<span class="string">"Data read: %s\n"</span>, byteSlice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-9-读取全部字节"><a href="#3-9-读取全部字节" class="headerlink" title="3.9 读取全部字节"></a>3.9 读取全部字节</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Open file for reading</span></span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// os.File.Read(), io.ReadFull(), and</span></span><br><span class="line">    <span class="comment">// io.ReadAtLeast() all work with a fixed</span></span><br><span class="line">    <span class="comment">// byte slice that you make before you read</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ioutil.ReadAll() will read every byte</span></span><br><span class="line">    <span class="comment">// from the reader (in this case a file),</span></span><br><span class="line">    <span class="comment">// and return a slice of unknown slice</span></span><br><span class="line">    data, err := ioutil.ReadAll(file)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"Data as hex: %x\n"</span>, data)</span><br><span class="line">    fmt.Printf(<span class="string">"Data as string: %s\n"</span>, data)</span><br><span class="line">    fmt.Println(<span class="string">"Number of bytes read:"</span>, <span class="built_in">len</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-10-快速读到内存中"><a href="#3-10-快速读到内存中" class="headerlink" title="3.10 快速读到内存中"></a>3.10 快速读到内存中</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 读取文件到byte slice中</span></span><br><span class="line">    data, err := ioutil.ReadFile(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Data read: %s\n"</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-11-使用缓存读"><a href="#3-11-使用缓存读" class="headerlink" title="3.11 使用缓存读"></a>3.11 使用缓存读</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打开文件，创建buffered reader</span></span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    bufferedReader := bufio.NewReader(file)</span><br><span class="line">    <span class="comment">// 得到字节，当前指针不变</span></span><br><span class="line">    byteSlice := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">5</span>)</span><br><span class="line">    byteSlice, err = bufferedReader.Peek(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Peeked at 5 bytes: %s\n"</span>, byteSlice)</span><br><span class="line">    <span class="comment">// 读取，指针同时移动</span></span><br><span class="line">    numBytesRead, err := bufferedReader.Read(byteSlice)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Read %d bytes: %s\n"</span>, numBytesRead, byteSlice)</span><br><span class="line">    <span class="comment">// 读取一个字节, 如果读取不成功会返回Error</span></span><br><span class="line">    myByte, err := bufferedReader.ReadByte()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Read 1 byte: %c\n"</span>, myByte)     </span><br><span class="line">    <span class="comment">// 读取到分隔符，包含分隔符，返回byte slice</span></span><br><span class="line">    dataBytes, err := bufferedReader.ReadBytes(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Read bytes: %s\n"</span>, dataBytes)           </span><br><span class="line">    <span class="comment">// 读取到分隔符，包含分隔符，返回字符串</span></span><br><span class="line">    dataString, err := bufferedReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Read string: %s\n"</span>, dataString)     </span><br><span class="line">    <span class="comment">//这个例子读取了很多行，所以test.txt应该包含多行文本才不至于出错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-12-使用-scanner"><a href="#3-12-使用-scanner" class="headerlink" title="3.12 使用 scanner"></a>3.12 使用 scanner</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// To define your own split function, match this fingerprint</span></span><br><span class="line"><span class="keyword">type</span> SplitFunc <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">Returning</span> <span class="params">(0, <span class="literal">nil</span>, <span class="literal">nil</span>)</span> <span class="title">will</span> <span class="title">tell</span> <span class="title">the</span> <span class="title">scanner</span></span></span><br><span class="line"><span class="function">// <span class="title">to</span> <span class="title">scan</span> <span class="title">again</span>, <span class="title">but</span> <span class="title">with</span> <span class="title">a</span> <span class="title">bigger</span> <span class="title">buffer</span> <span class="title">because</span></span></span><br><span class="line"><span class="function">// <span class="title">it</span> <span class="title">wasn</span>'<span class="title">t</span> <span class="title">enough</span> <span class="title">data</span> <span class="title">to</span> <span class="title">reach</span> <span class="title">the</span> <span class="title">delimiter</span></span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    scanner := bufio.NewScanner(file)</span><br><span class="line">    <span class="comment">// 缺省的分隔函数是bufio.ScanLines,我们这里使用ScanWords。</span></span><br><span class="line">    <span class="comment">// 也可以定制一个SplitFunc类型的分隔函数</span></span><br><span class="line">    scanner.Split(bufio.ScanWords)</span><br><span class="line">    <span class="comment">// scan下一个token.</span></span><br><span class="line">    success := scanner.Scan()</span><br><span class="line">    <span class="keyword">if</span> success == <span class="literal">false</span> &#123;</span><br><span class="line">        <span class="comment">// 出现错误或者EOF是返回Error</span></span><br><span class="line">        err = scanner.Err()</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">"Scan completed and reached EOF"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到数据，Bytes() 或者 Text()</span></span><br><span class="line">    fmt.Println(<span class="string">"First word found:"</span>, scanner.Text())</span><br><span class="line">    <span class="comment">// 再次调用scanner.Scan()发现下一个token</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4，压缩"><a href="#4，压缩" class="headerlink" title="4，压缩"></a>4，压缩</h2><h3 id="4-1-打包文件"><a href="#4-1-打包文件" class="headerlink" title="4.1 打包文件"></a>4.1 打包文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This example uses zip but standard library</span></span><br><span class="line"><span class="comment">// also supports tar archives</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"archive/zip"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Create a file to write the archive buffer to</span></span><br><span class="line">    <span class="comment">// Could also use an in memory buffer.</span></span><br><span class="line">    outFile, err := os.Create(<span class="string">"test.zip"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> outFile.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a zip writer on top of the file writer</span></span><br><span class="line">    zipWriter := zip.NewWriter(outFile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add files to archive</span></span><br><span class="line">    <span class="comment">// We use some hard coded data to demonstrate,</span></span><br><span class="line">    <span class="comment">// but you could iterate through all the files</span></span><br><span class="line">    <span class="comment">// in a directory and pass the name and contents</span></span><br><span class="line">    <span class="comment">// of each file, or you can take data from your</span></span><br><span class="line">    <span class="comment">// program and write it write in to the archive</span></span><br><span class="line">    <span class="comment">// without </span></span><br><span class="line">    <span class="keyword">var</span> filesToArchive = []<span class="keyword">struct</span> &#123;</span><br><span class="line">        Name, Body <span class="keyword">string</span></span><br><span class="line">    &#125; &#123;</span><br><span class="line">        &#123;<span class="string">"test.txt"</span>, <span class="string">"String contents of file"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"test2.txt"</span>, <span class="string">"\x61\x62\x63\n"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create and write files to the archive, which in turn</span></span><br><span class="line">    <span class="comment">// are getting written to the underlying writer to the</span></span><br><span class="line">    <span class="comment">// .zip file we created at the beginning</span></span><br><span class="line">    <span class="keyword">for</span> _, file := <span class="keyword">range</span> filesToArchive &#123;</span><br><span class="line">            fileWriter, err := zipWriter.Create(file.Name)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    log.Fatal(err)</span><br><span class="line">            &#125;</span><br><span class="line">            _, err = fileWriter.Write([]<span class="keyword">byte</span>(file.Body))</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    log.Fatal(err)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up</span></span><br><span class="line">    err = zipWriter.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-解压文件"><a href="#4-2-解压文件" class="headerlink" title="4.2 解压文件"></a>4.2 解压文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This example uses zip but standard library</span></span><br><span class="line"><span class="comment">// also supports tar archives</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"archive/zip"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"path/filepath"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    zipReader, err := zip.OpenReader(<span class="string">"test.zip"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> zipReader.Close()</span><br><span class="line">    <span class="comment">// 遍历打包文件中的每一文件/文件夹</span></span><br><span class="line">    <span class="keyword">for</span> _, file := <span class="keyword">range</span> zipReader.Reader.File &#123;</span><br><span class="line">        <span class="comment">// 打包文件中的文件就像普通的一个文件对象一样</span></span><br><span class="line">        zippedFile, err := file.Open()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> zippedFile.Close()</span><br><span class="line">        <span class="comment">// 指定抽取的文件名。</span></span><br><span class="line">        <span class="comment">// 你可以指定全路径名或者一个前缀，这样可以把它们放在不同的文件夹中。</span></span><br><span class="line">        <span class="comment">// 我们这个例子使用打包文件中相同的文件名。</span></span><br><span class="line">        targetDir := <span class="string">"./"</span></span><br><span class="line">        extractedFilePath := filepath.Join(</span><br><span class="line">            targetDir,</span><br><span class="line">            file.Name,</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// 抽取项目或者创建文件夹</span></span><br><span class="line">        <span class="keyword">if</span> file.FileInfo().IsDir() &#123;</span><br><span class="line">            <span class="comment">// 创建文件夹并设置同样的权限</span></span><br><span class="line">            log.Println(<span class="string">"Creating directory:"</span>, extractedFilePath)</span><br><span class="line">            os.MkdirAll(extractedFilePath, file.Mode())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//抽取正常的文件</span></span><br><span class="line">            log.Println(<span class="string">"Extracting file:"</span>, file.Name)</span><br><span class="line">            outputFile, err := os.OpenFile(</span><br><span class="line">                extractedFilePath,</span><br><span class="line">                os.O_WRONLY|os.O_CREATE|os.O_TRUNC,</span><br><span class="line">                file.Mode(),</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatal(err)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">defer</span> outputFile.Close()</span><br><span class="line">            <span class="comment">// 通过io.Copy简洁地复制文件内容</span></span><br><span class="line">            _, err = io.Copy(outputFile, zippedFile)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatal(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-压缩文件"><a href="#4-3-压缩文件" class="headerlink" title="4.3 压缩文件"></a>4.3 压缩文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个例子中使用gzip压缩格式，标准库还支持zlib, bz2, flate, lzw</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"compress/gzip"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    outputFile, err := os.Create(<span class="string">"test.txt.gz"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    gzipWriter := gzip.NewWriter(outputFile)</span><br><span class="line">    <span class="keyword">defer</span> gzipWriter.Close()</span><br><span class="line">    <span class="comment">// 当我们写如到gizp writer数据时，它会依次压缩数据并写入到底层的文件中。</span></span><br><span class="line">    <span class="comment">// 我们不必关心它是如何压缩的，还是像普通的writer一样操作即可。</span></span><br><span class="line">    _, err = gzipWriter.Write([]<span class="keyword">byte</span>(<span class="string">"Gophers rule!\n"</span>))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">"Compressed data written to file."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解压缩文件"><a href="#解压缩文件" class="headerlink" title="解压缩文件"></a>解压缩文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个例子中使用gzip压缩格式，标准库还支持zlib, bz2, flate, lzw</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"compress/gzip"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打开一个gzip文件。</span></span><br><span class="line">    <span class="comment">// 文件是一个reader,但是我们可以使用各种数据源，比如web服务器返回的gzipped内容，</span></span><br><span class="line">    <span class="comment">// 它的内容不是一个文件，而是一个内存流</span></span><br><span class="line">    gzipFile, err := os.Open(<span class="string">"test.txt.gz"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    gzipReader, err := gzip.NewReader(gzipFile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> gzipReader.Close()</span><br><span class="line">    <span class="comment">// 解压缩到一个writer,它是一个file writer</span></span><br><span class="line">    outfileWriter, err := os.Create(<span class="string">"unzipped.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> outfileWriter.Close()</span><br><span class="line">    <span class="comment">// 复制内容</span></span><br><span class="line">    _, err = io.Copy(outfileWriter, gzipReader)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5，其它"><a href="#5，其它" class="headerlink" title="5，其它"></a>5，其它</h2><h3 id="5-1-临时文件和目录"><a href="#5-1-临时文件和目录" class="headerlink" title="5.1 临时文件和目录"></a>5.1 临时文件和目录</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">     <span class="string">"os"</span></span><br><span class="line">     <span class="string">"io/ioutil"</span></span><br><span class="line">     <span class="string">"log"</span></span><br><span class="line">     <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="comment">// 在系统临时文件夹中创建一个临时文件夹</span></span><br><span class="line">     tempDirPath, err := ioutil.TempDir(<span class="string">""</span>, <span class="string">"myTempDir"</span>)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Fatal(err)</span><br><span class="line">     &#125;</span><br><span class="line">     fmt.Println(<span class="string">"Temp dir created:"</span>, tempDirPath)</span><br><span class="line">     <span class="comment">// 在临时文件夹中创建临时文件</span></span><br><span class="line">     tempFile, err := ioutil.TempFile(tempDirPath, <span class="string">"myTempFile.txt"</span>)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Fatal(err)</span><br><span class="line">     &#125;</span><br><span class="line">     fmt.Println(<span class="string">"Temp file created:"</span>, tempFile.Name())</span><br><span class="line">     <span class="comment">// ... 做一些操作 ...</span></span><br><span class="line">     <span class="comment">// 关闭文件</span></span><br><span class="line">     err = tempFile.Close()</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除我们创建的资源</span></span><br><span class="line">     err = os.Remove(tempFile.Name())</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">     err = os.Remove(tempDirPath)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-通过HTTP下载文件"><a href="#5-2-通过HTTP下载文件" class="headerlink" title="5.2 通过HTTP下载文件"></a>5.2 通过HTTP下载文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">     <span class="string">"os"</span></span><br><span class="line">     <span class="string">"io"</span></span><br><span class="line">     <span class="string">"log"</span></span><br><span class="line">     <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">     newFile, err := os.Create(<span class="string">"devdungeon.html"</span>)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Fatal(err)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">defer</span> newFile.Close()</span><br><span class="line">     url := <span class="string">"http://www.devdungeon.com/archive"</span></span><br><span class="line">     response, err := http.Get(url)</span><br><span class="line">     <span class="keyword">defer</span> response.Body.Close()</span><br><span class="line">     <span class="comment">// 将HTTP response Body中的内容写入到文件</span></span><br><span class="line">     <span class="comment">// Body满足reader接口，因此我们可以使用ioutil.Copy</span></span><br><span class="line">     numBytesWritten, err := io.Copy(newFile, response.Body)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Fatal(err)</span><br><span class="line">     &#125;</span><br><span class="line">     log.Printf(<span class="string">"Downloaded %d byte file.\n"</span>, numBytesWritten)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-哈希和摘要"><a href="#5-3-哈希和摘要" class="headerlink" title="5.3 哈希和摘要"></a>5.3 哈希和摘要</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/md5"</span></span><br><span class="line">    <span class="string">"crypto/sha1"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"crypto/sha512"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 得到文件内容</span></span><br><span class="line">    data, err := ioutil.ReadFile(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算Hash</span></span><br><span class="line">    fmt.Printf(<span class="string">"Md5: %x\n\n"</span>, md5.Sum(data))</span><br><span class="line">    fmt.Printf(<span class="string">"Sha1: %x\n\n"</span>, sha1.Sum(data))</span><br><span class="line">    fmt.Printf(<span class="string">"Sha256: %x\n\n"</span>, sha256.Sum256(data))</span><br><span class="line">    fmt.Printf(<span class="string">"Sha512: %x\n\n"</span>, sha512.Sum512(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/md5"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="comment">//创建一个新的hasher,满足writer接口</span></span><br><span class="line">    hasher := md5.New()</span><br><span class="line">    _, err = io.Copy(hasher, file)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算hash并打印结果。</span></span><br><span class="line">    <span class="comment">// 传递 nil 作为参数，因为我们不通参数传递数据，而是通过writer接口。</span></span><br><span class="line">    sum := hasher.Sum(<span class="literal">nil</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"Md5 checksum: %x\n"</span>, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6，参考"><a href="#6，参考" class="headerlink" title="6，参考"></a>6，参考</h2><ul><li><a href="https://www.devdungeon.com/content/working-files-go" target="_blank" rel="noopener">Working with Files in Go</a></li><li><a href="https://golang.org/pkg" target="_blank" rel="noopener">Go Standard Library Documentation</a></li><li><a href="https://www.linux.com/learn/understanding-linux-file-permissions" target="_blank" rel="noopener">understanding-linux-file-permissions</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>一些生活好习惯</title>
    <url>/2019/02/23/life-good-habit/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><p>又是一个周末，又是晚睡晚起，早饭随便吃一点，总说着要注意休息，但总不当回事。</p><p>在此立一个flag，从今天起，如果不是特别紧急的事情，哪怕留到明天去做，我也一定要早点睡觉！！！</p><h2 id="每天要做"><a href="#每天要做" class="headerlink" title="每天要做"></a>每天要做</h2><ul><li><p>晚上十点前准时上床睡觉，早上六点起床。</p></li><li><p>坚持吃早饭，鸡蛋牛奶蔬菜面包水果玉米糊糊都行，吃六分饱即可。</p></li><li><p>上班骑车，或走路，锻炼身体，公司离住处很近，所以不要太急，过马路看红绿灯，礼让行人。</p></li><li><p>早上坚持练习英语口语，背记英语单词。</p></li><li><p>到了工作时间，先把工作上的事情做完，再做其他的。</p></li><li><p>中午保证半小时的睡眠时间，不玩手机。</p></li><li><p>完成一个<code>LeetCode</code>上的编程题。</p></li><li><p>出门前对自己一个微笑。</p></li><li><p>写日记。</p></li></ul><h2 id="每周要做"><a href="#每周要做" class="headerlink" title="每周要做"></a>每周要做</h2><ul><li><p>去健身房锻炼身体三次，跑步，肌肉练习均可。</p></li><li><p>至少完成一个ARTS。</p></li><li><p>和家里人打电话，对他们说我很好；和伶儿通个电话，并告诉她我很想你。</p></li><li><p>去吃点好吃的，见一见朋友，放松身心。</p></li></ul><h2 id="每月要做"><a href="#每月要做" class="headerlink" title="每月要做"></a>每月要做</h2><ul><li><p>做总结。</p></li><li><p>读完一本科普或小说。</p></li></ul><h2 id="每年要做"><a href="#每年要做" class="headerlink" title="每年要做"></a>每年要做</h2><ul><li><p>去一个自己从没去过的地方。</p></li><li><p>回家陪父母聊聊天。</p></li></ul><p><img src="/2019/02/23/life-good-habit/flower.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>健康</tag>
      </tags>
  </entry>
  <entry>
    <title>当你孤单时你会想起谁</title>
    <url>/2019/02/22/when-you-lonely-remand-who/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><p>这一周，我提前一天完成了我的任务，用<code>Golang</code>给视频转码写了个小工具，复习了二进制基础，文件操作和<code>Golang</code>基本语法。</p><p>下午，一位朋友and他女友来看我，一起吃了顿冒菜，让我这平淡的周末多了份意料之外的喜悦。</p><h2 id="亲爱的，你怎么不在我身边"><a href="#亲爱的，你怎么不在我身边" class="headerlink" title="亲爱的，你怎么不在我身边"></a>亲爱的，你怎么不在我身边</h2><p>距离上次会合已经过去一个月，却让我感觉如昨日。</p><p>想起我们一起看过日出，站在塔里木大桥上看日落，在乌鲁木齐大冬天跑出去看电影吃麻辣小龙虾，去西安吃酿皮和肉夹馍，到成都看熊猫。</p><p>可是，这个周末，亲爱的你为什么不在我身边。</p><h2 id="当你孤单时你会想起谁"><a href="#当你孤单时你会想起谁" class="headerlink" title="当你孤单时你会想起谁"></a>当你孤单时你会想起谁</h2><p>想起远在乌鲁木齐的父母，从此养成了报喜不报忧的“好习惯”；</p><p>想起远在厦门的凡儿，没事调侃两句，解解闷；</p><p>想起远在家里蹲的羊纪元，吹吹牛释放下压力；</p><p>想起远在西安做销售的魁拔，高中时教我弹吉他和护肤，在QQ炫舞上一同唱着《老男孩》；</p><h2 id="我要你在我身旁"><a href="#我要你在我身旁" class="headerlink" title="我要你在我身旁"></a>我要你在我身旁</h2><p>你说你毕设答辩结束就坐飞机来成都，我想起去年我也说，我答完辩把论文材料提交完毕立马坐最近的一趟飞机去成都找你，顺便把offer拿了。</p><p>现在过了一年，角色互换，我相信，我们的异地恋接近尾声。</p><p>我在成都等你。</p><p><img src="/2019/02/22/when-you-lonely-remand-who/wait.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>孤单</tag>
        <tag>思念</tag>
      </tags>
  </entry>
  <entry>
    <title>放假归来上班综合症</title>
    <url>/2019/02/12/return-to-work-after-vacation/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><p>春节结束，放假归来，已在公司上班两天。</p><p>向公司行政部申请买了块8G台式机内存条，额头上又隐约在冒痘痘了，半年过去了，难道还没有适应南方的气候？</p><p>伶儿说她明天早上七点就到乌鲁木齐了，距离我们下次见面就是她在学校答辩完，五月底六月初的样子。下次重逢，不要再分开了好吗？</p><p>哈哈，突然觉得自己好矫情，说这些。</p><p>昨天浑身酸痛，什么也不想做。今天试着看了些技术书，看不进去里面的概念，试着刷了几道LeetCode关于数组的题目，收获还行。</p><p>又要开始程序化的生活了，早起-骑车-工作-看书-下班-玩/学习-睡觉，如此循环。</p><p>好想做一些白日梦骗自己几分钟，又感到幼稚。</p><p>乱七八糟的写了些话，记录放假归来后内心烦躁的情绪。</p><p>不管怎样，生活还得继续，世界还等着我创造奇迹。</p><p><img src="/2019/02/12/return-to-work-after-vacation/dark.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>放假</tag>
      </tags>
  </entry>
  <entry>
    <title>提问学习带给我的收获</title>
    <url>/2019/02/01/ask-questions-learn-bring-me-harvest/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><p>写以此文，记录我这三天（1.30-2.1）的收获和感悟。</p><p>上周把一个定时删除的服务的版本提交了，本以为在过年前的一周基本没什么事了。然而部门老哥告诉我，之前我负责的一个流媒体服务还存在两处bug</p><ul><li><p>不支持多用户同时拉取视频流；</p></li><li><p>不支持重新连接；</p></li></ul><p>所以这周我又忙着修改bug,然而在前两天，我还是束手无策，找不到应对方案，一筹莫展。</p><p>到了第三天老哥带我一步步熟悉整体流程，细致到每个函数，每个入参，以及每个重要的代码。不断的提问，不断的思考，再不断的提出新的问题，时间过得飞快，我也饿得快。不过最终还是蛮开心的，通过这两处bug，让我重新回顾了流媒体服务的整体工作流程，以及Go语言中对<code>goroutine</code>和<code>channel</code>机制，印象最深的是以下两点：</p><h3 id="管道中的-lt"><a href="#管道中的-lt" class="headerlink" title="管道中的&lt;-"></a>管道中的<code>&lt;-</code></h3><p>简单来说就是这样子的：接受者&lt;-发送者。</p><p>然而中间会多个管道，所以我借用Go语言圣经中的三处例子做解释</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- x  <span class="comment">// x作为发送者发送给管道</span></span><br><span class="line">x = &lt;-ch <span class="comment">// 管道作为发送者发送数据给接受者x</span></span><br><span class="line">&lt;-ch  <span class="comment">// 管道发送数据，没有接收者，丢弃，同时造成管道堵塞，等待接收者</span></span><br></pre></td></tr></table></figure><p>所以我们可以具体化刚才说的发送接收流程，它应该为：接收者 &lt;- 管道 &lt;- 发送者。如果缺了接收者或发送者，都会造成管道堵塞。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>举个例子</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">mu sync.Mutex   <span class="comment">// guards balance</span></span><br><span class="line">balance <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    balance = balance + amount</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    b := balance</span><br><span class="line">    mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先Lock锁住，再使用Unlock解锁。</p><p>如果Lock中再套一个Lock，就会造成死锁，需要将前一个Lock解开才行。</p><h3 id="dlv调试流程"><a href="#dlv调试流程" class="headerlink" title="dlv调试流程"></a>dlv调试流程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,./dlv debug xxxx(程序名)  ##启动dlv调试</span><br><span class="line"></span><br><span class="line">2,r(restart)  </span><br><span class="line"></span><br><span class="line">3,c(continue)</span><br><span class="line"></span><br><span class="line">4,b(break)   ##打断点，可以打函数名，也可以打文件下对应的行号</span><br><span class="line"></span><br><span class="line">5,n(next)或s(step)  ##n按一次单步执行，后面只需一直按回车；遇到需要深究的函数按s进去查看</span><br><span class="line">##如果碰到多线程，建议在线程内打个断点</span><br><span class="line"></span><br><span class="line">6,bt(stack)  ##查看堆栈</span><br><span class="line"></span><br><span class="line">7,frame  ##查看指定堆栈的内容</span><br><span class="line"></span><br><span class="line">8,q(exit)     ##退出调试</span><br></pre></td></tr></table></figure><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li><p>接触一个新东西，除了保证理解了流程，还要对每个函数的作用，影响范围都要了然于胸才行；</p></li><li><p>流程这东西，光知道不行，最好的办法是自己画个流程图出来，一步步跟着代码走；</p></li><li><p>IDE有时会因为环境参数或内在bug而报错，所以推荐使用dlv(针对go)和gdb进行调试；</p></li><li><p>多对自己提几个为什么，有助于理解技术的本质；</p></li><li><p>心态放平和，坦然接受bug和不足，耐心寻求突破。</p></li></ul><p>最后附一组测试成功的图片^_^</p><p><img src="/2019/02/01/ask-questions-learn-bring-me-harvest/%E8%83%8C%E5%BD%B1.png" alt></p><p><img src="/2019/02/01/ask-questions-learn-bring-me-harvest/%E5%9B%BE.png" alt></p><p><img src="/2019/02/01/ask-questions-learn-bring-me-harvest/%E7%AC%91.png" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>Go</tag>
        <tag>收获</tag>
        <tag>提问</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-面试题3-数组中重复的数字-题目一</title>
    <url>/2019/01/27/sword-to-offer-03/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h3 id="题目一：找出数组中重复的数字"><a href="#题目一：找出数组中重复的数字" class="headerlink" title="题目一：找出数组中重复的数字"></a>题目一：找出数组中重复的数字</h3><p>在一个长度为n的数组里的所有数字都在0~n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>1，先把输入的数组排序；</p><ul><li>从头到尾扫描排序后的数组。排序一个长度为n的数组需要O(nlogn)的时间。</li></ul><p>2，利用哈希表；</p><p>3，根据数组下表找重复数字；(过程会在后面详细写出)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] &lt; <span class="number">0</span> || numbers[i] &gt; length - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(numbers[i] != i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == numbers[numbers[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                *duplication = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换numbers[i]和numbers[numbers[i]]        </span></span><br><span class="line">            <span class="keyword">int</span> temp = numbers[i];</span><br><span class="line">            numbers[i] = numbers[temp];</span><br><span class="line">            numbers[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><ul><li><p>对一维数组的理解。一维数组在内存中占据连续的空间，因此我们可以根据下标定位对应的元素。</p></li><li><p>学会通过具体例子找出其中的规律。</p></li></ul><p><a href="https://github.com/OctopusLian/CodingInterviewChinese2/blob/master/03_01_DuplicationInArray/FindDuplication.cpp" target="_blank" rel="noopener">本题源代码</a></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>刷题的步伐</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>数组</tag>
        <tag>数字</tag>
      </tags>
  </entry>
  <entry>
    <title>公司年会收获</title>
    <url>/2019/01/27/company-annual-meeting-harvest/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><p>2019年1月23日，我参加了公司的年会彩排+表演。</p><p>此次年会收获如下：</p><ul><li>成功站在舞池中央，C位出道！</li><li>步伐放慢一点，脚印踩实一些。</li><li>有激情，才能带动一批人。</li><li>再多坚持一会儿。</li></ul><p><img src="/2019/01/27/company-annual-meeting-harvest/center.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>收获</tag>
        <tag>年会</tag>
      </tags>
  </entry>
  <entry>
    <title>重新正视自己的知识焦虑</title>
    <url>/2019/01/21/agagin-face-my-knowledge-anxiety/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><p>今天在豆瓣上看到一篇文章，分享一下：<a href="https://www.douban.com/note/704294887/" target="_blank" rel="noopener">高效学习成长的丰沃土壤长什么样</a></p><h2 id="与知识付费的相识"><a href="#与知识付费的相识" class="headerlink" title="与知识付费的相识"></a>与知识付费的相识</h2><p>记得是大二的时候，下载了得到app，打开后看到里面琳琅满目的付费专栏，内容主要涉及管理学，经济学，科技和做人做事，价格基本是199元/年，我说“好贵！学生党买不起。”</p><p>后来经不住app里对专栏的介绍，我买了下吴军的《硅谷来信》，想跟着专栏学习下大师的思考方式和处世之道。不得不说，大师思考问题的维度和方式的确与我们不一样，因此拓宽了我的知识面，于是在一年后，我又坚持订阅了他的《谷歌方法论》。</p><p>再到后来大学毕业，我做了和服务器开发和算法相关的工作，在工作中深深感受到基础知识的匮乏，这时候一款名叫极客时间的app映入眼帘，在这里我看了相关介绍，陆续订阅了《数据结构与算法之美》和《程序员的基础数学》两个专栏。</p><p>还有其他类似的知识付费栏目，比如简书的付费阅读原创小说最后30%的章节内容；GitChat；知识星球。</p><h2 id="为什么需要付费"><a href="#为什么需要付费" class="headerlink" title="为什么需要付费"></a>为什么需要付费</h2><p>曾经我很纳闷，这些知识网上都可以找到的，为什么还需要知识付费呢？</p><p>我想主要原因有以下几个方面：</p><ul><li>作者辛辛苦苦写出来的，我们总要回馈一些财富出来；（20%）</li><li>网上内容良莠不齐，而作者是一路走过来的，因此有经验，会帮你整理出来，让你少走弯路；（60%）</li><li>对版权的一种保护；（20%）</li></ul><p>所以归根结底，是我们对获取知识的途径比较匮乏，需要有个人（比如专栏作者）把自己的学习心得和经验共享出来，供需要的人吸收，那么问题又来了，你吸收的这些知识，就一定是正确且有用的吗？</p><h2 id="正视焦虑"><a href="#正视焦虑" class="headerlink" title="正视焦虑"></a>正视焦虑</h2><p>我是一个喜欢有成就感持续驱动学习的人，这种成就感不是满足于一群人对我说“大佬 666”，而是每解决一个bug或close一个issue，搞懂一个模块的功能或者比昨天对框架有了更深入的理解。</p><p>然而，当我逐渐在学习底层的时候，我就会愈发现知识的不足，例如并发编程的原理，常用算法的核心思想，模块功能类比上的失误，以及对协议的认知偏差等等，这时候我很想一步登天，例如狂刷CSAPP，算法，但此时我已经产生了知识焦虑，犯了欲速则不达的错误。</p><h2 id="学会分辨正确但无用的知识"><a href="#学会分辨正确但无用的知识" class="headerlink" title="学会分辨正确但无用的知识"></a>学会分辨正确但无用的知识</h2><p>“学会分辨正确但无用的知识”——这时一位前辈给我提的建议。</p><p>现在，我终于明白了这句话的含义。</p><p>无用，其实绝大多数是因为自己没有经过深度思考，只是别人告诉你，有这么个知识，你可以拿来套用和当谈资。但是这个知识到底有什么用，在什么场合下适用，都是要经过自己思考和实践出来的。</p><h2 id="一个小例子"><a href="#一个小例子" class="headerlink" title="一个小例子"></a>一个小例子</h2><p>我有位高中玩的很要好的朋友，我当时总会调侃他的英语，然而我很佩服他的数学，虽然我做的数学题比他多，周末还报了数学辅导班，但是每当考试时，他都比我考的高。</p><p>我私下请教他学习数学的方法，他说你做题只满足做对就行，却没有从出题人的角度思考这道题，而我做这道题只花了五分钟，想这道题背后的用意以及举一反三的过程却花了我45分钟的时间。</p><p>的确，他经过深度思考了，所以知识是他的，而我是花钱（买课外资料，报辅导班）买了别人的解题思路，走了个捷径，现在想想，其实是走了弯路。</p><h2 id="关于知识焦虑的感触"><a href="#关于知识焦虑的感触" class="headerlink" title="关于知识焦虑的感触"></a>关于知识焦虑的感触</h2><ul><li><p>正视自己的焦虑，因为有焦虑，所以才有强烈的求知欲和学习的动力；</p></li><li><p>集中自己的时间和注意力，对枯燥的原理和底层的知识，进行深度思考；</p></li><li><p>对那种表面业务逻辑部分，花最少的时间把它做好，后面就抽更少的时间维护即可；</p></li><li><p>从源头开始阅读，尽量获取第一手的资料；</p></li><li><p>正视自己的不足，扎扎实实一步一个脚印坚持走下去；</p></li></ul><p>GOOD LUCK !</p><p><img src="/2019/01/21/agagin-face-my-knowledge-anxiety/alone.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>感悟</tag>
        <tag>知识付费</tag>
        <tag>焦虑</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_面试题1_赋值运算符函数</title>
    <url>/2019/01/17/sword-to-offer-01/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如下为类型CMyString的声明，请为该类型添加赋值运算符函数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span>* pData = <span class="literal">nullptr</span>);</span><br><span class="line">    CMyString(<span class="keyword">const</span> CMystring &amp;str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>关注点如下：</p><ul><li>是否把返回值的类型声明为该类型的引用，并在函数结束前返回实例自身的引用(*this)。</li><li>是否把传入的参数的类型声明为常量引用。</li><li>是否释放实例自身已有的内存。</li><li>判断传入的参数和当前的实例(*this)是不是同一个实例。</li></ul><h2 id="Show-Code"><a href="#Show-Code" class="headerlink" title="Show Code"></a>Show Code</h2><h3 id="经典，初级解法"><a href="#经典，初级解法" class="headerlink" title="经典，初级解法"></a>经典，初级解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span> = (<span class="keyword">const</span> CMyString &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">//返回实例自身的引用</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> []m_pData;</span><br><span class="line">    m_pData = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_pData,str.m_pData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><ul><li>C++基础语法，如运算符函数、常量引用；</li><li>对内存泄露的理解</li></ul><p><a href="https://github.com/OctopusLian/CodingInterviewChinese2/tree/master/01_AssignmentOperator" target="_blank" rel="noopener">本题源代码</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.cplusplus.com/reference/cstring/strcpy/" target="_blank" rel="noopener">cpp函数_strcpy</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>刷题的步伐</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>低调成长</title>
    <url>/2019/01/17/low-growth/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="意外惊喜"><a href="#意外惊喜" class="headerlink" title="意外惊喜"></a>意外惊喜</h2><p>这段时间有两个意外发生在我的身上</p><h3 id="头条邀请"><a href="#头条邀请" class="headerlink" title="头条邀请"></a>头条邀请</h3><p>下午打开Gmail邮箱，意外发现了除了Medium的推送外，还夹带着一封头条后端开发岗的邀请…<br><img src="/2019/01/17/low-growth/%E5%A4%B4%E6%9D%A1%E9%9D%A2%E8%AF%95.png" alt></p><h3 id="写书邀请"><a href="#写书邀请" class="headerlink" title="写书邀请"></a>写书邀请</h3><p>除了面试邀请，还在前段时间在博客园上收到了一家北京出版社编辑发的写开发实战书籍的邀请。<br>（写书曾经想过写，但不是现在写，因为技术还没有积淀下来，写了也是浪费精力和纸张）</p><h2 id="低调成长"><a href="#低调成长" class="headerlink" title="低调成长"></a>低调成长</h2><p>想起两年前我大二，对于这样的邀请我是可望而不可即的，因为技术太渣，校招时四轮笔试做了一塌糊涂。<br>但是，当现在机会摆在我的面前时，我不禁想问下自己，现在接受真的合适吗？<br>最好的目前并不一定适合自己。<br>现在的还处于学习上升期阶段，除了在部门内负责流媒体服务外，还要学习网络，数据库和算法相关知识，需要巩固C/C++和Go语言编程；不断的接受一些有挑战性的任务，在踩坑和写Bug中茁壮成长。<br>我一直相信，只要自己坚持做一件认为对的事情，培养成一个习惯（例如写日记，早起晨练，学习），那么这就是个如蛹化蝶的过程，最终将会振翅飞翔。<br><img src="/2019/01/17/low-growth/%E8%8A%B1%E6%B5%B7.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>惊喜</tag>
      </tags>
  </entry>
  <entry>
    <title>2019年计划要做的事</title>
    <url>/2019/01/15/2019-demand-do-something/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:22 GMT+0800 (CST) --><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>目前了解到的会涉及以下方面：</p><ul><li>流媒体服务<br>以Go语言为主；熟练掌握TCP/IP，HTTP原理；常用的MySQL和Redis数据库用法。</li><li>视音频编解码<br>C/C++语言为主；</li><li>图形图像<br>C/C++语言，OpenGL；OpenCV。</li></ul><h2 id="业余安排"><a href="#业余安排" class="headerlink" title="业余安排"></a>业余安排</h2><p>业余时间计划完成以下事情：</p><h3 id="附加技能"><a href="#附加技能" class="headerlink" title="附加技能"></a>附加技能</h3><ul><li>熟悉JavaScript，争取能完成一个在线简历模板；</li><li>熟练Java语言，希望能接1-2个毕设赚些零花钱；</li><li>LeetCode每周一题；</li></ul><h3 id="阅读提升"><a href="#阅读提升" class="headerlink" title="阅读提升"></a>阅读提升</h3><ul><li>极客时间上的四个专栏（左耳听风，趣谈网络，数据结构算法，数学基础）研读；</li><li>开始阅读大部头经典书籍，例如CSAPP和UNP，并认真完成章节的课后练习题；</li><li>Medium上争取两周内翻译一篇和自己学习工作相关的技术文章；</li><li>每天半小时学习口语；</li></ul><h3 id="培养兴趣爱好"><a href="#培养兴趣爱好" class="headerlink" title="培养兴趣爱好"></a>培养兴趣爱好</h3><ul><li>学习下拍照摄影，争取给女友拍出美美的照片～</li><li>继续在健身房练习街舞，希望今年可以练出托马斯回旋和大风车；</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>继续维护我的英语学习项目<a href="https://github.com/OctopusLian/VocabularyMap" target="_blank" rel="noopener">VocabularyMap</a>，争取在九月底国庆前完成词根词汇的拓展并加上中文释义。</li><li>继续坚持创作，幻想和思考。</li></ul><p><img src="/2019/01/15/2019-demand-do-something/%E5%8A%A0%E6%B2%B9.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>计划</tag>
        <tag>兴趣</tag>
      </tags>
  </entry>
  <entry>
    <title>新的开始</title>
    <url>/2019/01/14/new-begin/</url>
    <content><![CDATA[<!-- build time:Sun Jun 07 2020 22:58:23 GMT+0800 (CST) --><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>大家好，我的网名叫不会飞的章鱼（Zoctopus Zhang），活跃在简书、豆瓣、博客园和Github上，之前在博客园上坚持写技术博客长达两年半，截止目前已发布了两百多篇文章共23万人+的访问量，同时在简书上写文章积累了有十二万余字。然而，我一直很想创建一个自己的Blog，记录一些平时工作和生活上的收获和心得。<br>今天这个愿望终于实现了，在此我很感谢我的好友冰水鉴心的远程帮助。</p><h2 id="接下来准备做什么"><a href="#接下来准备做什么" class="headerlink" title="接下来准备做什么"></a>接下来准备做什么</h2><p>我本科学的专业是计算机科学与技术，2018年6月毕业后在一家上市游戏公司做了三个月的游戏服务器开发，之后因工作原因转行，目前主要做流媒体服务和与视音频相关的图形图像。<br>我想把我在工作中的学习心得和生活上的感悟记录下来。</p><h2 id="那么，现在就开始吧"><a href="#那么，现在就开始吧" class="headerlink" title="那么，现在就开始吧"></a>那么，现在就开始吧</h2><p>我不知道这条路我会走多远，但我至今不后悔我做出的每一个选择。因为我知道：念念不忘，必有回响。</p><p><img src="/2019/01/14/new-begin/%E5%85%89%E6%99%95.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>开始</tag>
      </tags>
  </entry>
</search>

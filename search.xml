<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>博客尘埃落定</title>
    <url>/2019/10/13/%E5%8D%9A%E5%AE%A2%E5%B0%98%E5%9F%83%E8%90%BD%E5%AE%9A/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><p>2019年1月停更博客园，到现在为止已经接近十个月了。</p><p>在此期间试过<code>冰水鉴心</code>给我推荐的<code>hexo</code>，<code>ghost</code>这些风格的博客，最终从经济和简约的角度，选择了<code>hexo</code>。感谢他的热心帮助和答疑。</p><p>在搭建博客的过程，我发现前端真是很有意思，也许是给我带来的持续反馈机制吧。所以后面不光要关注后端和底层，可以适当去学习下前端的知识。</p><p>目前博客风格已尘埃落定，以后计划所有的学习收获和感想都优先发布在这里。</p><p>最后感谢<code>枫林无归</code>老哥给我推荐的插件。</p><p>明天又是崭新的一天，坚持。</p><h3 id="2019年10月18日更新"><a href="#2019年10月18日更新" class="headerlink" title="2019年10月18日更新"></a>2019年10月18日更新</h3><p>感谢@枫林无归提供的<code>hexo-plugin-gitalk</code>插件。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>乐山一日游</title>
    <url>/2019/09/15/%E4%B9%90%E5%B1%B1%E4%B8%80%E6%97%A5%E6%B8%B8/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h2 id="启程准备"><a href="#启程准备" class="headerlink" title="启程准备"></a>启程准备</h2><p>启程时间：9月15日早上，从成都到乐山坐高铁只需要50分钟。<br>所需物品：手机，钱包（身份证，零钱，车票），充电宝，充电线，雨伞，水杯，零食</p><h2 id="开始旅行"><a href="#开始旅行" class="headerlink" title="开始旅行"></a>开始旅行</h2><p>到乐山站后，先导航去芳芳家翘脚牛肉店吃午饭，然而到那时正好到了饭点，门口排起了长队，我预估到我至少要两个小时以上，于是放弃，买了个烧饼吃，接着前往下一个小吃街。</p><a id="more"></a><p>然而去了下一个小吃街，甜皮鸭店门口排起了长队，我看甜皮鸭以斤算价（一斤最便宜要30元），基本是按一只起卖，女朋友说太腻了，不排了，于是去四方豆腐店（排了三十多人）和小豆海棠（排了八个人），结果也排起了队，放弃。最后去了一家豆腐脑店，店了一碗牛肉粉，一晚牛肉豆腐脑，一碗水果冰粉，很好吃。</p><p>接下来坐车去乐山大佛，比较坑的是，乐山大佛的售票处离乐山大佛入口有一公里远，所以下次去的话，建议到乐山大佛入口处买票，成人价80元/人。<br>进了乐山大佛入口后，先是一个大大的佛字映入眼帘，接着就是爬台阶，如果要听讲解的话，可以请个导游，或者扫旁边的二维码花10元买个语音讲解。爬了半个多小时到达山上，看大了乐山大佛的头，不得不说，场景确实让人震撼，不过更让我震撼的是许多人排队去走栈道，不知道是去干嘛，据说是近距离欣赏大佛，无奈我又选择了放弃。逛了一会，然后下山去吃晚饭。</p><p>坐公交抵达另一处小吃街，比较出名的是叶婆婆和黄鸡肉两家钵钵鸡店，但是门口排着队，我换了一家档次也算不错的在吃，期间也品尝了下烧麦，个人觉得就是饺子的缩小版。吃了六分饱后，去了张公桥小吃街，买了酥肉咔饼（感觉就是肉夹馍），叶儿粑，味道不错。</p><p>吃完这些已经是晚上八点，于是我和女朋友坐公交赶去乐山站坐回成都的高铁。结果在公交车上人太多，我转了个身发现一位老大爷从我后面快速把手缩了回去，我猜测可能是人太多把他手卡住了吧，但我觉得不对劲，把书包翻过来正手拿着，结果发现我书包被拉开了半个口，接着刚好到站了那位缩手回去的老大爷也下车了，我检查了下包内的东西，没有少。</p><h2 id="旅行收获"><a href="#旅行收获" class="headerlink" title="旅行收获"></a>旅行收获</h2><ul><li>超过半小时需要步行到达的地方，最好选择共享单车或公交。</li><li>去看景点时如果不想请导游可以下个语音讲解。</li><li>防人之心不可无。</li><li>学会拍照很重要。</li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>Ubuntu18.04升级Go版本</title>
    <url>/2019/08/15/Ubuntu18-04%E5%8D%87%E7%BA%A7Go%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>因为我本机系统上的Go版本是<code>10.4</code>的，不支持<code>Go Module</code>，想升级到最新的<code>go12.7</code>。</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="1，先下载最新的源码文件"><a href="#1，先下载最新的源码文件" class="headerlink" title="1，先下载最新的源码文件"></a>1，先下载最新的源码文件</h3><p>上<a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a>下载自己需要的源码文件，我需要的是<code>go1.12.7.linux-amd64.tar.gz</code>。</p><h3 id="2，解压"><a href="#2，解压" class="headerlink" title="2，解压"></a>2，解压</h3><p>执行命令<code>tar -C /usr/local -zxvf go1.12.7.linux-amd64.tar.gz</code>,会覆盖到原先的<code>go</code>目录。</p><h3 id="3，复制可执行文件"><a href="#3，复制可执行文件" class="headerlink" title="3，复制可执行文件"></a>3，复制可执行文件</h3><p>如果不是第一次安装，需要将<code>/usr/local/go/bin</code>目录下的文件复制到<code>/usr/bin</code>下。</p><h3 id="4，检查环境配置"><a href="#4，检查环境配置" class="headerlink" title="4，检查环境配置"></a>4，检查环境配置</h3><p>打开<code>/etc/profile</code>文件检查环境配置参数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=$HOME/code/go</span><br><span class="line">PATH=$PATH:$GOROOT/bin:$GOPATH/bin</span><br></pre></td></tr></table></figure><p>命令<code>source /etc/profile</code>使环境生效。</p><h3 id="5，检查版本号"><a href="#5，检查版本号" class="headerlink" title="5，检查版本号"></a>5，检查版本号</h3><p>执行<code>go version</code>命令，输出版本号为<code>go version go1.12.7 linux/amd64</code></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，Ubuntu18.04下完成Go版本升级。<br>后面如果版本有更新，可照此方法再升级一遍。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>Go语言调试工具-Dlv使用</title>
    <url>/2019/07/28/Go%E8%AF%AD%E8%A8%80%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7-Dlv%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./dlv debug</span><br></pre></td></tr></table></figure><h3 id="打断点"><a href="#打断点" class="headerlink" title="打断点"></a>打断点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b 文件名.go:行号 或 函数名</span><br></pre></td></tr></table></figure><h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c(continue)</span><br></pre></td></tr></table></figure><p>重启</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">r(restart)</span><br></pre></td></tr></table></figure><h3 id="下一行"><a href="#下一行" class="headerlink" title="下一行"></a>下一行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n (next)</span><br></pre></td></tr></table></figure><h3 id="进入函数"><a href="#进入函数" class="headerlink" title="进入函数"></a>进入函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s (step)</span><br></pre></td></tr></table></figure><h3 id="退出函数"><a href="#退出函数" class="headerlink" title="退出函数"></a>退出函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stepout</span><br></pre></td></tr></table></figure><h3 id="查看堆栈"><a href="#查看堆栈" class="headerlink" title="查看堆栈"></a>查看堆栈</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bt</span><br></pre></td></tr></table></figure><h3 id="查看打了断点的列表"><a href="#查看打了断点的列表" class="headerlink" title="查看打了断点的列表"></a>查看打了断点的列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bp (breakpoints)</span><br></pre></td></tr></table></figure><h3 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clear 断点号</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>delve</tag>
      </tags>
  </entry>
  <entry>
    <title>Go vendor应用</title>
    <url>/2019/07/10/Go-vendor%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h2 id="为什么要用它"><a href="#为什么要用它" class="headerlink" title="为什么要用它"></a>为什么要用它</h2><p>控制包的依赖，例如一个项目引用的是A包1.0版本后编译成功，结果几个月后A包tag号升到了2.3，而我们平时用<code>go get</code>命令是直接从<code>master</code>分支下引入的，因此可能会造成引入了同样的包，但编译不通过的问题。<br>而如果这个项目中存在<code>vendor</code>文件夹，<code>go</code>项目编译时就会优先编译<code>vendor</code>文件夹里的包。</p><h2 id="问题还原"><a href="#问题还原" class="headerlink" title="问题还原"></a>问题还原</h2><p>今天编译一个用<code>Go</code>写的语音识别服务的项目，缺失的A包用<code>go get</code>命令获取了，但编译后显示<code>xxx function not defined</code>，而我查了这个<code>xxx</code>函数是A包声明好的，这是什么原因呢。<br>原因就在于<strong>版本不匹配</strong>。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="简单直接的方法"><a href="#简单直接的方法" class="headerlink" title="简单直接的方法"></a>简单直接的方法</h3><p>在该项目下新建一个<code>vendor</code>文件夹，假如这个包是引入<code>github</code>上的，就在这下面建立基于<code>github</code>的路径，像这样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── 20hours</span><br><span class="line">│   ├── 20hours</span><br><span class="line">│   ├── demo.txt</span><br><span class="line">│   ├── file.png</span><br><span class="line">│   └── main.go</span><br><span class="line">├── testgo</span><br><span class="line">├── test.go</span><br><span class="line">└── vendor</span><br><span class="line">    └── github.com</span><br><span class="line">        └── name</span><br><span class="line">            └── A</span><br></pre></td></tr></table></figure><p>获取包的指定版本号仓库文件，可以用命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone v版本号 httpurl  </span><br><span class="line"></span><br><span class="line">举例:获取版本号为1.4.1的go-socket.io包  </span><br><span class="line">git clone v1.4.1 https://github.com/googollee/go-socket.io</span><br></pre></td></tr></table></figure><h3 id="推荐的方法，使用dep构建"><a href="#推荐的方法，使用dep构建" class="headerlink" title="推荐的方法，使用dep构建"></a>推荐的方法，使用dep构建</h3><p>网上教程很多，在此不做赘述</p><ul><li><a href="https://golang.github.io/dep/docs/introduction.html" target="_blank" rel="noopener">dep官方文档</a></li><li><a href="https://godoc.org/github.com/golang/dep/cmd/dep" target="_blank" rel="noopener">dep_Godoc</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>vendor</tag>
      </tags>
  </entry>
  <entry>
    <title>炒菜心得小结</title>
    <url>/2019/07/06/%E7%82%92%E8%8F%9C%E5%BF%83%E5%BE%97%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><p>初衷</p><p>女友工作了，于是开始商议在家自己做饭，顺便把第二天中午的也做好，带到公司去吃。<br>本文记录这段时间做饭炒菜的收获。<br>炒菜心得</p><p>炒菜前需要把菜洗干净，然后把菜和肉切薄。<br>接着进入炒菜步骤：</p><pre><code>首先，热锅冷油：先把锅烧热，再倒入冷油。
如果是肉，先倒肉，接着赶紧翻炒，防止粘锅。
肉翻的差不多后，倒入切好的蒜，可以入味和杀菌。
倒入料酒，去腥味。
倒入老抽酱油（凉菜用生抽）。
其次倒入不容易煮熟的菜，例如青椒，进行翻炒。
再倒入容易熟的菜进行翻炒。
洒盐。
快熟的时候关火，洒鸡精，然后用余温翻炒。</code></pre><p>baobaocairou<br>jiucaieag<br>注意</p><pre><code>如果闻到糊味，就倒一些凉水。</code></pre><p>小试牛刀_自制冒菜</p><pre><code>1，买一个冒菜底料（和火锅底料类似）
2，准备食材</code></pre><p>素菜：鱼豆腐，娃娃菜，金针菇，海带，土豆片，土豆粉，火腿肠<br>荤菜：鸡胸肉，牛肉丸子，蟹棒，虾饺，毛肚，千层肚，午餐肉</p><pre><code>3，洗菜
4，切菜，切肉
5，烧水，煮沸
6，先倒入荤菜
7，再倒入素菜
8，煮熟，关火，试吃</code></pre><p>maocai<br>小结</p><p>认真做好一件事，真的很开心！</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>流媒体收录流程</title>
    <url>/2019/07/06/%E6%B5%81%E5%AA%92%E4%BD%93%E6%94%B6%E5%BD%95%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>因为工作相关，所以写篇文章记录下这整体的业务流程。</p><h2 id="收录"><a href="#收录" class="headerlink" title="收录"></a>收录</h2><h3 id="文字简述"><a href="#文字简述" class="headerlink" title="文字简述"></a>文字简述</h3><p>收录，简单来说就是将视频流保存成视频文件，比如后缀名为mp4,flv,ts等。那么需要哪些模块呢</p><ul><li>前端：展示给用户看的，同时将用户点击的请求数据发送给后端做处理；</li><li>数据中转服务：在前端传给调度服务的数据格式可能会有误，所以中间要经过这个服务，对数据进行加工（一般是<code>json</code>封装）后发送给对方；</li><li>调度服务：负责所有数据库表的创建，记录的添加，修改，删除的操作；将要收录的源流分发给空闲的收录服务器；如果源流的码率较高，需要用转码服务器转成低码文件后收录；</li><li>源流和设备信息检测服务：检测源流的状态是否异常，如果异常就反馈给前端；检测设备的<code>CPU</code>，物理存储，内存的使用占比情况；</li><li>收录服务：开始收录时，由调度服务发给收录服务一个信号，收录服务开始工作，如果不需要收录了，也是由调度服务发给收录服务一个信号，收录服务停止工作；</li><li>转码服务：如果源流的码率过高，例如有8000k，而用户那边的网速又很差，这样会导致视频收录下来播放给用户会显得很卡，影响用户体验，因此需要经过转码服务将高码率的源流转成低码率后，再由收录服务进行收录；</li><li>迁移服务：收录下来后，其他模块可能也会需要，这时需要做迁移。</li><li>适配服务：如果添加的流类型是收录服务器不支持的，需要通过适配服务转换成收录服务支持的，再进行收录。</li><li>定时删除服务：收录的视频文件过多，极其占用物理存储资源，所以需要定时删除。这个定时删除服务就是做这样的事情。</li></ul><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="/.io//streamsystem_o.png" alt></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>最开始做这个我不知道是干嘛用的，直到部门老哥给我讲了下<code>Youtube</code>的视频播放过程，让我看到当你的网速不好时，为了保证视频的流畅，画质会差一些，等你网速好了画质再变得高清点。<br>而我这个原理和它类似。<br>注意，收录服务器和转码服务器在图示为了简洁只画了一台，实际上现场要部署很多台。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>Leetcode-448-Find All Numbers Disappeared in an Array</title>
    <url>/2019/07/01/Leetcode-448-Find-All-Numbers-Disappeared-in-an-Array/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">Find All Numbers Disappeared in an Array</a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>题目意思是找出1～n(n是指数组的长度)内没有出现的数。例如[4,3,2,7,8,2,3,1]里1~8没有出现的数有5,6，所以输出就是[5,6]。</p><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDisappearedNumbers</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	n := <span class="built_in">len</span>(nums)  <span class="comment">//获取数组的长度</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>;i &lt; n;i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> nums[i]<span class="number">-1</span> != i &amp;&amp; nums[i] != nums[nums[i]<span class="number">-1</span>] &#123;</span><br><span class="line">			nums[i],nums[nums[i]<span class="number">-1</span>] = nums[nums[i]<span class="number">-1</span>],nums[i]  <span class="comment">//交换位置</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ans := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>;i &lt; n;i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i]<span class="number">-1</span> != i &#123;</span><br><span class="line">			ans = <span class="built_in">append</span>(ans,i+<span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>Leetcode-88-Merge Sorted Array</title>
    <url>/2019/07/01/Leetcode-88-Merge-Sorted-Array/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.com/problems/merge-sorted-array/" target="_blank" rel="noopener">merge-sorted-array</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(nums1 []<span class="keyword">int</span>, m <span class="keyword">int</span>, nums2 []<span class="keyword">int</span>, n <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">	nums := <span class="built_in">make</span>([]<span class="keyword">int</span>,n+m)  <span class="comment">//创建一个混合数组，长度是nums1和nums2的和</span></span><br><span class="line">	<span class="comment">//三个变量i，j，k，分别指向nums1，nums2，和混合数组的末尾</span></span><br><span class="line">	<span class="keyword">for</span> i,j,k := <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>;i &lt; m || j &lt; n;k++ &#123;</span><br><span class="line">		<span class="keyword">if</span> i &lt; m &amp;&amp; j &lt; n &#123;</span><br><span class="line">			<span class="keyword">if</span> nums1[i] &lt; nums2[j] &#123;</span><br><span class="line">				nums[k] = nums1[i]</span><br><span class="line">				i++</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				nums[k] = nums2[j]</span><br><span class="line">				j++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> i &lt; m &#123;</span><br><span class="line">			nums[k] = nums1[i]</span><br><span class="line">			i++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			nums[k] = nums2[j]</span><br><span class="line">			j++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">copy</span>(nums1,nums)  <span class="comment">//把nums的数拷贝到nums1里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>刷题的步伐</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>排序</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg常用命令整理</title>
    <url>/2019/07/01/FFmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h2 id="检测源流信息"><a href="#检测源流信息" class="headerlink" title="检测源流信息"></a>检测源流信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i 源流地址</span><br></pre></td></tr></table></figure><h2 id="推流"><a href="#推流" class="headerlink" title="推流"></a>推流</h2><h3 id="把A-MP4和B-mp4打包进同一个ts流，并推到本机的10003端口"><a href="#把A-MP4和B-mp4打包进同一个ts流，并推到本机的10003端口" class="headerlink" title="把A.MP4和B.mp4打包进同一个ts流，并推到本机的10003端口"></a>把A.MP4和B.mp4打包进同一个ts流，并推到本机的10003端口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -re -i A.mp4  -re -i B.mp4  -map 0:0 -map 0:1 -map 1:0 -map 1:1  -program program_num=1:title=videoA:st=0:st=1 -program program_num=3:title=videoB:st=2:st=3 -c copy -f mpegts udp://localhost:10003</span><br></pre></td></tr></table></figure><p>以此类推</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">推一路流</span><br><span class="line">ffmpeg -re -i A.mp4 -map 0:0 -map 0:1 -program program_num=1:title=videoA:st=0:st=1  -f mpegts udp://localhost:10003</span><br><span class="line"></span><br><span class="line">推三路流</span><br><span class="line">ffmpeg -re -i shenzhen.ts  -re -i guangdong.ts -re -i girl.mp4  -map 0:0 -map 0:1 -map 1:0 -map 1:1 -map 0:0 -map 0:1 -program program_num=1:title=videoA:st=0:st=1 -program program_num=3:title=videoB:st=2:st=3 -program program_num=5:title=videoXXX:st=4:st=5 -f mpegts udp://localhost:10003</span><br></pre></td></tr></table></figure><p>循环推一路流，不做编码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -re -stream_loop -1 -i aaa.xx -c copy -f mpegts udp://localhost:10003</span><br></pre></td></tr></table></figure><h3 id="命令参数解释"><a href="#命令参数解释" class="headerlink" title="命令参数解释"></a>命令参数解释</h3><ul><li>re:realtime 推的速度，按当前帧率推</li><li>map 0:0 第一个流的视频</li><li>map 0:1 第一个流的音频</li><li>map 1:0 第二个流的视频</li><li>map 1:1 第二个流的音频</li><li>program_num=1:title=videoA:st=0:st=1 0,1合成一个视频videoA</li><li>program program_num=3:title=videoB:st=2:st=3 2,3合成一个视频videoB</li><li>-stream_loop 循环推流</li><li>-c copy 将视频中压缩的数据复制</li><li>-c:v libh264 将视频流强制转换为h264编码</li></ul><h2 id="查看流中的program信息"><a href="#查看流中的program信息" class="headerlink" title="查看流中的program信息"></a>查看流中的program信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffprobe -show_programs -print_format json -timeout 5000000 -i udp://localhost:10003</span><br></pre></td></tr></table></figure><ul><li>注意:这个命令有返回值，<code>0</code>表示执行成功，<code>1</code>表示失败。</li></ul><h2 id="将流中的program-1和program-3分别截取5s钟的时间，生成了两个文件"><a href="#将流中的program-1和program-3分别截取5s钟的时间，生成了两个文件" class="headerlink" title="将流中的program 1和program 3分别截取5s钟的时间，生成了两个文件"></a>将流中的program 1和program 3分别截取5s钟的时间，生成了两个文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -timeout 5000000 -i udp://localhost:10003  -t 0:0:5  -map p:1 -c copy  1.mp4 -t 0:0:5 -map p:3 -c copy 3.mp4</span><br></pre></td></tr></table></figure><ul><li>注意。此时推的是复合流。</li></ul><h2 id="对视频流抽帧"><a href="#对视频流抽帧" class="headerlink" title="对视频流抽帧"></a>对视频流抽帧</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i 源流地址 -vframes 1 -vf scale=90:51 图片存放路径</span><br></pre></td></tr></table></figure><h2 id="重复推流"><a href="#重复推流" class="headerlink" title="重复推流"></a>重复推流</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -re -stream_loop -1 -i aaa.xx -c copy -f mpegts udp://localhost:10003</span><br><span class="line"></span><br><span class="line">./ffmpeg -re  -i -stream_loop -1 startslient.mp3  -c:a aac -f flv rtmp://123.56.17.184/live/znn</span><br></pre></td></tr></table></figure><h2 id="将流保存成文件"><a href="#将流保存成文件" class="headerlink" title="将流保存成文件"></a>将流保存成文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i 流地址 -c copy 文件名</span><br><span class="line"></span><br><span class="line">例如:</span><br><span class="line">ffmpeg -i udp://localhost:10003 -c copy test.ts</span><br></pre></td></tr></table></figure><h2 id="检测源流中是否有静音"><a href="#检测源流中是否有静音" class="headerlink" title="检测源流中是否有静音"></a>检测源流中是否有静音</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ffmpeg -i silence.mp3 -af silencedetect=noise=0.0001 -f null -</span><br><span class="line">(默认音频中如果有2秒是静音，就认为是有静音的)</span><br><span class="line"></span><br><span class="line">持续让ffmpeg检测音频5秒</span><br><span class="line">ffmpeg -i silence.mp3 -af silencedetect=noise=0.0001 -t 0:0:5 -f null -</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>FFmpeg学习</category>
      </categories>
      <tags>
        <tag>FFmpeg</tag>
        <tag>视音频</tag>
      </tags>
  </entry>
  <entry>
    <title>Go test单元测试小技巧</title>
    <url>/2019/06/30/Go-test%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>周五在做<code>go test</code>测试时，碰到个问题，我要对一个<code>xxx</code>函数写测试样例，然而它的首字母是小写的，没有导出，单元测试过不去，而这个<code>xxx</code>函数外面还有一个<code>YYY</code>函数首字母是大写的，但要经过很长的逻辑才能到<code>xxx</code>函数。这时我又要完成对<code>xxx</code>函数进行测试，又不想经过<code>YYY</code>函数走逻辑，该怎么办呢？</p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>首先，绝对不能做的事：</p><ul><li>将<code>xxx</code>函数改为首字母大写的<code>Xxx</code>函数<br>原因：很多地方都在调这个函数，你改了这一处只满足你这次的测试，那其他基本业务流程也就崩了。</li></ul><p>我目前是在<code>test</code>文件夹里新建了一个<code>xxx_test.go</code>测试文件，样子长这样</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Testxxx</span><span class="params">(t testing.T)</span></span>&#123;</span><br><span class="line">    control.XXX()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>xxx</code>函数是在<code>control</code>包里，因此我要在<code>control</code>包下建一个<code>export.go</code>文件</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> control</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> XXX = xxx</span><br></pre></td></tr></table></figure><p>然后执行<code>go test</code>命令，它会遍历<code>control</code>包下的所有文件，这时<code>export.go</code>文件 里的<code>var XXX = xxx</code>就起到了一个桥梁作用。</p><p>这时测试的时候就不需要再经过<code>YYY</code>的逻辑走到<code>xxx</code>函数里面。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://studygolang.com/topics/9332" target="_blank" rel="noopener">付费用户「每日一学」2019-06-14：你应该知道的单元测试小技巧</a></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>单元测试</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Git更改远程推送的仓库地址</title>
    <url>/2019/06/29/Git%E6%9B%B4%E6%94%B9%E8%BF%9C%E7%A8%8B%E6%8E%A8%E9%80%81%E7%9A%84%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>本地代码推送到远程仓库地址时，有时地址会发生变更，所以需要更改，<code>git</code>命令如下</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="查看远程仓库地址"><a href="#查看远程仓库地址" class="headerlink" title="查看远程仓库地址"></a>查看远程仓库地址</h3><figure class="highlight plain"><figcaption><span>remote -v```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 添加远程仓库链接  </span><br><span class="line"></span><br><span class="line">```git remote add 远程仓库链接</span><br></pre></td></tr></table></figure><p>所以当年<code>push</code>代码的时候，是<code>git push -u 链接名 分支名</code></p><h3 id="更改远程仓库链接名"><a href="#更改远程仓库链接名" class="headerlink" title="更改远程仓库链接名"></a>更改远程仓库链接名</h3><figure class="highlight plain"><figcaption><span>remote rename 老链接名 新链接名```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 删除远程链接仓库链接名</span><br><span class="line"></span><br><span class="line">```git remote remove 链接名</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>Git</tag>
        <tag>push</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员10x工作法</title>
    <url>/2019/06/23/%E7%A8%8B%E5%BA%8F%E5%91%9810x%E5%B7%A5%E4%BD%9C%E6%B3%95/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul><li>01：面对问题时，用思考框架问问自己，现状、目标和路径。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Where are we?（我们现在在哪？）</span><br><span class="line">Where are we going?（我们要到哪儿去？）</span><br><span class="line">How can we get there?（我们如何到达那里？）</span><br></pre></td></tr></table></figure></li><li>02：遇到事情，倒着想。</li><li>03：在做任何事之前，先定义完成的标准。</li><li>04：在做任何需求或任务之前，先定好验收标准。</li><li>05：尽早提交代码去集成。</li><li>06：默认所有需求都不做，直到弄清楚为什么要做这件事。</li><li>07：扩大自己工作的上下文，别把自己局限在一个“程序员”的角色上。</li><li>08：在动手做一件事之前，先推演一番。</li><li>09：问一下自己，我的工作是不是可以用数字衡量。</li><li>10：设计你的迭代0清单，给自己的项目做体检。</li><li>11：动手做一个工作之前，请先对它进行任务分解。</li><li>12：多写单元测试。</li><li>13：我们应该编写可测的代码。</li><li>14：将任务拆小，越小越好。</li><li>15：按照完整实现一个需求的顺序去安排分解出来的任务。</li><li>16：要想写好测试，就要写简单的测试。</li><li>17：想要管理好需求，先把需求拆小。</li><li>18：尽量做最重要的事。</li><li>19：做好产品开发，最可行的方式是采用 MVP（最小可行产品）。</li><li>20：通过沟通反馈，不断升级自己的编解码能力。</li><li>21：用业务的语言写代码。</li><li>22：多面对面沟通，少开会。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我昨天做了什么？  </span><br><span class="line">我今天打算做什么？  </span><br><span class="line">我在过程中遇到了什么问题，需要请求帮助。</span><br></pre></td></tr></table></figure></li><li>23：多尝试用可视化的方式进行沟通。</li><li>24：做好持续集成的关键在于，快速反馈。</li><li>25：定期复盘，找准问题根因，不断改善。</li><li>26：多走近用户。</li><li>27：事情往前做，有问题尽早暴露。</li><li>28：多输出，让知识更有结构。</li><li>29：请谨慎地将工作自动化。</li><li>30：将你的工作过程自动化。</li><li>31：有体系地学习运维知识。</li><li>32：将部署纳入开发的考量。</li><li>33：将验收测试自动化。</li><li>34：把函数写短。</li><li>35：构建好你的领域模型。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">万维钢有期节目里提到芯片设计时讲到了分层以及模型的概念。分层或模型，实质是因为人的认知能力有</span><br><span class="line">限不得已而为之的。学习计算机，我们都知道晶体管，即便早就忘了它的原理。实际上晶体管涉及非常深</span><br><span class="line">奥的物理学知识，这是绝大多数人一辈子都不需要了解的物理学。抛开复杂艰深的物理学，晶体管的本质</span><br><span class="line">却很简单，它就是一个包含通和不通两个状态的开关，这就是它构建的模型。</span><br><span class="line">在开关的模型基础之上，信息论的创立者香农用一篇硕士论文构建了逻辑门这层。他证明了可以用最简单</span><br><span class="line">的开关，实现所有逻辑运算。</span><br><span class="line">逻辑运算层次之上，就是我们所知道的CPU模型。再往上，就是我们所熟悉的信息世界</span><br></pre></td></tr></table></figure></li><li>36：用简单技术解决问题，直到问题变复杂。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一方面，有人会因为对业务量级理解不足，盲目低估其他人系统的复杂度；另一方面，也有人会盲目应用技</span><br><span class="line">术，给系统引入不必要的复杂度，让自己陷入泥潭。</span><br><span class="line">作为拥有技术能力的程序员，我们都非常在意个人技术能力的提升，但却对在什么样情形下，什么样的技术</span><br><span class="line">更加适用考虑得不够。采用恰当的技术，解决当前的问题，是每个程序员都应该仔细考虑的问题。</span><br></pre></td></tr></table></figure></li><li>37：学习领域驱动设计。</li><li>38：了解一个项目，从大图景开始。</li><li>39：小步改造遗留系统，不要回到老路上。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">构建测试防护网，保证新老模块功能一致；</span><br><span class="line">分成小块，逐步替换；</span><br><span class="line">构建好领域模型；</span><br><span class="line">寻找行业中关于系统构建的最新理解。</span><br></pre></td></tr></table></figure></li><li>40：在学习区工作和成长。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从目前的发展来看，IT 行业依然是一个非常有前景的行业，但想在这条路上走好，需要我们成为 “T ”型</span><br><span class="line">人才，也就是“一专多能”。一专多能的前提是“一专”，让自己成为某个方面的专家。这个专家要放在行</span><br><span class="line">业的标准去看，这才能降低因为一个公司的波动而造成的影响。</span><br><span class="line">成为行业专家，要向行业的大师学习，给自己定下一个高的目标，然后是脚踏实地，找适合自己的问题去解</span><br><span class="line">决，让自己一直在学习区成长。</span><br></pre></td></tr></table></figure></li></ul><h2 id="答疑解惑"><a href="#答疑解惑" class="headerlink" title="答疑解惑"></a>答疑解惑</h2><h3 id="单元测试做不好，是否会影响到-CI-的效果？"><a href="#单元测试做不好，是否会影响到-CI-的效果？" class="headerlink" title="单元测试做不好，是否会影响到 CI 的效果？"></a>单元测试做不好，是否会影响到 CI 的效果？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CI 作为一个单独的实践，本身是很简单的，但它可以成为提纲挈领的主线，帮助团队不断改善自己</span><br><span class="line">的开发过程。</span><br></pre></td></tr></table></figure><h3 id="老板参加复盘，不敢说真话怎么办？"><a href="#老板参加复盘，不敢说真话怎么办？" class="headerlink" title="老板参加复盘，不敢说真话怎么办？"></a>老板参加复盘，不敢说真话怎么办？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">问题，是改进的前提条件。</span><br></pre></td></tr></table></figure><h3 id="国内的技术信息落后吗？"><a href="#国内的技术信息落后吗？" class="headerlink" title="国内的技术信息落后吗？"></a>国内的技术信息落后吗？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">国内程序员真正落后的不是信息，而是观念。</span><br></pre></td></tr></table></figure><h3 id="如何管理上级？"><a href="#如何管理上级？" class="headerlink" title="如何管理上级？"></a>如何管理上级？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一，管理上级的预期。</span><br><span class="line">第二，帮助上级丰富知识。</span><br><span class="line">第三，说出你的想法。</span><br></pre></td></tr></table></figure><h3 id="面对不了解的技术，我该如何分解任务？"><a href="#面对不了解的技术，我该如何分解任务？" class="headerlink" title="面对不了解的技术，我该如何分解任务？"></a>面对不了解的技术，我该如何分解任务？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先把它变成你熟悉的技术。</span><br></pre></td></tr></table></figure><h3 id="项目时间紧，该怎么办？"><a href="#项目时间紧，该怎么办？" class="headerlink" title="项目时间紧，该怎么办？"></a>项目时间紧，该怎么办？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">混淆了目标与现状。</span><br><span class="line">目标是应该怎么做，现状是我们正在怎么做。我们都知道</span><br><span class="line">现状是什么样的，问题是，你对现状满意吗？如果每个人都对现状是满意的，就不会有人探索更好的做法。</span><br><span class="line">假设现在不忙了，你知道该怎么改进吗？</span><br><span class="line"></span><br><span class="line">自动糊改进：</span><br><span class="line">把测试覆盖率检查加入到工程里，得到现有的测试覆盖率。</span><br><span class="line">将测试覆盖率加入持续集成，设定当前测试覆盖率为初始值。测试覆盖率不达标，不许提交代码。</span><br><span class="line">每周将测试覆盖率调高，比如，5%或10%，直到测试覆盖率达到100%。</span><br></pre></td></tr></table></figure><h3 id="多个功能同时开发，怎么办？"><a href="#多个功能同时开发，怎么办？" class="headerlink" title="多个功能同时开发，怎么办？"></a>多个功能同时开发，怎么办？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在主分支开发模型中，有一些常见的解决多功能并行开发的方法，其中，Feature Toggle 是最常用的一个，</span><br><span class="line">也就是通过开关，决定哪个功能是对外可用的。</span><br></pre></td></tr></table></figure><h3 id="如何在实际工作中推行新观念？"><a href="#如何在实际工作中推行新观念？" class="headerlink" title="如何在实际工作中推行新观念？"></a>如何在实际工作中推行新观念？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">找到愿意和你一起改变的人，做一件具体的事。</span><br></pre></td></tr></table></figure><h3 id="测试怎么写？"><a href="#测试怎么写？" class="headerlink" title="测试怎么写？"></a>测试怎么写？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">关于外部系统的测试，你可以先通过接口隔离开来，然后，通过模拟服务或本地可控的方式进行</span><br><span class="line">测试。</span><br></pre></td></tr></table></figure><h3 id="IntelliJ-IDEA-怎么学？"><a href="#IntelliJ-IDEA-怎么学？" class="headerlink" title="IntelliJ IDEA 怎么学？"></a>IntelliJ IDEA 怎么学？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个工具怎么学？我的经验就是去用。我没有专门学过 IntelliJ IDEA，只是不断地在使用它。</span><br><span class="line">遇到问题就去找相应的解决方案。</span><br><span class="line">也有一些辅助的方法可以帮助我们练习，</span><br><span class="line">比如，我们会给新员工发放 IntelliJ IDEA 的快捷键卡片，写代码休息之余，可以拿来看一下；</span><br><span class="line">再比如，IntelliJ IDEA 有一个插件叫 Key Promoter X，</span><br><span class="line">如果你用鼠标操作，它会给你提示，帮你记住快捷键</span><br></pre></td></tr></table></figure><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul><li><a href="https://www.infoq.cn/article/function-switch-realize-better-continuous-implementations" target="_blank" rel="noopener">使用功能开关更好地实现持续部署</a></li><li><a href="https://martinfowler.com/articles/feature-toggles.html" target="_blank" rel="noopener">Feature Toggles (aka Feature Flags)</a></li><li><a href="https://www.unixhot.com/page/ops" target="_blank" rel="noopener">运维知识体系</a></li><li><a href="https://www.unixhot.com/page/cache" target="_blank" rel="noopener">Web缓存知识体系</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>Leetcode-485-Max Consecutive Ones</title>
    <url>/2019/06/17/Leetcode-485-Max-Consecutive-Ones/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.com/problems/max-consecutive-ones/" target="_blank" rel="noopener">Max Consecutive Ones</a></p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="题目意思"><a href="#题目意思" class="headerlink" title="题目意思"></a>题目意思</h3><p>给定一个二进制数组，计算数组中出现的最大连续1的个数。</p><p>注意：</p><ul><li>输入数组只包含0和1</li><li>数组长度是正整数并且不会超过10000</li></ul><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>遍历数组并对连续的数计数，最终取最大值。</p><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><ul><li><p>错误</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> max <span class="keyword">int</span>  <span class="comment">//声明最大值</span></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i &lt;= <span class="built_in">len</span>(nums);i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> _,v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[i] = v &#123;</span><br><span class="line">				max++</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				max=<span class="number">0</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>正确1</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	count := <span class="number">1</span></span><br><span class="line">	<span class="comment">//考虑特殊情况</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &amp;&amp; nums[<span class="number">0</span>] == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] == nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">			<span class="keyword">if</span> nums[i] == <span class="number">1</span> &#123;</span><br><span class="line">				count++  <span class="comment">//计数</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			count = <span class="number">1</span>  <span class="comment">//没有合适的就置为1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> count &gt; res &#123;</span><br><span class="line">			res = count</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>正确2</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> sum, max <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		sum += v</span><br><span class="line">		sum *= v</span><br><span class="line">		<span class="keyword">if</span> sum &gt; max &#123;</span><br><span class="line">			max = sum</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>知识星球Go项目实战爬虫项目总结</title>
    <url>/2019/06/16/%E7%9F%A5%E8%AF%86%E6%98%9F%E7%90%83Go%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>知识星球<code>Go项目实战</code>的第一个实战项目—&gt;爬虫。<br>本文记录直播内容和相关细节。</p><h2 id="前端相关"><a href="#前端相关" class="headerlink" title="前端相关"></a>前端相关</h2><p>DOM，CSS选择器，jQuery</p><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><ul><li>前端：Bootstrap和jQuery</li><li>后端：Go</li><li>数据库：MySQL</li></ul><h3 id="数据库设计思路"><a href="#数据库设计思路" class="headerlink" title="数据库设计思路"></a>数据库设计思路</h3><ul><li>job_info 表：我们计划抓取猎聘、Boss直聘和拉钩网三个网站的 Go 语言相关职位信息。通过分析三个网站上的职位信息数据，结合咱们的目标，设计了 job_info 表；</li><li>crawl_rule 表：针对 job_info 表的设计，我们希望在网站职位的详情页能够获取到相应信息。因为每个网站页面结构不同，抓取策略也会不一样，因此有了此表；</li><li>auto_crawl_rule 表：crawl_rule 表是针对一个职位详情页的，但我们不可能手动一个页面一个页面抓取，而是希望能够提供一些信息将某个网站上相关职位信息批量抓取。此表用于抓取职位列表信息，进而抓取一个个职位信息；</li></ul><h3 id="数据库设计原则和注意事项-重点"><a href="#数据库设计原则和注意事项-重点" class="headerlink" title="数据库设计原则和注意事项(重点)"></a>数据库设计原则和注意事项(重点)</h3><p>1，字段不允许 NULL 且提供默认值，即 NOT NULL DEFAULT xx；<br>2，选择合适的最小数据类型；<br>3，确保是非负数的字段，加上 unsigned;<br>4，使用 COMMENT 给字段加备注；<br>5，表一般应该有 created_at 字段；<br>6，没特殊情况，请使用 InnoDB 引擎；<br>7，字符编码使用 utf8mb4；<strong>不要用utf8</strong><br>8，VARCHAR 类型的长度值使用 2 的幂次方减1或减2，比如 varchar(127) varchar(255) varchar(510) 因为 510 这个数字（长度）本身需要 2 个字节存储。（也就是长度超过 255 之后，用两个字节存储长度，所以减 2）；<br>9，根据查询条件，建立必要的索引；<br>10，NOT NULL，确保它一定不是NULL；</p><h3 id="项目结构和代码组织"><a href="#项目结构和代码组织" class="headerlink" title="项目结构和代码组织"></a>项目结构和代码组织</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── cmd  //项目入口，主程序</span><br><span class="line">│   └── crawler</span><br><span class="line">│       ├── background.go</span><br><span class="line">│       ├── crawler</span><br><span class="line">│       └── main.go</span><br><span class="line">├── config  //配置信息</span><br><span class="line">│   └── config.yaml</span><br><span class="line">├── dao  //数据访问对象，直接和数据存储打交道</span><br><span class="line">│   ├── auto_crawl_rule.go</span><br><span class="line">│   ├── auto_crawl_rule_test.go</span><br><span class="line">│   ├── crawl_rule.go</span><br><span class="line">│   ├── db.go</span><br><span class="line">│   └── job.go</span><br><span class="line">├── docs  //文档</span><br><span class="line">│   └── db.sql</span><br><span class="line">├── global  //全局信息，初始化</span><br><span class="line">│   ├── app.go</span><br><span class="line">│   ├── error.go</span><br><span class="line">│   └── init.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── http  //</span><br><span class="line">│   ├── controller  //MVC 的 controller</span><br><span class="line">│   │   ├── job_handler.go</span><br><span class="line">│   │   └── job_handler_test.go</span><br><span class="line">│   ├── middleware  //http的中间件</span><br><span class="line">│   │   ├── logger.go</span><br><span class="line">│   │   └── recover.go</span><br><span class="line">│   └── routes.go</span><br><span class="line">├── LICENSE</span><br><span class="line">├── logic  //业务逻辑</span><br><span class="line">│   ├── crawler</span><br><span class="line">│   │   ├── colly.go</span><br><span class="line">│   │   ├── goquery.go</span><br><span class="line">│   │   ├── parser.go</span><br><span class="line">│   │   └── work.go</span><br><span class="line">│   └── job.go</span><br><span class="line">├── model  //映射的结构体</span><br><span class="line">│   ├── auto_crawl_rule.go</span><br><span class="line">│   ├── crawl_rule.go</span><br><span class="line">│   └── job_info.go</span><br><span class="line">├── README.md</span><br><span class="line">├── template  //模板</span><br><span class="line">│   ├── detail.html</span><br><span class="line">│   └── index.html</span><br><span class="line">└── util  //辅助工具</span><br><span class="line">    ├── file.go</span><br><span class="line">    ├── http.go</span><br><span class="line">    ├── int.go</span><br><span class="line">    └── ip.go</span><br></pre></td></tr></table></figure><h3 id="关于配置文件"><a href="#关于配置文件" class="headerlink" title="关于配置文件"></a>关于配置文件</h3><p>1，写死，保底<br>2，通过配置拿到数据，两种形式，读取配置文件和命令行参数传递过来<br>3，读环境变量</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本项目主要熟悉和培养用Go设计项目的框架，同时也把前段时间学习的知识点做了综合运用。下面记录下一些关键信息：</p><ul><li>熟悉<code>go mod</code></li><li>执行数据库语句的代码和数据库语句最好分开来操作</li><li>数据量很大的时候，最好不要随意改变数据表中的字段，不然服务会挂</li><li>项目中还有待完善的部分，例如<code>Colly</code>的实现，结构体转数据表或数据表转结构体，选择分析器的部分</li></ul><h2 id="提问环节"><a href="#提问环节" class="headerlink" title="提问环节"></a>提问环节</h2><p>Q1:cmd下为什么要有crawler文件夹<br>如果cmd下放main.go，编译出来的文件名叫什么？—cmd</p><p>Q2:并发版爬虫？什么时候成分布式的啊<br>抓的太频繁，会被封。</p><p>Q3:測試 controller 會直接對 db 調用，不知道這樣好嗎</p><p>Q4:http 为什么要加 recover ？ 默认没有么</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>Git如何更新fork后的repository</title>
    <url>/2019/06/10/Git%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0fork%E5%90%8E%E7%9A%84repository/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有一个仓库A，我经过<code>fork</code>后变成了仓库B，当仓库A已经有了新提交时，我需要更新仓库B，该怎么办呢？</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>1,首先，检查一下当前的配置，看看当前有没有已经设置了上游，这要使用<code>git remote -v</code>命令。</p><p>2,将原repository设置为自己fork出的repository的上游（upstream）。运用如下的命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git</span><br></pre></td></tr></table></figure><p>3,运行<code>git fetch upstream</code>命令，如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">remote: Enumerating objects: 122, done.</span><br><span class="line">remote: Counting objects: 100% (122/122), done.</span><br><span class="line">remote: Compressing objects: 100% (90/90), done.</span><br><span class="line">remote: Total 97 (delta 40), reused 0 (delta 0)</span><br><span class="line">Unpacking objects: 100% (97/97), done.</span><br><span class="line">From https://gitea.com/zsxq/jobs_crawler</span><br><span class="line"> * [new branch]      master     -&gt; upstream/master</span><br></pre></td></tr></table></figure><p>4,<code>git checkout master</code>，这是保证切换到本地的repository的master上，如果本来就在，那么这一步不是必须的。</p><p>5,运行<code>git merge upstream/master</code>命令，将upstream/master上的更新合并到本地的master上，其实就是将第三步中download到.git文件夹下的那些change合并到本地的master中。如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Updating e9540a6..c31fadf</span><br><span class="line">Fast-forward</span><br><span class="line"> README.md                      |   8 +-</span><br><span class="line"> cmd/crawler/background.go      |  42 ++++++++</span><br><span class="line"> cmd/crawler/main.go            |  32 +++---</span><br><span class="line"> config/config.yaml             |  18 +++-</span><br><span class="line"> dao/auto_crawl_rule.go         |  79 +++++++++++++++</span><br><span class="line"> dao/auto_crawl_rule_test.go    |  38 +++++++</span><br><span class="line"> dao/crawl_rule.go              |  44 ++++++++</span><br><span class="line"> dao/db.go                      |  19 ++--</span><br><span class="line"> dao/job.go                     | 101 ++++++++++++++++++-</span><br><span class="line"> docs/db.sql                    |  19 ++--</span><br><span class="line"> global/app.go                  |  77 ++++++++++++++</span><br><span class="line"> global/init.go                 |  35 +++++++</span><br><span class="line"> go.mod                         |   5 +-</span><br><span class="line"> go.sum                         |   3 +</span><br><span class="line"> http/controller/job_handler.go |  79 ++++++++++++++-</span><br><span class="line"> http/middleware/logger.go      |  35 +++++++</span><br><span class="line"> logic/crawler/colly.go         |  46 +++++++++</span><br><span class="line"> logic/crawler/goquery.go       | 221 +++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> logic/crawler/parser.go        |  68 +++++++++++++</span><br><span class="line"> logic/crawler/work.go          |  55 ++++++++++</span><br><span class="line"> logic/job.go                   |  14 ++-</span><br><span class="line"> model/auto_crawl_rule.go       |  31 ++++++</span><br><span class="line"> model/crawl_rule.go            |  26 +++++</span><br><span class="line"> model/job_info.go              |   2 +-</span><br><span class="line"> template/detail.html           |  49 +++++++++</span><br><span class="line"> template/index.html            |  70 +++++++++++++</span><br><span class="line"> util/file.go                   |  18 ++++</span><br><span class="line"> util/http.go                   |  21 ++++</span><br><span class="line"> util/int.go                    |   8 ++</span><br><span class="line"> util/ip.go                     |  37 +++++++</span><br><span class="line"> 30 files changed, 1253 insertions(+), 47 deletions(-)</span><br></pre></td></tr></table></figure><p>这时我在用<code>gitk</code>命令查看<br><img src="/.io//git-fork.png" alt="git-fork"></p><p>6,如果本地没有什么自己独立的更新的话，那么将执行”Fast-forward”的合并。如果本地有自己独立的更新，而又会引起冲突的话，则要解决冲突，再commit.</p><p>关于解决冲突，如果明确所有冲突都是使用upstream/master上的来override自己的，那么可以直接运行如下命令，则无需解决冲突了：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge -X theirs upstream/master</span><br></pre></td></tr></table></figure><p>注意，以上步骤结束后，仅仅是本地的fork出的repository和原repository取得了同步，如果想让远程的fork出的repository也同样取得同步，必须再git push上去。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://help.github.com/en/articles/syncing-a-fork" target="_blank" rel="noopener">Syncing a fork</a></li><li><a href="https://help.github.com/en/articles/configuring-a-remote-for-a-fork" target="_blank" rel="noopener">Configuring a remote for a fork</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <tags>
        <tag>Git</tag>
        <tag>fork</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-66-Plus One</title>
    <url>/2019/06/10/Leetcode-66-Plus-One/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.com/problems/plus-one/" target="_blank" rel="noopener">plus one</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>模拟十进制进位加法</li><li>注意处理有进位的情况</li></ul><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><ul><li><p>解法一</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plusOne</span><span class="params">(digits []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	digitslength := <span class="built_in">len</span>(digits)  <span class="comment">//获取数组长度</span></span><br><span class="line">	<span class="keyword">for</span> i := digitslength - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i-- &#123;</span><br><span class="line">		<span class="keyword">if</span> digits[i] &lt; <span class="number">9</span> &#123;  <span class="comment">//判断数组尾部是否小于9</span></span><br><span class="line">			digits[i]++</span><br><span class="line">			<span class="keyword">return</span> digits</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//有进位的情况</span></span><br><span class="line">		digits[i] = <span class="number">0</span>  <span class="comment">//数组最后一位置为0</span></span><br><span class="line">		res := []<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;  </span><br><span class="line">		res = <span class="built_in">append</span>(res,digits...)</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解法二</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plusOne</span><span class="params">(digits []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	digits = <span class="built_in">append</span>(digits,<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(digits) - <span class="number">1</span>;i &gt; <span class="number">0</span>;i-- &#123;</span><br><span class="line">		digits[i] = digits[i] + digits[i<span class="number">-1</span>]</span><br><span class="line">		digits[i<span class="number">-1</span>] = digits[i]/<span class="number">10</span>  <span class="comment">//取除数</span></span><br><span class="line">		digits[i] %= <span class="number">10</span>  <span class="comment">//取余数</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> digits[<span class="number">0</span>] == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> digits[<span class="number">1</span>:]</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> digits</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>刷题的步伐</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>进制转换</tag>
      </tags>
  </entry>
  <entry>
    <title>文字直播：消息推送系统介绍</title>
    <url>/2019/06/09/%E6%96%87%E5%AD%97%E7%9B%B4%E6%92%AD%EF%BC%9A%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>直播内容:主要讨论周洋在360做的消息推送系统，主要分为以下几个部分：</p><ul><li>关于push系统对比与性能指标的讨论~</li><li>消息系统架构介绍</li><li>哪些因素决定了推送系统的效果？</li><li>go语言开发问题与解决方案</li><li>消息系统的运维，测试</li></ul><h2 id="直播开始"><a href="#直播开始" class="headerlink" title="直播开始"></a>直播开始</h2><p>360消息系统更确切的说是长连接push系统，目前服务于360内部50多个产品，开发平台数千款app，也支持部分聊天业务场景，单通道多app复用，支持上行数据，提供接入方不同粒度的上行数据和用户状态回调服务。<br>目前整个系统按不同业务分成9个功能完整的集群，部署在10个idc上（每个集群覆盖不同的idc），实时在线2亿量级.<br>通常情况下，pc，手机，甚至是智能硬件上的360产品的push消息，基本上是从我们系统发出的，期望大家收到的push都是自己关心的… 如果不是，请相信，“我们不生产消息，我们只是消息的搬运工”~<br>很多同行比较关心go语言在实现push系统上的性能问题，单机性能究竟如何，能否和其他语言实现的类似系统做对比么？甚至问如果是创业,第三方云推送平台，推荐哪个?<br>其实各大厂都有类似的push系统，市场上也有类似功能的云服务。包括我们公司早期也有erlang，nodejs实现的类似系统，也一度被公司要求做类似的对比测试。<br>我感觉在讨论对比数据的时候，很难保证大家环境和需求的统一，我只能说下我这里的体会，数据是有的，但这个数据前面估计会有很多定语~</p><h2 id="一些重要指标"><a href="#一些重要指标" class="headerlink" title="一些重要指标"></a>一些重要指标</h2><h3 id="1，单机的连接数指标。"><a href="#1，单机的连接数指标。" class="headerlink" title="1，单机的连接数指标。"></a>1，单机的连接数指标。</h3><p>做过长连接的同行，应该有体会，如果在稳定连接情况下，连接数这个指标，在没有网络吞吐情况下对比，其实意义往往不大，维持连接消耗cpu资源很小，每条连接tcp协议栈会占约4k的内存开销，系统参数调整后，我们单机测试数据，最高也是可以达到单实例300w长连接。<br>但做更高的测试，我个人感觉意义不大。因为实际网络环境下，单实例300w长连接，从理论上算压力就很大：因为实际弱网络环境下，移动客户端的断线率很高，假设每秒有1000分之一的用户断线重连。300w长连接，每秒新建连接达到3w，这同时连入的3w用户，要进行注册，加载离线存储等对内rpc调用，另外300w长连接的用户心跳需要维持,假设心跳300s一次，心跳包每秒需要1w tps。<br>单播和多播数据的转发，广播数据的转发，本身也要响应内部的rpc调用，300w长连接情况下，gc带来的压力，内部接口的响应延迟能否稳定保障。<br>这些集中在一个实例中，可用性是一个挑战。所以线上单实例不会hold很高的长连接,实际情况也要根据接入客户端网络状况来决定。</p><h3 id="2，消息系统的内存使用量指标"><a href="#2，消息系统的内存使用量指标" class="headerlink" title="2，消息系统的内存使用量指标"></a>2，消息系统的内存使用量指标</h3><p>这一点上，使用go语言情况下，由于协程的原因，会有一部分额外开销。但是要做两个推送系统的对比，也有些需要确定问题。<br>比如系统从设计上是否需要全双工（即读写是否需要同时进行）如果半双工，理论上对一个用户的连接只需要使用一个协程即可（这种情况下，对用户的断线检测可能会有延时），如果是全双工，那读/写各一个协程。两种场景内存开销是有区别的.</p><p>另外测试数据的大小往往决定我们对连接上设置的读写buffer是多大，是全局复用的，还是每个连接上独享的，还是动态申请的。另外是否全双工也决定buffer怎么开. 不同的策略，可能在不同情况的测试中表现不一样。</p><h3 id="3，每秒消息下发量"><a href="#3，每秒消息下发量" class="headerlink" title="3，每秒消息下发量"></a>3，每秒消息下发量</h3><p>这一点上，也要看我们对消息到达的QoS级别(回复ack策略区别），另外架构策略，每种策略有其更适用的场景，是纯粹推，还是推拉结合。甚至是否开启了消息日志，日志库的实现机制，缓冲开多大，flush策略,这些都影响整个系统的吞吐量。另外为了HA，增加了内部通信成本，为了避免一些小概率事件，提供闪断补偿策略，这些都要考虑进去。如果所有的都去掉，那就是比较基础库的性能了.</p><p>所以我只能给出大概数据，24核，64G的服务器上，在Qos为message at least，纯粹推的情况，消息体256B<del>1kB情况下，单个实例100w实际用户（200w+）协程，峰值可以达到2</del>5w的QPS…<br>内存可以稳定在25G左右，gc时间在200<del>800ms左右.（还有优化空间） 我们正常线上单实例用户控制在80w以内，单机最多两个实例</del><br>事实上，整个系统在推送的需求上，对高峰的输出不是提速，往往是进行限速，以防push系统瞬时的高吞吐量，转化成对接入方业务服务器的ddos攻击<br>所以对于性能上，我感觉大家可以放心使用，至少在我们这个量级上，经受过考验，go1.5到来后，确实有之前投资又增值了的感觉~<br>下面是对消息系统的大概介绍，之前一些同学可能在gopher china上可以看到分享，这里简单讲解下架构和各个组件功能，额外补充一些当时遗漏的信息：<br>架构图如下，所有的service都 written by golang.<br><img src="/content/images/2019/06/0b8323ed2b40742005a9a6b2010f85b.jpg" alt="0b8323ed2b40742005a9a6b2010f85b"></p><h2 id="几个大概重要组件介绍如下"><a href="#几个大概重要组件介绍如下" class="headerlink" title="几个大概重要组件介绍如下"></a>几个大概重要组件介绍如下</h2><h3 id="dispatcher-service"><a href="#dispatcher-service" class="headerlink" title="dispatcher service"></a>dispatcher service</h3><p>根据客户端请求信息，将应网络和区域的长连接服务器的，一组IP传送给客户端。客户端根据返回的IP，建立长连接，连接Room service.</p><h3 id="room-Service"><a href="#room-Service" class="headerlink" title="room Service"></a>room Service</h3><p>长连接网关，hold用户连接，并将用户注册进register service，本身也做一些接入安全策略、白名单、IP限制等</p><h3 id="coordinator-service"><a href="#coordinator-service" class="headerlink" title="coordinator service"></a>coordinator service</h3><p>用来转发用户的上行数据，包括接入方订阅的用户状态信息的回调，另外做需要协调各个组件的异步操作，比如kick用户操作,需要从register拿出其他用户做异步操作.</p><h3 id="saver-service"><a href="#saver-service" class="headerlink" title="saver service"></a>saver service</h3><p>是存储访问层，承担了对redis和mysql的操作，另外也提供部分业务逻辑相关的内存缓存，比如广播信息的加载可以在saver中进行缓存。另外一些策略，比如客户端sdk由于被恶意或者意外修改，每次加载了消息，不回复ack，那服务端就不会删除消息，消息就会被反复加载，形成死循环，可以通过在saver中做策略和判断。（客户端总是不可信的）</p><h3 id="center-service"><a href="#center-service" class="headerlink" title="center service"></a>center service</h3><p>提供给接入方的内部api服务器，比如单播或者广播接口，状态查询接口等一系列api,包括运维和管理的api.</p><h3 id="举两个常见例子，了解工作机制："><a href="#举两个常见例子，了解工作机制：" class="headerlink" title="举两个常见例子，了解工作机制："></a>举两个常见例子，了解工作机制：</h3><p>比如发一条单播给一个用户，center先请求Register获取这个用户之前注册的连接通道标识、room实例地址，通过room service下发给长连接。<br>Center Service比较重的工作如全网广播，需要把所有的任务分解成一系列的子任务，分发给所有center，然后在所有的子任务里，分别获取在线和离线的所有用户，再批量推到Room Service。通常整个集群在那一瞬间压力很大。<br>deployd/agent service 用于部署管理各个进程，收集各组件的状态和信息,zookeeper和keeper用于整个系统的配置文件管理和简单调度</p><h2 id="关于推送的服务端架构"><a href="#关于推送的服务端架构" class="headerlink" title="关于推送的服务端架构"></a>关于推送的服务端架构</h2><p>常见的推送模型有长轮训拉取，服务端直接推送（360消息系统目前主要是这种），推拉结合（推送只发通知，推送后根据通知去拉取消息）.<br>拉取的方式不说了，现在并不常用了，早期很多是nginx+lua+redis，长轮训，主要问题是开销比较大，时效性也不好, 能做的优化策略不多。<br>直接推送的系统，目前就是360消息系统这种，消息类型是消耗型的，并且对于同一个用户并不允许重复消耗,如果需要多终端重复消耗，需要抽象成不同用户。<br>推的好处是实时性好，开销小，直接将消息下发给客户端，不需要客户端走从接入层到存储层主动拉取.<br>但纯推送模型，有个很大问题，由于系统是异步的，他的时序性无法精确保证。这对于push需求来说是够用的，但如果复用推送系统做im类型通信，可能并不合适。</p><h2 id="这里还有一个常见话题，哪些因素决定推送系统的效果？"><a href="#这里还有一个常见话题，哪些因素决定推送系统的效果？" class="headerlink" title="这里还有一个常见话题，哪些因素决定推送系统的效果？"></a>这里还有一个常见话题，哪些因素决定推送系统的效果？</h2><h3 id="首先是sdk的完善程度"><a href="#首先是sdk的完善程度" class="headerlink" title="首先是sdk的完善程度"></a>首先是sdk的完善程度</h3><p>sdk策略和细节完善度，往往决定了弱网络环境下最终推送质量.</p><p>1.SDK选路策略,最基本的一些策略如下：<br>有些开源服务可能会针对用户hash一个该接入区域的固定ip，实际上在国内环境下不可行，最好分配器（dispatcher）是返回散列的一组，而且端口也要参开，必要时候，客户端告知是retry多组都连不上，返回不同idc的服务器。因为我们会经常检测到一些case，同一地区的不同用户，可能对同一idc内的不同ip连通性都不一样，也出现过同一ip不同端口连通性不同，所以用户的选路策略一定要灵活，策略要足够完善.<br>另外在选路过程中，客户端要对不同网络情况下的长连接ip做缓存，当网络环境切换时候(wifi 2G,3G)，重新请求分配器，缓存不同网络环境的长连接ip.</p><p>2.客户端对于数据心跳和读写超时设置,完善断线检测重连机制<br>针对不同网络环境，或者客户端本身消息的活跃程度，心跳要自适应的进行调整并与服务端协商，来保证链路的连通性。并且在弱网络环境下，除了网络切换（wifi切3G）或者读写出错情况，什么时候重新建立链路也是一个问题。客户端发出的ping包，不同网络下，多久没有得到响应，认为网络出现问题，重新建立链路需要有个权衡。另外对于不同网络环境下，读取不同的消息长度，也要有不同的容忍时间，不能一刀切。好的心跳和读写超时设置，可以让客户端最快的检测到网络问题，重新建立链路，同时在网络抖动情况下也能完成大数据传输。</p><p>3.结合服务端做策略<br>另外系统可能结合服务端做一些特殊的策略，比如我们在选路时候，我们会将同一个用户尽量映射到同一个room service实例上。断线时，客户端尽量对上次连接成功的地址进行重试。主要是方便服务端做闪断情况下策略，会暂存用户闪断时实例上的信息，重新连入的时候，做单实例内的迁移，减少延时与加载开销.</p><p>4.客户端保活策略<br>很多创业公司愿意重新搭建一套push系统，确实不难实现，其实在协议完备情况下（最简单就是客户端不回ack不清数据），服务端会保证消息是不丢的。但问题是为什么在消息有效期内,到达率上不去？<br>往往因为自己app的push service存活能力不高。选用云平台或者大厂的，往往sdk会做一些保活策略，比如和其他app共生，互相唤醒，这也是云平台的push service更有保障原因~ 我相信很多云平台旗下的sdk，多个使用同样sdk的app，为了实现服务存活，是可以互相唤醒和保证活跃的~ 另外现在push sdk本身是单连接，多app复用的，这为sdk实现，增加了新的挑战~</p><p>综上，对我来说，选择推送平台，优先会考虑客户端sdk的完善程度~ 对于服务端，选择条件稍微简单，要求部署接入点（IDC）越要多，配合精细的选路策略，效果越有保证，至于想知道哪些云服务有多少点，这个群里来自各地的小伙伴们，可以合伙测测~</p><p>这个系统在开发过程中遇到挑战和优化策略，给大家看下当年的一张图，在第一版优化方案上线前一天截图~</p><p>可以看到，内存最高占用69G，GC时间单实例最高时候高达3<del>6s.这种情况下，试想一次悲剧的请求，经过了几个正在执行gc的组件，后果必然是超时… gc照成的接入方重试，又加重了系统的负担。遇到这种情况当时整个系统最差情况每隔2，3天就需要重启一次</del></p><p><img src="/content/images/2019/06/2b01512149c092fa9edf1e4023d7ed0.jpg" alt="2b01512149c092fa9edf1e4023d7ed0"></p><p>当时出现问题，现在总结起来，大概以下几点</p><p>1.散落在协程里的I/O，Buffer和对象不复用。<br>当时由于对go的gc效率理解有限，比较奔放，程序里大量short live的协程，对内通信的很多io操作，由于不想阻塞主循环逻辑或者需要及时响应的逻辑，通过单独go协程来实现异步。这回会gc带来很多负担。</p><p>针对这个问题，应尽量控制协程创建，对于长连接这种应用，本身已经有几百万并发协程情况下，很多情况没必要在各个并发协程内部做异步io，因为程序的并行度是有限，理论上做协程内做阻塞操作是没问题。<br>如果有些需要异步执行，比如如果不异步执行，影响对用户心跳或者等待response无法响应，最好通过一个任务池，和一组常驻协程，来消耗，处理结果，通过channel再传回调用方. 使用任务池还有额外的好处，可以对请求进行打包处理，提高吞吐量，并且可以加入控量策略.</p><p>2.网络环境不好引起激增<br>go协程相比较以往高并发程序，如果做不好流控，会引起协程数量激增。早期的时候也会发现，时不时有部分主机内存会远远大于其他服务器，但发现时候，所有主要profiling参数都正常了。<br>后来发现，通信较多系统中，网络抖动阻塞是不可免的(即使是内网)，对外不停accept接受新请求，但执行过程中，由于对内通信阻塞，大量协程被创建，业务协程等待通信结果没有释放，往往瞬时会迎来协程暴涨. 但这些内存在系统稳定后，virt和res都并没能彻底释放，下降后，维持高位。<br>处理这种情况，需要增加一些流控策略，流控策略可以选择在rpc库来做，或者上面说的任务池来做，其实我感觉放在任务池里做更合理些，毕竟rpc通信库可以做读写数据的限流，但它并不清楚具体的限流策略，到底是重试还是日志还是缓存到指定队列。任务池本身就是业务逻辑相关的，它清楚针对不同的接口需要的流控限制策略。</p><p>3.低效和开销大的rpc框架<br>早期rpc通信框架比较简单，对内通信时候使用的也是短连接。这本来短连接开销和性能瓶颈超出我们预期，短连接io效率是低一些，但端口资源够，本身吞吐可以满足需要，用是没问题的，很多分层的系统，也有http短连接对内进行请求的。但早期go版本，这样写程序，在一定量级情况，是支撑不住的。短连接大量临时对象和临时buffer创建，在本已经百万协程的程序中，是无法承受的。所以后续我们对我们的rpc框架作了两次调整。</p><p>第二版的rpc框架，使用了连接池，通过长连接对内进行通信（复用的资源包括client和server的：编解码Buffer、Request/response），大大改善了性能。</p><p>但这种在一次request和response还是占用连接的，如果网络状况ok情况下，这不是问题，足够满足需要了，但试想一个room实例要与后面的数百个的register，coordinator，saver，center，keeper实例进行通信，需要建立大量的常驻连接，每个目标机几十个连接，也有数千个连接被占用。</p><p>非持续抖动时候（持续逗开多少无解），或者有延迟较高的请求时候，如果针对目标ip连接开少了，会有瞬时大量请求阻塞，连接无法得到充分利用。第三版增加了Pipeline操作，Pipeline会带来一些额外的开销，利用tcp的全双特性，以尽量少的连接完成对各个服务集群的rpc调用。</p><p>4.GC时间过长<br>Go的Gc仍旧在持续改善中，大量对象和buffer创建，仍旧会给gc带来很大负担，尤其一个占用了25G左右的程序。之前go team的大咖邮件也告知我们，未来会让使用协程的成本更低，理论上不需要在应用层做更多的策略来缓解gc. （目前最新版本，Go 的 GC 已经有了很大的改进）</p><p>改善方式，一种是多实例的拆分，如果公司没有端口限制，可以很快部署大量实例，减少gc时长，最直接方法。不过对于360来说，外网通常只能使用80和433。因此常规上只能开启两个实例。当然很多人给我建议能否使用SO_REUSEPORT，不过我们内核版本确实比较低，并没有实践过。另外能否模仿nginx，fork多个进程监控同样端口，至少我们目前没有这样做，主要对于我们目前进程管理上，还是独立的运行的，对外监听不同端口程序，还有配套的内部通信和管理端口，实例管理和升级上要做调整。</p><p>解决gc的另两个手段，是内存池和对象池,不过最好做仔细评估和测试，内存池、对象池使用，也需要对于代码可读性与整体效率进行权衡。<br>这种程序一定情况下会降低并行度，因为用池内资源一定要加互斥锁或者原子操作做CAS，通常原子操作实测要更快一些。CAS可以理解为可操作的更细行为粒度的锁（可以做更多CAS策略，放弃运行，防止忙等）。这种方式带来的问题是，程序的可读性会越来越像C语言，每次要malloc，各地方用完后要free，对于对象池free之前要reset，我曾经在应用层尝试做了一个分层次结构的“无锁队列”</p><p>上图左边的数组实际上是一个列表，这个列表按大小将内存分块，然后使用atomic操作进行CAS。但实际要看测试数据了，池技术可以明显减少临时对象和内存的申请和释放，gc时间会减少，但加锁带来的并行度的降低，是否能给一段时间内的整体吞吐量带来提升，要做测试和权衡…</p><p><img src="/content/images/2019/06/d5fb44dcbb01cb30d4820ece2db74fb.jpg" alt="d5fb44dcbb01cb30d4820ece2db74fb"></p><p>在我们消息系统，实际上后续去除了部分这种黑科技，试想在百万个协程里面做自旋操作申请复用的buffer和对象，开销会很大，尤其在协程对线程多对多模型情况下，更依赖于golang本身调度策略，除非我对池增加更多的策略处理，减少忙等，感觉是在把runtime做的事情，在应用层非常不优雅的实现。普遍使用开销理论就大于收益。<br>但对于rpc库或者codec库，任务池内部，这些开定量协程，集中处理数据的区域，可以尝试改造~<br>对于有些固定对象复用，比如固定的心跳包什么的，可以考虑使用全局一些对象，进行复用，针对应用层数据，具体设计对象池，在部分环节去复用，可能比这种无差别的设计一个通用池更能进行效果评估.</p><h2 id="架构迭代和迭代经验"><a href="#架构迭代和迭代经验" class="headerlink" title="架构迭代和迭代经验"></a>架构迭代和迭代经验</h2><p>下面介绍消息系统的架构迭代和一些迭代经验，由于之前在其他地方有过分享，后面的会给出相关链接，下面实际做个简单介绍，感兴趣可以去链接里面看</p><h3 id="架构迭代"><a href="#架构迭代" class="headerlink" title="架构迭代"></a>架构迭代</h3><p>根据业务和集群的拆分，能解决部分灰度部署上线测试，减少点对点通信和广播通信不同产品的相互影响，针对特定的功能做独立的优化.<br>消息系统架构和集群拆分，最基本的是拆分多实例，其次是按照业务类型对资源占用情况分类，按用户接入网络和对idc布点要求分类（目前没有条件，所有的产品都部署到全部idc）</p><p><img src="/content/images/2019/06/3bd38ef89d953b4a38ee82d3883845a.jpg" alt="3bd38ef89d953b4a38ee82d3883845a"></p><h3 id="简要介绍下我们的运维系统"><a href="#简要介绍下我们的运维系统" class="headerlink" title="简要介绍下我们的运维系统"></a>简要介绍下我们的运维系统</h3><p>我们利用Go原生的profiling工具，做了些可视化工作。可以对比多次上线出现的问题，通过压测程序复现部分瓶颈。定位cpu或者内存消耗的瓶颈。</p><p><img src="/content/images/2019/06/9d20e7fc447c0934ede155cd7a1ca5f.jpg" alt="9d20e7fc447c0934ede155cd7a1ca5f"></p><p><img src="/content/images/2019/06/d582183dc3ccbbc15ae6203fcb08762.jpg" alt="d582183dc3ccbbc15ae6203fcb08762"></p><p>另外，我们也可以对基础库代码做内嵌，将RPC库，Redis库，内存池命中数据等，做可视化的展示，统计它的QPS、网络带宽占用、idle与working，各种出错情况。然后再通过各种压测手段，观察优化性能点，上线前后是否有影响。如果一个系统不可评估就无法优化，利用压测评估就会发现一些潜在的问题。</p><p><img src="/content/images/2019/06/fd90a02582647647c1631b71a570164.jpg" alt="fd90a02582647647c1631b71a570164"></p><h3 id="系统的测试"><a href="#系统的测试" class="headerlink" title="系统的测试"></a>系统的测试</h3><p>go语言在并发测试上有独特优势。<br>在功能测试上，系统分成两套，一套是我们针对自己的功能，自己设计并测试，但这样难免会有问题。另一套是公司的自动化测试部门（python实现的<del>）根据我们的功能来测试。双保险</del><br><img src="/content/images/2019/06/c1e3523ce678de3c2a5e0d763b6927a.jpg" alt="c1e3523ce678de3c2a5e0d763b6927a"></p><p>对于压力测试，目前主要针对指定的服务器，选定线上空闲的服务器做长连接压测。然后结合可视化，分析压测过程中的系统状态。但压测早期用的比较多，但实现的统计报表功能和我理想有一定差距。理论上压测完后，可以根据协议版本，汇总每一次压测进程详细数据，业务的QPS数量、每秒钟建立连接数量，极限状态下的cpu和内存消耗，等每一个考核细节。现在只是能看一个大概趋势.对于细微的性能提升，没法评估，我们后续准备结合自己写的中央管理组件keeper，做这个数据收集和展示~</p><p>对于go语言适用的场景。之前在gopher china上，有过我个人的理解和概括：适用于重逻辑的io密集型应用.</p><p>我觉得最近出的golang开源产品都符合这种场景， go写网络并发程序给大家带来的便利，让大家把以往为了降低复杂度，拆解或者分层协作的组件，又组合在了一起。</p><p>比如go的web框架是在做负责并发的webserver和负责业务处理cgi程序，放在了webserver中。新近的一些go写的“智能”代理或者中间件，把很多原先分层控制或者不同功能但类似的子系统，以各种形式组装起来，reborn一个新的中间件或者新产品<del>包括之前百度放出的go-bfe也是把重逻辑和io密集型很好结合的产物</del>（群里有bfe的同学么，求更多资料）</p><p>个人感觉在国内互联网创业公司爆发环境下，大厂的复杂设备，很多将被golang重新打包成适用在一定量级下的“全能”工具箱~<br>以上就是今天的go分享~ 谢谢大家，欢迎提问~</p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>架构设计和概要（ 1小时的分享 文字总结）<br><a href="http://blog.qiniu.com/archives/3720" target="_blank" rel="noopener">http://blog.qiniu.com/archives/3720</a><br>关于基础库实现和性能参数对比表格：<br><a href="http://blog.golang.org/qihoo" target="_blank" rel="noopener">http://blog.golang.org/qihoo</a></p><h2 id="提问环节"><a href="#提问环节" class="headerlink" title="提问环节"></a>提问环节</h2><p>提问：对比kafaka这些消息系统 有什么优点？<br>回答：我们是消息推送系统 指的对客户端的高并发推送的 面对场景不一样</p><p>提问：hadoop生态圈的大数据，算重逻辑和IO密集型应用不？<br>回答：不算 Hadoop主要是计算</p><p>提问：这种推送的方式如何保证消息是有序到达的？<br>回答：如果要保证有序 需要重新设计协议 对消息编号 先存储 后拉取 可以按人存储也可以按订阅关系 目前花椒的im系统 属于这种场景 有机会大家感兴趣可以分享升级版本聊天架构</p><p>提问：golang适不适合写web应用<br>回答：这个可以单独一讲回答 我的建议新的应用 大并发的场景可以考虑 老项目酌情改写替换</p><p>提问：推送的消息会有多级转发吗？还是说客户端直接跟一个server保持长链接就完事了？<br>回答：当流量大到一定程度 可以多级转发 类似cdn架构 目前花椒直播的推送系统支持这种场景 为idc流量做分级转发 普通场景不需要</p><p>提问：极光推送跟这种推送的应用场景就是差不多吧？<br>回答：方案都类似 协议复杂度会不同 比如为了保证一致性采取编号 先存储后发送</p><p>提问：多级之间也是长链接吧<br>回答：多级别只是rpc调用 rpc通常keepalive</p><p>提问：推送系统目前支持什么协议呢？ mqtt？web socket？<br>回答：分传输层和协议层 传输层web socket 没问题 mqtt是一个具体交互协议了 不具备通用可比性</p><p>提问：推送系统里面有用到epoll吗？有没有开源地址？<br>回答：用的golang； go原生就是对epoll封装…目前不开源 安全公司理解下</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>Leetcode-1-Two Sum</title>
    <url>/2019/06/09/Leetcode-1-Two-Sum/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">two-sum</a></p><h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = [<span class="number">2</span>]<span class="keyword">int</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span> ; i &lt; <span class="built_in">len</span>(nums) - <span class="number">1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;  </span><br><span class="line">            <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                result[<span class="number">0</span>] = i</span><br><span class="line">                result[<span class="number">1</span>] = j</span><br><span class="line">                <span class="keyword">return</span> result[:]  <span class="comment">//返回结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; numsSize;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; numsSize;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] == target - nums[i])&#123;</span><br><span class="line">                a[<span class="number">0</span>] = i;</span><br><span class="line">                a[<span class="number">1</span>] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>刷题的步伐</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>端午安康以及我的高考</title>
    <url>/2019/06/08/%E7%AB%AF%E5%8D%88%E5%AE%89%E5%BA%B7%E4%BB%A5%E5%8F%8A%E6%88%91%E7%9A%84%E9%AB%98%E8%80%83/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><p>昨天是中国的传统节日端午节，也是2019年高考的第一天。</p><p>她在端午节前一天下午来到了成都，我们相遇了，是的，相隔三千公里远外长达十个月的异地恋，终于宣告结束了。</p><p>端午节这一天，我们把房子整体收拾了一下，该扔的扔，该买的买，中午吃的冒菜，晚上买了鸭肉，虾尾，酸奶和啤酒庆祝。</p><p>今天是高考第一天，想起2014年我参加高考时，第一场语文作文后半段写的有些急，字都飞了起来；第二场数学填空选择做的很好，后面大题做的糟糕；第三场英语作文写的还可以；第四场理综一般般。后来回学校估分觉得应该能上个一本。</p><p>后来高考成绩公布，与我估分的偏差有些大，但还是能上个二本，然而我不甘心，思考着是复读还是去上大学。后来决定还是去上大学，因为我厌恶了高考那压抑的生活。</p><p>上了大学，遇见了各种各样的人，以及琳琅满目的社团和学生会。在每一次把酒言欢的夜晚，我独自坐在桌前，思考着我未来要走的路。当时的我很长一段时间都在自责与后悔中度过，放佛人生已成定数。</p><p>直到大二下学期，开始尝试打开窗户看外面的世界，开阔新视野的同时让我对自己的遭遇和学校看淡了些。大学毕业后，从事研发，专注于提升实力，前几天还意外被Go语言中文站长拉入了一个Go语言实践和布道者的群，里面的人大部分都是公司内的专家了，我有些激动，因为我从没有想过，我会离大佬们如此接近。未来的路，我想我会更坚定的走下去，因为这是一次他们对我的认可。</p><p>回忆了这么多，其实我想告诉正在准备高考的你，也是告诉那个曾经对未来惶恐不安的自己。人生就像一个长跑，也像一条正弦曲线，刚开始为0，然后你的事业会经历高峰和低谷，到高峰不要骄傲，到低谷不要气馁。</p><p>高考只是一道小山坡，未来的变数还有很多。</p><p>面带微笑，温暖前行。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>Ubuntu设置root账号登录</title>
    <url>/2019/06/04/Ubuntu%E8%AE%BE%E7%BD%AEroot%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h2 id="这样做的原因"><a href="#这样做的原因" class="headerlink" title="这样做的原因"></a>这样做的原因</h2><p>如果你是用<code>root</code>权限去启动一个服务，而这个服务正在跑时，我又在根据它反馈的信息，对代码做调整，比如打日志，而修改完源代码后，你是无法保存文件的，原因是你用<code>root</code>执行它，而就应该用<code>root</code>权限去修改它，否则你的编辑是无效的，<code>push</code>上去的代码还是原来的。</p><h2 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h2><ul><li><p>使用<code>chown</code>命令修改文件或文件夹的拥有者，具体如下</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chown -R 用户名 文件夹名或文件名</span><br></pre></td></tr></table></figure></li><li><p>使用<code>chmod</code>命令直接开放代码所在目录的所有权限</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">chmod -R 777 代码目录</span><br></pre></td></tr></table></figure></li><li><p>设置<code>root</code>账号登录。<br>不过一般<code>root</code>严格只用来管理服务器，只有少数人有该权限，所以在公司内不一定所有人都会有开启<code>root</code>的权限。<br>(在此感谢知识星球Go项目实战里的<code>Hy、per</code>提供的建议)</p></li></ul><h2 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h2><p>1，设置<code>root</code>用户密码</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo passwd root</span><br></pre></td></tr></table></figure><p>（注意：以下步骤必须在<code>root</code>权限下操作）<br>2，修改<code>/root/.profile</code>文件<br>用<code>vim</code>打开该文件内容</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ~/.profile: executed by Bourne-compatible login shells.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$BASH</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [ -f ~/.bashrc ]; <span class="keyword">then</span></span><br><span class="line">    . ~/.bashrc</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">mesg n || <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>将最后一句<code>mesg n || true</code>修改为<code>tty -s&amp;&amp;mesg n || true</code></p><p>2，修改<code>/usr/share/lightdm/lightdm.conf.d/50-ubuntu.conf</code>文件<br>在文件中添加以下内容</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#手动输入登录系统的用户名和密码</span></span><br><span class="line">greeter-show-manual-login=<span class="literal">true</span></span><br><span class="line"><span class="comment">#不允许guest登录</span></span><br><span class="line">all-guest=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>3，修改<code>/etc/pam.d/gdm-autologin</code>文件<br>注释掉</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#auth   required        pam_succeed_if.so user != root quiet_success</span></span><br></pre></td></tr></table></figure><p>4，修改<code>/etc/pam.d/gdm-password</code>文件<br>注释掉</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#auth   required        pam_succeed_if.so user != root quiet_success</span></span><br></pre></td></tr></table></figure><p>5，重新启动<code>ubuntu</code>系统，输入<code>root</code>名和密码登录即可。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>用<code>root</code>账户登录相当于给你重新创建一个新的桌面，所以个人建议是重装系统后就立马设置以<code>root</code>账户登录最佳。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>Golang并发中的FanIn范式学习</title>
    <url>/2019/06/02/Golang%E5%B9%B6%E5%8F%91%E4%B8%AD%E7%9A%84FanIn%E8%8C%83%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><p>在学习并发时，对<code>Fanin</code>和<code>Fanout</code>这两个范式印象深刻，特此记录一下学习心得。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>扇出（Fan-out）是一个术语，用于描述启动多个goroutines以处理来自管道的输入的过程，并且扇入（fan-in）是描述将多个结果组合到一个通道中的过程的术语。</p><p>画个图</p><p><img src="/.io//fanin_o.png" alt="fanin"></p><p><img src="/.io//fanout_o.png" alt="fanout"></p><p>这样做有什么好处呢，下面来看看源码。</p><h2 id="源码学习"><a href="#源码学习" class="headerlink" title="源码学习"></a>源码学习</h2><p>在<code>concurrent_map.go</code>文件中</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Iter returns an iterator which could be used in a for range loop.</span></span><br><span class="line"><span class="comment">// Deprecated: using IterBuffered() will get a better performence</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m ConcurrentMap)</span> <span class="title">Iter</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">Tuple</span></span> &#123;</span><br><span class="line">	chans := snapshot(m)</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Tuple)</span><br><span class="line">	<span class="keyword">go</span> fanIn(chans, ch)</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fanIn</span><span class="params">(chans []<span class="keyword">chan</span> Tuple, out <span class="keyword">chan</span> Tuple)</span></span> &#123;</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(<span class="built_in">len</span>(chans))  <span class="comment">//总共要进入的管道数目</span></span><br><span class="line">	<span class="keyword">for</span> _, ch := <span class="keyword">range</span> chans &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span> Tuple)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> t := <span class="keyword">range</span> ch &#123;  <span class="comment">//取出每一个管道内的数据</span></span><br><span class="line">				out &lt;- t  <span class="comment">//将数据发送给管道接收者out</span></span><br><span class="line">			&#125;</span><br><span class="line">			wg.Done()  <span class="comment">//每取完一次管道内的数据，管道数目减1</span></span><br><span class="line">		&#125;(ch)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="built_in">close</span>(out)  <span class="comment">//管道内的数据已经取完，关闭管道接收者out</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画图演示下过程<br><img src="/.io//chan_o.png" alt="chan"></p><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul><li><code>sync.WaitGroup</code><br>sync.WaitGroup只有3个方法，Add()，Done()，Wait()。其中Done()是Add(-1)的别名。简单的来说，使用Add()添加计数，Done()减掉一个计数，计数不为0, 阻塞Wait()的运行。<br>因此当计数为0时，也就是要进入的管道数都没有的时候，关闭管道。</li></ul><h2 id="FanIn范式的用途"><a href="#FanIn范式的用途" class="headerlink" title="FanIn范式的用途"></a>FanIn范式的用途</h2><p>在此引用我看到的一段话</p><blockquote><p>管道的一个有趣属性是它的各个阶段相互独立，方便组合。你可以多次重复使用管道的各个阶段。因此，在多个goroutine上重用管道的单个阶段实现并行化，将有助于提高管道的性能。<br>事实上，这种模式被称为扇入扇出。<br>那么在什么情况下适用于这种模式呢？如果出现以下两种情况，你就可以考虑这么干了：<br>不依赖模块之前的计算结果。<br>运行需要很长时间。</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.kancloud.cn/mutouzhang/go/596844" target="_blank" rel="noopener">扇入扇出_Concurrency in Go 中文笔记</a></li><li><a href="https://austburn.me/blog/a-better-fan-in-fan-out-example.html" target="_blank" rel="noopener">Go: A Better Fan-out, Fan-in Example</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>记一次项目演示前赶deadline的经历</title>
    <url>/2019/05/31/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%A1%B9%E7%9B%AE%E6%BC%94%E7%A4%BA%E5%89%8D%E8%B5%B6deadline%E7%9A%84%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>给新疆广电做的流媒体收录系统，原定于六月二十日研发完毕，无奈要提前演示，定到了五月底。所以我负责的地方需要抓紧进度。<br>同时下周一要做芒果TV的演示，我这里负责的模块网络端没有跑通。</p><h2 id="紧张"><a href="#紧张" class="headerlink" title="紧张"></a>紧张</h2><p>由于我之前在根据芒果TV的需求修改我负责的流媒体服务，改动较大（确切地说我已经改晕了），已经把最原始的功能都已经无法复现了，导致新疆广电的需求也无法完成。我在想，我该怎么办？</p><h2 id="转机"><a href="#转机" class="headerlink" title="转机"></a>转机</h2><p>在我即将感到绝望的一刻，产品负责人把部门的两位大佬打电话叫来，他看了下我的代码，改删的删，改增的增，在本地跑通后，放到测试环境上跑了一下，看了下日志，修改了几处异常，测试环境就跑通了，新疆广电的演示算是完成了。<br>而芒果TV的需求，涉及把业务流程搞懂再添加业务判断逻辑，和数据的封装和请求的发送，而我的问题就在于不知道这段逻辑代码放在哪里。不过还好最后有老哥带我一步步跟代码，最终把代码放到了正确的位置，测试也跑通了。</p><h2 id="经验教训和感受"><a href="#经验教训和感受" class="headerlink" title="经验教训和感受"></a>经验教训和感受</h2><ul><li>用<code>Go</code>写一个服务，应当首先用<code>curl</code>命令在本地跑通，接着写一个<code>Test</code>测试函数针对核心逻辑就行测试和修改，如果需要依赖其他服务，要么把需要的服务也部署起来，或者用<code>Nginx</code>去模拟<code>Mock</code>它（这个我还不会）。</li><li>越紧急的事情，一定要放宽心，深呼吸两次，不然很容易犯低级错误，比如该打日志的地方没有打，或者数据库查询语句写错，或者是变量名的格式没有写对，或者是<code>curl</code>命令请求时忘记在每一个出现<code>&quot;</code>加<code>\</code>（<code>curl</code>命令请求发<code>json</code>时的格式）。而这些细微的出错，最终都将导致自己，或者陪同的其他研发人员，甚至测试人员白忙活一阵。</li><li>一定要对服务器业务逻辑熟悉，一定要经常打断点去跟代码。</li><li>遇到<code>Panic</code>空指针报错，一定是一些值没有初始化造成的，而我是犯了一个低级错误：没有<code>error</code>，自己在日志中打了个<code>error.Error()</code>导致的，为此我付出了代价，全局搜索了<code>error.Error()</code>字段，把有问题的语句全部改了。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是错误的，一定要注意，直接会抛异常</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(xxx) == <span class="number">0</span> &#123;</span><br><span class="line">    Log.Error(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>遇到想不通的问题，多在存在疑惑的代码片段周围打满日志。</li><li>遇到的每一个<code>bug</code>，详细记录错误发生的原因，以及找到错误解决的方式，还有解决过程，记录完后要及时回看。</li><li>熟练使用<code>git</code>指令，不只满足于<code>add commit push</code>三步，还应该涉及合并，<code>cherry-pick</code>等比较危险的指令，这有益于减少管理代码和发版时瞎忙活的概率。</li><li>相比于研发，测试运维这些人在体力上都比较辛苦，所以建议能自己解决的就少给他们增添麻烦。也许是我看到他们一个电脑开着十几台虚拟机，远程连接里套着远程连接再套着远程连接，周围做前后端和产品都围着他时，才有的感触吧。</li></ul><p>问题警报解除后，同事问我，有没有是在给家乡做贡献的感觉。我说，有那么一点。但我心里更多的是对他们的感激与深深的惭愧，交代给我负责的项目，没有完成，同时也暴露了我的诸多开发上的问题。这些坑，我需要尽快填上。</p><p>希望项目演示一切顺利！</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>Golang中的CPU占满100%及解决方案</title>
    <url>/2019/05/26/Golang%E4%B8%AD%E7%9A%84CPU%E5%8D%A0%E6%BB%A1100-%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><p>有一个流媒体适配服务，出现了<code>CPU</code>开销很大的问题，一个服务把<code>CPU</code>资源占满了，导致其他服务无法正常工作。<br>下面来详细记录发现<code>bug</code>和解决的流程。</p><h1 id="发现CPU开销很大"><a href="#发现CPU开销很大" class="headerlink" title="发现CPU开销很大"></a>发现CPU开销很大</h1><p>扫描发现，是垃圾回收导致 <code>CPU</code> 使用上升 ：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Time: Mar 22, 2019 at 5:52pm (CST)</span><br><span class="line">Duration: 1mins, Total samples = 1.43mins (142.57%)</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof) tree </span><br><span class="line">Showing nodes accounting for 83.13s, 97.11% of 85.60s total</span><br><span class="line">Dropped 256 nodes (cum &lt;= 0.43s)</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">      flat  flat%   sum%        cum   cum%   calls calls% + context 	 	 </span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">                                            71.36s 99.86% |   runtime.gcDrain</span><br><span class="line">                                             0.10s  0.14% |   runtime.systemstack</span><br><span class="line">    48.56s 56.73% 56.73%     71.46s 83.48%                | runtime.scanobject</span><br><span class="line">                                            11.86s 16.60% |   runtime.heapBitsForObject</span><br><span class="line">                                            11.04s 15.45% |   runtime.greyobject</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">                                            11.86s 99.92% |   runtime.scanobject</span><br><span class="line">    11.87s 13.87% 70.60%     11.87s 13.87%                | runtime.heapBitsForObject</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">                                            11.04s   100% |   runtime.scanobject</span><br><span class="line">    11.02s 12.87% 83.47%     11.04s 12.90%                | runtime.greyobject</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">                                             6.53s 95.05% |   runtime.gosweepone.func1</span><br><span class="line">                                             0.34s  4.95% |   runtime.(*mheap).alloc</span><br><span class="line">     4.34s  5.07% 88.54%      6.87s  8.03%                | runtime.sweepone</span><br><span class="line">                                             2.53s 36.83% |   runtime.(*mspan).sweep</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">                                            74.42s   100% |   runtime.gcBgMarkWorker.func2</span><br><span class="line">     1.97s  2.30% 90.84%     74.42s 86.94%                | runtime.gcDrain</span><br><span class="line">                                            71.36s 95.89% |   runtime.scanobject</span><br><span class="line">                                             0.52s   0.7% |   runtime.pollWork</span><br><span class="line">----------------------------------------------------------+-------------</span><br></pre></td></tr></table></figure><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>之后考虑使用 <code>buffer pool</code>,</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 这里不再分配新的内存，而是从 buffer pool 里面 GET </span></span><br><span class="line">databuf = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">100000</span>)</span><br></pre></td></tr></table></figure><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>参考<a href="https://github.com/libp2p/go-buffer-pool" target="_blank" rel="noopener">go buffer pool</a></p><ul><li><p>先创建一个<code>buffer pool</code></p></li><li><p>在<code>Get</code>它</p></li><li><p>用完再<code>Put</code>回去</p></li><li><p>注意，最好在<code>Get</code>和<code>Put</code>时加锁。</p></li></ul><h1 id="是什么原因导致了CPU开销很大（重点）"><a href="#是什么原因导致了CPU开销很大（重点）" class="headerlink" title="是什么原因导致了CPU开销很大（重点）"></a>是什么原因导致了CPU开销很大（重点）</h1><p>当我们新建了一个有长度变量时，例如100<code>byte</code>的数组，那么它在操作系统内存中是这样展现的</p><p><img src="/.io//memory.png" alt></p><p>因此，当我们新建一个变量时，操作系统会在自己的运行内存里开辟一块内存给这个变量存数据用。当我们不需要这个数据时，或者说要删除这个变量时，<code>Golang</code>会执行垃圾回收机制。</p><p>然而当<code>Golang</code>在执行垃圾回收时，操作系统会不断对这些有或者没有被引用的变量进行扫描，这中间涉及操作系统的算法，我们不用深究，但是，在执行这种算法时，会占用<code>CPU</code>的资源，如果新开辟的变量和内存过多，就会导致系统不停的检查是否有不需要引用的变量了，从而造成占用<code>CPU</code>资源过多。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>创建一个<code>buffer pool</code></p><p>创建一个大的<code>buffer pool</code>，你需要内存时，向<code>buffer pool</code>获取一下<code>Get</code>，用完不需要时再还回去<code>Put</code>。</p><p><img src="/.io//bufferpool.png" alt></p><p>这样做的好处是，操作系统每次检查内存时，都只有一个<code>buffer pool</code>在引用，不增不减，于是也就减少<code>CPU</code>资源的消耗了。</p><h2 id="打个比方"><a href="#打个比方" class="headerlink" title="打个比方"></a>打个比方</h2><p>比如说操作系统就是一个土豪，借东西再换回来不收利息。它有一个很大的内存，周围许多人都想找它去借(新声明的变量并初始化)，刚开始借的人只有十几个，后面有上万个，于是它要每天记录谁借了多少内存出去，谁还没有归还，归还的直接从记录上把名字划掉(垃圾回收)。后来操作系统烦了，于是就建了一个很大的内存池，够所有人分批次借，只要借完及时归还就行，而它每次去看这个内存池有没有变小即可，省了不少精力。</p><p>而这个内存池就是<code>go buffer pool</code>的作用。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>建议给<code>Get</code>和<code>Put</code>加锁，防止多个协程同时借阅，造成竞争冒险。<br>这个<code>CPU</code>占满问题涉及<code>Golang</code>的垃圾回收机制，这块是要点，一定要搞明白。</p><h1 id="参考文章和资源"><a href="#参考文章和资源" class="headerlink" title="参考文章和资源"></a>参考文章和资源</h1><ul><li><a href="https://github.com/libp2p/go-buffer-pool" target="_blank" rel="noopener">go buffer pool</a></li><li><a href="http://legendtkl.com/2017/04/28/golang-gc/" target="_blank" rel="noopener">Golang 垃圾回收剖析</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>工作记录</category>
      </categories>
      <tags>
        <tag>Golang</tag>
        <tag>解决方案</tag>
        <tag>CPU占满</tag>
      </tags>
  </entry>
  <entry>
    <title>吊车尾</title>
    <url>/2019/05/23/%E5%90%8A%E8%BD%A6%E5%B0%BE/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><p>这一周感觉过得好慢，也许是我太压抑了的缘故吧。</p><p>周一，让我做一个新需求，周二，又增加了一个新需求，让我抓紧时间，五月底要上线，然而我周二下午发现这个需求有问题，周三又讨论了一上午定下来要修改的部分。然而就在今天，又说这些不重要了，先把另外一个新需求做了。</p><p>好吧，我认了，毕竟是拿人钱财，替人干活。你说干嘛我干嘛。</p><p>然而，新需求是在老项目的一个逻辑上做的，而我对这块业务不熟悉，于是请教，接着受打击，这已经成为我工作的家常便饭了。</p><p>晚上回家，突然想看火影，看李使用八门遁甲开了五门虐我爱罗最终获得凯老师的认可，看鸣人中忍考试最终用实力证明给宁次看我不是吊车尾，看迈特凯开了死门虐拥有六道能力的斑。</p><p>他们都在坚持不懈的贯彻自己的忍道。</p><p>那我在编程上的忍道又是什么呢？</p><p>我喜欢钻研新东西，喜欢用自己的方式去创新，然而我现在经验不足，只能通过大佬的源代码窥探其中工程设计的奥妙。</p><p>我能力不足，但又不肯认输；我进步缓慢，原来，突然发现自己真的是一无是处，放佛成了部门的吊车尾。</p><p>今天我不知道在内心深处有多少次想过放弃，但我实在不甘心，不跨过这个坎，我怎么成长？！</p><p>只能在深夜再给自己打气，让自己挺住，毕竟，在那些大佬看来，这真的是一件微不足道的挫折罢了。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang中的协程泄露及解决方案</title>
    <url>/2019/05/14/Golang%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B%E6%B3%84%E9%9C%B2%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>Golang中的内存泄露及解决方案</title>
    <url>/2019/05/14/Golang%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><p>工作中记一次碰到内存泄漏的解决过程。</p><h1 id="发现内存泄露"><a href="#发现内存泄露" class="headerlink" title="发现内存泄露"></a>发现内存泄露</h1><p>写的一个定时删除文件的服务，结果无缘无故被系统杀死了。</p><p>于是我设置了参数，每隔30s启动一次。并用<code>dmesg</code>命令查看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1700172.849656] Out of memory: Kill process 1195 (SliceDyson) score 730 or sacrifice child</span><br><span class="line">[1700172.849665] Killed process 1195 (SliceDyson) total-vm:13314968kB, anon-rss:8693980kB, file-rss:116kB</span><br></pre></td></tr></table></figure><p>确定是内存泄露造成的。</p><h1 id="使用pprof分析造成内存泄露的原因"><a href="#使用pprof分析造成内存泄露的原因" class="headerlink" title="使用pprof分析造成内存泄露的原因"></a>使用pprof分析造成内存泄露的原因</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><p><a href="https://golang.org/pkg/runtime/pprof/" target="_blank" rel="noopener">golang pprof 的文档</a> 里面给了一个例子，如何把 <code>pprof</code> 信息输出到文件里面</p></li><li><p><a href="https://www.reddit.com/r/golang/comments/6kv625/my_app_has_memory_leaks_how_to_find_them/" target="_blank" rel="noopener">Reddit 上这篇文章</a>，提到了如何通过对比两次 <code>heap</code> 的结构，来判断到底哪些内存没有释放：</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">One thing you can do is to compare 2 heap pprofs. You can do it like this:</span><br><span class="line"></span><br><span class="line">    Extract a heap profile heap0.pprof</span><br><span class="line"></span><br><span class="line">    Add some load to the application</span><br><span class="line"></span><br><span class="line">    Extract another heap profile heap1.pprof</span><br><span class="line"></span><br><span class="line">    Compare them with go tool pprof -base heap0.pprof &lt;bin&gt; heap1.pprof</span><br><span class="line"></span><br><span class="line">This way you can see exactly what is increasing over time.</span><br></pre></td></tr></table></figure><ul><li><a href="https://blog.golang.org/profiling-go-programs" target="_blank" rel="noopener">https://blog.golang.org/profiling-go-programs</a></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li>分析生成的<code>.pprof</code>文件</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ go tool pprof 120.pprof </span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: Mar 6, 2019 at 9:27pm (CST)</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting for 603.20MB, 99.67% of 605.20MB total</span><br><span class="line">Dropped 1 node (cum &lt;= 3.03MB)</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">  603.20MB 99.67% 99.67%   605.20MB   100%  main.main</span><br><span class="line">         0     0% 99.67%   605.20MB   100%  runtime.main</span><br><span class="line">(pprof) ^C</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ go tool pprof 240.pprof </span><br><span class="line">Type: inuse_space</span><br><span class="line">Time: Mar 6, 2019 at 11:42pm (CST)</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting for 2.81GB, 99.86% of 2.81GB total</span><br><span class="line">Dropped 6 nodes (cum &lt;= 0.01GB)</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">    2.81GB 99.86% 99.86%     2.81GB   100%  main.main</span><br><span class="line">         0     0% 99.86%     2.81GB   100%  runtime.main</span><br></pre></td></tr></table></figure><ul><li>分析各个函数的占比情况</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">File: SliceDyson</span><br><span class="line">Type: inuse_objects</span><br><span class="line">Time: Mar 7, 2019 at 2:52pm (CST)</span><br><span class="line">Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)</span><br><span class="line">(pprof) web</span><br><span class="line">(pprof) top</span><br><span class="line">Showing nodes accounting for 6810, 100% of 6810 total</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">      6554 96.24% 96.24%       6554 96.24%  main.GetXMLFiles</span><br><span class="line">       256  3.76%   100%        256  3.76%  vendor/golang_org/x/net/http2/hpack.addDecoderNode</span><br><span class="line">         0     0%   100%        256  3.76%  main.init</span><br><span class="line">         0     0%   100%       6554 96.24%  main.main</span><br><span class="line">         0     0%   100%        256  3.76%  net/http.init</span><br><span class="line">         0     0%   100%       6810   100%  runtime.main</span><br><span class="line">         0     0%   100%        256  3.76%  vendor/golang_org/x/net/http2/hpack.init</span><br><span class="line">         0     0%   100%        256  3.76%  vendor/golang_org/x/net/http2/hpack.init.0</span><br></pre></td></tr></table></figure><p>最后定位到造成内存泄露的原因，是<code>GetXMLFiles</code>函数造成的。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlFilesPath []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> LoopGetXmlFilesPath []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> AllTasks []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> tasks []*Task</span><br><span class="line"><span class="keyword">for</span> _, RootPath := <span class="keyword">range</span> ParseStorageINI(StorageINIPath) &#123;</span><br><span class="line">	xmlFilesPath = GetXMLFiles(RootPath)</span><br><span class="line">	<span class="keyword">for</span> _, xmlFilesPath_str := <span class="keyword">range</span> xmlFilesPath &#123;</span><br><span class="line">		LoopGetXmlFilesPath = <span class="built_in">append</span>(LoopGetXmlFilesPath, xmlFilesPath_str)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>把<code>xmlFilesPath</code>放到<code>for range</code>循环里面声明初始化即可</p><h1 id="是什么原因会导致内存泄露"><a href="#是什么原因会导致内存泄露" class="headerlink" title="是什么原因会导致内存泄露"></a>是什么原因会导致内存泄露</h1><h1 id="什么时候需要垃圾回收-GC"><a href="#什么时候需要垃圾回收-GC" class="headerlink" title="什么时候需要垃圾回收(GC)"></a>什么时候需要垃圾回收(GC)</h1><h1 id="参考文章和资源"><a href="#参考文章和资源" class="headerlink" title="参考文章和资源"></a>参考文章和资源</h1><ul><li><a href="https://stackoverflow.com/questions/48618201/how-to-release-memory-allocated-by-a-slice" target="_blank" rel="noopener">how-to-release-memory-allocated-by-a-slice</a></li><li><a href="https://stackoverflow.com/questions/37382600/cannot-free-memory-once-occupied-by-bytes-buffer" target="_blank" rel="noopener">cannot-free-memory-once-occupied-by-bytes-buffer</a></li><li><a href="http://legendtkl.com/2017/04/28/golang-gc/" target="_blank" rel="noopener">Golang垃圾回收剖析</a></li><li><a href="https://golang.org/pkg/runtime/pprof/" target="_blank" rel="noopener">pprof</a></li><li><a href="https://www.reddit.com/r/golang/comments/6kv625/my_app_has_memory_leaks_how_to_find_them/" target="_blank" rel="noopener">my_app_has_memory_leaks_how_to_find_them</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>解决方案</tag>
        <tag>内存</tag>
        <tag>泄露</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang踩坑集中整理</title>
    <url>/2019/05/14/Golang%E8%B8%A9%E5%9D%91%E9%9B%86%E4%B8%AD%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h1 id="append-x-1-与x-append-x-1-的区别"><a href="#append-x-1-与x-append-x-1-的区别" class="headerlink" title="append(x,1)与x = append(x,1)的区别"></a>append(x,1)与x = append(x,1)的区别</h1><p>今天有同事问我</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line">x = <span class="built_in">append</span>(x,<span class="number">1</span>)</span><br><span class="line"><span class="comment">//append(x,1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//两者有什么区别</span></span><br></pre></td></tr></table></figure><p>我瞬间懵了，这不很明显吗？</p><p><code>x = append(x,1)</code>是在<code>x</code>的原先基础上增加了一个元素，所以<code>x</code>中元素为5，而<code>append(x,1)</code>没有赋返回值，所以会报错!</p><p>同事说，这不是重点，我是问你<code>append(x,1)</code>后<code>x</code>中的元素有几个。</p><p>于是，我想了下，同时也请教了他人，最终得出答案，<code>x</code>为4。</p><h2 id="为什么会这样？"><a href="#为什么会这样？" class="headerlink" title="为什么会这样？"></a>为什么会这样？</h2><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>学习</tag>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title>再见乌鲁木齐，再见新疆</title>
    <url>/2019/05/11/%E5%86%8D%E8%A7%81%E4%B9%8C%E9%B2%81%E6%9C%A8%E9%BD%90%EF%BC%8C%E5%86%8D%E8%A7%81%E6%96%B0%E7%96%86/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><p><a href="./plane"></a></p><p>(本文有感于五一，完稿于母亲节)</p><p>5月6号晚，在乌鲁木齐的地窝堡国际机场，坐在飞机上，广播里说着飞机即将起飞，请关闭手机或调整为飞行模式，我知道，我又要和这座城市告别了。</p><p>父亲开车送我去机场的路上，在穿过蜘蛛山隧道时，落日的余晖洒向了这座城市，我看到了这里林立的高楼，和四通八达的街道，以及刚刚亮起来的路灯。</p><p>是的，这是我生活了二十二年的城市。</p><p>它完整的记录了我从孩童成长为工作者的心路历程。</p><p>就让我再穿越回过去，回忆这些转瞬即逝又弥足珍贵的记忆。</p><h1 id="与杨搭城堡"><a href="#与杨搭城堡" class="headerlink" title="与杨搭城堡"></a>与杨搭城堡</h1><p>时间：小学四年级。</p><p>地点：小巷子。</p><p>人物：童年玩伴杨</p><p>结束了一天在学校的学习，作业太少了，提前做完了，就算不会第二天去早点抄，玩耍才是最重要的！</p><p>我约了杨和我一起去沙堆上搭城堡（其实现在看来像是在打洞），我和他挖的正兴奋时，父亲怒气冲冲的过来把我像提小鸡一样提起来，告诫我不要玩沙子，把手弄脏了。</p><p>我给杨递了个眼色，于是给父亲保证再不会碰这个了。</p><p>等父亲走后，我又跑过去和他动工了。忙活到了晚上十点多，终于把城堡搭完了，筷子用断了好几根，脸也脏了，不过还是很开心呢。</p><p>虽然这些艺术品在大人看来一文不值，明天估计就要被毁了，但我知道那时的我看到自己辛苦搭建出来的东西后，充满了成就感。</p><h1 id="新华书店窃读记"><a href="#新华书店窃读记" class="headerlink" title="新华书店窃读记"></a>新华书店窃读记</h1><p>时间：小学五年级</p><p>地点：乌鲁木齐市南门新华书店</p><p>人物：童年玩伴杨</p><p>因为非常喜欢看冒险小虎队系列的侦探书，无奈杨用零花钱买的几本书已经被我看了两遍了，于是我和他计划，周末去书店看。</p><p>于是和父母说了一声后，周末吃过早饭和杨坐着61路公交车去书店，心里默念：今天我要看十本书！</p><p>抵达书店，上二楼后厅，拿书，找空地坐下来，动作一气呵成。</p><p>那一天，我记得是我生命中最充实最开心的时光，因为我把我的意识完全沉浸在侦探的世界里。</p><h1 id="街边小巷你追我打的欢快"><a href="#街边小巷你追我打的欢快" class="headerlink" title="街边小巷你追我打的欢快"></a>街边小巷你追我打的欢快</h1><p>时间：小学六年级</p><p>地点：街头小巷</p><p>人物：一群小屁孩</p><p>作业写完，叫上好朋友，一起去玩捉迷藏，真假孙悟空…反正就是各种跑。</p><p>有时候玩得过头了，十几个小娃娃追着我，我就东躲西藏，他们说抓住我有重赏。</p><p>就这样，间接锻炼了我奔跑的耐力和随机应变的决断力，也收获了一下午的喜悦。</p><h1 id="插卡游戏机街头霸王车轮战"><a href="#插卡游戏机街头霸王车轮战" class="headerlink" title="插卡游戏机街头霸王车轮战"></a>插卡游戏机街头霸王车轮战</h1><p>时间：初一、二年级</p><p>地点：韩家蛋糕盒厂</p><p>人物：韩，杨等游戏高手</p><p>初一认识了韩，因为他家有插卡游戏机，所以我经常跑他家里打游戏。</p><p>还记得当时我最爱玩街头霸王，最喜欢用一个黄头发发冲击波的格斗家和会放电的野兽。为了发出绝招，我把游戏手柄的方向键搓掉了，又把自己的大拇指搓肿了。经常玩到父母上门来找才肯结束。</p><p>除了街头霸王，还有四代魂斗罗，超级赛亚人等。</p><h1 id="地下游戏厅称霸记"><a href="#地下游戏厅称霸记" class="headerlink" title="地下游戏厅称霸记"></a>地下游戏厅称霸记</h1><p>时间：初一</p><p>地点：家对面的地下游戏厅</p><p>人物：游戏爱好者</p><p>家对面开了家游戏厅，里面有台球桌，还有两台PS2，在一个小隔间里还有四五台电脑，于是这里成了我放学和周末的天堂。</p><p>我充分发挥了自己善于钻研和学习的天分，不到两个月，没花一分钱，成了这家游戏厅里的游戏专家，没事给打三国无双的玩家指点一二，或者去和其他人联机CS1.6场场爆头。</p><p>后来因为白玩的次数太多了，被游戏厅老板拉入了黑名单。</p><h1 id="懵懂无知的好感"><a href="#懵懂无知的好感" class="headerlink" title="懵懂无知的好感"></a>懵懂无知的好感</h1><p>时间：初二</p><p>地点：某初中</p><p>人物：a gril</p><p>第一次对一个女孩产生好感应该就是这个时候吧。</p><p>想想也真是奇葩，产生好感那就表现的好一点就是，然而偏偏把自己最坏的一面表现了出来。</p><p>那种抑制不住的脸红和怦怦的心跳声，大概就是初恋的滋味吧，也是我再也回不去的青春。</p><p>虽然我已经记不清她的模样，但也是因为她的出现和离开，让我学会如何去用心喜欢上一个人。</p><h1 id="与赵的原始书信"><a href="#与赵的原始书信" class="headerlink" title="与赵的原始书信"></a>与赵的原始书信</h1><p>时间：初三</p><p>地点：无</p><p>人物：学习的榜样老赵</p><p>面临中考，每当这时候会与相互打气，还记得那时候没有手机，不能登QQ，于是就以最原始的方式保持通信—写信。</p><p>将信写好，装入那种放自动笔芯的圆筒内，然后交给顺路的人帮忙捎带给他，想想也是够机智的。</p><p>这种方式一直持续到高考结束，然后就戛然而止。</p><h1 id="影响我一生的良师益友"><a href="#影响我一生的良师益友" class="headerlink" title="影响我一生的良师益友"></a>影响我一生的良师益友</h1><p>时间：高三</p><p>地点：高中</p><p>人物：张，沈，杨，赵</p><p>高三，多么神圣的阶段，也许你的一分，就能干掉上千人，这是当时最流行的宣传语。</p><p>然而我又何尝不想拼搏努力呢。</p><p>只是，当我把自己想象成一台做题机器时，总会有人帮我找回本来的模样。</p><p>我想起，每当吃午饭的时候，我都会给凡儿和魁拔，讲述我自编的喜剧小说《高考命题组专家的故事》；我会在补习班内和杨还有赵吐槽这该死的高考题；我会咨询张老师是不是我太笨了为什么我一天睡五个小时，做题十个小时还是年级还不进步呢…</p><p>多年后当我再来看这些问题时，会觉得当时的我多么幼稚。</p><h1 id="大学毕业之后才懂"><a href="#大学毕业之后才懂" class="headerlink" title="大学毕业之后才懂"></a>大学毕业之后才懂</h1><ul><li>原来挣钱真的不容易</li><li>保持终生学习的观念，这是一个长跑</li><li>有空常回家看看</li><li>学习靠主动，工作靠自觉</li><li>有些人走着走着就会散了，你可以沉默一时，但不能一直活在这个阴影里</li><li>生命第一，生活第二，工作第三</li></ul><h1 id="再见乌鲁木齐，再见新疆"><a href="#再见乌鲁木齐，再见新疆" class="headerlink" title="再见乌鲁木齐，再见新疆"></a>再见乌鲁木齐，再见新疆</h1><p>这里有我忘不掉的人和景。</p><p>我想起和家人一起去阜康天池坐船看瀑布；一起去吐鲁番欣赏交河故城的荒凉，维吾尔族村寨，坎儿井的避暑好去处，火焰山的金箍棒温度计，葡萄沟的葡萄；一起去天山野生动物园里看狮子老虎大象长颈鹿，去植物园看各种花花草草，去游乐场玩碰碰车、旋转椅子和疯狂老鼠；一起自驾游去昌吉的杜氏旅游村；一起去石人沟骑马，我在湖边行走时右脚踏入沼泽地硬是左腿发力挣脱了出来；</p><p>我感谢家人给予我资金和精神上的鼓励，在我大二暑假时同意让我一个人走出去看看，这一走就是一个多月，走了十三座城市，路上遇到了许多社会上各个阶级的人，使我长了见识；感谢他们一如既往的支持我继续读研和深造，而不是逼着我赶紧就业，虽然最后没有成功考上。</p><p>我会想起和大学同学一起骑行一百二十公里去阿克苏的惊险刺激；和朋友去库车旅行，在沙漠公路上遭遇沙尘暴，方圆能见度不足三米的时候一辆越野车及时出现化解了危机；百里徒步去沙漠路上的艰辛，以及看到屹立不倒的胡杨，放佛沙漠中守护的卫士；</p><p>我会想起和女友夏天去的博斯腾湖，夜晚欣赏那静谧的孔雀河；冬天在公园里散步，差点把自己的耳朵冻掉；</p><p>我会想起和学校同学夏天扔水球，泼水冲凉，冬天打雪仗的开心；和慎在学校内散步，讨论物理化学题；和涛咨询人生困惑；和杨推着购物车在七一酱园，好家乡，友好里面乱逛；和好朋友去火焰山吃自助火锅烧烤，去八音和里唱歌，去人民电影院和和平都会踩点找最合适的场次；高三毕业去南山牧场吃烧烤，骑马。</p><p>仔细梳理，原来我留在这的回忆有这么多。</p><p>五一回家，看着周围熟悉的街道已经拆的差不多了，想想自己以后也是要一年才回一次家，不知明年回来时，这些记忆是否还能记住一半？</p><p>从我决定离开这座城市到一座新城市发展的时候，我知道我以后需要独自面临许多未知的阻碍。我要随机应变适应新的环境。</p><ul><li>我要更加坚强，来应对突如其来的质疑和压力；</li><li>我要更加机警，防止被套路；</li><li>我要更加勇敢，接受新挑战；</li><li>我要更加感恩，记住在这样一个陌生的城市里还愿意帮助我的人；</li><li>我要更加珍惜学习的机会；</li><li>我要学会接纳自己的不足。</li></ul><p>今天，我不认为一年前我放弃校招选择社招离开自己熟悉的环境而感到遗憾，并且我从没有如此神清气爽过，我放佛看到了重生，因为从此以后，我将不受束缚。</p><p><img src="/.io//bohu" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>乌鲁木齐</tag>
        <tag>新疆</tag>
        <tag>告别</tag>
      </tags>
  </entry>
  <entry>
    <title>我们这一代人面临的知识焦虑</title>
    <url>/2019/04/28/%E6%88%91%E4%BB%AC%E8%BF%99%E4%B8%80%E4%BB%A3%E4%BA%BA%E9%9D%A2%E4%B8%B4%E7%9A%84%E7%9F%A5%E8%AF%86%E7%84%A6%E8%99%91/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h1 id="为什么要写这样一篇文章"><a href="#为什么要写这样一篇文章" class="headerlink" title="为什么要写这样一篇文章"></a>为什么要写这样一篇文章</h1><p>零点整，和远在三千公里外的女友互道晚安后，继续刷我在极客时间上订阅的关于操作系统的专栏，无意间看到微信群里有人谈到焦虑，我想是时候写一篇文章，来聆听下自己的心声，因为不知道下次又等到什么时候去了。</p><h1 id="我的知识焦虑"><a href="#我的知识焦虑" class="headerlink" title="我的知识焦虑"></a>我的知识焦虑</h1><p>我最开始感到知识焦虑，是在我上大三的时候，当时下载了一个得到app，看到我尊敬的老师在里面建了专栏发文章，于是我咬牙拿出我半个月的伙食费，订阅了为期一年的专栏，于是我坚持早起打开app刷一篇文章，觉得不错还在下面进行留言。</p><p>讲真，我到现在都没有记住里面的内容，只记得当时讲的各种人生经验、理论、方法都很高大上，让我这小白大开眼界。</p><p>后来知识付费不知不觉就流行了起来，从得到app，到知识星球和小专栏，再到极客时间，于是美其名曰充分利用碎片化时间进行学习。</p><h1 id="为什么要知识付费"><a href="#为什么要知识付费" class="headerlink" title="为什么要知识付费"></a>为什么要知识付费</h1><p>说说我为什么会对一些专栏进行付费的原因</p><ul><li>得到某一领域技能的提点，从而提升在某领域的核心竞争力(主因)</li><li>与大佬近距离接触，沟通，不是常说“近朱者赤，近墨者黑”嘛</li><li>拓宽人脉，结识优秀的人</li><li>督促自己主动学习(既然花钱了，肯定想要回本啊)</li></ul><h1 id="那为什么会有知识焦虑呢"><a href="#那为什么会有知识焦虑呢" class="headerlink" title="那为什么会有知识焦虑呢"></a>那为什么会有知识焦虑呢</h1><p>在这里让我想起了木心的一首诗</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">记得早先少年时 大家诚诚恳恳 说一句是一句</span><br><span class="line"></span><br><span class="line">清早上火车站 长街黑暗无行人 卖豆浆的小店冒着热气</span><br><span class="line"></span><br><span class="line">从前的日色变得慢 车、马、邮件都慢 一生只够爱一个人</span><br><span class="line"></span><br><span class="line">从前的锁也好看 钥匙精美有样子 你锁了 人家就懂了</span><br></pre></td></tr></table></figure><p>从前的交通很慢，父母要从陕西到乌鲁木齐，要坐七天七夜的绿皮车；从前的网速邮件很慢，话费很贵，见字如面，惜字如金，只要能半个月写封信或通个电话那头的人就已经心满意足了；从前的人想法很简单，只要学一个技能，能混个饭饱饿不死就行。</p><p>然而那是二十年前的日子，现在是高速信息化时代，一切都在追寻快。</p><p>交通如果慢一点，就着急跺脚；视频通话稍微卡顿，就说网速太差；一个技能还没有吃透，又想着吃另一个，然而精力时间有限。</p><p>我一直在找寻产生知识焦虑的原因，如果让我追本溯源的话，我想，那就是当我们的野心还配不上我们的行动时，现实与理想的落差而造成的。</p><h1 id="IT，一个特殊的行业"><a href="#IT，一个特殊的行业" class="headerlink" title="IT，一个特殊的行业"></a>IT，一个特殊的行业</h1><p>IT，我觉得它与传统行业的差别在于，更新迭代速度非常快，稍微慢一点，你就会感觉到掉队。</p><p>比如新框架替换老框架，就像人体的新城代谢似的。</p><p>所以，在我们入了这个行业的时候，就要抱着终身学习的方向去努力。</p><h1 id="我曾如此焦虑过"><a href="#我曾如此焦虑过" class="headerlink" title="我曾如此焦虑过"></a>我曾如此焦虑过</h1><p>当我早上醒来时，去操场跑步，去食堂吃早饭，在校园的林荫小道上背半小时的新概念，看一会我订阅的专栏的更新，然后去教师上课，这时候视情况而定，如果老师在吹牛逼，就屏蔽掉，同时拿出自己到图书馆借阅的算法书或一些文学小说看；中午午休，下午没课去图书馆或实验室看书刷题写博客；晚饭过后继续做看书学习的循环。</p><p>这样的日子持续了很长时间，因为我不知道未来我会遇到什么样的竞争对手，不知道我遇到的同事是否比我强，如果比我强，拖后腿就难受了。<br>未知是恐惧的，所有的这一切促使我紧张而又焦虑的度过生活的每一天。</p><h1 id="战胜焦虑的过程"><a href="#战胜焦虑的过程" class="headerlink" title="战胜焦虑的过程"></a>战胜焦虑的过程</h1><p>这一切的改变源于一个人的出现。</p><p>直到她的出现我的生活中，让我知道原来学校外还有一些好吃的餐馆，原来秋天学校里通往教学楼的路是如此美丽，原来梨花开的那一刻竟是如此浪漫，原来和喜欢的人安安静静的坐在小水池旁边，一人各抱着半个西瓜啃是如此美好。</p><p>她说：<strong>生命苦短，及时行乐</strong>。</p><h1 id="适当焦虑"><a href="#适当焦虑" class="headerlink" title="适当焦虑"></a>适当焦虑</h1><p>现在的我，有时会因为新出现的需求和<code>bug</code>而忙前忙后，和各个岗位负责人做沟通，但我依旧会挤出晚上宝贵的睡前半小时，静下心来写一写日记，听几首喜欢的音乐。培养着和艺术，音乐，书法方面的爱好。</p><p>焦虑每一个人都会有，我也不例外。也许我们会为了自己道路远方的光而不断奔跑，但请别忘了适当停下来回首自己走过的路，因为那是属于你独一无二，不可替代的曾经。</p><p><img src="/.io//weroad.png" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>感情这东西</title>
    <url>/2019/04/25/%E6%84%9F%E6%83%85%E8%BF%99%E4%B8%9C%E8%A5%BF/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><p>今天是2019年4月25日，距离她毕业离校到来成都，还有一个月的时间。</p><p>放佛是越到最后越按捺不住自己的情绪。感情这东西，真是有趣。</p><p>最近情绪不怎么稳定，运维上出现了两个bug已经拖了四天还没有解决，五一回家，想和女友聚一波去耍，无奈新疆太大，从她出学校到见我，还有坐两个小时的班车和十三个小时的火车（速度比较快的）。真是很惆怅。</p><p>我对她说，你要来，我肯定会给你把吃住安排好，带你去看美景，但是我也就在家呆六天，然后就要飞回成都工作。</p><p>感情这东西，真是神奇，长年累月，让两个素不相识的人在一起，成为伴侣，这样的感觉很美妙，然而，当两个人分开时，却要承受分开时思念的痛苦。</p><p>我希望这是我最后一次品尝，不管是不是最后一次，请不要再分开这么长的时间了。</p><p>而我，也绝对绝对绝对不会再让我爱的人离开我，也不会让她再受到半点委屈。</p><p>也许这就是爱情所赋予平凡人的力量吧。</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>成长</category>
      </categories>
  </entry>
  <entry>
    <title>Go项目结构设计过程点滴记录</title>
    <url>/2019/04/22/Go%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B%E7%82%B9%E6%BB%B4%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>之前在知识星球里星主让用<code>SMTP</code>协议实现邮件发送功能，看了<code>Max Li</code>的设计，并和他交流了一小时，在此将设计经验记录下来。</p><h1 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h1><p>设计一个项目的结构，有时候就像写文章一样，得分清层级。下面我将把讨论出的设计经验记录下来。</p><ul><li><p>main.go文件，当做项目的入口，里面可以写明版本号，读取配置文件，以及日志的初始化；</p></li><li><p>gomod文件，包管理</p></li><li><p>makefile文件，如果启动程序较多，可以写入makefile文件中，到时运行直接make即可；</p></li><li><p>pkg文件夹，存放项目的主要源代码</p></li><li><p>cmd文件夹，存放项目生成的可执行文件</p></li><li><p>config文件夹，存放配置文件，包含项目的基本配置信息</p></li><li><p>vendor文件夹，将依赖的包放入此目录中</p></li><li><p>util文件夹，项目中所写的小工具，例如进制转换，查错，类型转换，时间转时间戳等放入该文件件</p></li></ul><h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><h2 id="1，设计中难免会出现明文密码显示等相关信息，如何做到保密呢？"><a href="#1，设计中难免会出现明文密码显示等相关信息，如何做到保密呢？" class="headerlink" title="1，设计中难免会出现明文密码显示等相关信息，如何做到保密呢？"></a>1，设计中难免会出现明文密码显示等相关信息，如何做到保密呢？</h2><h2 id="2，如何做到在项目build同时自己更新tag号？"><a href="#2，如何做到在项目build同时自己更新tag号？" class="headerlink" title="2，如何做到在项目build同时自己更新tag号？"></a>2，如何做到在项目build同时自己更新tag号？</h2><p>参考<a href="https://github.com/ahmetb/govvv" target="_blank" rel="noopener">govvv</a></p><h2 id="3，怎样设计出一个框架，支持易扩展可维护呢？"><a href="#3，怎样设计出一个框架，支持易扩展可维护呢？" class="headerlink" title="3，怎样设计出一个框架，支持易扩展可维护呢？"></a>3，怎样设计出一个框架，支持易扩展可维护呢？</h2><p>我能想到的是，<code>web</code>服务设计接口，在接口中添加操作。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://idiomaticgo.com/post/best-practice/server-project-layout/" target="_blank" rel="noopener">Server Project Layout</a></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>写<code>demo</code>的时候，还是忍不住将所有的程序写进一个<code>main</code>函数里，又或者是新建一个<code>server.go</code>文件，然后一股脑的在里面做文章。</p><p>今天早上看星球里的朋友提出了一个问题，我觉得很对，在此摘录如下</p><blockquote><p>提高编程技能是很不容易的，一个人一旦习惯了某种编程思维就很难再突破。就说说我自己，一个业务用一般方法能实现的，我很难再去想到用接口，函数类型，闭包，反射等。虽然业务实现了，但总感觉代码写的很烂，自己看了都恶心。我相信大家一定有同感，教程和视频看了很多，也知道很多概念，但等到自己用的时候，又回到了旧的思维习惯。我觉得老大在布道go时，更应关注这方面的培养，知识的细节和技巧可以慢慢积累，但思维定势不突破，永远也不可能提高。</p></blockquote><p>今天和<code>Max Li</code>的沟通，还有在做项目时不断的以工程思维冲击着以前遗留下来的旧的思维习惯，我只想说，越早做出好的改变，成长的空间的也就越大。</p><p>共勉！</p><p><img src="/.io//road" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Go学习</category>
      </categories>
  </entry>
  <entry>
    <title>使用Go语言通过SMTP协议实现发送邮件功能</title>
    <url>/2019/04/22/%E4%BD%BF%E7%94%A8Go%E8%AF%AD%E8%A8%80%E9%80%9A%E8%BF%87SMTP%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>暂时停留</title>
    <url>/2019/04/21/%E6%9A%82%E6%97%B6%E5%81%9C%E7%95%99/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><p>前天，也就是星期五，我终于把我负责的流媒体收录系统上的<code>bug</code>和需求都清空了，成功打了<code>tag</code>号。</p><p>可以暂时休息下，思考一下前方的路该如何走？</p><p>有时候很好奇，大家都是24小时的时间，为什么有的人风生水起，有的人碌碌无为呢？</p><p>昨天去现场咨询了一下成都落户，本科以上学历+无房，落的是集体户口。嗯，觉得这块得好好了解下。不然以后再落会比较麻烦。</p><p>接下来要做的事情，似乎还有很多：</p><ul><li><p>流媒体收录关于管道，并发，以及<code>nginx</code>的服务还要细看下；</p></li><li><p>英语流利说的会员到期日还有80天，要抓紧时间了；</p></li><li><p>极客专栏上有关<code>Linux</code>操作系统内核，网络协议和数据库原理的的内容也需要更新；</p></li><li><p>给伶说好的画画，要在她五月底来成都前画完，虽然时间还很充裕，但不能再拖了。</p></li></ul><p>入职半年多，现在才真正感觉是在跟着大家一块做项目。</p><p>加油，努力！</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>远方</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>服务端漫游</title>
    <url>/2019/04/14/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%BC%AB%E6%B8%B8/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><p>注：本文内容源自<code>polaris</code>在知识星球<strong>Go项目实战</strong>中的直播，已获得本人许可。</p><h1 id="第一站：穿梭于Internet"><a href="#第一站：穿梭于Internet" class="headerlink" title="第一站：穿梭于Internet"></a>第一站：穿梭于Internet</h1><p><img src="/.io//internet.png" alt></p><h1 id="第二站：协议"><a href="#第二站：协议" class="headerlink" title="第二站：协议"></a>第二站：协议</h1><p>重点掌握</p><ul><li>TCP/UDP</li><li>HTTP</li></ul><p>常考面试题</p><ul><li>TCP的三次握手过程</li><li>TCP的四次挥手过程</li></ul><h4 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h4><ul><li>《图解http协议》</li><li>《图解TCP协议》</li></ul><p>建议用<code>wireshark</code>抓包软件进行分析。</p><h1 id="第三站：Unix-Linux操作系统"><a href="#第三站：Unix-Linux操作系统" class="headerlink" title="第三站：Unix/Linux操作系统"></a>第三站：Unix/Linux操作系统</h1><p>掌握对<code>Unix/Linux</code>操作系统的常用操作指令操作，例如</p><ul><li><code>shell</code>脚本</li><li><code>vim</code>编辑器的使用</li><li><code>sed</code></li><li><code>awk</code></li></ul><p>多练习，多总结</p><p>网络编程方面需掌握</p><ul><li>Socket、Unix Domain Socket</li><li>进程间通讯</li></ul><h4 id="推荐书籍-1"><a href="#推荐书籍-1" class="headerlink" title="推荐书籍"></a>推荐书籍</h4><ul><li>《UNIX网络编程卷一：套接字》</li><li>《UNIX环境高级编程》</li><li>《Linux/Unix设计思想》</li></ul><h1 id="第四站：Nginx、Apache、Caddy、等Web-Server和核心功能"><a href="#第四站：Nginx、Apache、Caddy、等Web-Server和核心功能" class="headerlink" title="第四站：Nginx、Apache、Caddy、等Web Server和核心功能"></a>第四站：Nginx、Apache、Caddy、等Web Server和核心功能</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><img src="/.io//server.png" alt></p><h2 id="Web-Server核心功能"><a href="#Web-Server核心功能" class="headerlink" title="Web Server核心功能"></a>Web Server核心功能</h2><ul><li>HTTP解析</li><li>HTTPS支持</li><li>虚拟主机(一个端口，多个域名)</li><li>静态资源</li><li>URL重写</li><li>gzip压缩</li><li>作为反向代理，和其他进程常用通讯协议的支持</li></ul><p>推荐学习了解下<code>Caddy</code></p><h1 id="第五站：常用的支持Web开发的语言"><a href="#第五站：常用的支持Web开发的语言" class="headerlink" title="第五站：常用的支持Web开发的语言"></a>第五站：常用的支持Web开发的语言</h1><ul><li>PHP(LAMP、LNMP)</li><li>Java</li><li>Python</li><li>Ruby</li><li>Go</li><li>C#(.NET)</li></ul><p>另外常用的数据结构和算法要有了解</p><h1 id="第六站：数据库"><a href="#第六站：数据库" class="headerlink" title="第六站：数据库"></a>第六站：数据库</h1><ul><li>关系数据库：SQLite,MySQL,Postgresql,SQL Server,Oracle</li><li>NoSQL：Redis,Mongodb,Cassandra,HBase</li><li>缓存：Redis,Memcached</li><li>其他：Go BoltDB,dgraph,CockroachDB</li></ul><p>入门数据库推荐使用<code>MySQL</code></p><h4 id="推荐书籍-2"><a href="#推荐书籍-2" class="headerlink" title="推荐书籍"></a>推荐书籍</h4><ul><li>《高性能MySQL》</li><li>《MySQL技术内幕InnoDB引擎》</li><li>《Redis实战》</li></ul><h1 id="第七站：架构"><a href="#第七站：架构" class="headerlink" title="第七站：架构"></a>第七站：架构</h1><ul><li>高可用，高性能，可扩展</li><li>分布式，CAP理论</li><li>分布式消息队列：Redis,ActiveMQ,RabbitMQ,ZeroMQ,Kafka,MetaMQ,RocketMQ等</li><li>常用的应用场景：异步处理，应用解耦，流量削峰和消息通讯</li><li>微服务</li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>直播后有个答疑环节，我将此次答疑的收货整理如下：</p><h4 id="关于服务端面试"><a href="#关于服务端面试" class="headerlink" title="关于服务端面试"></a>关于服务端面试</h4><p>面试考语言的分量比较小，因为服务端涉及的面比较广，需要学习的东西很多，有时候原理比语言更重要。</p><h4 id="关于承压"><a href="#关于承压" class="headerlink" title="关于承压"></a>关于承压</h4><p>在项目研发过程中，无论是测试还是上线跑，服务端会经常背锅，所以在压力上要及时调整好心态，做好和其他岗位人员的及时有效沟通。</p><h4 id="关于未来发展"><a href="#关于未来发展" class="headerlink" title="关于未来发展"></a>关于未来发展</h4><p>努力去大公司，做一些大项目，最好流量是千万级别以上的。</p><p>学无止境，一起努力！</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
  </entry>
  <entry>
    <title>关于996，我想说</title>
    <url>/2019/04/07/%E5%85%B3%E4%BA%8E996%EF%BC%8C%E6%88%91%E6%83%B3%E8%AF%B4/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>最近Github上有一个叫<a href="https://github.com/996icu/996.ICU" target="_blank" rel="noopener">996.ICU</a>的项目很火，原因是它公开抵制国内的996工作制，这严重违反了劳动法。工作996，住院ICU。</p><p>于是我身边有朋友问我，996到底是什么意思，那么我先说下我个人的亲身经历吧。</p><h1 id="回忆"><a href="#回忆" class="headerlink" title="回忆"></a>回忆</h1><p>去年六月大学本科毕业后，幸运的入职一家上市游戏公司，从事游戏服务端开发，刚开始对新公司，新工作充满好奇，想着下班回去也没什么事，就多待会，熟悉公司的业务流程。于是在公司内，我算是比较活跃的一类。</p><p>游戏公司与其他互联网公司最大的不同在于，活动非常多，各种节日庆祝，生日庆祝，下午茶，大家其乐融融，嬉戏打闹，品尝美食，氛围很融洽…</p><p>2018年8月，隔壁一工作室出了一款暗黑类手游，IOS端零点开服，于是我看着他们工作室从早忙到深夜，要么服务器崩了，要么数据有误急需修改，有些策划兼当游戏客服，而我看到一小伙子有时还披着被子工作，莫不是凌晨都睡在公司了吧。</p><p>后来，我也要开始加班了，虽然我也并不知道为什么加班，明明可以六点半走的，莫不是为了八点的餐补，还是九点的滴滴打车报销？</p><p>再后来，我经常晚上回来，同租的老哥每次看我拖着疲惫的身子回来，一脸倦容，就知道我又加班了。</p><p>八月底，做了两个梦</p><ul><li>第一个梦是让我两天把《Java编程思想》看完，我被吓醒了；</li><li>第二个梦是半醒中，突然摸到了一双手在我后脑勺处，我吓的大叫了一声，后来才发现是我那双已经被压麻的手，因为太累，躺床上还没有调整好睡姿就已经睡着了。</li></ul><p>八月三十一号，我记得很清楚，那是我离猝死最近的距离…</p><p>那天，我坐在工位前，一直在看服务端主程用<code>Lua</code>语言写的球球大作战源码，虽然看不懂，但我还是坚持把这四千行的代码都过了一遍，吃晚饭的时候一激动，起身起的太快，感到心脏隐隐作痛，头昏脑涨，恍恍惚惚间已经不知道自己在哪里，在干什么。旁边的客户端同事告诉我赶紧休息下，不能再工作了。我想也是。</p><p>在回去的路上，我将我今天的症状对学西医的朋友描述的一遍，他说你这离猝死不远了，得好好休息。</p><p>我慌了，我再也不敢透支身体了！</p><p>九月初，转正答辩，虽然我列举了我这三个月的改变，和完成的事情，但当他们一脸不屑，以及对我提出的问题，我就能猜出我能否通过转正了，虽然我每天都在拼命加班，但产出在他们看来微乎其微，公司不养闲人，于是我光荣的提了离职申请。</p><p>九月十一号，我办好离职手续，出了公司，成了一名工作经验仅只有三个月的社会人士。</p><p>我很想找个没人的地方哭一次，但我知道，塞翁失马，焉知非福。如果这就是我所了解到的游戏生涯，那我的游戏开发的梦也可以就此宣告结束了。</p><h1 id="工作996，生病ICU"><a href="#工作996，生病ICU" class="headerlink" title="工作996，生病ICU"></a>工作996，生病ICU</h1><p>我觉得这个比喻真的很好，说的更直白点，就是有命赚钱，没命花钱。</p><p>曾经我以为996就是累点而已，多学点东西也是极好的。</p><p>现在想想错了。</p><p>996在消耗你的体力的同时，也在消耗你的自由支配时间。在你本应该下班好好玩耍或吃顿美食开始看书学习的时候，你却要在嘈杂的环境下持续输出。可想而知，在精力和体力都枯竭的情况下，怎么能高产出呢？</p><p>然后负责人觉得你每天工作十二个小时，产出还这么低，看来你能力不行嘛，明天可以走人了，我再招一批年轻的实习生进来。</p><p>于是最终吃亏的还是自己。</p><h1 id="关于996，我想说"><a href="#关于996，我想说" class="headerlink" title="关于996，我想说"></a>关于996，我想说</h1><ul><li><p>跟对<code>leader</code>很重要。在我看来，一个好<code>leader</code>可以成为自己学习的榜样。虽然我无法全面定义一个好<code>leader</code>到底是什么样子，但是有一点是可以证明的：就是不会总是在他人面前炫耀自己曾经获得过什么荣誉。毕竟那都是过去的事情，一个人总沉浸在过去，会影响现在以及对未来的判断。</p></li><li><p>对不应该加的班说不。工作重要的一点是能力，另一点就是沟通。对于不是自己负责的任务，及时说明原因，让负责人定夺，而不是一股脑的全都接下。</p></li><li><p>抓紧一切时间去学习，去提升自我。我相信那些大厂年薪过百万的人，即使不加班领导也不会拿他怎样，毕竟这种人是无法短期被替代的，同时掌握着公司内最核心的技术。</p></li><li><p>加班多工资多，加班少工作也低，放佛总不能找到一个完美的选择，那么就请平衡好自己的能力和野心。</p></li><li><p>提升工作效率是关键。比如设立番茄钟，遇到不懂的赶紧问。</p></li></ul><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>转眼间我已经工作快十一个月了，有时还会把自己想象是在校大学生。</p><p>从996到955，从睡眠不足到睡到自然醒精神的去上班，我知道我找到了适合自己的工作方式。</p><p>曾经看着红的蓝的绿的共享单车如三条颜色的河流缓缓的流向软件园，中间有分流到xx大厦，xx集团，我曾想过上班的意义是什么？</p><p>直到现在我也没彻底想明白，但我知道，上班绝不是去医院住ICU。</p><p>希望996这样的工作制能成为个例，也希望以后的程序员们可以早点下班。</p><p>Good Luck.</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>工作</tag>
        <tag>成长</tag>
        <tag>感悟</tag>
        <tag>加班</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Golang进行字符串的替换</title>
    <url>/2019/04/07/%E4%BD%BF%E7%94%A8Golang%E8%BF%9B%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9B%BF%E6%8D%A2/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//转换为字符串后追加到字节数组</span></span><br><span class="line">	slice := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	slice = strconv.AppendBool(slice, <span class="literal">true</span>)</span><br><span class="line">	<span class="comment">//第二个数为要追加的数，第三个数为指定10进制方式追加</span></span><br><span class="line">	slice = strconv.AppendInt(slice, <span class="number">1234</span>, <span class="number">10</span>)</span><br><span class="line">	slice = strconv.AppendQuote(slice, <span class="string">"abcgohello"</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"slice = "</span>, <span class="keyword">string</span>(slice))</span><br><span class="line"></span><br><span class="line">	<span class="comment">//其它类型转换为字符串</span></span><br><span class="line">	<span class="keyword">var</span> str <span class="keyword">string</span></span><br><span class="line">	str = strconv.FormatBool(<span class="literal">false</span>)</span><br><span class="line">	fmt.Println(<span class="string">"str = "</span>, str)</span><br><span class="line">	<span class="comment">//'f'指打印格式，以小数形式，-1指小数点位数，64以float64处理</span></span><br><span class="line">	str = strconv.FormatFloat(<span class="number">3.14</span>, <span class="string">'f'</span>, <span class="number">-1</span>, <span class="number">64</span>)</span><br><span class="line">	fmt.Println(<span class="string">"str = "</span>, str)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//整型转字符型</span></span><br><span class="line">	str = strconv.Itoa(<span class="number">6666</span>)</span><br><span class="line">	fmt.Println(<span class="string">"str = "</span>, str)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符串转其它类型</span></span><br><span class="line">	flag, err := strconv.ParseBool(<span class="string">"true"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"err = "</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"flag = "</span>, flag)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//字符串转换为整型</span></span><br><span class="line">	a, _ := strconv.Atoi(<span class="string">"56479"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"a = "</span>, a)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><p><img src="/.io//str.png" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>字符串</tag>
        <tag>替换</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串操作常用函数介绍</title>
    <url>/2019/04/07/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><ul><li>操作</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//"helloogo"中是否包含"hello"</span></span><br><span class="line">fmt.Println(strings.Contains(<span class="string">"helloogo"</span>, <span class="string">"hello"</span>))</span><br><span class="line">fmt.Println(strings.Contains(<span class="string">"helloogo"</span>, <span class="string">"goe"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//Join组合</span></span><br><span class="line">s := []<span class="keyword">string</span>&#123;<span class="string">"abc"</span>, <span class="string">"hello"</span>, <span class="string">"mike"</span>, <span class="string">"go"</span>&#125;</span><br><span class="line">buf := strings.Join(s, <span class="string">"_"</span>)</span><br><span class="line">fmt.Println(<span class="string">"buf = "</span>, buf)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Index 查找子串所在位置</span></span><br><span class="line">fmt.Println(strings.Index(<span class="string">"abcdhello"</span>, <span class="string">"hello"</span>))</span><br><span class="line">fmt.Println(strings.Index(<span class="string">"abcdhello"</span>, <span class="string">"go"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">//Repeat 重复打印</span></span><br><span class="line">buf = strings.Repeat(<span class="string">"go"</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="string">"buf = "</span>, buf)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Split 以指定的分隔符对字符串进行拆分</span></span><br><span class="line">buf = <span class="string">"hello&amp;abc&amp;go&amp;mike&amp;you"</span></span><br><span class="line">s2 := strings.Split(buf, <span class="string">"&amp;"</span>)</span><br><span class="line">fmt.Println(<span class="string">"s2 = "</span>, s2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Trim 去掉两头的字符</span></span><br><span class="line">buf = strings.Trim(<span class="string">"      are you ok    "</span>, <span class="string">" "</span>)</span><br><span class="line">fmt.Println(<span class="string">"buf = "</span>, buf)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Fields 去掉空格，把元素放入切片中</span></span><br><span class="line">s3 := strings.Fields(<span class="string">"    are you ok?    "</span>)</span><br><span class="line"><span class="keyword">for</span> i, data := <span class="keyword">range</span> s3 &#123;</span><br><span class="line">	fmt.Println(i, <span class="string">", "</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">buf =  abc_hello_mike_go</span><br><span class="line">4</span><br><span class="line">-1</span><br><span class="line">buf =  gogogo</span><br><span class="line">s2 =  [hello abc go mike you]</span><br><span class="line">buf =  are you ok</span><br><span class="line">0 ,  are</span><br><span class="line">1 ,  you</span><br><span class="line">2 ,  ok?</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次做项目学到的技术之外的东西</title>
    <url>/2019/03/28/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%81%9A%E9%A1%B9%E7%9B%AE%E5%AD%A6%E5%88%B0%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B9%8B%E5%A4%96%E7%9A%84%E4%B8%9C%E8%A5%BF/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><p>三月初转正后开始接手公司内的一个有关流媒体收录系统服务器方面的项目，和部门老哥，产品，测试，运维，前端交流，对需求，看bug，学习到了很多编程之外的技能，写篇文章记录下来。</p><h2 id="接手新项目"><a href="#接手新项目" class="headerlink" title="接手新项目"></a>接手新项目</h2><ul><li>把完整的接口说明文档，配置文件拿到手，大致先过一遍</li><li>学会打断点，代码不是文章，不能从头读到尾，除非是一个文件只有一个<code>main</code>函数从头跟到尾</li><li>有不懂就赶紧问，时间不等人！</li><li>大部分时间都是把逻辑理清楚，代码只是分分钟的事情。</li></ul><h2 id="与产品沟通"><a href="#与产品沟通" class="headerlink" title="与产品沟通"></a>与产品沟通</h2><ul><li>大部分产品是不写代码的，所以不要和他/她扯到程序内部的实现上，否则他/她会很懵逼</li><li>遇到需求完成不了或觉得有问题，应尽早提出来</li></ul><h2 id="与其他部门的沟通"><a href="#与其他部门的沟通" class="headerlink" title="与其他部门的沟通"></a>与其他部门的沟通</h2><ul><li>其实在做编码设计的时候，我的时间不是整块的，有时候会被测试，运维临时打断去处理bug</li><li>学会把时间整片化，例如25-30分钟做一件事情，如果中间被要求去解决<code>bug</code>，咨询他能否等10分钟</li><li>每次解决完一个<code>bug</code>，把问题和解决过程描述清楚，记录在<code>wiki</code>上，方便自己和其他相关人员以后查看</li><li>学会看日志，通过日志分析问题的所在</li></ul><h2 id="排查bug的基本流程"><a href="#排查bug的基本流程" class="headerlink" title="排查bug的基本流程"></a>排查bug的基本流程</h2><p>当运维、测试那里出现问题需要你来解决时，解决流程是这样的:</p><ul><li>先看配置文件是否正确，也许是模式<code>model</code>选错，也许是路径没有配置正确;</li><li>再看日志记录;(所以前提是自己要在关键模块打详细日志描述，方便排查问题)</li><li>然后再看版本号是否正确;</li><li>最后再将问题在本机复现，用<code>dlv</code>或<code>gdb</code>打断点调试找出问题;</li><li>当问题解决后，一定记得在<code>wiki</code>里做好相应的记录，原因有二，帮助自己整理和回顾项目中的业务流程，当另外的运维或测试碰到类似的问题时，直接让它看<code>wiki</code>记录就可以，自己可以专心干其他的事情。</li></ul><p>加油！这将是我正式开发和维护的第一个<code>Golang</code>语言的项目！</p><p><img src="/.io//beautiful.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>一点进展</title>
    <url>/2019/03/25/%E4%B8%80%E7%82%B9%E8%BF%9B%E5%B1%95/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><p>今天部门老大问我项目进展怎样，我说有点慢，一个需求正在测试，还有四个需求没有开始实施。（我为什么要这么诚实？！）</p><p>中午和同事出去吃饭，他建议我先把接口列出来，然后把每一步要做的注释写出来，再将注释翻译成代码。</p><p>散步快结束时，董说你已经过了让我们告诉你如何做的阶段，现在只能是自己去探索，而我们告诉你是<code>true</code>或<code>false</code>。</p><p>当我听到这句话的时候，我竟然心中油然升起一种莫名其妙的喜悦。</p><p>是的，我已经转正了，已经离开学校九个多月了，应该学会独立解决问题和培养随机应变的能力。</p><p>企业不是学校，没有责任和义务告诉你每一步该怎么做。</p><p>谢谢给我指导的部门老哥们。</p><p>是我自己太矫情了，一直沉溺在学校的幻想中，不愿意走出来。</p><p>今天终于解决了第一个需求，不知明天能不能把第二个需求做完。</p><p>坚持，并学会改变。</p><p><img src="/.io//smile.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>一点小挫折</title>
    <url>/2019/03/23/%E4%B8%80%E7%82%B9%E5%B0%8F%E6%8C%AB%E6%8A%98/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><p>终于迎来了最难受的时期，流媒体收录服务，逻辑很杂，但不难，就是tmd理不清楚。</p><p>下周五要发版，现在东西搞定不了，该如何是好？</p><p>父母说，遇到困难就去解决，不要逃避，他们也说，这个东西以后就交给我来负责了！</p><p>可是，我真的能扛起这个重任吗？我反复问自己。</p><p>明天还有一天的时间，我想重新用dlv调试把每个流程弄懂。</p><p>希望可以来得及！</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>开发</tag>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>痛并成长着</title>
    <url>/2019/03/18/%E7%97%9B%E5%B9%B6%E6%88%90%E9%95%BF%E7%9D%80/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><p>三月，对我来说是一个特殊的月份，特殊在:</p><ul><li>转正通过，开始接手公司项目;</li><li>月底我将23岁，每当这个时候，我都会感到莫名其妙的沉默寡言。</li></ul><p>上一周感觉过得很艰难，很充实，因为自己不会的很多，得一个个去补。</p><p>杨说叫我把B站上的20小时快速入门Go语言课程从新再系统学习一遍，虽然我觉得之前都接触过，但我还是欣然接受。现在课程已经过半，让我真正意识到，忘记自己曾经以为对的东西，推到重来，反而会有新的收获，也许这就是温故而知新吧。</p><p>这周很荣幸加入了Go语言中文网创始人创办的知识星球，与无闻，轩辕刃这些大佬一起学习Go语言，探究底层的本质。</p><p>技术文章我仍旧会继续坚持写下去，但我会逐渐摒弃数量，追求质量。</p><p>上周六和一位朋友去看漫展，然后去逛街，疯玩了一天，身心放松了下来，很是开心，让我忘却了工作上的烦恼。</p><p>我一直坚信，天将降大任于斯人也，必先苦其心智，饿其筋骨，劳其体肤…</p><p>加油!扛过去，胜利就在前方。</p><p><img src="/.io//whale.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>转正才是工作的开始</title>
    <url>/2019/03/04/%E8%BD%AC%E6%AD%A3%E6%89%8D%E6%98%AF%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><p>转正通过，也算是对我这六个月的一次认可吧。</p><p>然后有一老哥的流媒体服务相关的项目移交给我负责了，还有视音频编码，放佛之前是在过家家，现在才是正式工作的开始。</p><p>加油吧，机遇与挑战并存！</p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>对Go语言interface的理解</title>
    <url>/2019/03/03/%E5%AF%B9Go%E8%AF%AD%E8%A8%80interface%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h1 id="什么是interface"><a href="#什么是interface" class="headerlink" title="什么是interface"></a>什么是interface</h1><p>interface是一组method（方法）的组合，我们通过interface来定义对象的一组行为。</p><h1 id="interface类型"><a href="#interface类型" class="headerlink" title="interface类型"></a>interface类型</h1><p>interface类型定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口。<br>（如果给鸭子模型定义划水的方法，当我再新建立一个鸟的对象，让它实现划水的方法，这时我可以认为鸟也是鸭子）</p><p>一个例子：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段Human</span></span><br><span class="line">    school <span class="keyword">string</span></span><br><span class="line">    loan <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段Human</span></span><br><span class="line">    company <span class="keyword">string</span></span><br><span class="line">    money <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Human对象实现Sayhi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Hi, I am %s you can call me on %s\n"</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Human对象实现Sing方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">Sing</span><span class="params">(lyrics <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"La la, la la la, la la la la la..."</span>, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Human对象实现Guzzle方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">Guzzle</span><span class="params">(beerStein <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Guzzle Guzzle Guzzle..."</span>, beerStein)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Employee重载Human的Sayhi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Hi, I am %s, I work at %s. Call me on %s\n"</span>, e.name,</span><br><span class="line">        e.company, e.phone) <span class="comment">//此句可以分成多行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Student实现BorrowMoney方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">BorrowMoney</span><span class="params">(amount <span class="keyword">float32</span>)</span></span> &#123;</span><br><span class="line">    s.loan += amount <span class="comment">// (again and again and...)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Employee实现SpendSalary方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">SpendSalary</span><span class="params">(amount <span class="keyword">float32</span>)</span></span> &#123;</span><br><span class="line">    e.money -= amount <span class="comment">// More vodka please!!! Get me through the day!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义interface</span></span><br><span class="line"><span class="keyword">type</span> Men <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(lyrics <span class="keyword">string</span>)</span><br><span class="line">    Guzzle(beerStein <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> YoungChap <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(song <span class="keyword">string</span>)</span><br><span class="line">    BorrowMoney(amount <span class="keyword">float32</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ElderlyGent <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(song <span class="keyword">string</span>)</span><br><span class="line">    SpendSalary(amount <span class="keyword">float32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以知道</p><ul><li>interface可以被任意对象调用和实现。</li><li>一个对象可以实现任意多个interface。</li></ul><p>形象的比喻：每个物种都是一个类，我们给这个类定义一系列的行为，例如给鸟类定义可以飞行的行为，给狗定义可以“汪汪”的声音，给人类定义可以说话可以跑步的行为，那么当你和我都实现了说话和跑步的行为，你我都属于人类，你和我都实现了飞行的行为，你我都属于鸟类，以此类推。这么做的意义在于，实现代码的高度使用。</p><h1 id="思考：errors-这个-package-里面的-errors-New-到底是做什么的？"><a href="#思考：errors-这个-package-里面的-errors-New-到底是做什么的？" class="headerlink" title="思考：errors 这个 package 里面的 errors.New 到底是做什么的？"></a>思考：errors 这个 package 里面的 errors.New 到底是做什么的？</h1><p><code>errors</code>包实现了创建错误值的函数。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>使用字符串创建一个错误,可以类比fmt包的Errorf方法，差不多可以认为是New(fmt.Sprintf(…))。</p><p>例子</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">echo</span><span class="params">(request <span class="keyword">string</span>)</span> <span class="params">(response <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> request == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="comment">//调用errors.New函数时传入一个由字符串代表的错误信息，它会返回</span></span><br><span class="line">		<span class="comment">//给我们一个包含了这个错误信息的error类型值。该值的静态类型是error</span></span><br><span class="line">		err = errors.New(<span class="string">"empty content"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	response = fmt.Sprintf(<span class="string">"echo: %s"</span>, request)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是返回一个自己定义的错误。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://golang.org/pkg/errors/" target="_blank" rel="noopener">gopkg-errors</a></p><p><a href="https://golang.org/src/errors/errors.go?s=293:320#L1" target="_blank" rel="noopener">New的实现</a></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>interface</tag>
      </tags>
  </entry>
  <entry>
    <title>开始学习一项新技术</title>
    <url>/2019/02/27/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E4%B8%80%E9%A1%B9%E6%96%B0%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><p>今天部门老哥说，周五会开始做一个新东西，会用到<code>Docker</code>，叫我先下载下来，后面要用。</p><p><code>Docker</code>这东西有段时间听过，是个容器，把应用放在里面跑，还是<code>Golang</code>的开源项目，对此我一直很好奇它和虚拟机相比究竟优点在哪里？</p><p>现在终于要开始接触它了！</p><p>加油，这两天先把手上的<code>flv</code>时移推进一下进度。</p><p><img src="/.io//docker.png" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>Go文件操作大全</title>
    <url>/2019/02/25/Go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h1 id="Go文件操作大全"><a href="#Go文件操作大全" class="headerlink" title="Go文件操作大全"></a>Go文件操作大全</h1><h2 id="1，介绍"><a href="#1，介绍" class="headerlink" title="1，介绍"></a>1，介绍</h2><h3 id="1-1-万物皆文件"><a href="#1-1-万物皆文件" class="headerlink" title="1.1 万物皆文件"></a>1.1 万物皆文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">One of the fundamental aspects of UNIX is that everything is a file. We don&apos;t necessarily know what the file descriptor maps to, that is abstracted by the operating system&apos;s device drivers. The operating system provides us an interface to the device in the form of a file.</span><br><span class="line"></span><br><span class="line">The reader and writer interfaces in Go are similar abstractions. We simply read and write bytes, without the need to understand where or how the reader gets its data or where the writer is sending the data. Look in /dev to find available devices. Some will require elevated privileges to access.</span><br></pre></td></tr></table></figure><p>在此引用刘超老师专栏里写的话</p><h4 id="Linux一切皆文件"><a href="#Linux一切皆文件" class="headerlink" title="Linux一切皆文件"></a>Linux一切皆文件</h4><ul><li>启动一个进程，需要一个程序文件，这是一个二进制文件</li><li>启动的时候，要加载一些配置文件，例如yml、properties等，这是配置文件；启动之后会打印一些日志，如果写到硬盘上，也是文本文件；如果我想把日志打印到交互控制台上，在命令行上打印出来，这是一个标准输出的stdout文件</li><li>这个进程的输出可以作为另一个进程的输入，这种方式称为管道，它也是一个文件</li><li>进程可以通过网络和其他进程进行通信，建立的Socket，也是一个文件</li><li>进程需要访问外部设备，设备也是一个文件</li><li>文件都被存储在文件夹里面，文件夹也是一个文件</li><li>进程运行起来，要想看到进程运行的情况，会在/proc下面有对应的进程号，也是一系列的文件</li></ul><h2 id="2，基本操作"><a href="#2，基本操作" class="headerlink" title="2，基本操作"></a>2，基本操作</h2><h3 id="2-1-创建空文件"><a href="#2-1-创建空文件" class="headerlink" title="2.1 创建空文件"></a>2.1 创建空文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    newFile *os.File</span><br><span class="line">    err     error</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    newFile, err = os.Create(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(newFile)</span><br><span class="line">    newFile.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-缩短文件"><a href="#2-2-缩短文件" class="headerlink" title="2.2 缩短文件"></a>2.2 缩短文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 裁剪一个文件到100个字节。</span></span><br><span class="line">    <span class="comment">// 如果文件本来就少于100个字节，则文件中原始内容得以保留，剩余的字节以null字节填充。</span></span><br><span class="line">    <span class="comment">// 如果文件本来超过100个字节，则超过的字节会被抛弃。</span></span><br><span class="line">    <span class="comment">// 这样我们总是得到精确的100个字节的文件。</span></span><br><span class="line">    <span class="comment">// 传入0则会清空文件。</span></span><br><span class="line">    err := os.Truncate(<span class="string">"test.txt"</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-获取文件信息"><a href="#2-3-获取文件信息" class="headerlink" title="2.3 获取文件信息"></a>2.3 获取文件信息</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    fileInfo os.FileInfo</span><br><span class="line">    err      error</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 如果文件不存在，则返回错误</span></span><br><span class="line">    fileInfo, err = os.Stat(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"File name:"</span>, fileInfo.Name())</span><br><span class="line">    fmt.Println(<span class="string">"Size in bytes:"</span>, fileInfo.Size())</span><br><span class="line">    fmt.Println(<span class="string">"Permissions:"</span>, fileInfo.Mode())</span><br><span class="line">    fmt.Println(<span class="string">"Last modified:"</span>, fileInfo.ModTime())</span><br><span class="line">    fmt.Println(<span class="string">"Is Directory: "</span>, fileInfo.IsDir())</span><br><span class="line">    fmt.Printf(<span class="string">"System interface type: %T\n"</span>, fileInfo.Sys())</span><br><span class="line">    fmt.Printf(<span class="string">"System info: %+v\n\n"</span>, fileInfo.Sys())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-重命名和移动文件"><a href="#2-4-重命名和移动文件" class="headerlink" title="2.4 重命名和移动文件"></a>2.4 重命名和移动文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    originalPath := <span class="string">"test.txt"</span></span><br><span class="line">    newPath := <span class="string">"test2.txt"</span></span><br><span class="line">    err := os.Rename(originalPath, newPath)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-删除一个文件"><a href="#2-5-删除一个文件" class="headerlink" title="2.5 删除一个文件"></a>2.5 删除一个文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := os.Remove(<span class="string">"test.txt"</span>)  <span class="comment">//Remove 移除</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-打开和关闭文件"><a href="#2-6-打开和关闭文件" class="headerlink" title="2.6 打开和关闭文件"></a>2.6 打开和关闭文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 简单地以只读的方式打开。下面的例子会介绍读写的例子。</span></span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">    <span class="comment">// OpenFile提供更多的选项。</span></span><br><span class="line">    <span class="comment">// 最后一个参数是权限模式permission mode</span></span><br><span class="line">    <span class="comment">// 第二个是打开时的属性    </span></span><br><span class="line">    file, err = os.OpenFile(<span class="string">"test.txt"</span>, os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">    <span class="comment">// 下面的属性可以单独使用，也可以组合使用。</span></span><br><span class="line">    <span class="comment">// 组合使用时可以使用 OR 操作设置 OpenFile的第二个参数，例如：</span></span><br><span class="line">    <span class="comment">// os.O_CREATE|os.O_APPEND</span></span><br><span class="line">    <span class="comment">// 或者 os.O_CREATE|os.O_TRUNC|os.O_WRONLY</span></span><br><span class="line">    <span class="comment">// os.O_RDONLY // 只读</span></span><br><span class="line">    <span class="comment">// os.O_WRONLY // 只写</span></span><br><span class="line">    <span class="comment">// os.O_RDWR // 读和写</span></span><br><span class="line">    <span class="comment">// os.O_APPEND // 往文件末尾添加（Append）</span></span><br><span class="line">    <span class="comment">// os.O_CREATE // 如果文件不存在时则先创建这个文件</span></span><br><span class="line">    <span class="comment">// os.O_TRUNC // 文件打开时裁剪文件</span></span><br><span class="line">    <span class="comment">// os.O_EXCL // 和O_CREATE一起使用，文件不能存在</span></span><br><span class="line">    <span class="comment">// os.O_SYNC // 以同步I/O的方式打开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-判断这个文件是否存在"><a href="#2-7-判断这个文件是否存在" class="headerlink" title="2.7 判断这个文件是否存在"></a>2.7 判断这个文件是否存在</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    fileInfo *os.FileInfo</span><br><span class="line">    err      error</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 文件不存在则返回error</span></span><br><span class="line">    fileInfo, err := os.Stat(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> os.IsNotExist(err) &#123;</span><br><span class="line">            log.Fatal(<span class="string">"File does not exist."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">"File does exist. File information:"</span>)</span><br><span class="line">    log.Println(fileInfo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8-检查读写权限"><a href="#2-8-检查读写权限" class="headerlink" title="2.8 检查读写权限"></a>2.8 检查读写权限</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这个例子测试写权限，如果没有写权限则返回error。</span></span><br><span class="line">    <span class="comment">// 注意文件不存在也会返回error，需要检查error的信息来获取到底是哪个错误导致。</span></span><br><span class="line">    file, err := os.OpenFile(<span class="string">"test.txt"</span>, os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> os.IsPermission(err) &#123;</span><br><span class="line">            log.Println(<span class="string">"Error: Write permission denied."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">    <span class="comment">// 测试读权限</span></span><br><span class="line">    file, err = os.OpenFile(<span class="string">"test.txt"</span>, os.O_RDONLY, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> os.IsPermission(err) &#123;</span><br><span class="line">            log.Println(<span class="string">"Error: Read permission denied."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    file.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-9-改变权限、拥有者、时间戳"><a href="#2-9-改变权限、拥有者、时间戳" class="headerlink" title="2.9 改变权限、拥有者、时间戳"></a>2.9 改变权限、拥有者、时间戳</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用Linux风格改变文件权限</span></span><br><span class="line">    err := os.Chmod(<span class="string">"test.txt"</span>, <span class="number">0777</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改变文件所有者</span></span><br><span class="line">    err = os.Chown(<span class="string">"test.txt"</span>, os.Getuid(), os.Getgid())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 改变时间戳</span></span><br><span class="line">    twoDaysFromNow := time.Now().Add(<span class="number">48</span> * time.Hour)</span><br><span class="line">    lastAccessTime := twoDaysFromNow</span><br><span class="line">    lastModifyTime := twoDaysFromNow</span><br><span class="line">    err = os.Chtimes(<span class="string">"test.txt"</span>, lastAccessTime, lastModifyTime)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-10-硬链接和软链接"><a href="#2-10-硬链接和软链接" class="headerlink" title="2.10 硬链接和软链接"></a>2.10 硬链接和软链接</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个硬链接。</span></span><br><span class="line">    <span class="comment">// 创建后同一个文件内容会有两个文件名，改变一个文件的内容会影响另一个。</span></span><br><span class="line">    <span class="comment">// 删除和重命名不会影响另一个。</span></span><br><span class="line">    err := os.Link(<span class="string">"original.txt"</span>, <span class="string">"original_also.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"creating sym"</span>)</span><br><span class="line">    <span class="comment">// Create a symlink</span></span><br><span class="line">    err = os.Symlink(<span class="string">"original.txt"</span>, <span class="string">"original_sym.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Lstat返回一个文件的信息，但是当文件是一个软链接时，它返回软链接的信息，而不是引用的文件的信息。</span></span><br><span class="line">    <span class="comment">// Symlink在Windows中不工作。</span></span><br><span class="line">    fileInfo, err := os.Lstat(<span class="string">"original_sym.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Link info: %+v"</span>, fileInfo)</span><br><span class="line">    <span class="comment">//改变软链接的拥有者不会影响原始文件。</span></span><br><span class="line">    err = os.Lchown(<span class="string">"original_sym.txt"</span>, os.Getuid(), os.Getgid())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3，读写"><a href="#3，读写" class="headerlink" title="3，读写"></a>3，读写</h2><h3 id="3-1-复制文件"><a href="#3-1-复制文件" class="headerlink" title="3.1 复制文件"></a>3.1 复制文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打开原始文件</span></span><br><span class="line">    originalFile, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> originalFile.Close()</span><br><span class="line">    <span class="comment">// 创建新的文件作为目标文件</span></span><br><span class="line">    newFile, err := os.Create(<span class="string">"test_copy.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> newFile.Close()</span><br><span class="line">    <span class="comment">// 从源中复制字节到目标文件</span></span><br><span class="line">    bytesWritten, err := io.Copy(newFile, originalFile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Copied %d bytes."</span>, bytesWritten)</span><br><span class="line">    <span class="comment">// 将文件内容flush到硬盘中</span></span><br><span class="line">    err = newFile.Sync()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-跳转到文件指定位置（Seek）"><a href="#3-2-跳转到文件指定位置（Seek）" class="headerlink" title="3.2 跳转到文件指定位置（Seek）"></a>3.2 跳转到文件指定位置（Seek）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, _ := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="comment">// 偏离位置，可以是正数也可以是负数</span></span><br><span class="line">    <span class="keyword">var</span> offset <span class="keyword">int64</span> = <span class="number">5</span></span><br><span class="line">    <span class="comment">// 用来计算offset的初始位置</span></span><br><span class="line">    <span class="comment">// 0 = 文件开始位置</span></span><br><span class="line">    <span class="comment">// 1 = 当前位置</span></span><br><span class="line">    <span class="comment">// 2 = 文件结尾处</span></span><br><span class="line">    <span class="keyword">var</span> whence <span class="keyword">int</span> = <span class="number">0</span></span><br><span class="line">    newPosition, err := file.Seek(offset, whence)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Just moved to 5:"</span>, newPosition)</span><br><span class="line">    <span class="comment">// 从当前位置回退两个字节</span></span><br><span class="line">    newPosition, err = file.Seek(<span class="number">-2</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Just moved back two:"</span>, newPosition)</span><br><span class="line">    <span class="comment">// 使用下面的技巧得到当前的位置</span></span><br><span class="line">    currentPosition, err := file.Seek(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    fmt.Println(<span class="string">"Current position:"</span>, currentPosition)</span><br><span class="line">    <span class="comment">// 转到文件开始处</span></span><br><span class="line">    newPosition, err = file.Seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"Position after seeking 0,0:"</span>, newPosition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-写文件"><a href="#3-3-写文件" class="headerlink" title="3.3 写文件"></a>3.3 写文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 可写方式打开文件</span></span><br><span class="line">    file, err := os.OpenFile(</span><br><span class="line">        <span class="string">"test.txt"</span>,</span><br><span class="line">        os.O_WRONLY|os.O_TRUNC|os.O_CREATE,</span><br><span class="line">        <span class="number">0666</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="comment">// 写字节到文件中</span></span><br><span class="line">    byteSlice := []<span class="keyword">byte</span>(<span class="string">"Bytes!\n"</span>)</span><br><span class="line">    bytesWritten, err := file.Write(byteSlice)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Wrote %d bytes.\n"</span>, bytesWritten)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-快写文件"><a href="#3-4-快写文件" class="headerlink" title="3.4 快写文件"></a>3.4 快写文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := ioutil.WriteFile(<span class="string">"test.txt"</span>, []<span class="keyword">byte</span>(<span class="string">"Hi\n"</span>), <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-使用缓存写"><a href="#3-5-使用缓存写" class="headerlink" title="3.5 使用缓存写"></a>3.5 使用缓存写</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打开文件，只写</span></span><br><span class="line">    file, err := os.OpenFile(<span class="string">"test.txt"</span>, os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="comment">// 为这个文件创建buffered writer</span></span><br><span class="line">    bufferedWriter := bufio.NewWriter(file)</span><br><span class="line">    <span class="comment">// 写字节到buffer</span></span><br><span class="line">    bytesWritten, err := bufferedWriter.Write(</span><br><span class="line">        []<span class="keyword">byte</span>&#123;<span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>&#125;,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Bytes written: %d\n"</span>, bytesWritten)</span><br><span class="line">    <span class="comment">// 写字符串到buffer</span></span><br><span class="line">    <span class="comment">// 也可以使用 WriteRune() 和 WriteByte()   </span></span><br><span class="line">    bytesWritten, err = bufferedWriter.WriteString(</span><br><span class="line">        <span class="string">"Buffered string\n"</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Bytes written: %d\n"</span>, bytesWritten)</span><br><span class="line">    <span class="comment">// 检查缓存中的字节数</span></span><br><span class="line">    unflushedBufferSize := bufferedWriter.Buffered()</span><br><span class="line">    log.Printf(<span class="string">"Bytes buffered: %d\n"</span>, unflushedBufferSize)</span><br><span class="line">    <span class="comment">// 还有多少字节可用（未使用的缓存大小）</span></span><br><span class="line">    bytesAvailable := bufferedWriter.Available()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Available buffer: %d\n"</span>, bytesAvailable)</span><br><span class="line">    <span class="comment">// 写内存buffer到硬盘</span></span><br><span class="line">    bufferedWriter.Flush()</span><br><span class="line">    <span class="comment">// 丢弃还没有flush的缓存的内容，清除错误并把它的输出传给参数中的writer</span></span><br><span class="line">    <span class="comment">// 当你想将缓存传给另外一个writer时有用</span></span><br><span class="line">    bufferedWriter.Reset(bufferedWriter)</span><br><span class="line">    bytesAvailable = bufferedWriter.Available()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Available buffer: %d\n"</span>, bytesAvailable)</span><br><span class="line">    <span class="comment">// 重新设置缓存的大小。</span></span><br><span class="line">    <span class="comment">// 第一个参数是缓存应该输出到哪里，这个例子中我们使用相同的writer。</span></span><br><span class="line">    <span class="comment">// 如果我们设置的新的大小小于第一个参数writer的缓存大小， 比如10，我们不会得到一个10字节大小的缓存，</span></span><br><span class="line">    <span class="comment">// 而是writer的原始大小的缓存，默认是4096。</span></span><br><span class="line">    <span class="comment">// 它的功能主要还是为了扩容。</span></span><br><span class="line">    bufferedWriter = bufio.NewWriterSize(</span><br><span class="line">        bufferedWriter,</span><br><span class="line">        <span class="number">8000</span>,</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// resize后检查缓存的大小</span></span><br><span class="line">    bytesAvailable = bufferedWriter.Available()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Available buffer: %d\n"</span>, bytesAvailable)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-读取最多N个字节"><a href="#3-6-读取最多N个字节" class="headerlink" title="3.6 读取最多N个字节"></a>3.6 读取最多N个字节</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打开文件，只读</span></span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="comment">// 从文件中读取len(b)字节的文件。</span></span><br><span class="line">    <span class="comment">// 返回0字节意味着读取到文件尾了</span></span><br><span class="line">    <span class="comment">// 读取到文件会返回io.EOF的error</span></span><br><span class="line">    byteSlice := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">16</span>)</span><br><span class="line">    bytesRead, err := file.Read(byteSlice)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Number of bytes read: %d\n"</span>, bytesRead)</span><br><span class="line">    log.Printf(<span class="string">"Data read: %s\n"</span>, byteSlice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-读取正好N个字节"><a href="#3-7-读取正好N个字节" class="headerlink" title="3.7 读取正好N个字节"></a>3.7 读取正好N个字节</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Open file for reading</span></span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// file.Read()可以读取一个小文件到大的byte slice中，</span></span><br><span class="line">    <span class="comment">// 但是io.ReadFull()在文件的字节数小于byte slice字节数的时候会返回错误</span></span><br><span class="line">    byteSlice := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">2</span>)</span><br><span class="line">    numBytesRead, err := io.ReadFull(file, byteSlice)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Number of bytes read: %d\n"</span>, numBytesRead)</span><br><span class="line">    log.Printf(<span class="string">"Data read: %s\n"</span>, byteSlice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-读取至少N个字节"><a href="#3-8-读取至少N个字节" class="headerlink" title="3.8 读取至少N个字节"></a>3.8 读取至少N个字节</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打开文件，只读</span></span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    byteSlice := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">512</span>)</span><br><span class="line">    minBytes := <span class="number">8</span></span><br><span class="line">    <span class="comment">// io.ReadAtLeast()在不能得到最小的字节的时候会返回错误，但会把已读的文件保留</span></span><br><span class="line">    numBytesRead, err := io.ReadAtLeast(file, byteSlice, minBytes)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Number of bytes read: %d\n"</span>, numBytesRead)</span><br><span class="line">    log.Printf(<span class="string">"Data read: %s\n"</span>, byteSlice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-9-读取全部字节"><a href="#3-9-读取全部字节" class="headerlink" title="3.9 读取全部字节"></a>3.9 读取全部字节</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Open file for reading</span></span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// os.File.Read(), io.ReadFull(), and</span></span><br><span class="line">    <span class="comment">// io.ReadAtLeast() all work with a fixed</span></span><br><span class="line">    <span class="comment">// byte slice that you make before you read</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ioutil.ReadAll() will read every byte</span></span><br><span class="line">    <span class="comment">// from the reader (in this case a file),</span></span><br><span class="line">    <span class="comment">// and return a slice of unknown slice</span></span><br><span class="line">    data, err := ioutil.ReadAll(file)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"Data as hex: %x\n"</span>, data)</span><br><span class="line">    fmt.Printf(<span class="string">"Data as string: %s\n"</span>, data)</span><br><span class="line">    fmt.Println(<span class="string">"Number of bytes read:"</span>, <span class="built_in">len</span>(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-10-快速读到内存中"><a href="#3-10-快速读到内存中" class="headerlink" title="3.10 快速读到内存中"></a>3.10 快速读到内存中</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 读取文件到byte slice中</span></span><br><span class="line">    data, err := ioutil.ReadFile(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"Data read: %s\n"</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-11-使用缓存读"><a href="#3-11-使用缓存读" class="headerlink" title="3.11 使用缓存读"></a>3.11 使用缓存读</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打开文件，创建buffered reader</span></span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    bufferedReader := bufio.NewReader(file)</span><br><span class="line">    <span class="comment">// 得到字节，当前指针不变</span></span><br><span class="line">    byteSlice := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">5</span>)</span><br><span class="line">    byteSlice, err = bufferedReader.Peek(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Peeked at 5 bytes: %s\n"</span>, byteSlice)</span><br><span class="line">    <span class="comment">// 读取，指针同时移动</span></span><br><span class="line">    numBytesRead, err := bufferedReader.Read(byteSlice)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Read %d bytes: %s\n"</span>, numBytesRead, byteSlice)</span><br><span class="line">    <span class="comment">// 读取一个字节, 如果读取不成功会返回Error</span></span><br><span class="line">    myByte, err := bufferedReader.ReadByte()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Read 1 byte: %c\n"</span>, myByte)     </span><br><span class="line">    <span class="comment">// 读取到分隔符，包含分隔符，返回byte slice</span></span><br><span class="line">    dataBytes, err := bufferedReader.ReadBytes(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Read bytes: %s\n"</span>, dataBytes)           </span><br><span class="line">    <span class="comment">// 读取到分隔符，包含分隔符，返回字符串</span></span><br><span class="line">    dataString, err := bufferedReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"Read string: %s\n"</span>, dataString)     </span><br><span class="line">    <span class="comment">//这个例子读取了很多行，所以test.txt应该包含多行文本才不至于出错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-12-使用-scanner"><a href="#3-12-使用-scanner" class="headerlink" title="3.12 使用 scanner"></a>3.12 使用 scanner</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// To define your own split function, match this fingerprint</span></span><br><span class="line"><span class="keyword">type</span> SplitFunc <span class="function"><span class="keyword">func</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>, err error)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">Returning</span> <span class="params">(0, <span class="literal">nil</span>, <span class="literal">nil</span>)</span> <span class="title">will</span> <span class="title">tell</span> <span class="title">the</span> <span class="title">scanner</span></span></span><br><span class="line"><span class="function">// <span class="title">to</span> <span class="title">scan</span> <span class="title">again</span>, <span class="title">but</span> <span class="title">with</span> <span class="title">a</span> <span class="title">bigger</span> <span class="title">buffer</span> <span class="title">because</span></span></span><br><span class="line"><span class="function">// <span class="title">it</span> <span class="title">wasn</span>'<span class="title">t</span> <span class="title">enough</span> <span class="title">data</span> <span class="title">to</span> <span class="title">reach</span> <span class="title">the</span> <span class="title">delimiter</span></span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    scanner := bufio.NewScanner(file)</span><br><span class="line">    <span class="comment">// 缺省的分隔函数是bufio.ScanLines,我们这里使用ScanWords。</span></span><br><span class="line">    <span class="comment">// 也可以定制一个SplitFunc类型的分隔函数</span></span><br><span class="line">    scanner.Split(bufio.ScanWords)</span><br><span class="line">    <span class="comment">// scan下一个token.</span></span><br><span class="line">    success := scanner.Scan()</span><br><span class="line">    <span class="keyword">if</span> success == <span class="literal">false</span> &#123;</span><br><span class="line">        <span class="comment">// 出现错误或者EOF是返回Error</span></span><br><span class="line">        err = scanner.Err()</span><br><span class="line">        <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Println(<span class="string">"Scan completed and reached EOF"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到数据，Bytes() 或者 Text()</span></span><br><span class="line">    fmt.Println(<span class="string">"First word found:"</span>, scanner.Text())</span><br><span class="line">    <span class="comment">// 再次调用scanner.Scan()发现下一个token</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4，压缩"><a href="#4，压缩" class="headerlink" title="4，压缩"></a>4，压缩</h2><h3 id="4-1-打包文件"><a href="#4-1-打包文件" class="headerlink" title="4.1 打包文件"></a>4.1 打包文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This example uses zip but standard library</span></span><br><span class="line"><span class="comment">// also supports tar archives</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"archive/zip"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Create a file to write the archive buffer to</span></span><br><span class="line">    <span class="comment">// Could also use an in memory buffer.</span></span><br><span class="line">    outFile, err := os.Create(<span class="string">"test.zip"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> outFile.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a zip writer on top of the file writer</span></span><br><span class="line">    zipWriter := zip.NewWriter(outFile)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add files to archive</span></span><br><span class="line">    <span class="comment">// We use some hard coded data to demonstrate,</span></span><br><span class="line">    <span class="comment">// but you could iterate through all the files</span></span><br><span class="line">    <span class="comment">// in a directory and pass the name and contents</span></span><br><span class="line">    <span class="comment">// of each file, or you can take data from your</span></span><br><span class="line">    <span class="comment">// program and write it write in to the archive</span></span><br><span class="line">    <span class="comment">// without </span></span><br><span class="line">    <span class="keyword">var</span> filesToArchive = []<span class="keyword">struct</span> &#123;</span><br><span class="line">        Name, Body <span class="keyword">string</span></span><br><span class="line">    &#125; &#123;</span><br><span class="line">        &#123;<span class="string">"test.txt"</span>, <span class="string">"String contents of file"</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"test2.txt"</span>, <span class="string">"\x61\x62\x63\n"</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create and write files to the archive, which in turn</span></span><br><span class="line">    <span class="comment">// are getting written to the underlying writer to the</span></span><br><span class="line">    <span class="comment">// .zip file we created at the beginning</span></span><br><span class="line">    <span class="keyword">for</span> _, file := <span class="keyword">range</span> filesToArchive &#123;</span><br><span class="line">            fileWriter, err := zipWriter.Create(file.Name)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    log.Fatal(err)</span><br><span class="line">            &#125;</span><br><span class="line">            _, err = fileWriter.Write([]<span class="keyword">byte</span>(file.Body))</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    log.Fatal(err)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up</span></span><br><span class="line">    err = zipWriter.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-解压文件"><a href="#4-2-解压文件" class="headerlink" title="4.2 解压文件"></a>4.2 解压文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This example uses zip but standard library</span></span><br><span class="line"><span class="comment">// also supports tar archives</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"archive/zip"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"path/filepath"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    zipReader, err := zip.OpenReader(<span class="string">"test.zip"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> zipReader.Close()</span><br><span class="line">    <span class="comment">// 遍历打包文件中的每一文件/文件夹</span></span><br><span class="line">    <span class="keyword">for</span> _, file := <span class="keyword">range</span> zipReader.Reader.File &#123;</span><br><span class="line">        <span class="comment">// 打包文件中的文件就像普通的一个文件对象一样</span></span><br><span class="line">        zippedFile, err := file.Open()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> zippedFile.Close()</span><br><span class="line">        <span class="comment">// 指定抽取的文件名。</span></span><br><span class="line">        <span class="comment">// 你可以指定全路径名或者一个前缀，这样可以把它们放在不同的文件夹中。</span></span><br><span class="line">        <span class="comment">// 我们这个例子使用打包文件中相同的文件名。</span></span><br><span class="line">        targetDir := <span class="string">"./"</span></span><br><span class="line">        extractedFilePath := filepath.Join(</span><br><span class="line">            targetDir,</span><br><span class="line">            file.Name,</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">// 抽取项目或者创建文件夹</span></span><br><span class="line">        <span class="keyword">if</span> file.FileInfo().IsDir() &#123;</span><br><span class="line">            <span class="comment">// 创建文件夹并设置同样的权限</span></span><br><span class="line">            log.Println(<span class="string">"Creating directory:"</span>, extractedFilePath)</span><br><span class="line">            os.MkdirAll(extractedFilePath, file.Mode())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//抽取正常的文件</span></span><br><span class="line">            log.Println(<span class="string">"Extracting file:"</span>, file.Name)</span><br><span class="line">            outputFile, err := os.OpenFile(</span><br><span class="line">                extractedFilePath,</span><br><span class="line">                os.O_WRONLY|os.O_CREATE|os.O_TRUNC,</span><br><span class="line">                file.Mode(),</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatal(err)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">defer</span> outputFile.Close()</span><br><span class="line">            <span class="comment">// 通过io.Copy简洁地复制文件内容</span></span><br><span class="line">            _, err = io.Copy(outputFile, zippedFile)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Fatal(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-压缩文件"><a href="#4-3-压缩文件" class="headerlink" title="4.3 压缩文件"></a>4.3 压缩文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个例子中使用gzip压缩格式，标准库还支持zlib, bz2, flate, lzw</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"compress/gzip"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    outputFile, err := os.Create(<span class="string">"test.txt.gz"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    gzipWriter := gzip.NewWriter(outputFile)</span><br><span class="line">    <span class="keyword">defer</span> gzipWriter.Close()</span><br><span class="line">    <span class="comment">// 当我们写如到gizp writer数据时，它会依次压缩数据并写入到底层的文件中。</span></span><br><span class="line">    <span class="comment">// 我们不必关心它是如何压缩的，还是像普通的writer一样操作即可。</span></span><br><span class="line">    _, err = gzipWriter.Write([]<span class="keyword">byte</span>(<span class="string">"Gophers rule!\n"</span>))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    log.Println(<span class="string">"Compressed data written to file."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解压缩文件"><a href="#解压缩文件" class="headerlink" title="解压缩文件"></a>解压缩文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个例子中使用gzip压缩格式，标准库还支持zlib, bz2, flate, lzw</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"compress/gzip"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 打开一个gzip文件。</span></span><br><span class="line">    <span class="comment">// 文件是一个reader,但是我们可以使用各种数据源，比如web服务器返回的gzipped内容，</span></span><br><span class="line">    <span class="comment">// 它的内容不是一个文件，而是一个内存流</span></span><br><span class="line">    gzipFile, err := os.Open(<span class="string">"test.txt.gz"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    gzipReader, err := gzip.NewReader(gzipFile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> gzipReader.Close()</span><br><span class="line">    <span class="comment">// 解压缩到一个writer,它是一个file writer</span></span><br><span class="line">    outfileWriter, err := os.Create(<span class="string">"unzipped.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> outfileWriter.Close()</span><br><span class="line">    <span class="comment">// 复制内容</span></span><br><span class="line">    _, err = io.Copy(outfileWriter, gzipReader)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5，其它"><a href="#5，其它" class="headerlink" title="5，其它"></a>5，其它</h2><h3 id="5-1-临时文件和目录"><a href="#5-1-临时文件和目录" class="headerlink" title="5.1 临时文件和目录"></a>5.1 临时文件和目录</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">     <span class="string">"os"</span></span><br><span class="line">     <span class="string">"io/ioutil"</span></span><br><span class="line">     <span class="string">"log"</span></span><br><span class="line">     <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="comment">// 在系统临时文件夹中创建一个临时文件夹</span></span><br><span class="line">     tempDirPath, err := ioutil.TempDir(<span class="string">""</span>, <span class="string">"myTempDir"</span>)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Fatal(err)</span><br><span class="line">     &#125;</span><br><span class="line">     fmt.Println(<span class="string">"Temp dir created:"</span>, tempDirPath)</span><br><span class="line">     <span class="comment">// 在临时文件夹中创建临时文件</span></span><br><span class="line">     tempFile, err := ioutil.TempFile(tempDirPath, <span class="string">"myTempFile.txt"</span>)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Fatal(err)</span><br><span class="line">     &#125;</span><br><span class="line">     fmt.Println(<span class="string">"Temp file created:"</span>, tempFile.Name())</span><br><span class="line">     <span class="comment">// ... 做一些操作 ...</span></span><br><span class="line">     <span class="comment">// 关闭文件</span></span><br><span class="line">     err = tempFile.Close()</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除我们创建的资源</span></span><br><span class="line">     err = os.Remove(tempFile.Name())</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">     err = os.Remove(tempDirPath)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-通过HTTP下载文件"><a href="#5-2-通过HTTP下载文件" class="headerlink" title="5.2 通过HTTP下载文件"></a>5.2 通过HTTP下载文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">     <span class="string">"os"</span></span><br><span class="line">     <span class="string">"io"</span></span><br><span class="line">     <span class="string">"log"</span></span><br><span class="line">     <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">     newFile, err := os.Create(<span class="string">"devdungeon.html"</span>)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Fatal(err)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">defer</span> newFile.Close()</span><br><span class="line">     url := <span class="string">"http://www.devdungeon.com/archive"</span></span><br><span class="line">     response, err := http.Get(url)</span><br><span class="line">     <span class="keyword">defer</span> response.Body.Close()</span><br><span class="line">     <span class="comment">// 将HTTP response Body中的内容写入到文件</span></span><br><span class="line">     <span class="comment">// Body满足reader接口，因此我们可以使用ioutil.Copy</span></span><br><span class="line">     numBytesWritten, err := io.Copy(newFile, response.Body)</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">          log.Fatal(err)</span><br><span class="line">     &#125;</span><br><span class="line">     log.Printf(<span class="string">"Downloaded %d byte file.\n"</span>, numBytesWritten)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-哈希和摘要"><a href="#5-3-哈希和摘要" class="headerlink" title="5.3 哈希和摘要"></a>5.3 哈希和摘要</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/md5"</span></span><br><span class="line">    <span class="string">"crypto/sha1"</span></span><br><span class="line">    <span class="string">"crypto/sha256"</span></span><br><span class="line">    <span class="string">"crypto/sha512"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 得到文件内容</span></span><br><span class="line">    data, err := ioutil.ReadFile(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算Hash</span></span><br><span class="line">    fmt.Printf(<span class="string">"Md5: %x\n\n"</span>, md5.Sum(data))</span><br><span class="line">    fmt.Printf(<span class="string">"Sha1: %x\n\n"</span>, sha1.Sum(data))</span><br><span class="line">    fmt.Printf(<span class="string">"Sha256: %x\n\n"</span>, sha256.Sum256(data))</span><br><span class="line">    fmt.Printf(<span class="string">"Sha512: %x\n\n"</span>, sha512.Sum512(data))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"crypto/md5"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    file, err := os.Open(<span class="string">"test.txt"</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="comment">//创建一个新的hasher,满足writer接口</span></span><br><span class="line">    hasher := md5.New()</span><br><span class="line">    _, err = io.Copy(hasher, file)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算hash并打印结果。</span></span><br><span class="line">    <span class="comment">// 传递 nil 作为参数，因为我们不通参数传递数据，而是通过writer接口。</span></span><br><span class="line">    sum := hasher.Sum(<span class="literal">nil</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"Md5 checksum: %x\n"</span>, sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6，参考"><a href="#6，参考" class="headerlink" title="6，参考"></a>6，参考</h2><ul><li><a href="https://www.devdungeon.com/content/working-files-go" target="_blank" rel="noopener">Working with Files in Go</a></li><li><a href="https://golang.org/pkg" target="_blank" rel="noopener">Go Standard Library Documentation</a></li><li><a href="https://www.linux.com/learn/understanding-linux-file-permissions" target="_blank" rel="noopener">understanding-linux-file-permissions</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>Golang学习</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>文件操作</tag>
      </tags>
  </entry>
  <entry>
    <title>一些生活好习惯</title>
    <url>/2019/02/23/%E4%B8%80%E4%BA%9B%E7%94%9F%E6%B4%BB%E5%A5%BD%E4%B9%A0%E6%83%AF/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><p>又是一个周末，又是晚睡晚起，早饭随便吃一点，总说着要注意休息，但总不当回事。</p><p>在此立一个flag，从今天起，如果不是特别紧急的事情，哪怕留到明天去做，我也一定要早点睡觉！！！</p><h2 id="每天要做"><a href="#每天要做" class="headerlink" title="每天要做"></a>每天要做</h2><ul><li><p>晚上十点前准时上床睡觉，早上六点起床。</p></li><li><p>坚持吃早饭，鸡蛋牛奶蔬菜面包水果玉米糊糊都行，吃六分饱即可。</p></li><li><p>上班骑车，或走路，锻炼身体，公司离住处很近，所以不要太急，过马路看红绿灯，礼让行人。</p></li><li><p>早上坚持练习英语口语，背记英语单词。</p></li><li><p>到了工作时间，先把工作上的事情做完，再做其他的。</p></li><li><p>中午保证半小时的睡眠时间，不玩手机。</p></li><li><p>完成一个<code>LeetCode</code>上的编程题。</p></li><li><p>出门前对自己一个微笑。</p></li><li><p>写日记。</p></li></ul><h2 id="每周要做"><a href="#每周要做" class="headerlink" title="每周要做"></a>每周要做</h2><ul><li><p>去健身房锻炼身体三次，跑步，肌肉练习均可。</p></li><li><p>至少完成一个ARTS。</p></li><li><p>和家里人打电话，对他们说我很好；和伶儿通个电话，并告诉她我很想你。</p></li><li><p>去吃点好吃的，见一见朋友，放松身心。</p></li></ul><h2 id="每月要做"><a href="#每月要做" class="headerlink" title="每月要做"></a>每月要做</h2><ul><li><p>做总结。</p></li><li><p>读完一本科普或小说。</p></li></ul><h2 id="每年要做"><a href="#每年要做" class="headerlink" title="每年要做"></a>每年要做</h2><ul><li><p>去一个自己从没去过的地方。</p></li><li><p>回家陪父母聊聊天。</p></li></ul><p><img src="/.io//flower.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>习惯</tag>
        <tag>健康</tag>
      </tags>
  </entry>
  <entry>
    <title>当你孤单时你会想起谁</title>
    <url>/2019/02/22/%E5%BD%93%E4%BD%A0%E5%AD%A4%E5%8D%95%E6%97%B6%E4%BD%A0%E4%BC%9A%E6%83%B3%E8%B5%B7%E8%B0%81/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><p>这一周，我提前一天完成了我的任务，用<code>Golang</code>给视频转码写了个小工具，复习了二进制基础，文件操作和<code>Golang</code>基本语法。</p><p>下午，一位朋友and他女友来看我，一起吃了顿冒菜，让我这平淡的周末多了份意料之外的喜悦。</p><h2 id="亲爱的，你怎么不在我身边"><a href="#亲爱的，你怎么不在我身边" class="headerlink" title="亲爱的，你怎么不在我身边"></a>亲爱的，你怎么不在我身边</h2><p>距离上次会合已经过去一个月，却让我感觉如昨日。</p><p>想起我们一起看过日出，站在塔里木大桥上看日落，在乌鲁木齐大冬天跑出去看电影吃麻辣小龙虾，去西安吃酿皮和肉夹馍，到成都看熊猫。</p><p>可是，这个周末，亲爱的你为什么不在我身边。</p><h2 id="当你孤单时你会想起谁"><a href="#当你孤单时你会想起谁" class="headerlink" title="当你孤单时你会想起谁"></a>当你孤单时你会想起谁</h2><p>想起远在乌鲁木齐的父母，从此养成了报喜不报忧的“好习惯”；</p><p>想起远在厦门的凡儿，没事调侃两句，解解闷；</p><p>想起远在家里蹲的羊纪元，吹吹牛释放下压力；</p><p>想起远在西安做销售的魁拔，高中时教我弹吉他和护肤，在QQ炫舞上一同唱着《老男孩》；</p><h2 id="我要你在我身旁"><a href="#我要你在我身旁" class="headerlink" title="我要你在我身旁"></a>我要你在我身旁</h2><p>你说你毕设答辩结束就坐飞机来成都，我想起去年我也说，我答完辩把论文材料提交完毕立马坐最近的一趟飞机去成都找你，顺便把offer拿了。</p><p>现在过了一年，角色互换，我相信，我们的异地恋接近尾声。</p><p>我在成都等你。</p><p><img src="/.io//wait.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>孤单</tag>
        <tag>思念</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode_905_Sort-Array-By-Parity</title>
    <url>/2019/02/14/LeetCode-905-Sort-Array-By-Parity/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># [905] Sort Array By Parity</span><br><span class="line">#</span><br><span class="line"># https://leetcode.com/problems/sort-array-by-parity/description/</span><br><span class="line">#</span><br><span class="line"># Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A.</span><br><span class="line"># </span><br><span class="line"># You may return any answer array that satisfies this condition.</span><br><span class="line"># </span><br><span class="line"># Example 1:</span><br><span class="line"># </span><br><span class="line"># </span><br><span class="line"># Input: [3,1,2,4]</span><br><span class="line"># Output: [2,4,3,1]</span><br><span class="line"># The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.</span><br><span class="line"># </span><br><span class="line"># Note:</span><br><span class="line"># </span><br><span class="line"># 1 &lt;= A.length &lt;= 5000</span><br><span class="line"># 0 &lt;= A[i] &lt;= 5000</span><br><span class="line">#</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><ul><li>Python</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortArrayByParity</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">if</span> A[i] % <span class="number">2</span> &gt; A[j] % <span class="number">2</span>:</span><br><span class="line">                A[i], A[j] = A[j], A[i] <span class="comment">#互换</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> A[i] % <span class="number">2</span> == <span class="number">0</span>: i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> A[j] % <span class="number">2</span> == <span class="number">1</span>: j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure><ul><li>C++</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortArrayByParity(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                swap(A[i--],A[len--]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode_977_Squares-of-a-Sorted-Array</title>
    <url>/2019/02/13/LeetCode-977-Squares-of-a-Sorted-Array/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* [977] Squares of a Sorted Array</span><br><span class="line">*</span><br><span class="line">* https://leetcode.com/problems/squares-of-a-sorted-array/description/</span><br><span class="line">*</span><br><span class="line">* algorithms</span><br><span class="line">* Easy (73.76%)</span><br><span class="line">* Total Accepted:    23.7K</span><br><span class="line">* Total Submissions: 32.2K</span><br><span class="line">* Testcase Example:  &apos;[-4,-1,0,3,10]&apos;</span><br><span class="line">*</span><br><span class="line">* Given an array of integers A sorted in non-decreasing order, return an array</span><br><span class="line">* of the squares of each number, also in sorted non-decreasing order.</span><br><span class="line">* </span><br><span class="line">* </span><br><span class="line">* </span><br><span class="line">* </span><br><span class="line">* Example 1:</span><br><span class="line">* </span><br><span class="line">* </span><br><span class="line">* Input: [-4,-1,0,3,10]</span><br><span class="line">* Output: [0,1,9,16,100]</span><br><span class="line">* </span><br><span class="line">* </span><br><span class="line">* </span><br><span class="line">* Example 2:</span><br><span class="line">* </span><br><span class="line">* </span><br><span class="line">* Input: [-7,-3,2,3,11]</span><br><span class="line">* Output: [4,9,9,49,121]</span><br><span class="line">* </span><br><span class="line">* </span><br><span class="line">* </span><br><span class="line">* </span><br><span class="line">* Note:</span><br><span class="line">* </span><br><span class="line">* </span><br><span class="line">* 1 &lt;= A.length &lt;= 10000</span><br><span class="line">* -10000 &lt;= A[i] &lt;= 10000</span><br><span class="line">* A is sorted in non-decreasing order.</span><br><span class="line">* </span><br><span class="line">*</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>此题比较简单，意思就是对数组里的数字进行排序和开平方。代码如下</p><ul><li>Java</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] sortedSquares(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            A[i] = A[i] * A[i];  <span class="comment">//对数组中每个数都平方</span></span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(A);  <span class="comment">//对数组进行排序</span></span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Python</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedSquares</span><span class="params">(self, A: <span class="string">'List[int]'</span>)</span> -&gt; 'List[int]':</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> x*x</span><br><span class="line">        <span class="keyword">return</span> sorted(map(f,A))</span><br></pre></td></tr></table></figure><h2 id="开启刷题之路"><a href="#开启刷题之路" class="headerlink" title="开启刷题之路"></a>开启刷题之路</h2><p>加入了大佬创建的刷题圈，目标是一天一道LeetCode算法题，按专题刷，加油！</p><p><img src="/.io//sky.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>放假归来上班综合症</title>
    <url>/2019/02/12/%E6%94%BE%E5%81%87%E5%BD%92%E6%9D%A5%E4%B8%8A%E7%8F%AD%E7%BB%BC%E5%90%88%E7%97%87/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><p>春节结束，放假归来，已在公司上班两天。</p><p>向公司行政部申请买了块8G台式机内存条，额头上又隐约在冒痘痘了，半年过去了，难道还没有适应南方的气候？</p><p>伶儿说她明天早上七点就到乌鲁木齐了，距离我们下次见面就是她在学校答辩完，五月底六月初的样子。下次重逢，不要再分开了好吗？</p><p>哈哈，突然觉得自己好矫情，说这些。</p><p>昨天浑身酸痛，什么也不想做。今天试着看了些技术书，看不进去里面的概念，试着刷了几道LeetCode关于数组的题目，收获还行。</p><p>又要开始程序化的生活了，早起-骑车-工作-看书-下班-玩/学习-睡觉，如此循环。</p><p>好想做一些白日梦骗自己几分钟，又感到幼稚。</p><p>乱七八糟的写了些话，记录放假归来后内心烦躁的情绪。</p><p>不管怎样，生活还得继续，世界还等着我创造奇迹。</p><p><img src="/.io//dark.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>成长</category>
      </categories>
      <tags>
        <tag>感悟</tag>
        <tag>放假</tag>
      </tags>
  </entry>
  <entry>
    <title>提问学习带给我的收获</title>
    <url>/2019/02/01/%E6%8F%90%E9%97%AE%E5%AD%A6%E4%B9%A0%E5%B8%A6%E7%BB%99%E6%88%91%E7%9A%84%E6%94%B6%E8%8E%B7/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><p>写以此文，记录我这三天（1.30-2.1）的收获和感悟。</p><p>上周把一个定时删除的服务的版本提交了，本以为在过年前的一周基本没什么事了。然而部门老哥告诉我，之前我负责的一个流媒体服务还存在两处bug</p><ul><li><p>不支持多用户同时拉取视频流；</p></li><li><p>不支持重新连接；</p></li></ul><p>所以这周我又忙着修改bug,然而在前两天，我还是束手无策，找不到应对方案，一筹莫展。</p><p>到了第三天老哥带我一步步熟悉整体流程，细致到每个函数，每个入参，以及每个重要的代码。不断的提问，不断的思考，再不断的提出新的问题，时间过得飞快，我也饿得快。不过最终还是蛮开心的，通过这两处bug，让我重新回顾了流媒体服务的整体工作流程，以及Go语言中对<code>goroutine</code>和<code>channel</code>机制，印象最深的是以下两点：</p><h3 id="管道中的-lt"><a href="#管道中的-lt" class="headerlink" title="管道中的&lt;-"></a>管道中的<code>&lt;-</code></h3><p>简单来说就是这样子的：接受者&lt;-发送者。</p><p>然而中间会多个管道，所以我借用Go语言圣经中的三处例子做解释</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- x  <span class="comment">// x作为发送者发送给管道</span></span><br><span class="line">x = &lt;-ch <span class="comment">// 管道作为发送者发送数据给接受者x</span></span><br><span class="line">&lt;-ch  <span class="comment">// 管道发送数据，没有接收者，丢弃，同时造成管道堵塞，等待接收者</span></span><br></pre></td></tr></table></figure><p>所以我们可以具体化刚才说的发送接收流程，它应该为：接收者 &lt;- 管道 &lt;- 发送者。如果缺了接收者或发送者，都会造成管道堵塞。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>举个例子</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">mu sync.Mutex   <span class="comment">// guards balance</span></span><br><span class="line">balance <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Deposit</span><span class="params">(amount <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    balance = balance + amount</span><br><span class="line">    mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Balance</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    b := balance</span><br><span class="line">    mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先Lock锁住，再使用Unlock解锁。</p><p>如果Lock中再套一个Lock，就会造成死锁，需要将前一个Lock解开才行。</p><h3 id="dlv调试流程"><a href="#dlv调试流程" class="headerlink" title="dlv调试流程"></a>dlv调试流程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,./dlv debug xxxx(程序名)  ##启动dlv调试</span><br><span class="line"></span><br><span class="line">2,r(restart)  </span><br><span class="line"></span><br><span class="line">3,c(continue)</span><br><span class="line"></span><br><span class="line">4,b(break)   ##打断点，可以打函数名，也可以打文件下对应的行号</span><br><span class="line"></span><br><span class="line">5,n(next)或s(step)  ##n按一次单步执行，后面只需一直按回车；遇到需要深究的函数按s进去查看</span><br><span class="line">##如果碰到多线程，建议在线程内打个断点</span><br><span class="line"></span><br><span class="line">6,bt(stack)  ##查看堆栈</span><br><span class="line"></span><br><span class="line">7,frame  ##查看指定堆栈的内容</span><br><span class="line"></span><br><span class="line">8,q(exit)     ##退出调试</span><br></pre></td></tr></table></figure><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li><p>接触一个新东西，除了保证理解了流程，还要对每个函数的作用，影响范围都要了然于胸才行；</p></li><li><p>流程这东西，光知道不行，最好的办法是自己画个流程图出来，一步步跟着代码走；</p></li><li><p>IDE有时会因为环境参数或内在bug而报错，所以推荐使用dlv(针对go)和gdb进行调试；</p></li><li><p>多对自己提几个为什么，有助于理解技术的本质；</p></li><li><p>心态放平和，坦然接受bug和不足，耐心寻求突破。</p></li></ul><p>最后附一组测试成功的图片^_^</p><p><img src="/.io//%E8%83%8C%E5%BD%B1.png" alt></p><p><img src="/.io//%E5%9B%BE.png" alt></p><p><img src="/.io//%E7%AC%91.png" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>收获</tag>
        <tag>提问</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-面试题3-数组中重复的数字-题目一</title>
    <url>/2019/01/27/%E5%89%91%E6%8C%87offer-%E9%9D%A2%E8%AF%95%E9%A2%983-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97-%E9%A2%98%E7%9B%AE%E4%B8%80/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h3 id="题目一：找出数组中重复的数字"><a href="#题目一：找出数组中重复的数字" class="headerlink" title="题目一：找出数组中重复的数字"></a>题目一：找出数组中重复的数字</h3><p>在一个长度为n的数组里的所有数字都在0~n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的数字2或者3。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>1，先把输入的数组排序；</p><ul><li>从头到尾扫描排序后的数组。排序一个长度为n的数组需要O(nlogn)的时间。</li></ul><p>2，利用哈希表；</p><p>3，根据数组下表找重复数字；(过程会在后面详细写出)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[i] &lt; <span class="number">0</span> || numbers[i] &gt; length - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(numbers[i] != i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == numbers[numbers[i]])</span><br><span class="line">            &#123;</span><br><span class="line">                *duplication = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换numbers[i]和numbers[numbers[i]]        </span></span><br><span class="line">            <span class="keyword">int</span> temp = numbers[i];</span><br><span class="line">            numbers[i] = numbers[temp];</span><br><span class="line">            numbers[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><ul><li><p>对一维数组的理解。一维数组在内存中占据连续的空间，因此我们可以根据下标定位对应的元素。</p></li><li><p>学会通过具体例子找出其中的规律。</p></li></ul><p><a href="https://github.com/OctopusLian/CodingInterviewChinese2/blob/master/03_01_DuplicationInArray/FindDuplication.cpp" target="_blank" rel="noopener">本题源代码</a></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>公司年会收获</title>
    <url>/2019/01/27/%E5%85%AC%E5%8F%B8%E5%B9%B4%E4%BC%9A%E6%94%B6%E8%8E%B7/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><p>2019年1月23日，我参加了公司的年会彩排+表演。</p><p>此次年会收获如下：</p><ul><li>成功站在舞池中央，C位出道！</li><li>步伐放慢一点，脚印踩实一些。</li><li>有激情，才能带动一批人。</li><li>再多坚持一会儿。</li></ul><p><img src="/.io//center.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>年会</tag>
        <tag>收获</tag>
      </tags>
  </entry>
  <entry>
    <title>重新正视自己的知识焦虑</title>
    <url>/2019/01/21/%E9%87%8D%E6%96%B0%E6%AD%A3%E8%A7%86%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9F%A5%E8%AF%86%E7%84%A6%E8%99%91/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><p>今天在豆瓣上看到一篇文章，分享一下：<a href="https://www.douban.com/note/704294887/" target="_blank" rel="noopener">高效学习成长的丰沃土壤长什么样</a></p><h2 id="与知识付费的相识"><a href="#与知识付费的相识" class="headerlink" title="与知识付费的相识"></a>与知识付费的相识</h2><p>记得是大二的时候，下载了得到app，打开后看到里面琳琅满目的付费专栏，内容主要涉及管理学，经济学，科技和做人做事，价格基本是199元/年，我说“好贵！学生党买不起。”</p><p>后来经不住app里对专栏的介绍，我买了下吴军的《硅谷来信》，想跟着专栏学习下大师的思考方式和处世之道。不得不说，大师思考问题的维度和方式的确与我们不一样，因此拓宽了我的知识面，于是在一年后，我又坚持订阅了他的《谷歌方法论》。</p><p>再到后来大学毕业，我做了和服务器开发和算法相关的工作，在工作中深深感受到基础知识的匮乏，这时候一款名叫极客时间的app映入眼帘，在这里我看了相关介绍，陆续订阅了《数据结构与算法之美》和《程序员的基础数学》两个专栏。</p><p>还有其他类似的知识付费栏目，比如简书的付费阅读原创小说最后30%的章节内容；GitChat；只是星球。</p><h2 id="为什么需要付费"><a href="#为什么需要付费" class="headerlink" title="为什么需要付费"></a>为什么需要付费</h2><p>曾经我很纳闷，这些知识网上都可以找到的，为什么还需要知识付费呢？</p><p>我想主要原因有以下几个方面：</p><ul><li>作者辛辛苦苦写出来的，我们总要回馈一些财富出来；（20%）</li><li>网上内容良莠不齐，而作者是一路走过来的，因此有经验，会帮你整理出来，让你少走弯路；（60%）</li><li>对版权的一种保护；（20%）</li></ul><p>所以归根结底，是我们对获取知识的途径比较匮乏，需要有个人（比如专栏作者）把自己的学习心得和经验共享出来，供需要的人吸收，那么问题又来了，你吸收的这些知识，就一定是正确且有用的吗？</p><h2 id="正视焦虑"><a href="#正视焦虑" class="headerlink" title="正视焦虑"></a>正视焦虑</h2><p>我是一个喜欢有成就感持续驱动学习的人，这种成就感不是满足于一群人对我说“大佬 666”，而是每解决一个bug或close一个issue，搞懂一个模块的功能或者比昨天对框架有了更深入的理解。</p><p>然而，当我逐渐在学习底层的时候，我就会愈发现知识的不足，例如并发编程的原理，常用算法的核心思想，模块功能类比上的失误，以及对协议的认知偏差等等，这时候我很想一步登天，例如狂刷CSAPP，算法，但此时我已经产生了知识焦虑，犯了欲速则不达的错误。</p><h2 id="学会分辨正确但无用的知识"><a href="#学会分辨正确但无用的知识" class="headerlink" title="学会分辨正确但无用的知识"></a>学会分辨正确但无用的知识</h2><p>“学会分辨正确但无用的知识”——这时一位前辈给我提的建议。</p><p>现在，我终于明白了这句话的含义。</p><p>无用，其实绝大多数是因为自己没有经过深度思考，只是别人告诉你，有这么个知识，你可以拿来套用和当谈资。但是这个知识到底有什么用，在什么场合下适用，都是要经过自己思考和实践出来的。</p><h2 id="一个小例子"><a href="#一个小例子" class="headerlink" title="一个小例子"></a>一个小例子</h2><p>我有位高中玩的很要好的朋友，我当时总会调侃他的英语，然而我很佩服他的数学，虽然我做的数学题比他多，周末还报了数学辅导班，但是每当考试时，他都比我考的高。</p><p>我私下请教他学习数学的方法，他说你做题只满足做对就行，却没有从出题人的角度思考这道题，而我做这道题只花了五分钟，想这道题背后的用意以及举一反三的过程却花了我45分钟的时间。</p><p>的确，他经过深度思考了，所以知识是他的，而我是花钱（买课外资料，报辅导班）买了别人的解题思路，走了个捷径，现在想想，其实是走了弯路。</p><h2 id="关于知识焦虑的感触"><a href="#关于知识焦虑的感触" class="headerlink" title="关于知识焦虑的感触"></a>关于知识焦虑的感触</h2><ul><li><p>正视自己的焦虑，因为有焦虑，所以才有强烈的求知欲和学习的动力；</p></li><li><p>集中自己的时间和注意力，对枯燥的原理和底层的知识，进行深度思考；</p></li><li><p>对那种表面业务逻辑部分，花最少的时间把它做好，后面就抽更少的时间维护即可；</p></li><li><p>从源头开始阅读，尽量获取第一手的资料；</p></li><li><p>正视自己的不足，扎扎实实一步一个脚印坚持走下去；</p></li></ul><p>GOOD LUCK !</p><p><img src="/.io//alone.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>知识付费</tag>
        <tag>焦虑</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer_面试题1_赋值运算符函数</title>
    <url>/2019/01/17/%E5%89%91%E6%8C%87offer-%E9%9D%A2%E8%AF%95%E9%A2%981-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如下为类型CMyString的声明，请为该类型添加赋值运算符函数。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span>* pData = <span class="literal">nullptr</span>);</span><br><span class="line">    CMyString(<span class="keyword">const</span> CMystring &amp;str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>关注点如下：</p><ul><li>是否把返回值的类型声明为该类型的引用，并在函数结束前返回实例自身的引用(*this)。</li><li>是否把传入的参数的类型声明为常量引用。</li><li>是否释放实例自身已有的内存。</li><li>判断传入的参数和当前的实例(*this)是不是同一个实例。</li></ul><h2 id="Show-Code"><a href="#Show-Code" class="headerlink" title="Show Code"></a>Show Code</h2><h3 id="经典，初级解法"><a href="#经典，初级解法" class="headerlink" title="经典，初级解法"></a>经典，初级解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span> = (<span class="keyword">const</span> CMyString &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">//返回实例自身的引用</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> []m_pData;</span><br><span class="line">    m_pData = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_pData,str.m_pData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><ul><li>C++基础语法，如运算符函数、常量引用；</li><li>对内存泄露的理解</li></ul><p><a href="https://github.com/OctopusLian/CodingInterviewChinese2/tree/master/01_AssignmentOperator" target="_blank" rel="noopener">本题源代码</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.cplusplus.com/reference/cstring/strcpy/" target="_blank" rel="noopener">cpp函数_strcpy</a></li></ul><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>offer到手</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>低调成长</title>
    <url>/2019/01/17/%E4%BD%8E%E8%B0%83%E6%88%90%E9%95%BF/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h2 id="意外惊喜"><a href="#意外惊喜" class="headerlink" title="意外惊喜"></a>意外惊喜</h2><p>这段时间有两个意外发生在我的身上</p><h3 id="头条邀请"><a href="#头条邀请" class="headerlink" title="头条邀请"></a>头条邀请</h3><p>下午打开Gmail邮箱，意外发现了除了Medium的推送外，还夹带着一封头条后端开发岗的邀请…<br><img src="/.io//%E5%A4%B4%E6%9D%A1%E9%9D%A2%E8%AF%95.png" alt></p><h3 id="写书邀请"><a href="#写书邀请" class="headerlink" title="写书邀请"></a>写书邀请</h3><p>除了面试邀请，还在前段时间在博客园上收到了一家北京出版社编辑发的写开发实战书籍的邀请。<br>（写书曾经想过写，但不是现在写，因为技术还没有积淀下来，写了也是浪费精力和纸张）</p><h2 id="低调成长"><a href="#低调成长" class="headerlink" title="低调成长"></a>低调成长</h2><p>想起两年前我大二，对于这样的邀请我是可望而不可即的，因为技术太渣，校招时四轮笔试做了一塌糊涂。<br>但是，当现在机会摆在我的面前时，我不禁想问下自己，现在接受真的合适吗？<br>最好的目前并不一定适合自己。<br>现在的还处于学习上升期阶段，除了在部门内负责流媒体服务外，还要学习网络，数据库和算法相关知识，需要巩固C/C++和Go语言编程；不断的接受一些有挑战性的任务，在踩坑和写Bug中茁壮成长。<br>我一直相信，只要自己坚持做一件认为对的事情，培养成一个习惯（例如写日记，早起晨练，学习），那么这就是个如蛹化蝶的过程，最终将会振翅飞翔。<br><img src="/.io//%E8%8A%B1%E6%B5%B7.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>邀请</tag>
      </tags>
  </entry>
  <entry>
    <title>2019年计划要做的事</title>
    <url>/2019/01/15/2019%E5%B9%B4%E8%AE%A1%E5%88%92%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>目前了解到的会涉及以下方面：</p><ul><li>流媒体服务<br>以Go语言为主；熟练掌握TCP/IP，HTTP原理；常用的MySQL和Redis数据库用法。</li><li>视音频编解码<br>C/C++语言为主；</li><li>图形图像<br>C/C++语言，OpenGL；OpenCV。</li></ul><h2 id="业余安排"><a href="#业余安排" class="headerlink" title="业余安排"></a>业余安排</h2><p>业余时间计划完成以下事情：</p><h3 id="附加技能"><a href="#附加技能" class="headerlink" title="附加技能"></a>附加技能</h3><ul><li>熟悉JavaScript，争取能完成一个在线简历模板；</li><li>熟练Java语言，希望能接1-2个毕设赚些零花钱；</li><li>LeetCode每周一题；</li></ul><h3 id="阅读提升"><a href="#阅读提升" class="headerlink" title="阅读提升"></a>阅读提升</h3><ul><li>极客时间上的四个专栏（左耳听风，趣谈网络，数据结构算法，数学基础）研读；</li><li>开始阅读大部头经典书籍，例如CSAPP和UNP，并认真完成章节的课后练习题；</li><li>Medium上争取两周内翻译一篇和自己学习工作相关的技术文章；</li><li>每天半小时学习口语；</li></ul><h3 id="培养兴趣爱好"><a href="#培养兴趣爱好" class="headerlink" title="培养兴趣爱好"></a>培养兴趣爱好</h3><ul><li>学习下拍照摄影，争取给女友拍出美美的照片～</li><li>继续在健身房练习街舞，希望今年可以练出托马斯回旋和大风车；</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>继续维护我的英语学习项目<a href="https://github.com/OctopusLian/VocabularyMap" target="_blank" rel="noopener">VocabularyMap</a>，争取在九月底国庆前完成词根词汇的拓展并加上中文释义。</li><li>继续坚持创作，幻想和思考。</li></ul><p><img src="/.io//%E5%8A%A0%E6%B2%B9.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>计划</tag>
        <tag>兴趣</tag>
      </tags>
  </entry>
  <entry>
    <title>新的开始</title>
    <url>/2019/01/14/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<!-- build time:Sat Oct 19 2019 19:41:43 GMT+0800 (CST) --><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>大家好，我的网名叫不会飞的章鱼（Zoctopus Zhang），活跃在简书、豆瓣、博客园和Github上，之前在博客园上坚持写技术博客长达两年半，截止目前已发布了两百多篇文章共23万人+的访问量，同时在简书上写文章积累了有十二万余字。然而，我一直很想创建一个自己的Blog，记录一些平时工作和生活上的收获和心得。<br>今天这个愿望终于实现了，在此我很感谢我的好友冰水鉴心的远程帮助。</p><h2 id="接下来准备做什么"><a href="#接下来准备做什么" class="headerlink" title="接下来准备做什么"></a>接下来准备做什么</h2><p>我本科学的专业是计算机科学与技术，2018年6月毕业后在一家上市游戏公司做了三个月的游戏服务器开发，之后因工作原因转行，目前主要做流媒体服务和与视音频相关的图形图像。<br>我想把我在工作中的学习心得和生活上的感悟记录下来。</p><h2 id="那么，现在就开始吧"><a href="#那么，现在就开始吧" class="headerlink" title="那么，现在就开始吧"></a>那么，现在就开始吧</h2><p>我不知道这条路我会走多远，但我至今不后悔我做出的每一个选择。因为我知道：念念不忘，必有回响。</p><p><img src="/.io//%E5%85%89%E6%99%95.jpg" alt></p><!-- rebuild by neat -->
<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"9b0e6a8ee9514649c4e7","clientSecret":"93f2b2b36da58f64f4353d6d5b7f6005a9f80d7c","repo":"octopuslian.github.io","owner":"OctopusLian","admin":["OctopusLian"],"distractionFreeMode":false};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
